/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* SPIR-V Serialization Utilities/Functions                                   *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_SERIALIZATION_FNS

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AccessChainOp>(::mlir::spirv::AccessChainOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  for (Value operand : op->getOperands()) {
    auto id = getValueID(operand);
    assert(id && "use before def!");
    operands.push_back(id);
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAccessChain, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicAndOp>(::mlir::spirv::AtomicAndOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    if (auto attr = op->getAttr("memory_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("memory_scope");
  }
  {
    if (auto attr = op->getAttr("semantics")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("semantics");
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicAnd, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicCompareExchangeWeakOp>(::mlir::spirv::AtomicCompareExchangeWeakOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    if (auto attr = op->getAttr("memory_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("memory_scope");
  }
  {
    if (auto attr = op->getAttr("equal_semantics")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("equal_semantics");
  }
  {
    if (auto attr = op->getAttr("unequal_semantics")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("unequal_semantics");
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    for (auto arg : op.getODSOperands(2)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #2 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicCompareExchangeWeak, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicIAddOp>(::mlir::spirv::AtomicIAddOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    if (auto attr = op->getAttr("memory_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("memory_scope");
  }
  {
    if (auto attr = op->getAttr("semantics")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("semantics");
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicIAdd, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicIDecrementOp>(::mlir::spirv::AtomicIDecrementOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  for (Value operand : op->getOperands()) {
    auto id = getValueID(operand);
    assert(id && "use before def!");
    operands.push_back(id);
  }
  if (auto attr = op->getAttr("memory_scope")) {
    operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
  }
  elidedAttrs.push_back("memory_scope");
  if (auto attr = op->getAttr("semantics")) {
    operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
  }
  elidedAttrs.push_back("semantics");
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicIDecrement, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicIIncrementOp>(::mlir::spirv::AtomicIIncrementOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  for (Value operand : op->getOperands()) {
    auto id = getValueID(operand);
    assert(id && "use before def!");
    operands.push_back(id);
  }
  if (auto attr = op->getAttr("memory_scope")) {
    operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
  }
  elidedAttrs.push_back("memory_scope");
  if (auto attr = op->getAttr("semantics")) {
    operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
  }
  elidedAttrs.push_back("semantics");
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicIIncrement, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicISubOp>(::mlir::spirv::AtomicISubOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    if (auto attr = op->getAttr("memory_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("memory_scope");
  }
  {
    if (auto attr = op->getAttr("semantics")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("semantics");
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicISub, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicOrOp>(::mlir::spirv::AtomicOrOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    if (auto attr = op->getAttr("memory_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("memory_scope");
  }
  {
    if (auto attr = op->getAttr("semantics")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("semantics");
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicOr, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicSMaxOp>(::mlir::spirv::AtomicSMaxOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    if (auto attr = op->getAttr("memory_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("memory_scope");
  }
  {
    if (auto attr = op->getAttr("semantics")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("semantics");
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicSMax, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::AtomicSMinOp>(::mlir::spirv::AtomicSMinOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    if (auto attr = op->getAttr("memory_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("memory_scope");
  }
  {
    if (auto attr = op->getAttr("semantics")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("semantics");
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpAtomicSMin, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_con4C}ÎeT-NÆkuÀäÔ2P-,Ç9Tğ¯ÄÙĞ_MtƒvIÖ@¢ ˆã¡wĞS¿WÍ'#9f°&š¦¬jŞÔ(/áèaÕ•$òÎv&å”æêÒÚ°LEí¬ô§NE|nncmh‰såbg÷ïQ*ˆs;~"+É+ª¯™³A	ó,\…Zb îÍKÓÃO";…?Z5ooˆú½ òVİfv½õÙ}ãCuªº+pb?;{ßXÜÁÊş(½ë>I:o=I4„Úu üŞ¬yÅzçzìhQAwqĞ¹çcNs#€Ğ‘ Ù°Äºøít\{s~WúP½ø•Gø{Î:A_?l0`”š/vº»ËDoË{+ßÕ¥x5x	Xş ë0(€e”ZVô´e6‚t&x•{wt¢~dàWğßW%XUÛ  €MèìÆ
—ÃÖ–=¹ntxÁFz¤75cJ^ùEA¡ìäG1•lzgjÔIëí1<»ÒSEcb3ëc^ÁºªÖ…fiíXk:í×«hEr)ÍTR@‹Ò'\áw=1°h&€(šïgWŠ¸“KcãzâVQdÄİŒy«|äiÿ(a Ãıãà¥ak8<gò{yøİ"~Wuò“Ï³ƒ',û
b)ª£Cš||ì>`1«L¥áx‹j:ôª,ğ¥mòìRÕAM+P}Ñk›F^uh˜KößE|şØaRl Á;3p÷{ßd:)nó&{l<jCëòMô2«PQp}î×`mcMA0Y-$`ÎTÜÄu]vn4í&#?–h“|XmËf<²)Ï9åâ#û±äóßi2ÓšÄJ;Ìúã7+ıØ®)4;øl{¼Tô¤¼ğ¶SºªP
/j$[woÀ™Ñ0.wCì­¿Kyôøõó„Ëš j“†°ê>/à˜‚ÆO{«Dâ£E’xºr¨ùŠA›}G|t>¥19J
±ÑEBkò½Ù_Ë/AéRvd²Å€[eœqÿbz«ÁiUÂªönè(ëÂü °0ûP_ÂĞ çRå³` \e ¾I^s'LlYş–mIı%g?Z«3c ^*MJ$Q‚*%ğo-c¦b¶ˆ©]hgâm3S:°£Z=)» ‚ê”Zªs®+Ò¹†,À¸!h[(l1¼yï¸K°³c°Qˆ_bĞÙé£Ù1¶„/—AÏËpûönnÛ4qÖc/w0È¡¹¾ppâ€<>ó8ä$³[@ÓÇ±1ªÁXóìÆxcşEt
SõxîğìvaÕ—jË&¹ì1Õ.hñ7?xÍ¶îOÑ ²7ôÂõÙö]ùÉSZj±¢ªEş¥ŞJÊ5ì$TÎ!ÔPQğ]ø¶qêZˆób¼Çù‹O(c5“K>§cã´dã?g":²-Ë¨1ş Ò-w‚B)PT×á;Ù7İv	B’avD©(Ìn\Ğ!ìXù/~â+¶§}È–RrïÏ -0g0Nª(›†9WséU !ük 7Å®9f:=Í&æD9FdëUHNMBc'å.®ö©NªpıT¯ºH©r>ÁĞ4Uwßã€Exp¾»é{k
¶¥®ıK‡ )`ä=´F5%7<L´!†²æ[ªÌjå‡zÀ‹SZÓÈÄ´Ì+Ñ¹]n¸&yõ«ò‘˜`G(XR
³vŞ«ógöõ¬VX.§máNÂ³hÄin®7	a¢-
  ¶µPc0éDuKÄ_}éÀä<2TÅaÖƒkü–ÏP(R¡ôâ«¶<‚î¼ƒäàBÄ!(èCóÛ6m<{ŠäÜ‚9m(æª9Nà6ßg}|3ohä«w¤ae¢DNOI¶ÏÄŸü«|(0p‹y!S‰4šDeÏÌs= ı­b¨k«ê» f(útrhÃˆˆ	¢\£J^ñ¾·yN9ŞÒE/soš éÒ`=‰g€  õTA¬3ÒT¬ˆ$Èa\˜xmım“Ê]è¬÷¬Íánaw,vÏ,y„àgZ‘û}4Î¯"°DàNàª¬¶YON¡é…IiÚ«Ö¶¯€Uk'Õ¿´½úÉşV\'³èz$B:OLsÚçrs±3Ö¸Ï¥V#QÎ|e|GOf¶J|€›+#nMİ˜ÃÏÇ$MÄvé`b ghÁ¶`"(º÷eÔ!;à$´fúaj‘_Á;„pLèœd°lÙcpoVácCìC€äØq{]{Aæ`hÇå&FÚ{ò¯€o”"ävÁH"û²‡0 vüäa§mUmİ5xˆ„X¼pN"0ÍB k")J®N¦(x£Oá4u4ÇEMÈĞ5åÖíˆa–{_û‡`E­(=€ow.hë‘0hdWÏVj,‹,)yi.ó0‚HÑÛgö{×/^¢@GrO!#’DD%«nâı—Œ"sRjyö p¿ƒ"A ó;Œ5èG<ebNiÅa#O=¡iÏçşGÊÖÖ~ö½k­’émã{ÿÑÊ©:ÑËcµvN[^*¯×>j(ùpAüÔ“‚Ç
ï2³Ô5²aš.¨MXfMkÚ˜I¡(ĞÓ¼£¿t,lÎQ÷Nz•~Bµj}Ã?¡¹HCs‘å%Ğ,{÷*x¼xŒc5ˆŸ|¤Rc	G|\oòY˜-Ã$‚wØİ/"E“Îo‚¼qåÙ¤_}eô	`SÇoba"S9Qïúá;
n}›fÒ3‘ıi!ƒMØ“ç/£bë`2K^£<^şø\Õ Ÿ¹åúÏq}.ÿFsöïÉ>©r/8",ˆëRu"o!ÆGÎMhòoXaáOœ¤.9BîÇÄüóp	» g˜*,'~x#¦ªxI1öJKãVaIaé¿ÁÓ GSC•8Jwc=!6í(
"³y»9'n
>Ebn¬>dş`òjBgë*€#·Et~xgÔ€A5*ÔPÛÕ~mÆA‚üõ÷ãjÕy,MÙ(ƒáèácFÂlù_ING}Û‡ÄJvL%ÖÅãïè°üB•¾wL1ÿráµ"^x¯g¢Ãÿyœñß“ê}X)È­5m±0èıÊlò1ò¶[3(àÉqú,2R3ôÏk¼c}¥Œfı4s!òW1NĞSÖzÄdîsº„U€?Å‚Š°;åãx³G"FÛg"Õ©Ÿ*fT1ç=mÛªÉ¹w g¢²ä!lôr*î¥©ÙŠc[ÇO_(<¿P¼!3	@R$2ñò€ÖÎ.Şw­A‚:Î?ñ[ÌAåH;í¨_æÕ5RåÕ9vZÔ‹n" ^àı8å=Í)?Ğ=ÉÀaÉø÷@#w›zŒBÿ(ñˆ×šp",m‡îrW3ç’8frÛpLèİE¢#\çñ		3$Û·º ©ó¾E+¢S›?°Š%v5a*°p?)%0İãäUB\ù½[òíÉpı/4t÷ráZ.ı†)1)×½#v>2±6(zìÚÚ&â÷LÃß@éƒbátDÌP)Œ³~Fr…õÀq¢¬ˆÏ0lå†, /n¥F5&a	ör7é…{öZ­DÔBv¬t]Ø¨#t ?‚£,}0(¸àr+¡öâ]*"Í§CîpMë [õ§i3\¼ejîdyM‰w?D¸Qˆê§&ÂHji:¬êS&‰d˜%Š~!)D—ìûÙ'miÀ¸gİ,1!{ûnÉO3eë!Ë±(!PG6pçZí~cw÷_Ãv¥¶é×Ÿ…ƒ·ÙuÓ3Aİ«ÅÑfZ"tº#„)Û£Æ#-*Mé°½7C_Ôr4ãPK9aûäo6kä@Gæ7¥"%ûAĞå»i«t! ?wakø}*@œ¦°{.P“}Ès ß{f'`IÃÃ#á¦ 1¢`çs€ú© Û26Z,Aé/`ÿfí;ÂşnmÛ)ç8ñávY¬óÅw)p"{˜n¢õã=¬íIAŞŸWÒÏ0÷!Ù—ÃÑua 7p¯eÁ)»ˆx#
aÄ·y…âzc`f#€a÷ğ¤ÂÇn
JI.Åp:·™}^t¼Bzíú„ü8’ÿâ]²=E?îj²bï`jXA¼*ıÑZCPrA¦Ğ?“W¢ÛS— Õi@N'/¤ğÅ!•<bÑ<gè o‚&˜!ë"9ÖÊÉ7ãMĞ lqEà¸ß2Ik¢T^2f† ¡òÃigéààXlyu“k#]Ïzünİ-ÛFK.´kà™˜Ç1NLt>&6Í /ˆB#5` ¥"Õ'/aÄÓ¢
êJg‰^>IÃL¢l]°ÆÎşcøONT¤bq\k,Ó&šëÅdwML‹…T°æ;ï{œEsÉêü¦~ÕÒI´2ĞÀ!õîZ…÷º¬|½õ¾„T	vm•uõÕt5twö8'h”ú<`§[f(ÓR9sk7R¦+Eö‹~*i4Õ»×ˆNUês4üt8$k¼õ1,Ş5\Dûbó&T {Vh¾pµvy´‚ñI$ıd{‡´€‘ö¦ùJñ~ŞE†<ğ_ãJ¹yF÷Ó`nõ4iYèO7&d>Té‘¼(jr‘Ò.CD.óiØö i·§Zù°7 GPxÕŞs^qŠ9eºù‰j$<YaCÈ—2èoy$¸ÈmÖ~v]Q}Ió;“÷ F„vìJD}Õ`¹>$y)sVXm]ql²¨ô[aµx“Öï`, 2¬HËÕ+‰"Ş*²_qâä¾,ûĞiØ„gäÜçi9+ZùHşé4{lo‹P2[ö@ävbÈwQHlÚt‹%cé$z…«³Šeì¼Õ¹{¸İt>È-^]+Fõ"*–»(KaîaiX9Q ˜LL
ÅÒWF8¿2VğmÈ­ÓA®l¨¢]‘æmêîÌr½'bÊ“+QnÜa5P¾LU/]|ñK¯*!¿§£xÔkº>0®-ÀÊmeUà*†2=*ŒiD*Ä°¡1¬´PD}Ã¼WAxÔ§ûä,|•íPeä~#ÃOtFW'3+nãxq¢ÂŞØÖZeALt•fÙUW`WB~iËqÛØ¤úËh|r~úİôz¬tVy}n)a³Xj°ç¢šDw¸eÇõP¨}&ŞYË{F±Ág	hÉAÀC¸p?paV_å?Ì©Ye±d@Ájßàí5rLD\i^c‘±
jì6k_­%©dªë™&5|kUev,‘Ïôw)i_«I‘R‹ÃM¤/@QKà/L,xŒmN2~~¸B?yYx¼şÚ¥Ûïüş§m˜R§9‘§@‘2í3€}9 Ïzt…Ã >Ur—â|vØ”#Fóİ<cMjG`&F½ÿÓ¿“(ãœ6l`©Ç]Â(‹¬E½|[ >oîDçÈ]{Ä
¹Zº á¸"¿;&IçÇ³çN7Zz‘!&š"¥$›£ş•HĞ€üâHv¶ûkOÂ+mf¨fmx|¢
<­D¸_:åJ)X¤=s®eÊÃX•«€Saı‰ÜäŞZ@H`®#:Œ½ äIÑC!íäjé‹Øi;efÈs&øXÛŠÑ:æw›[”%Å§1”,®âÀ(’1.j0¶1a‡B³I@ƒçô¶Ît÷t }2¦Mÿ¬æåÇ­PæwnÚè3Aêw
#&ÌK
ÀĞ(â'Ípä‰BdµYïVØ[
aDî$Z¤íaa.yOs±ç21­-¢i«sÃŒLLoÈåY}ĞIw$ì¤³k¸LNºì®Í2ã¼Ú@"ék“¹â!·
}1á@5…M~EOÀÕdâ§¸fY©ÁI<Š©¦uÿw÷OŞE†Ù÷›eSp¼õú…F®¢EdÂ¤=µ£Ôvó;:Ïà©²—i_G€4RrdBùerœÆ«¹œb´a[ ğµùGÓÄ÷Wü¢ëtŒd%”)‚Äé.Tjòìá~UÍa~´jŞ-ì–oLx‚ë ™_z6dèbï!qBÆ`ÌMok7–Á²İ04liÛà"¸'º~4"+ mÇr-ÔÍ¶Ï¾ò¹éêdgáÌ²
%Ï0£DF‰êñ³¬°xø8xPccb¨ Fa ®hUV÷?¤`Û%… ïn&¯ŸşOìÓn‡#XMeÏt¤­Ù_Œæ£!¥õŒÁ=ötı8Šz«I<²İÁÅöÛëMßëV ÅŞeEíÁ‚23yÄ‚¯&¾Z”Bsˆ6j¼/¡ iróu@;QeMCÑëcA0
âäcBkc`;`fqÌCğdæ,ëJK=jÕà‚%ıU>aŞfïø/îaf¨ ¡ e£hìÂ¬«‚fzÚ÷Yd{_äj‘úé AfM£_D	÷‰ı! w©·Ş	©‰¢uaÅÙÅmÃ^°eK¿}lÀI,:µ}…iç ÁkÖO$a8	#3èu&\w `#«{NVæöHìjU¦$Up\1‡Nâ|mÎÏ­…béDt€ñrtäHfgi½X*iµv\*Læ'G$¤+BâYUûEo2¹íêù‚d5¶ùnT%4L` gI"ÍjòıÆx"Á\^ _8‰gt”q¦XCqDŞ8ª	ÏôI@ aØâD©+ê»yÒçSôîüSÕËiöÁEn#±i‡}äelÃÄ&å.i%Hıõu+S%ÜºE›‹CÀ¤!‰r¯-I2¾’3û_0À Úoó`æ ·‚ÈÃ xp^Ãm­Sô7‡cb¯$ÌØ…†´5aÎ
I!DOåÔUu`å	¾|ç}KùåMİº°lÊ2¦y2ÇŞQóCYŞqÚD=æYhÍ²o Ÿè¡ ¾ÈË$Õ·UÔp¶4sæòºmrè]\ï¬‹52ÿ	ğóaí®ÔgeÉbó¯äÁñÏ˜F)Q@°KøYc48¶uP´8nT¿"j= ¸{0“l
Îv[kKóàåüÄmYN(XÛ^í‘àfà0öôàŠOÊ èKv5§ÆJz!®0n_k‚¬àp¡ßM´jÀ¡9ß×QrİñØCØuÆØİe)ÚtşZ—_imò4Tº/?êi­ÈŒO’Ì§AŞW–y–!cI„Û2<€"§|=,2ª£Ø÷GÅEb$JÜ]lD]oá~)ìX–¯mŸH(U‘Q)uG‹`SóŠçE\Zk×¶<ôc@zE;½h`’Ssø#3Ûåšb<`}“iLÏ]GÀM?–%Ô4'Èl	(Ñ*ç+±.›tF{*‚Otîä¦-ó[ü McŸ‹FÒ¹/8;46r"dun–1Z’}Ûåp™tÉøÆ_NbT¤`p•0ÜoÙ}X5zŒ·ZùısI‚7œ"ûôœãz~9¼õZj‚I¨¿rfp:m`Šl@0¬uÕÎq\äxe;!åaXDÂTŒ`F¶Z,íd–\MôVäTöD‹~áëuÁ½…TUÔh*Äózi‡fç¢p3’s~édÙsˆñĞ&Yoõhğ†ã	ºd]pwäECC,#-£GĞdvÇLªjW„·i8•¾:¼ûÚëy|
‘cbôNOşªU…B–÷¯Ô(JRd»ˆè›aßfüÿ#¤šE“ğÊ´í…Âõ¹õ5OPêGÖ×è‘<jÀ~ *"$v±¥b§H‰î³fSvk7ÿ
®èÿ³$Â&UYòšJ'úD^oğ;xÚYfe«U"›ÄÃt[ ¦`µï9¬Ó›eXE©Ôìıoe´ßş‚Çí-Ê;YápeÓÇD?QÅrK³8MEã%;˜ĞXNäãrÈcc@¡ElëBûw>÷ ĞË‰dìØáÅpIS\Ùq¹R×.§vÛ òyxÂ€1äQşÚ€#%]i¼H5f±İº$E*z1ÊÈ¸Øn=Ójetq`n‡À“Í|YhrüMîõO|;d£"ócQò{cÏ8­Ø&ÂšL{¹ÆfhÅøÃ·iq$tTDõx®*ÕÔğ^_š:Eã®,mÚ+APA1\FØaUÏ[³åÀxãöÄ96Êp{Š%ñ\Ò¤=¢çÁÌT Ì»Éğ%hcš…©ÖÃñ[Cì	¬GØ>¼VÈ#.Åxní(ÍÓoq	Øj1WR~‚Höç·ZÑCAXCˆ¹}¤“ò"p'ä{t8…àÌì™Í5 x’¥]è` &>®ÖyAZ¼8ÈwïaeGz}É¯ªw|†eNå©R¹¤ùÌüè"2®ğc°xLi"Ûgã}ù]ü£aBm2‚£üqøjÌv:zå7M#D«n–Q#`^óVëv%z#.Éª±Llì>Re#T:pàÆç:e{.óuû¤ìú€ú9o&AXba£¼y§pHç½?X²n8£¿™¬\¹X2¸<yñDW"Uè†C4ñ^P<C ZñVcüâ;sÒş¡=–: y>eH÷[F"·<FYÆíçÊ;ø—;ÓÑ#8PÂE¡#¤Îoàw!Aİ™@Ø7\6)¨3î•ùp!iyuzb0]5…ˆ4
HìátSöà2ÇÀSkÔ¸«]÷í.OÑû\ä"ê/5P¨]Eë51UCŠ	'PÚiWõÍ·J fğ}İ`ŸvñÉñÁl)ÿÌ2’jx.Y†uj—
N±¾/Ox…fùººu\è FRáwáÃEñîMR;ˆz,„Iìº;RDLkşO~jaCÓ¥SÀhJÖ)&KØ8
ƒ¼Èƒm‚cò¢H’bµ*7Qñwµ’ÀdÚiÃ†sqÂ	0ÆP56õê‡R^¶˜(QpfŞ$ke{È1µ$<	ˆ;#šRëx!*pdÒùQaWDÁÖ“ØC6]ÙíË"eè»¯¥i8Òe¿ÍÃ|s›oº+İlñ£¸vÅßvièXƒ#•C”­úÊÃ£e¸òSdË^L²s¾Ê¼`9:5} ! ºX ŞeçePd}Y8!±#ee=$»zª~iôjr£SÃd€)R´ÁÂÇa*}r0L"C hö¨w²æ.*øFÅ¥¢”í}X‰)éÎõo‚gÌáRK¼Š;æˆÆ‘!âÅòPvqfW (bG4ıËôL«$(ÙPú3súÒrˆ-ÿ…qİ—x,uMğwƒ” †1+İÕpä¼ı›v«>ğ*¿@_dJåäeSUbñ¨…s€J,l˜ôrºRµâ×Ó8¥iÛ9RAVªAsÛOÛqK|eM7 9$”ÔXŒ}Üzœ³T	ÿÏK**òzZß@îU+(Y/¢±{¢ np”$«d ×Áü`.€BÅ›rÍ#kbi”hå@z_å\lqyrÙ†£}ÀL€7	i';xpw±_èpÓ)4™÷yOO“Ã×ğ(OC¿çùÿº25šQÇL… kÜb9’‘ëE5Ùß#)- Š"&Eéz	t](."Œ6c1*¿
mÍsg)\ñ,7éèÌÀä¶ ñH¢[†[\Tğé“…°y«*»±ú©?+‹sz |9MË'üwaÁÓv·&vs†2óTŞ">êùÿ:{İ£º~÷=ú~iV¤Ÿm^ôc™{W+DĞª 8;X‚)m
ş¾&¬oÚotğ nbd›&RÔ
6ªÌÛmçyn	AÚ†WeGwÕE£°¦r–W»33^?|J);;4ªÖ+AÆ)50’iƒ~$móÔf^Ôq-LĞÌÓ™VÙíEóéÒ;Â;©Î´³l¦O\$ĞWò)T)jOÇzD€r\Ó¸%éÄ¢ˆBÁ•"-T32B`)ÅÚ0ûyP<’ÌjOÅGt=İk9ÈYWÍ_ôu¶ï"ª=|%û[LdX[EgjP:"‹Xz¡DÄm:¹1}!©/f]Q›ª»#eè$õò»öKhÕVŸÔ#@@B‰òÓfÅsylÕó:¤£,è«Zşèò^¹­Êö!¢«aBâREnè4K1ı©™*YôÈpµ(­hB¬ŸCş ©v\hÄˆ«™m8rú~—¼p1„&!õÄ(•=“tÜõò 9B.Ãõ>øiÖı´5N s:Ê@d¥Ê.¡<N¥ûQÚa÷yØ]¢,$S±:ÑEĞÂÄK¨Jd0]¨©a§Ù<x¡ÀÓÃtÃ…Ë L­Me˜a´íe˜À<MX;W	•ûèü ¦RÀ†Aû²4<J*'–Â¾>Æ} *-pg0$~$.Gé©á¸ğª²‘?úepñænÒxnùäîâ0CŠ~µv9óCC {Ì"ˆ8•ë$áÅıºäLc.i´e)L%óÁmèÃ¥×dô£Œ¾_¢o}Şw{y9!.d7z»j!å·GÓƒİ$M™¨{ây¾"f…C3¾4ïÒİ6
nìO‘Ó^Ã.–!p–V=›/»aÅ´¨ì 9bpïÉI{'¤N›Dgöy£WAm!¼?IİtßF<B$=C ‚Æ1(h	ÇÕ¯.¼|FL# È§úu'vĞÇ€¿4‚òˆ8…ùp!ï §ÒÈ£'ÌM„úSë¾Gænõ*³¥LDÀ¬¥U]^èb)h¸©r¯öw±F)Rs¦d¥¢Ô ùO~pSJ&WH1vV1Ğê#¹H?À*¶°êæ!åˆèû-!Pa=V¥*,Vc]ºÆ6ÒXÙõU¨›H'• wEÑ+Àò0¢	ŞeÀV©Š°ÕRe¾¥ ¨|E$JÆiZ&æQÔfhÈN*š6æ*Cè™šK²Smíğ+¥ëkE¿øS‚-P® êštÂıì1Æa>9äG&c?Î Wnæ
u0ä¬2~-{9Tá·gYP_Mt/şÔP¯Ò|çquĞS;ÇÉ'm9f/²gFx¦¨`ßTK':èaõÅ§Î:~&&m”rş:Zˆl-m­tôç^a\bætmêËU!d*/£íS¢©qh>$»Ø+Î¯½úM;UEs,I‘^s0nísçƒo2· ?Inkt	âõ(öV|æc½5ÏÕæu2®º©Xf7-{ŞXĞš¾ ™i>Q2v]I¼gÕedøÎüy1g*ì`	?uGÑÛö#:S3 @©,Ùœ ´É¯ÿ$yi”|wş[Ğ,Ğ•GùKJ&cW>Lp`9î0vş¯oæhÈ;;ñ$ü%|:ş	ê<!…Q”8Tğ;œe‰|)x·{I±trşdàRõ)‡g8uÊr  ^;İhêC’‚/š†!jtv‹j¤0=bISù@ƒFúåt™i:YJe* û;qr»æõE*f¡cNWA²ûÖ]D(Å&©lÉf:ìÓëhQh!Õ[|VA‡«ÖGUãw1¹1 ƒ,šç-gt€3Kjá~pxçäİ¢Iy2<îayjjcp€îÙ)àÁik/‹"cí8üÖ"m¼Eõ¶’ï³a?,Ñf-«gš|Üè4p¯# t¨h:ôï`ğum³îPı(c$+`İÕñîD7}D9/öåA|o˜d
n #Áyes)1rwt:5f 'nìjÂ©âÍ°ò‰R!`yîS`mcEG!ä)¦O óQÜÀgmzæaÅãa+ô*|YmÆ|0ør)94à+¹a±õó”i"Ò²Ôj3ÌÚçpéRş)d3knıô$şR´P¢Ğ/ eMg/ÔXUPzuRj-³9möø4ú‡ÁÛäîÑ–²i{,äğ‚Æ/{«T‚¢á x»r)ë‹f|~X—lg5}Zt \™ ÅFi÷µ}_Î’ui zvìªU{W8íb2ûsÁGÂ¦ödA¸êbş ±°c;PÄKàT i¥G‘U8@ô\e¾É{a#M„p¸&?Iı!ë+)_é{cŒ~4^dQ….%³b-c§a–)/Mhg²O)W>²£R;i¦H¢ô_¬s,oS8<Ä¼#xy¬l1¼9ÿø	 rgôA˜Vf(™¨£Û1²Œ^/ûQİÉhî´/~Ï0pvtw4Ì©tĞºppjd={«;Çl#y`sÖ1)ºêOsìF8*K•6
U•·òéòì6!Ù3Êc&9ìyÕ,*á77xÈŸf0Ó©²7¬cÇUîuùåwp(j½¢-Eæµß
RPvä$ÜÊ9T’ p]¸»iâØ¬÷bıaù_o,ã]5G<†’aótDe=å"s#åA¬1º#R-s’C	0 ”a*Ñ7YrJBûau«,0)Å×(<bb¶¯@¶ÒqïO s8~¢8™ÇV7é•.!¨K07åª5v;?&¯–E:rìxUINáawå*(¨ví^ğpùC/Ù†5rb¥P´P°ÿáòA8u¾¿è`lL¥îıC (``õ±´F '7/ˆ´ ‚2³\;ÎkçEzäIC^Óè¤¤€©İ›	]eøfÙóõo *“òaA`IZB²v¾s.gµ¼5VV&:ohVÂ3*Tgª7	A'%N ·uPc6éÖu[æI]©˜à<rŞÛa!k|zR8xñ}ğí´$‚î¼UFôBÀ7(ìSûÛ }~eËô\%})ÑZv©l¡·ßg}<")Hö{7dñ1‚eÎHÁD¡¾€ŞÇ¿nø0pI1£mas(–‹2 dÏàw|t¼b¨k)jy f,_triÇ™Õ	¦L£JÓ 6yb3È’W=rOp› ¨’b<IU€0*åT@¬1Ô­H$Ècºz¡½mJ4Qè®óDéza!"$wí,yoà-Úù|$/8"tVğVùª,¢pGJcè•A	2 [†¯—¤…Î×2#q¿z”ôÿÈ;æ^\7>à~ >KL Zår#µ7ĞeÏU¥p#qú|$lr(N{UQ+9gM”Ø‰O [YÅt}âA gøP§d Nzv!Ü;¤9¤,”fœlve^ÁE	zp e°ôÁctgv¡bÃ¨x æÌv{{QÀ@hÑí¶ò{v¿oğ"svÀ	"{s#Sàty$é"mQïİ7`†„XO`o^v:m@$:"nÎ¯n6|t£J±p¤,cMˆ˜—R,‰`sv{ - 9!w'n`ç°hoWËRhn«di»8i"÷1¢Pñòã {Â>&Ş¢s_+bc²nXe2bóßL"k j4à`'.c#qshL'äÇ')xÈ1Ï±(ßæ8gï1ßÔÍ²ıi½"é}ûqşU@­:ˆc¡fd"Wo÷ *-¨8Aöí‘‚çw³Ô5òaè'mEZpwJ4Na¡(Póy£2%,lftóNz…l•Ã"]a5$½hnr’å3.zY{øè:B#,è–tM¤BGqåyL~ğëh¤=Æ- 8Ñw¢Q“/áôsÅû7 pKaÓAm#zª™…AkZá(g m›¤Ğ"Ñİ81×Y˜’õ++aëw*ó$v³=Zş¸Mà»»mïìq$tsæşï=©`8rw,¨{aUb;¡Rg«Oib. a-¼9}¤¿0ÂæóÅ‰s`A»—to°+mj*.x)+¤ªpO1¶JlK¢F(ah6¿iE[ LïshÇ6fvw!6Í(
Beo Ğ¿cÀ
>Ubkyº$ş0û .:e»
€#õ¥<^2kÔˆK•)ÔuÙÆVMeZA üğrã.ÆÑÓ*O8 ‚áhá/ÀF<iIODV„Bv%ÔAãıàpøkÑ>ûxç5‡O=º'rËci¼‘Š¹j}(é­5m±aè¼j,²5pö{3$àÃst-:ğsô†G ½ m$fıp;"à^!ˆQÆzpdfs:u
<õL˜ò{õçp3WaFÏg"uiÚ*gT0»gŒÛ*İ¸5 fæ2ô!lü`êì¥½ÙÊ!;DN®ğl!!KqR$h²ÖJ.~s¥A–¦4:‚2«{¬Á¤h*í,^vÕwp3Ğ)vZñßî(:
hı±í­Ì­}Ğ)ÈN`Éùw@#wWDÂÿ)pˆÃÒpN,|'R3ò’=f%_›p$èúg°	2Xgó9I#4•{÷*7¨/óİoQ£Ñº-´H$v½0+¹r=+E4Ô÷äëıBı½[ğh5Éxñ*d`òñš/ô.)qÉÆ=e^6ºğhzhÊ~¢G7÷LSödıS&å7-S;,œ³ôBzµÁsf¨u0l¥'&Ò>n¥Bµ+`/~:Ñ{ö}Z<TÒ6îyZÉ,c~İm»‚ã|$¸Ôq‰!ö2Y"²Í£Cî!8AêrRµ¦
5q\,Lì¦-9BŠR>L °sâJv§7.BLxq;¬jS5ÿÔ¸
;Ne!-Æ“nßxÛ'l)àiadT<1!;ò.ËK;:fë#E1(Aqg>y§ß/wc6sÓ¡´¨×ò…·ÑWWUİ¡ÁŒdZrex3Ù5öÎ#-8Màt*ü5ÓmÅ`1cÒ9#œyY€e6? TO(7áfZ%úSÖçë*jT!‚ow!oø}mxõ¯!+wD“)HàÕmsmb7 IFæN©aRÑŸ,1a`esáús!Ó6™	-E!/t`ïæí?sûlo}¡c.>µQ6iôÓéïjPr z+’fæÏå<,½Ieo7òÇÜç q7' áu2p[\c kİ:p'eÌw!”gza2 awğ¥âĞV+
X/Õpc—A=^T¾B~¡ò¤n=šùâ]²<s7jûboIaY¸'
Ğ¶R@rEsĞ)Ó×2ĞQÿ Õ+ZNt7.ğÅa•SœkS=g)¢?NŠ¤©ã*1ÖÅs=Ë7ËMÔ0luSâR´oÁ"Im¦^b9n¦ ¡òó{géğíP<y|İk3}~øjÔ,VC.¶kÀ‘D1N^\v8"6İ)bG­ªFrµ;d ³å"V3=èÔRjªZev)ACÈ l^0S¤r"xC¢XubM\k,Á¬Î¹å„sYÜMK…T0b1ø?tB1éªü Ø~U²	¶pEb³áîv—÷ì|9<1¼ÄTIrc‘uõÛV7ugö,gQB½uR]Dt[,ÕgÁv%4P¦;Ö_ş3é6÷?×Kuês4|Ure+¹q5œ>\$ëb÷VWdl>Pµ6*y1‚¹A<&¹}^ó‡ı´APş¶iHğ6IÃ†=
Òş´N©y ››pneS#øo)v>©»4(j°‘RtóTãh\ôlqwÇZĞ:$ÁB[yš]T?_ñª%s¹‰z44YqÖãØWz`ç>'ıÈt §u'Lw	ãL/³× æP~ÀhF}ı@­?$x!8qsØl}qd4¸şôZ5{!ŞäFÂ°7â@ëÕ.•k×*Ú{qâ¤,,{©œ…o¤ ç(5:Xyıitq)-r	R¶dì0fcÊfus0Á<ítƒ%kmdhÚ²7ÅfÌ¼õ9z8|D9È/^\!Àõ*£jgá7¬ea5X%Y4¸:6
ˆÄ’!fm»1qíJ­[Átg©åI‘- èîDb3'jŞ+QôaP£Llr.Y5õËDgc%'£xm"0,Ár-å$):=.Eit.Í¸Â:@ Ql}’ÓŒWA.´&ûÄ,•­Dd…ä^#x<6Q'u1N;qqªæÊÔF`ïAMLtÔ&éAW`ZRtjGpT@Û}¬ÚíHxº"èÁô:,p–xíb	-1Hb!'g†DS9uÖ´p¨=fæ{){F³oĞ‰kPA¸*;pavRõ{ÌMqmË™F%uicßß`5~ØeLmzc›¡?èg6kW½h|f›$u<(caew•tw)hjë#‹æ ')Aéà=D,(Œ
mOš~i  L²qx4ô’tûï||;åmtR§›§}Cñ¨2 _x Œ{u¡Ão×]xÀ<Wx”&ÄãÑ,{=jOa@¦d]¼ó?O×0GŒvlhˆ¿Ø!Â(ƒmi±Le²:jlDeÊRÂ‚;Qê ñè/ÿ/ifÇ´‡åN2~jâ°Õv‚[&6¤¿£ÿ•I°@x*Lb6iJ@6m$¨feL2tKìEüV8óJ¯|´/ó­gÃÃ\·«„’Iı«ÜîLU X $#:Œöâä<mˆgd…ıdrë‰I+wg »&øó‚ñ>æ»{Œ2mÕæ!T<«fe(²q,j`¶Aa¤R±HAGRç¾Ä7rpûT°u3¢eú¨ªåÎéÔ\]v®8è —`èS	F .ìI
Èñ)|5üx?ÅB$µCÉştX+NPDæ4
%Èm/y]3©ç2z+m ‹iªSqomg‰õ{w”'&¬¤²{z^JªüÌ¤ò®yH³Ëfa İg Ñ§ }sçP46^hE„Õjb9¢¹bS
å8m<¨·g¨ÿÇÅ$Òò›uSpD¼åò…vì
ZàzÚ¤>0õ¯Ñfã{\:`(º“k?G µRRvÄBñep´†ã0øf½!Y$pl§:¾ûWËğ„±ö#ítˆ(%´¡‚Æ;®G:oäá¹fÔI!zµxŞ5yÌ–-LØR€y´I]\?l$rÿ¡aŠÌpÄInk6”År^©gXl(Ûa2¸úút£;€cG¥1„4 Í·_<¾Âù¯rFi¥Oö&%Ş0#H&úàµäxp8y;Baæ$ Va$hUF÷>ôPÜ…$Í&d?«üób‡#XD¥î$gmÈuì 5¥W$Aq=v\¹<¨Z¨M~¸mÙEÅ¹Ûó‡/s6°çÄáE:íÕŠx;'8K¯¶>v­qrˆ¾w¼,1atê5D+Q}aáie0â¦á1RÒ#ba§Cy&qÈo{_¢ÿNa?,Õ&Á­}u>ÖFîù'çaî(„,PN¡dw»bdîF¼«‚fsúgR  “mb„·¹Adi!_Ôvì1q-·[¨½§5´qEÙáx—]°vh¿<jåI%:ti„è&¢ÀkôFbaz	#³è±2ØwAb	s¢Ú}DDQÆ"V¾Jp¦m—0‘!‡NdşVÏ©…dèIx…ñ~<çXf$i½x<JM³Ìm*Poæ$C iTæm!Uqqï2³í®Ù˜&!–ôzD|%$dIdKa2œFp"Õ]Ò nx çt•q¶yfrDN8zCOõiP !iˆ`D­+BpciÒ2òp¤éYÓi÷É-.!I‡ü mÇd&å/ah²ıõtcV%ô;p¿Ã´"sª¯I0¿Òs__5Ä@$r{eâæ#Ñ ip^ãeìSr/2‡c§ví,…¦”)_bMBimOeSoyåp~v]NzåOôv2|É2'yrÚQóGÏŒwÏD=Ö}vMgDŸÈå ¶ÙÁ®u5>Ş <¶ûbğznvaLt`Ş$‹°6{ 9siïáô# ‹j÷¯íbñOD)Q ¸Úhs0?u@d¼hfE^?"*9$y{p“lÜx/kË÷à|<~íyfiÑÏ^à³âfàbõ*à‹OÈècv4'Gâgàr oWiª,Ê~¡_	¤pÔ¡¹Çam9ñÓBÚwÒÚØe!Êvn^–ßo}rT˜=?ökôÿhŒOšÀ¡MW†y,TaçM7)»4 n|48>¾£üôBÁbbfB¬¦[lTU7áx)ìyÇåı†Xh—1€<@[›eIÓŠguôJkW§(lo`jA=$!R42{t03ne»‚n`3m!,DïE 3I?Ö&\>6À{,w‘ õauD[(¢m@ï†ª=óZİ MkµËFÔ¹/8;(—2"`uDO·1Z0}4[a`‘XÁ,øâ~Lbh¤-ñÕ‰/Ut7r\ì·Zùl3!L†7´0(ıŸ	ãx(,<õ8HK ?r&`{( <$š	m7Ul9+İx!åñX@Â`ÍQ0O4Zí&ÇXVöRäTô
T¹váëtÑ½¥RÔÔh*Ä#¢sŸf÷*x'N{(~8FÑaxãÚ7S{åDt¦ éºmIpwl5Kg¼-àÆV`ĞÄlªjwÅsjº”¿z”Z:ÊK|	‘/cñM_^*u‚O’$·&´BVpT;)êáİFü÷2$A’°2b¦y…Âõ™µuWÊ&Ò—høÊÀ:tbaT±
'ú%<ïtfWrc#ÿ®èÿ1$ÂT4ºšz'zk“â{3ššzw!™ÀƒeK´¥`aïrür[eHE¡Äú¾ï%¶ßü‚Çı-Î9Mápg’îd/IöøÛ³8Mec5iTĞXN–la8ÏKc=<"p¡ÍfPJrÚ>û¤ùc8xüÙáY:S~™q¿r×7¯vQÃe²xxçàq&sŞ ;%|!èL06°]z.Í&Ú(hEıÑ|"6ÓÙafU`nƒÄ;î|¬S½jñ{l»&" Óÿ)ökg_(£íBºM{ôâ2b•ø¶iq$lVeõp?Û#õÕ0JiŸc®.ìS/AdeVDqUny7å@x¦Ñ54Ê`yŠ% \Î–<¢beÌQ ˆ}“Œğ'hD+:„©Æ	ÇUZSâ¼ĞÍtù8_€ #Œ€q­xàYo!	ÈfeGBl‚J·gT;^2ÑsaHA¬»E ¡²rbpcÄue0¥áFì‘½7@xòµ_è@ u¯zÒ[J¼té0Õ!eF j}Áoª{W|uŠ­oõ©B¸¤)8I¼ ø&7îõáïu${gk0ùal/cGl ²¢¡ü1øjÍv6æã7%!Öcd2[#p
Zó«v%r¡|¬Šª!k,Î6PgC©u(t`æïeq.³=÷$ìú²ú;o&LYV!ª¬y#úIâº°j8³U,Y±Y2º%Y·DmUúƒFuµ\Q<V¤úqVc¬å9rWŞ)w
 pgeH÷%QA‚·=wY9s¸Ç/‰íçê3ù—;óÑ?BRF¡#¤/za!aÓ	étB(Íwîé>ødémq|b¸B#E€<*E¹ìåG4SÖ!KÀbcÖjï]¿m.!-ÀWärê~4Rà]k53åÃê«'ğØ©o7É7L$&´y‘iÿvò™l+%Ìº’jh.Y†qjóGáîEFS¥çm8ºW\h›öörá7çcÁ|şSIr	ˆqs¤Yşº9R†cü_j©#™5[À`jv-&[Í¬ ½èmbºr@b¼"Q17u¢Ä%ÚhòsaÂaÄµ7’}Z‹@~üšjpyfJ ªgqh1Ç$>9{gJRJ;?()*vfÒøAafàEƒØSO	&TùŒÃg`3ç§e°“¦OïÃ—}Z?óe3«Ü6ñ£Átdßfñèx¢"¥c´/új0ÃeùãÛk^M²3Ÿn”6À55E*+#K%¢NgÏ`@li8aµCe5?±ú*?a´is¦5`æÇ-x0ÁÂÖab}p0L¢G+iô¬U2dzüVã/# ùMH¨+:©Î•w;#x 
-‹~öæ°U!àşšPF|,C 8hCtíÓ0Â~N£f8Ér6!rë™Ğ2 yÿT1q|7v.uütwÃ½0Y{^Õp%¼ÕŸv{6Px`¿a0jõ­ öbÑ°¥wÂJ$dÖÖrkZ—à÷¥+Š[rG¦a¯ÏûOg-4(4´Ñh˜ıİúØåõ1ÿÃc"¢2nßlúU+8R?¢0|
"PtpIv(Cf@vü`
	sÅpü'k¨Ší’y$zä|D™izÛ¤«tÀ¿ik#zp{vê0“-›‹—|OOã¤:oÃ¾guû;4’Q?Ã,Å$KÜB»€ˆ*M4ß’í')' Œ&&u){	pe(Dæ6sa"Ÿ"aÍ{m)\©4'èê‰Âä–x¡M¢C†|GÆåƒ…8y«.¿°ú…­M:ƒsb |8Lë3ü7aÁÂ3&fs†åTû)lêùÿ:{£>÷=»¶h<¶Ÿm^üb8‡{?V? Tâ¤=5K—-9z¯ ½íú.4ğ¨Nr&úf[Ôtt>Ü[-ïY2	
APÑu=CwuG³¢ö—O¸7'^?m+ø)%)y4rÖ)V($°#i£4MõóğfWÔq!|±HŠ™™áUàéÒ9ò:¨Ş°ólçltPR(^)lKGz€rmS<-'aÅ³„bUm1°B +-z ËgD<awLê_ÅFw:İJk3»K_L_m2g¦nA*ıX{ûn¤\_j:p>2‹GXz+!ŠÌÄm;±%}/&2Q³î}¨	'`hPdõöòvx]VŸÔƒI@C¥¨Ôs§ÄS0Tñò{  là+ß~ÎâZ²Èò$%p#gâun¨1IquÍ/,*yp"™x7,íø`ŸkÏ	Éö\éÈ™;+¹G:Vz{4t°,$w‚	6…=tÜô| Ce‚õ?øyÔ½ô5 SòzìsD¯Ë.1(íûRÚköy^]ânlC±8‘ğ‚¤K¼Ød0><ªñã˜Û¾:Àcqƒ…Ş|íoe$ìb¸ÀU~1UCódø nsÆÖey245J2&Í2Â4<ä}3z,`'"8~)~mmíaªÂğ¦2?íäpõ¦îğ&(nyUêF8b|õzyuZCcNR r‰‘ë¤ Dÿ*floc.lôa%H&ÓÈoëÃ·õl”§·¢_5qş'{k|13.ewzÿr!ev[ó…7}8k¢i¾°c¥v2‘mûAPU6
míO™ZÅ,À!`³T=™n;iÄ×ˆí1îpéÏC {3¬ncöy§5Eoeu;ÍİtMv4B4C$éF1(i#³ù­*ó|FÌ3yJ-,_3VĞÓ½>+ÒÊúÔódpqm)§ÒN·7ñGûw«®².·uE¨2‘ñÆFÒl•q]^h`9è¹ˆq)¶s3LEJPc d¥¯øháOr0	$s@1vw9üOú3;Z}â·°jæ%å<Ëº-Pq<2ª$<Rã¾6ÆWq}õtŒ šM&õsÀÑƒ+Ã¾8:™aa–7{¹”v®g¾¥Á¾,M
K@iZ&•æEwuHHMbË6""Sø –J×S_j k oKi|»È3“ít6&¡f’p¹oİş#ÆA4á¨:G "", static_cast<uint32_t>(spirv::Opcode::OpFOrdGreaterThanEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FOrdGreaterThanOp>(::mlir::spirv::FOrdGreaterThanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFOrdGreaterThan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FOrdLessThanEqualOp>(::mlir::spirv::FOrdLessThanEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFOrdLessThanEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FOrdLessThanOp>(::mlir::spirv::FOrdLessThanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFOrdLessThan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FOrdNotEqualOp>(::mlir::spirv::FOrdNotEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFOrdNotEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FRemOp>(::mlir::spirv::FRemOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFRem));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FSubOp>(::mlir::spirv::FSubOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFSub));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FUnordEqualOp>(::mlir::spirv::FUnordEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFUnordEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FUnordGreaterThanEqualOp>(::mlir::spirv::FUnordGreaterThanEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFUnordGreaterThanEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FUnordGreaterThanOp>(::mlir::spirv::FUnordGreaterThanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFUnordGreaterThan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FUnordLessThanEqualOp>(::mlir::spirv::FUnordLessThanEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFUnordLessThanEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FUnordLessThanOp>(::mlir::spirv::FUnordLessThanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFUnordLessThan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::FUnordNotEqualOp>(::mlir::spirv::FUnordNotEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpFUnordNotEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLAcosOp>(::mlir::spirv::GLSLAcosOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 17);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLAsinOp>(::mlir::spirv::GLSLAsinOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 16);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLAtanOp>(::mlir::spirv::GLSLAtanOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 18);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLCeilOp>(::mlir::spirv::GLSLCeilOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 9);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLCosOp>(::mlir::spirv::GLSLCosOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 14);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLCoshOp>(::mlir::spirv::GLSLCoshOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 20);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLExpOp>(::mlir::spirv::GLSLExpOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 27);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLFAbsOp>(::mlir::spirv::GLSLFAbsOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 4);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLFClampOp>(::mlir::spirv::GLSLFClampOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 43);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLFMaxOp>(::mlir::spirv::GLSLFMaxOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 40);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLFMinOp>(::mlir::spirv::GLSLFMinOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 37);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLFSignOp>(::mlir::spirv::GLSLFSignOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 6);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLFloorOp>(::mlir::spirv::GLSLFloorOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 8);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLFmaOp>(::mlir::spirv::GLSLFmaOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 50);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLFrexpStructOp>(::mlir::spirv::GLSLFrexpStructOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 52);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLInverseSqrtOp>(::mlir::spirv::GLSLInverseSqrtOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 32);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLLdexpOp>(::mlir::spirv::GLSLLdexpOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 53);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLLogOp>(::mlir::spirv::GLSLLogOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 28);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLPowOp>(::mlir::spirv::GLSLPowOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 26);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLRoundOp>(::mlir::spirv::GLSLRoundOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 1);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLSAbsOp>(::mlir::spirv::GLSLSAbsOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 5);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLSClampOp>(::mlir::spirv::GLSLSClampOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 45);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLSMaxOp>(::mlir::spirv::GLSLSMaxOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 42);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLSMinOp>(::mlir::spirv::GLSLSMinOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 39);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLSSignOp>(::mlir::spirv::GLSLSSignOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 7);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLSinOp>(::mlir::spirv::GLSLSinOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 13);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLSinhOp>(::mlir::spirv::GLSLSinhOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 19);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLSqrtOp>(::mlir::spirv::GLSLSqrtOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 31);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLTanOp>(::mlir::spirv::GLSLTanOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 15);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLTanhOp>(::mlir::spirv::GLSLTanhOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 21);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GLSLUClampOp>(::mlir::spirv::GLSLUClampOp op) {
  return processOpWithoutGrammarAttr(op, "GLSL.std.450", 44);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GroupBroadcastOp>(::mlir::spirv::GroupBroadcastOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    if (auto attr = op->getAttr("execution_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("execution_scope");
  }
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpGroupBroadcast, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GroupNonUniformBallotOp>(::mlir::spirv::GroupNonUniformBallotOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    if (auto attr = op->getAttr("execution_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("execution_scope");
  }
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpGroupNonUniformBallot, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GroupNonUniformBroadcastOp>(::mlir::spirv::GroupNonUniformBroadcastOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    if (auto attr = op->getAttr("execution_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("execution_scope");
  }
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpGroupNonUniformBroadcast, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GroupNonUniformElectOp>(::mlir::spirv::GroupNonUniformElectOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  if (auto attr = op->getAttr("execution_scope")) {
    operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
  }
  elidedAttrs.push_back("execution_scope");
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpGroupNonUniformElect, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GroupNonUniformFAddOp>(::mlir::spirv::GroupNonUniformFAddOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    if (auto attr = op->getAttr("execution_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("execution_scope");
  }
  {
    if (auto attr = op->getAttr("group_operation")) {
      operands.push_back(static_cast<uint32_t>(attr.cast<IntegerAttr>().getValue().getZExtValue()));
    }
    elidedAttrs.push_back("group_operation");
  }
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  {
    for (auto arg : op.getODSOperands(1)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #1 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpGroupNonUniformFAdd, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::GroupNonUniformFMaxOp>(::mlir::spirv::GroupNonUniformFMaxOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    if (auto attr = op->getAttr("execution_scope")) {
      operands.push_back(prepareConstantInt(op.getLoc(), attr.cast<IntegerAttr>()));
    }
    elidedAttrs.push_back("execution_scope");
  }
  {
    if (auto attr = op->getAttr("group_operation")) {
      operands.push_back(static_cast<uint32_t>(attr.cast<IntegerAttr>().getValue().getZExtValue()));
    }
    elidedAttrs.push_back("group_operation");
  }
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
H*4ïoj ¥m³æRßc	) ßÅó›OuL™öÛC(oˆencÔMDsyöz‹v|³9~â%+n¼jÃ#òÅ°ò­PQrmî×`ma]Guôi¦ ÊPˆâeM2:"í"#:Ö)ƒ8iÃ~lğ)ˆ{´ª"(ˆ¡ òirÔßÖJ3LÉfcRøÒ¾(4süno}Tô¥¼ğ®3¢ğ/*eİg+ôÍÑújcRş­3+-îü´óÎÕä®—²°)êŠ®äØ‹’FL{«D†³ÁÒhúz¨«êUÓ|~Y§|(á1=
Í™ÁFkv¬İNÎkMéxvà¶LÅ¤[eÌxïlÿiEÂ®çnè¨êJì ğ°®?@t[æÀ¨ë¤‚vW@åLeE¯ë^a#M|ÆY9ÓIÍec/\ûssÈ^éMJdY‚¨q0ktw«s˜«Md?²M1W>?·Z{.µHo’d„İës®%×°Ô|Ä¼ax[¹)!¬9ïø ãgğÁ˜Vb\Ğ¨£Ùq¶Œ/“AßÁaê¥.6Û2qör0Ev4Ì©ıÙºxpë–9ÿª9cdïxDÓÇâá-®Ê]6óò†(Czê±4BSÕµŞÈ2ì2 I7ŠÊ&©laUn*ñw;hÌ¬ b‰ °7¬Âg˜îFqùÎWÔ@±‚£Eû±ßJŞpà4ÜÎ{Ô²QpM(ºhêĞ¨·bıÃùËLhå4rNv‡»!cğ ¢9ç":óm_d1ú!RAi&°B(×‰*™7Ù""–c6$©Ü,\À!eH÷+fój¶-=ˆ—
÷Ï@Pã¸O¢8›ÖWgéQ,`¸A 7Ìè¨S/7‰$çÆE6ÂnúÔHO]Ãa'á>®öí_{p9SíÙ&ºz/£À¼PrÏëÀhxv®úOloÖ±n|S†()hõ¹´V4e7(ˆÕ ¦°¢LªÆç‡rÌÛG^ÇÈÄ¥Ì©ÑñIj¸bÙÓõë(â‘š"ak`LVJ²tŞ÷&æ4¼RnX&¦oáFÂ³(Äê7A²=N ³õPc6éTu&^Æ_^éà,6ßÅa–Åkş’ÚP8S¡ät»4<¢î4ÓäõBÄ(hS³Û6|6wËöÜ<}iğ}ã¡9¡±ÛgÏıx8"!Hrª&äõ4‚dlIÍÀ¶ ŞÀßùÉü0t+‹l!S
ÖÉ2šeÇĞõ<!íüjüm«ê« f9UÿTwIÇÕÈM¢ ZZ` –xN%ÌqC=so	 ±’f<é'  "µ ¬3TG.èfÈc’x!ím“ÊTYèî÷¬ÌÁj`gP$r,i–àgZõx$Š¯b±VàFøì©¢XOJk¨MIOBÚÃ¦O£„W{#Õ¿~Ô½~Í:ŞNL5³ì":OlsXçr#´2B¹ïá&Qú|4-0FJv	²N{‘‹k#jœàÁÏÇ0…xé""ágòÀ‡`"*ú÷ğ#2à§”g¼tr‘ÅÅ&Mz\¤}±úécqgW¡bK¬R€äÌ6{ozqò‰àhÓdöÚhòşÂo‘"ôr@	bÿZŸçVàöô‰ôì¢mU­İ5xŒ&HO _tr0ÌIB6hÎ¾F§||ãNÑp¤4‡Aiˆ ·õRm‰ >+|û í`=‘o.*tû°4hesËR*lÊdiyi/÷1âHuÚã¢i“+Vâ 2_5 ‚xg¯`ó]×O ì"aR+öÀd¾"@òhÌ%ìÇ}d'Kd…èvÏ}¸ioå`ûFÊ ’Äœæ}k¼’`VuöyşQÊ*Q«c°v^_"go×Jj-è¼EüÄ“Fç-÷³ÔAu²a›)è\\âE{Ë4ÙÚ¥(‰Öı£¾(lÏDòo~7nœÓ*UÓ3¥=Mhz³å;ƒ&xJ:ø¬ºˆ#,ÌÒ|M$Rg×<h}ÓÏIŒ=Çn‚ØÑ?¢EWÏéôqåÉW¤iğC`ÑÅ¸(#`"™@ïú¡*
}o‚ Ò.€ı)s‚K˜òö+£cïv`óB~à9ZöømÔàŸ«¥ça<‡ÿcâîOér"8R7,ÜúRmg;¥ÂGŞOi«nˆ!a8i¤¯9@ïÓÅÉãp{»‹gˆ),z:tL#¦¢xgK16JKâd`èa\è?QÛ¨Í)Çp
R•<
vg 6Íy
CÁeóİ»'HoUbk¬ª$ş"³ .Be³€#§…0~{RcÔA#ÔQÙÑ\aÊC‚¼àçcjÕÓ(aé “aè¡w‚Â0éIG1ÇÆ„Jt\eÖ€ó¿¨°ôDRÑ&®¶Lûcáµ!¥[=»#¢ƒ¿ˆŠ»êq	<Ì[¬1}÷0è©j(Iö4ò÷Oq(èÁ9ê #Ò{Œ+%#Mäü"#í03!à1
†cÂzĞ$î2ºU3?uÉæ‹à{õâpã3"FŞncÕyÊ*f„%9â¬ÿªÑø& fâ°ô!i¼sbî¥­˜Ša
Æ^(o¿t¼!3KPr$
°rŞÂ*†ã¬AÏ’jŞ2àrÌÁåM:m¬^æÑ4sãP9wZÑâ"8_ à¹¡¡Üo/Ğ=áÌiÉÉw@3wŠÌÀï)õÈÃÒpF,^Çú&V7ö69g]Úp¡Í+  0^çóx	#u•Û÷ª^1ÿrÏ¾E+ê Ó_?&Î$b50+°`|im WçäÜJı½[åì%ŠxıjetçôğŞ/üÆoaÉÇô#^?hå(zèZÚâæM\·ÈÓşdm’&áaEşA;LÔ¶ğz¥Àg¦-¨Ï0lå‚,¡
.­J·&`j"‰„zöMR½ÔÖ{.¬}YÉèctıoó¢£dQ~p2¼ôbi%vrH*³ÍcSî0¨ x¡¦5s^¼Iêä%9L€	r"D¨UàÚl¦&ÂMhx{ìêWwÔøpe3oaiÔÃí›ş{Ù'emÀªcMT-% 3ïÉN;^gëaË8±)aQ{68£=¨5cw÷Ãvä´­Óß„Ó7Ée‡§¡€œc#eª1€™5ãÎ"-{mèôíß7«OÕcqâÂOq3ó„(> @eæ7¡d["ësĞîú
ûD  /eaü{+Xú¥#oBy,³ Ísjg i{Ææ/)ñFÕŸäqöqæóûè!ÚR6Û	9©/hïâí;Óë|kÛ£ó-µÅW]½óÄïxPSby˜n¢ñg,züIAŞWbÎD÷ Ù–Îa‘”p!7p¾|ƒ û˜œiglÄ÷1œæ"c>g CçáäÂ×\
H/Åp{¥˜=^¼Hz¡ú¤è}’qâ]¢,7únû"ºKjyP}ìĞZRI2EX/“Õ²pØQ— Õ¸A~7$lñÀaÙT,#‘=ïè"n‚¦ˆéë#xVÎxyK'ëMÔ0lRtU ¸ÏÅ2Akn(b† ¯òÃXgià Xl{uQ‘îwU¿|¼jÜ,ËB>)À€ˆÚ‡uNŞL6j#6üò)‰r#%d ¤*Õ7èÄNÓ¢«ZfB{ÁÃè"d]òÂŒ#øK€Y>„"q|k5ÇŒÄ¤whÌm„T0æ)jœB3É:ô£˜~u’A…3ĞEÀó±|^—÷´¬|½õ¶„Twrm”utÑZ54wö<gABİuú]<t“_b/]oÓÑw®6@¦+AÊ˜.:ë$Ó«VÈnÕªs4üG(34)ü19Ü´L$ëc÷CUeWlşP±4iğÂña.ı}³‡™µ
Ğò¤¸BğzŞÂÇ|
Òš·Z1iRƒ“ak¥eXáJ"d©Å<¸*j"ÕRş.qTãhØö$yöUZö°3UgKnxšMÏ_qÊ.9%º¹‰ú 4Y ÎÃˆ…rèçy'üe|–us|S5}	òá/³×äÂrìLE}ßq);pm sÜ,\aü²¨ôA´{“ÒîtÎ,¡w¬XËU/Ÿb*òKqâ4ö,û°éÜS…cÌÙ,ç q*_è
ïé4y(	Œr	FìrgbÂVQSSi=Ût‹%cì z…3ó?‹cì¼Õ¹z´Ù@H/M)ÀäR*’³lKk>&aaX(U4¸~¾DXÄWE<+3_ámÌ©Óà¾wéäI‘"#9ªnÌ"½bÎ“)ULØd5@»LQ.Y<ñ\â/%¿§£tĞo¿0,ÁZ-4Åäj‡8=*€hT.Å°@!`¬„Ply Ó¼WA(ç;Ä(|Õ­D`”ä^sJ=BQ'U!ïãaqªÂJØÆáAEHt„"Ù_UF!WSnjÏpV0Óİ¤
ÏZl:{
Ìô:¤t&yln)a¡Xn G§Ds¹u‡0¨=FÎqŠ{VñÀmÉÉAÄC¸*:qqVO÷~Ìé,Y-™%ĞißÄè5zDUmZc‘±K¢í4k×½c(lªŠ™)1<kUdw4Q¤g)hJjMÑÂ¤wkAáà@ 8kmKO¨09*x½îº Û¯°ú9§mœ§ß&MK‘è:„{yl‹:Á„Ã~W~{‡Ø<SØÔ&RòÙ8{j!¢Fİ¾ñï/“³‰v`dÇÙB)ËüMùL[p>k«$§*zÀ€­Sş„ áùnÿo	çO³„Š6^z‚Òvôš&¤$Ÿåÿ•I’Àüâc´şiOÀ.m'¨b,:<Ê­f¼N:ñ/X´=á®uÛÁX·«†Óyí‰Ümß_H ®#2Œ¼€¤M€RÇìäjÌÛ/HmugÌ»&á[ŠĞ*æy›€!Ñ÷(€0®æÀ(Ãy/ê1¾iÁR&²H@ÇSæœ€^wÎqşXğu3§Mz¬êåÆS­tNOb¾w.ÛH€@îO'TnÌk
ÀÑ+ö7ÉpÅéK$±aéÎ~ÙYPDç$J émQ/)[3ág3«,¡ÊiªSÇÌELoØq[gÄwf¬§²o¼Ş
ªü®Ídâ®ÛA¢û+’Íç±$¡'}pã@4•;K„•:ãÙãÙbó
/‘I<Š ²g¸i÷ÇŞÅ’úö³eSpF½õîÅv®gDèJVä>´/ä`ówŞ:À©ò“I_‡€uRdä±@v¼¤+ùœ2½$ rT“6©KË…ÄwTı)éôŒIt-”eÂÆèîE¾óìå™~VÉ!z7zŞ4a’/LøÒû5Ø^^6(mpş¡q †pÄHjk7’Å"İ)dlhûá2¼úø4¡;€mG s"¿ šg»é¬êFw§ÍôJ!›9£ÈG‰öñ±ôˆxğ<(T$"æ¬fb`$®lUG÷6´PŸDÁ$Kzd½Ÿ»Exûk§#XLå85íİW‰l¢såaŒWÑ?ævù>ÎZ«N<:İÁÅó[ëGOë6 ÇaDm¨ÑZXi3ĞË¯¶¾ßğ-BrˆnkÎ¼¯A¡itò±@+AmuCáëg©pÓã&Té1PC#`;}& Ì?ğuæ,ÿfO[}:Õ ÂıU~ŞGïı/÷dnè¤v³äw£*n†¼«Šõf@Úós GPIìj‘º­4fMá_ìÔMöœı0q6:­µŞ­¦ ÅÙÁqÃ_°xK}|l„I,:µk… ã¢ÁéÖh%áé#±èµ"ìs9 `g«z]MTÎ·@¸U %<µ%…N?¢üŞ©…réIx„ùrdäXf-i½Z> mµÄ]&S}æd$à+Ba]UéQn23ı*¹ ’25vyz]%$\K¤[h Éc²œÆR2Ì\J Ox‰'p•p¢XNqUş8ºCÏõIA@%a˜pDm*â“çHÒsæWğ¤éK•Ği÷Á.±YÇ|ğílÍ€4¥om@ÔüåucC%Ì«UŸÏã ´/‰sï+Ip®/Âsû_5uH$Úz÷R† ´’ˆò a jÂ)¬Qô'c»4„$Œ†µ!dÎ2	#KåUpïHúç]OºµÍö²0Ê"¢y&OÊA÷cHİ~ÚD9êY~ÍBõDßèá ¾ÑË®ÑWŞ4´ä}¢òº,tøT]Tªş¤Ë06ûóóyí-
ö7!‰hò'ôÁõË˜)  š]+0¶qD[	&hl	4»r*x$¹k1‚l
Êxokéãäõ,ĞmYziyÛ\¬»¢Nàöä Š
Š ¨Kf% ÆänÃº n_j¢¬àu ß.¥vÀ%¹ŸÇcÙõSRÔuÂÙ,ØF ©Ø6ïZ—Ë)yö$EšMÒkî{½ÿÉĞKšÌ#U›Wsy,PeçM9›34€^&<kşeØüGACr,HÌ¤YlD\@Váj)nIgÿüš\(µˆˆ 5)@G‹eLİÑŠ÷¸ZiÓ¯<¬c@zi½(#ÒWNd#1Ûì›ƒ,`g“}HG]GÀ"Ez—'Ô?fèm!)WÁ+çéª5F[j‚û@î‚¢fóR™ yŸ‹FÆ©/8;r§"'`wC‡1ZW“|S¤ ¹`C
R‚:Hbd¥dğ•0?ÙU\3~Ì·Zõù?CL†œ1úwãº.<¼õZHÇI¨©r&a y)Š< ¨,­5Î0Jıxv{aåáX@ÂLÍP`g¶j@ìf—TM÷R¬TlPË~ákuá­FTÄhiÔ²¢)bç¢t'–òxüFÙa˜ãĞ':õğ… ã¨º ]pwäAIgt#-¢ÖÕ`•ÇD«ªCÅ·l¸”2¤ÛêK<Ñ«róNKòªõ€g’
w­”.JruV;ŒâaßFìõ#ìšE’°=Ê¦é‰ƒá¹65€R×é¸ÉÀ:$b(#%W±¥ğ¦„ê³fWro)»
ªèÿ³$Â&PòÙZ'úk°i"šš0$‹U3šH‚eK¤aô{x|“kahUãÔZ½ë!¤ïlƒÇı%Ê9Lápg’äD+qpÔ°ÓóiEc%iÌqHfŸäâ(ŸÊb" ¡ÕJ€ÊB˜w.wàk˜q¼YáÕQ	CN™+q¿CÇ?§v¤3x(ÃØ1¤şÎÀp%Ena¬D56±ÕªjÄ.ê0LIıÙ~.ÓÿelEkn‡ÀƒÍ|[¨r½jğ:,»dê"k÷eòkcÇ8ëøÒLc¹Åfn•x‡ş)pt.
TD÷xJîÙ+4Õ°^I’¿ çì(ïÉ/ADEP]&Áñ˜\Î³îÁx§›Ô}6Æd}Ë-±MÖ”l"òÁÍQ  |Œø'h7 ©öK Â´Së¾ÃÉt¼U>ˆ #‰[xk-(åÄ-pÈf%FBlƒ_¦góZÑSAGŒ¹e}aÓòbp#Ä	ke0…§Ìh™Sİ x’¡Y(  ~®[ÆyZ¤xI7U l 
jmÂ¯*{WlõÆNô¨â¸áùÌÍõp"<îáà x,u$ûgk|é	,£aCl2ğ‚ì¨jÜv>îá3D"´«d’C#r›}Zs«f#z£<¾(«$Œ6g T>t Âç:e*³!ÿ´èk€û9&FHO#ª¬yçøIâı®°n(ç™èY±]2¼J|LµHG@UûÃÆt÷^ßQ>GòÛqVcüå::“Ş©—Xr{`Iw[V3=×X)RXÇí÷Î{ÍùÖ;ÓÁ.:PFà#¬ÊzáQŸ›'ØÖe)ÉvîÕiÜ!i}pzcX¨I)„ 4J¡HLüå4SÒàVÃÄR;Õ¨mM·í.•ÕúÉä"û?$T Yë43ÕãÚK'¸Ú¥¡Í7J%&¼i ­6à‰ä„l)çÜ2–jh Öqj—K{îDFC‡åíôûW\è™ á7çÂh±²S\B*ÈyLQíú?Z,/¢]{j¡™ôSÂhkÖ-f[ÈjÁÑ¿Ù} bª¦H’bµ>7m°'¡ˆÄ-Ú(Ã‡rğÂ	1dµ'šõò“J\şœhEi'É$*%qÈ1¥ >Y˜;ÚCË?2a
qdÒø@W€Ç“Üq…&LÙœË"Ffè3ï$m´Óe®îÇ•}a_Óo»«Ørñ«½vÅ]fqè‡#„BÄÚÊ†ƒ!;¢YªÉDI’sóÊÖ‡Ğ=
5l %!5Ë}‰ªÎaç`}A8qñ@d?=$¿úï?iôks£qSfÈ­R ÁÂ¦a*{stLËGhî¨W²l.=¹DÅ¬&¢•ùmO‰iU°Ş•2Ü$Ã­;ö˜è’Ø!ÏòÕúTFt,W¢(eGíøz#d(Épö së”r"¸SêVqÙ?|*tÍôg“½ap{ÜÑpå¸Lr»> ö.¼e_4J ¡Pö3cÑ»T•W€B<lœòsêP—â+9Ó¥)ŠËRF.A¶ÏÉËuO}e	{4%öĞJˆùİúÜçU	ÿ_Cjªâ_KAßl¯E+;^.¢0{
¦Y>0ÔvªCe ƒĞOô`ĞXBD›:Í'j-m”i$2ºåvm9y[Í„£wÀ_ÀwMk';(r2è0ƒ)«ÉxaO€Ã&²lGC¿çıë«!tĞA~Ç,•ejØr;’èªU1Üß'it ""U©{Ib](LDêvv1;*Ÿ
aÅYv©\¹<"è¨ÅÄäNœ`õId[œ†LEğçƒ„°9¯.¿°º-]n+‚tsrl9|ËküaA“à§&cs‡0òTÚ~aıı:nÜ«ÿ>÷-»>ˆ l^ücnˆ‡{'W?Dàªä|1X‚)1.ş¾ üíÛ4ñ fr&Û¦Rd
z®˜Û-ã9zekaÚ—ES]Õg£"¦÷ÆG»r8+bI)){ª–+Æ(5acƒW,Eı‚ĞfZÄa)E€ÜÂ™šVØéeçéÒ}ÖLoxÎ±³l‡n|U²*T)nJÅz„2+Ó¬!ùE³ G³Ä d3«`)ú ú/TÒwÈh[Oy,Ô++Ì]~Íôc¦îªİ\!ûÛ XOl*:2‹@X~)ÎÌÀ-:ù%u$¹f#®P›«wº©'Qpç0¡~ºîZüÜWßÓ²ArBŒvÂ'…#)]ñò3¤#,áûÛşbâ^¹ŒÊâ $ö¥eJâEm©tZLqCıÁ¡˜*ğbÙpµ(©ZBŸêÉ8¶X‰À˜#™G8Vú;“¼`4…hv2ô‚I>”'‡tÜäö 9 ,¢õ>øxÔ­¤4O¡ğzJ@¤Ën1(†åÓPÚ	÷mÔã,dBœ 8Ğ‚„  Âa ,¢ñ§ÄÙ>x1ÀÊ×bƒ…ÛLìOED!™/´ee8ÀLR;S‘»ìì	¦yÅdAó¢%=M;¦-Í—Â¾<Æ}Y~lpg$2~(/Oé'á¨à®8Á=»¥pT§fÂêhhùUnî0D‹~µzy÷CE OÌXˆv	«¥àÔm«æ@c.(ôamJ´ÓÁoøÃµÖt´³½¢Q}o7[[l)+zmsk»~ ¤öÒÓW]š¸k¢i®òc”S#Õ4ûIÑ]6
cìO¹ÓÇm–!`Ó“T<™.ºa‡°¨í 9Êp Éj\{'.N¿EcöxçSAn!L:ÍØtŸU,B4uB5Æ€10la‡R¯:½tBì#{È'êsVĞÓÀ7>“ÖÈøÄ¹`qî)¦è'³&Ég…nWä®".±}Í ¦‘åMDÀ¸¥E]ZìjmmY™©ñª8wJFHSg§D¤Ğ`ğWn0(&C€ 14V1Ğíê7b¾H=Ä
¶1êå åœÊ«! Pu<R".,VãÎºæUÒSÙóU¨›I&•W@Ñ3+ïòxâ4aĞ>È
¹vn¾¥áö<EQKAiZ`šäQVrhØmj&“7ærSøˆÄMşc_­±+àîi\ºèQmT¶¥ëru™Ç]ï#ÆCzá(GdC¿ÊpVÎÖ*udBl=ÏyDå6ÅÑĞLt†¢IÖq¤ œ!±wĞWÿÇÉgr96°'DÛ¦¼zß"/àëaÅ‘C§Îs åâö’ÎÀ%íätæ~|kb#m…ê˜våf'§ïQ\w;:ŠÈ"í³IÜDò¬O•LsQîÈO “N6}…?Z?O5ˆú] TâTİîr½åL§V5ª+r"*?yßlÍŒŠúaéë{Y:95IíÔÚe XÊëxŸ;¦~jh1	5pAÑ™â³S ÑU‘dy™¼Ä¦ËéñLyg”z6S|ñ¸\‘gùIÎ&AG?I1`›6 ş+ßLoN;sñ¥öa\b	ÿb19ÄmA”VĞ	e&‚t6l‘qH²qİâ¿ æBõß&UN  €N]èjÆ#––›´X™nt6Á&jR75sKZ¸E[‚üäGuÛi~YZgj’k¨q<ùÂuA.fëcÁûëâ?Yåf´éIj;í“«hb)”œ]FA«×f\ágLW1°1'‹,¯EeG®øò
jã|âzUõÅİŒK»Cš8daÿnc` X¢à¥ike4gò­yıÜ([>Wû² Ö³‡vlùNg<ªºC|Øï4`=«¥°t‹J*t¯mpõm.îS_,CM)pß÷û›Fv}röI8ïdf#ay$q9`ßtA“9nó'{~sjÇ£ğEëz"¡pC`}îghOcEGpä#&ªQ|Ê$Mrî4Í"ciÖ
ªÁ||oáv<ğ)¿9oè/»±åó¾arR«TJ;EÚç3iğt)f3öj;µyö¤|°¶îğ"/+e~g.ÔzßØjucê¬»,şj<ó‡ÃÛ4îí–0ij§l8‚ÒÆG;ãTc‚·Áx1zdët~Ÿmd¥5!]B	n™ÕåZiö½×UìeHéx~ä²A„[w˜°)b0ñúÁEuÀ önì¸}âxªğ°sHÄOR| Ë¥E“]K@§\%É^c*e ¦[¸”=a]oã)_}3¨~«!jltÑ®d™g-O§c–¯e`	g¢m0_>º R9!¤e_¢Ôßjq,cÇ¸`¼uxY¨l1ö;/x ³g° Vb•P™ #k1ö=/Šcağ¶*~C0uÖrGi4Ì©õĞºpcê¬=®«)çg¡ydÓïu)*ÊAsh$8"*ªµ4
s¡úäöm6eÙ6ÈÃ&©îjÕ**±70xL–¤f Ñ ²2¬âÇşäw]ùOsÒLJá¢«Eşµw
FZ7ä$üê9}!ğ]š¢ikØ =wbæÇy‹o$cO%“c>&’oófD#=Çr{³íÛ¬(¸1Ò-7’C  Òá;Ù7QrB2al¨Ì&]ğ1åL×m<fhtg7È’Ò`í¡ $óºJ¨1™rF©•}!´A 7Åª!vr?•&ç–%:eìúÕXN_ã$c0åf.Öo^(p}G+[P†¨pn%@´p²ßáÀI9uµ¿oèrn*¶pî|C§()hµ™´F%%"3<ˆ´ °¢\oäkgÇzÄiZóÊÄ4à!C›+}fºeÑyõëà±’C HFB2~V«ù&êµ=VVH&¦oéTn²(Ô-)·A¢-J  75Xc4ùÜ
Æ[]éà<2Şma½kü–ğT8B±tğ½4<‚î<IÄğBÄ-nc»Û6]>g9|ƒ8y;Óæ£9àµ»o}d#)hv¯7eù5enMÉ´†&ÄŸü‰~$qpˆmaÓs–‰2˜mÏÁ÷tı¾"fğmêêõ AtlûTuIç™J	¢#b{(¤•yN;J’sso›á¨~b<Ég€ ªeTA¬5Ôs­¨$èc<’f¡sm3ÊQz.÷Éájad$vÍqàgú‘ñp$¢/"0VàVıª¥(xOjãì•I	%Û†«—ª®Wk#U¿ÔLşÉ;\L7§ê NL1Úfp#=#ø!ï¡#@Ú($-$~9&N˜{UÉ++nMØ O‹1y…vèâb wúr`"cúwÓ9$‚¬”vœiv‘^Eá>x\ 6e³üYctgV!vÃ^PPäÑ<k?kQº¬àhÓçµ&úro"év
È  ûr—SòöõˆNënmUíİ7r&ÑHŸO`~\z:Íb*"yN/F¶|>ƒft <§cMÌ˜—óÒwÉi_|;p¥ 9ƒm'.`Ú0p`oWËrjlGf2Ùi.÷5€MQğã¦{W;Ş¢ {q%c³F|g¿bóİ×
ÄBëFj9¶@a-aƒ ^Añ@ô%®Ç9DH'Mx•È7Ít¹sÿç}ÿG@9bô½"}{½îa}÷qòsé…;ÊcpvON"VïĞ¾
:b-ø¸@ü`™‚Çø2+TU53a™=!MMò-J4\Ë¡(ÉÕ-#|$lÎTqnµ~À/_Q7%µHnw‘Å9‰,kÛø$º!,m~/$AGÇ4L?Òh„=$€øñ7"f“«éôqÅY >kğKsóÄTp¢A™©A«z¡*Eom‘¬D"9õé1±[šv)bëwbñvsm~şyMÍáš»íïÎq5‡^ 3æşO()p/8r3$SûZUA?bGîMmêh%á<]|¿"ÂçóÌUsuIûŸTe(zŠ x!i*x2C56j KpF`Íalè?AEÿ tGSÇİ4Bvg!6Ï"BÑe³Ù»oÊ*‹-Ubaí:$ş ód.e»
 #7s5x:aPs•#tUÛÕ\.eJA‚üu.c.¬UÛjm© €ádágâb<é>-OO}uÖÆ„Av|%6“3c¿ø|$AQ>’D1 rá´'‡t}º#¦Á¿k<Óª›â}(D;¥5m±ai®êi
ö5òò	3àÉy:,2Ò{ô€G)-gM œe#ou13$â)_0ªbYşzÔDnsôD‚?õ}”zòõexãkNÏg*Õ©Ú
fÔ1‘§pû:İº5fğ°õ)m|sjë­íùÈæ_(¾ğu!;ISRd²úaÖL&Nó-a>¦:_0s[ìÁäh;í,NäÕ7rïĞ1tÑ§n":O4à½9õ­¨-/Ğ=Éà` ÷@!w²umÀ)õ ÁÒpF'dr/^3w’)f_:p,à]G`0$2|ç÷9#+1•Ów
# ;ûß¾E+«Pó4$t5e(¸pO5*etÔÇäÏİB(ù½kğÿğx)*ufãòaš(t§)té ½r^:` zåÚŞ"c=ÔÌqşDı&¡7D`;m”³üdr¡µAs¥(ºŠh0l¥†* r¥f·ghŞ =Ì{ö/R<PZs6lyKã¨cd]gÓ¢#-wv “¸Ôjƒ±öóY(2e£Cî8)è Zµ¦53\0Dê¦%1LˆR%D0¸G`^V'$Âlpu;¨úC5ƒö8 %?#)ÄìšÿzÙ'm+@£c
T,1 ;ë†éG3gh!Ú±*!IqG6q¶_­ug5eŸã¥¶(×… ·ÛUG ¥Ì!ÁŒgZ!eª„™7gíc9MátíŞ=óE+1âÒ+1 !™ûE€/4o fEF7%f%øS ç¸ ºTe¢=w"gì}+pM¯£+jD_±-ì±`İ­y%j#"IGÆe©áPãŸ¤1óbgó!zùjd›)-`©bo`kç=p½loÚ¡£,µ¡X­|ÓEoxPQ s˜n¢3åç ®íIEšòÅÜu
É”E ‘µqA7p&lC`ûB¬r'&lÄ÷uœfxg2v ”iBğ¤èÿ|
U/Ep;™=_T(B8!ú„|=ûcM =E7ób{`kIjY¸.møŞr@vEÿğ/®××ª Yq÷ õ)zN0$¬ñİkqœsQ}çh¢.nb¦(©ë#ÖÎ{}K?ãmÔplu=b¼ïÁ2i+¦VB:&†0¥rYoá!àcXlyu³c(E	z½j8$JvI.°iÀ™š9LŞLv{"vıâ-èF(µ(d`ô"Ô3>èğÖ¢¢zg_V9ÁCÊ lU’ÁŒš&èC#ªu$6Bq|c,}2±å$cY(Mª…e°`9h˜J3I2öd˜~Õr)t1yEˆt³±m\•wº¬}­3¾„lRm‘uõQV%u9v<gQ@œ}¢]4t—Yr.	ÓÉv.,P.;EÖ›té$×»× kRèq4~U074+¸—1=Ø4ùbƒ']esl¿P´6yá‚aA$}ñı¢ áö¶íJp<ÒC&=JØz7r¡i‘bnd6!øGr>>T«8ğ*j²ÒA.óuóhØÆ4yãÏø´6Ão[yzİº?WñŠx'ÿ9ê`4osOCØprpåk'øÈ| 6}W'i\?}	tî?3× FvhJL}3Ü`©8$s!
8s.^Ø,]uä ¨ô[$ï{VæDÌ,ådhÕ'™"ß*Ñdqb¤¶,{;œ…g¬[§(;(Zq
õéty0^laf`J^1SÉ5ÚtN%bç	`„›³6‹fà´õ¹:¸ÜD-È-\Y)gÈå:’´hCa.¯`ax8Q.²l€,’WFt;0wxíŒ-ÒÁvg,åI• 9ën_b¼& Ş³+QÖúa$p¹LD<U,Y<s‹@å´¥'xÔo)0.ÁÙ'mÏb+º9>Ìku.5Åñ@1Jì”pL9’ÃÑxWI,(¢û$,<µ@`…å\+‘J&Qf']3oîCqa(ÂÊPænåQMHtÔ&İuU`QRij[xÙÚ§Ht²nèìt:®t–ylo	a±Hjpå'ds)u4J¨-FY s±ÄyPÁAFc *>p!tVwwÌiYmÁ™&%ákÇß`4zødOeZc£ê¨6k×¥¨|(›‘$5<(iWes4ÑÔw!hJëA‘4@­å'+Caà?D,(„
oWš~( 2h|´m’ä[nüú¦íbf›‘'YC•ğ2„9([ u …OnU1z—È8WÁgFwù4{hRh‰¦Dİ®ó:´;O³6¨>ìDˆçüB*‹®I¸DY,`êFãb$wé‚½Së”`ù8'¿/Iuoc•ÎfVtÂôÕr"2&´&U£ßI@øâL#¶òi+àoM"¨"l:?’Ê©m°~>qB¯Xµ=ñãgëãx*sIë‰ìÜK\ ¾#z(>päSoÈ³C‡mìjÃEI+ug:»%xÛÑ2twœYeUV!ô<®æH ey.ê1¾apªÈ G çLÍ÷ÎPwTpq2}úlêåã-ÔfB¼v.úèE—aâ_
.ˆIèÓ!æ7ÍpÅbe·AIäVÙ
PDf4%Ê}/y GO«) „a(qÓˆo
g¨ñCwÄw&n$2oF¨|JªîÍ¤â¬Õ@¢CJkß«“§(}1ï@4%\kE/„Õjâ;
±"á
‡‘E<Ÿ¨¶ei}çÇ:E²òÿ›%Sp\¼çò	Vª‚eàGò¤>¡­En3{î0Àa²ƒK_G 5gRtÄñErœ†«¹”"½YòDµùGËÄsö}£ëàa%¼¡BFã®DºóL!¹<Tm!jµZj5{í†/hx2ú´X_>V6dårÿ¡p‚Æp,Ioi'–Ñ²õ)`9HlsY¡2¹zú0¡+€-G!…r¬ "M·OœJ í­jFe¥Dö%y2£È&‰ú±±ü°yğ0y!`bæL 5Vh$*hF§>´PR%N%fÏ/d=ŸşGtSn‡!Øp­g$tmÉW©l =¤÷¨AS}æt±>‹xªM˜ı¹ÁÏá[rs6 ÇÄá3EOñŠ ;0uĞK¡¶¼Ü½Rra¶oŠ†´¯1¥i|òµB+]wCÁëg0³`. áZÒ#`;+y&qìGğudÿNN[=.m¤ÇïmUŞFîy+í`îh†.p.¡äs¨*,nÆ¼£‚v—lx«wR JW™üj»éAfM©wÔw½1My.í7ù æ5‡3QûKxÃ_°v[¿L`ÄK,»õigh'¢Áé×Nlã2»à»0Øv9`Qs;Ú%DlvD T<BU¦$5t“!‡N7°|>¬şÍ)¥bãSxqr|ìHd$i½H> MtÄM*Slæ,C¢#BbltñUí`³m¦q &1¶¹p$|',NIô3l écú4¢P"Õyn"gh«çe—i¶(1D^8 CËõEp`6!iHàD-3Â³çKR¦Wê&éSqñiõA­.5AFşáímÇ$&å/eD’üµtaW%›DŸá ´#©s¯¯Q0¾VsûuÄl$˜{gbæ 2ˆÑ ij^ m¤wõ?c¯2ÓŒ
5`LHe$Gd®]mTgEëVg]IúõMUvò|Ë:&y6ÂQ¶KQ_ƒwûd;ŞX~~=÷od»êó ıÙK®5×Şp´¾{êÒ.lvã1TTëş¬»¸2ûi;ãimiÔm ªjÿ'fÁu
OøD+y$°ú]Sl5u@ >(n>·#(9Ö{p“np-nKóâu,ğí\L+Ñ]\lÓâf°öõèBOê è`~q¯Æâfáş nWbª¬b5¡	åreA¡±¿Ça8ùÓBXtZØĞa¡Zvk\–ß`]ÿTšu/|"kŸÿˆoÒE#T_¦y, }§	?›0<¦"†|D$:´£xøDCab4HÌ¦}|,_ aj)îPGcÿX|”‘€)( ‹eI½ózÅMÜ\KÄ/=ía@zA"½(#b1W:ô#3éí»‚$`"mš¤ïMG “Q=–$Ü4bÈd)(WÑjgñ¶uF[Tb@ïX@k†&=cX½ Da5•“Fö9/o;v—"*t]o—;Z}U{å I™pÁNZî~nbd$fñÕí'Ù]7{\ä7{ùl1LŠ6„2ïõãún<.uzHI"¿b&`q Â<Tm3İ¨1Jİxw;!eñX ãXìQ`G4XR-&7PMvBdTö tÛ|#ktÑ¹TÔÿh+Ä³ªpŸ"w¢p3”ã ~¬NYa¼áA'Y{½Nô¤ ã™¢å}pvä5CG¼/bÆT`
On0êE·/`8œ?2œÙšji|“/róW8şªu G¶÷§´>j\}V; èéF¬w#,aq°B=Â¤û…æu=·qPj#ò¿àÑ¬Âô: b(qVá
¥ò¥n0fVrj#?8&è³$B$u4šbeö' >k›ğy;$»:5‹#—ÀÃeZ¥`uïqüÑûeBM¡ôû¹ç$6ş#Çı%Ò9iapg2fD/U}Àğk³9M!c!iLĞY~¾ìã8®Ác"&©ålPêÒw,u¦°éqpöÙññS2V­u¯RG?¯vaãô’px×Bq+µè^©1?<!(d=6 Uº&ÅoÒ`@ÅıQ~b>SûenM`nƒÃ“îtªp=jğ[~;d #{ö	òka_|«˜Cš@y©Æfb•ø§6uq,,TDõz.Ù+Uõ0_IšŸ%c¬,ìË+qD\ĞñUdsqåàx¦¿t5Ê`yâ'eTÖ”= dÅLQà
e™X%h&+˜„éÆ)€ÃU[sI-ò	~¤S> #¤Ârqf­0ÄÕmpÒf%GnĞJ·å<“[ÙsDHC¸E>¡Ïòbp'Ä	mq0%áTä‘1HjÒµ-à$b ;®RyB{¼xÉ Õ!mf Gj}c¯*{UtıNõéÊ¸$¡˜É¼x=¬±a P}$ûek|p`ì£aOn22b¡|øjüv&Náv$#ÔudScp»bû«~'z!®ˆª%«,$6vew£t"vàFî=e{.ğ5ÿ¤ìxÈğ9O&dYb)¨(y&x	`½²(°j8£¿™¬y1Z0¸8y%dFEú¤Æt5\a<G¦Úñvcşå.r×Ü­Ÿq.elwûa‚´=W99`m÷J1ù{óá/dPÆ!¤ÈrásA
2È—8Vbíwì•é>ğ!i}qrbH¸M!E€T*™@`á%<sVáƒÀRkTlïU¿í®-@ß•ä"n7´DàMó=;Öã‹&ĞÊ!7Í·H,b´y¹!¿0p©°¥l)§M²Ónl.Y†sj—0kánGf[ïím¸2w\'|y/öBë7åÁÉ1şir	ÊiYm::R Œk~gWJ£c™şS.DrH×-g{È*„SµÈˆe¢)²H’b§3Q17´‚Ä$Ş`ò§{aÎ	0ÖMµ5õÚÃbX~œ›h1q&Ê%ª`yh=å$>9ˆ{çËRô	?(a
0DÔøqwDG“ìsG f|ŒK&g©3®¥i0±®0ã¿~Z?Ûm;ªØ41«9vEWbñéR¦#ÅC4-VÊ©ƒeùâY3DÊK^2s?n”½È1:%í4!)É="Òeç`}H(auCd5=$)úª?)´#q"5âä€­R:@ÂÅah}r0l c(ö W=ä.uıFÅ­w¢ùmHˆ;5©Î•{®# 
¯+~PF‘İ!ŒêdFF|$w h`gtìÛBoD«d8ÙP²!rëÒbmÿV•q}|.uüôw2¦sûØÕd¤şÕv;> `j?aW`jd¥ö5aÑğçu j}n¼ÖsãV—â(’ó£)šßRF®A–×ÏûeOqeI%4 <ÔHü]ú\g2uKG*ªóLLßn>U"8|?¢°z*ö>pÔvªCe@“Oü@„)ÅŸrÍk ©í”i$u;à\l³yòi£uÀ_ ·K'xpw™Zèp›)“ËŸiMoÃ¤°(KÉ¿å}û«3pšR7Ç„s\b»‡ˆ®m>İ€Ï'))r† &T){p](LGà­gs1*Ÿ*iÇ[u¡t+4%`êÄä6A!L K”fZEõí#àys&>0ú…$­m)ƒtrh!~)LË3<aÉ·Â·&cs)2ğTÖ
:êÍÿ;{]£û:O58¾‰h¼«m?üsŠ¥w5w?dtë$<5X—+¹zå¤íÚ.tğ Ns{¦R\j5v>ÜS-gYr1Kaœ±w=CW×G±¢&öŸG¹7w^mØ+!)kªÖk)M(5²‚i…}$Oyóñv8ts+I‘ü‚¸r™èUóéb7s;¨^°vln<tPğ(a! fGÇ*!ÔrmÓ¼$'áÅµc`:2²"i2 ûf`pwfj_åGuiı k9;J]_Í_ño6îA
*ıM{Ûh¤@Wj:P;‹GxzKiÖÄÌe*%u%1^$zQ›ªu:‰'cèdõöºö\øşVÔ£QbB­ˆÜÓ§Åq)|®ñò;,«<`êÙúÎ¢^¹¬âò %ñ£ebäUn(1xaıÅ-¯˜zYt ğp5$­ØBCZ‰{t\éí¸PZg8Wúsğ´02„204€	>•½•t}ôæ 9C.¢u?øqT½47l úzîlË.±(/Û]ØçyMUà,ds!8pÄKìZd0 <ªñ¸Ù>bÀ’ãz£¥ÔDíOe$ù/eíqºğ_/^+W•ºlş ¦SÈöI{34=J2.,Íâ¾Æ	:,dop2~)pOá&2¨€ğ¯ºC?lípÕ¦îÂ`néÕîÆtbJ~%ry÷cCğKíRˆj]+$àåßªÄhã/l¤!$H¬Òóe`Á5×|”c˜¾!QŞ7{{l3!jewzºz0åîÓõ§}˜:ibi(°+Bq‘<ùIĞõ6*m¬Mã>C&”!`³õT<™/9rÅ!¨éyJ0sÀKl{g&FŸDmry¯Ag!};MétvT<B$5C$@F5*Kµqg
|Vì2{H¯è_2vSÓÁ¿2¾ĞÈøtùApaoU)fÒÄCµiG€ûU)®/¢.µÍ ²‘àÌDĞmµQ]Tìb)è±Íóéw34VJscîd%(øGz0-s@1vV9Ïê#»L<
6°jæ1a¸K¹-pa<v«"<ocî¤FRQXuu„¨ºi&İSÀÑ«hCò0¥¾aÀ–‰i9´vŠg²%i¶<O-Kái#Z&îPVrHÈmb4<"rù	_ş_í
ñ+¥ÿIi@»à¢m¶©êxt™İş#ÆA:a G($a/î WîF#:qĞäÂ:$=|¯9Tá·DÙR_MtôP×R¤Zİç1uPS¿oÉ#1#f;2'FW¦#jÓĞk%ièiÕ”6&N=6 &e”òşš€Nå$tÇ^|{æ!m!êWÀn'%íQ¢8q">"³H+&¯‰óMIÕD÷4OÁ^r0níIÓƒN>6§?XSK1	úŸ òvYær½­Íw;/W}®ş£Pb7?{]zü¾)™ë&>y:~<P¼'Ze¨øËüq•7çzìz)7]GÑ™g3[€4¤´à¶oÃíwB}g”~uSşpØ‘GiiV&Qlz`Œš?v0ş»ĞÌkÊ3suüul2	şj8)‚…A–vzm$d|2Xµ{M³f•âşeàPw_§gIÊ  V0İèêd)Ö‚’š¾9jd6Ál$!7uK~ÙAƒ’úá1i:9:gke{ùy<;’7e*g#+cUi²º~yMf©Ïén8ıÛ/hQb*½yT{Á‡«RG|Á100vƒ šo*gey³Kjá~âR1çtİŒIû<¤a÷~km‚Ù£ğôio-<cöä1üY")şW}â²o±ã7,Ù~f=*©c¸iÜí>p±</¤t‹OpIsInf));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::IsNanOp>(::mlir::spirv::IsNanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpIsNan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::LoadOp>(::mlir::spirv::LoadOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  for (Value operand : op->getOperands()) {
    auto id = getValueID(operand);
    assert(id && "use before def!");
    operands.push_back(id);
  }
  if (auto attr = op->getAttr("memory_access")) {
    operands.push_back(static_cast<uint32_t>(attr.cast<IntegerAttr>().getValue().getZExtValue()));
  }
  elidedAttrs.push_back("memory_access");
  if (auto attr = op->getAttr("alignment")) {
    operands.push_back(static_cast<uint32_t>(attr.cast<IntegerAttr>().getValue().getZExtValue()));
  }
  elidedAttrs.push_back("alignment");
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpLoad, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::LogicalAndOp>(::mlir::spirv::LogicalAndOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpLogicalAnd));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::LogicalEqualOp>(::mlir::spirv::LogicalEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpLogicalEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::LogicalNotEqualOp>(::mlir::spirv::LogicalNotEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpLogicalNotEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::LogicalNotOp>(::mlir::spirv::LogicalNotOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpLogicalNot));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::LogicalOrOp>(::mlir::spirv::LogicalOrOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpLogicalOr));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::MatrixTimesMatrixOp>(::mlir::spirv::MatrixTimesMatrixOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpMatrixTimesMatrix));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::MatrixTimesScalarOp>(::mlir::spirv::MatrixTimesScalarOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpMatrixTimesScalar));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::NotOp>(::mlir::spirv::NotOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpNot));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::OCLExpOp>(::mlir::spirv::OCLExpOp op) {
  return processOpWithoutGrammarAttr(op, "OpenCL.std", 19);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::OCLFAbsOp>(::mlir::spirv::OCLFAbsOp op) {
  return processOpWithoutGrammarAttr(op, "OpenCL.std", 23);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::OCLSAbsOp>(::mlir::spirv::OCLSAbsOp op) {
  return processOpWithoutGrammarAttr(op, "OpenCL.std", 141);
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::OrderedOp>(::mlir::spirv::OrderedOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpOrdered));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::ReturnOp>(::mlir::spirv::ReturnOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpReturn));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::ReturnValueOp>(::mlir::spirv::ReturnValueOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpReturnValue));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SConvertOp>(::mlir::spirv::SConvertOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSConvert));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SDivOp>(::mlir::spirv::SDivOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSDiv));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SGreaterThanEqualOp>(::mlir::spirv::SGreaterThanEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSGreaterThanEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SGreaterThanOp>(::mlir::spirv::SGreaterThanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSGreaterThan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SLessThanEqualOp>(::mlir::spirv::SLessThanEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSLessThanEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SLessThanOp>(::mlir::spirv::SLessThanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSLessThan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SModOp>(::mlir::spirv::SModOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSMod));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SNegateOp>(::mlir::spirv::SNegateOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSNegate));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SRemOp>(::mlir::spirv::SRemOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSRem));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SelectOp>(::mlir::spirv::SelectOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSelect));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::ShiftLeftLogicalOp>(::mlir::spirv::ShiftLeftLogicalOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpShiftLeftLogical));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::ShiftRightArithmeticOp>(::mlir::spirv::ShiftRightArithmeticOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpShiftRightArithmetic));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::ShiftRightLogicalOp>(::mlir::spirv::ShiftRightLogicalOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpShiftRightLogical));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::StoreOp>(::mlir::spirv::StoreOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  for (Value operand : op->getOperands()) {
    auto id = getValueID(operand);
    assert(id && "use before def!");
    operands.push_back(id);
  }
  if (auto attr = op->getAttr("memory_access")) {
    operands.push_back(static_cast<uint32_t>(attr.cast<IntegerAttr>().getValue().getZExtValue()));
  }
  elidedAttrs.push_back("memory_access");
  if (auto attr = op->getAttr("alignment")) {
    operands.push_back(static_cast<uint32_t>(attr.cast<IntegerAttr>().getValue().getZExtValue()));
  }
  elidedAttrs.push_back("alignment");
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpStore, operands);
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SubgroupBallotKHROp>(::mlir::spirv::SubgroupBallotKHROp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSubgroupBallotKHR));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SubgroupBlockReadINTELOp>(::mlir::spirv::SubgroupBlockReadINTELOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSubgroupBlockReadINTEL));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::SubgroupBlockWriteINTELOp>(::mlir::spirv::SubgroupBlockWriteINTELOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpSubgroupBlockWriteINTEL));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::TransposeOp>(::mlir::spirv::TransposeOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpTranspose));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::UConvertOp>(::mlir::spirv::UConvertOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpUConvert));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::UDivOp>(::mlir::spirv::UDivOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpUDiv));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::UGreaterThanEqualOp>(::mlir::spirv::UGreaterThanEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpUGreaterThanEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::UGreaterThanOp>(::mlir::spirv::UGreaterThanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpUGreaterThan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::ULessThanEqualOp>(::mlir::spirv::ULessThanEqualOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpULessThanEqual));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::ULessThanOp>(::mlir::spirv::ULessThanOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpULessThan));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::UModOp>(::mlir::spirv::UModOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpUMod));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::UnorderedOp>(::mlir::spirv::UnorderedOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpUnordered));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::UnreachableOp>(::mlir::spirv::UnreachableOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpUnreachable));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::VariableOp>(::mlir::spirv::VariableOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  {
    if (auto attr = op->getAttr("storage_class")) {
      operands.push_back(static_cast<uint32_t>(attr.cast<IntegerAttr>().getValue().getZExtValue()));
    }
    elidedAttrs.push_back("storage_class");
  }
  {
    for (auto arg : op.getODSOperands(0)) {
      auto argID = getValueID(arg);
      if (!argID) {
        return emitError(op.getLoc(), "operand #0 has a use before def");
      }
      operands.push_back(argID);
    }
  }
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpVariable, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::VectorExtractDynamicOp>(::mlir::spirv::VectorExtractDynamicOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpVectorExtractDynamic));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::VectorInsertDynamicOp>(::mlir::spirv::VectorInsertDynamicOp op) {
  return processOpWithoutGrammarAttr(op, "", static_cast<uint32_t>(spirv::Opcode::OpVectorInsertDynamic));
}

template <> LogicalResult
Serializer::processOp<::mlir::spirv::VectorShuffleOp>(::mlir::spirv::VectorShuffleOp op) {
  SmallVector<uint32_t, 4> operands;
  SmallVector<StringRef, 2> elidedAttrs;
  uint32_t resultID = 0;
  uint32_t resultTypeID = 0;
  if (failed(processType(op.getLoc(), op.getType(), resultTypeID))) {
    return failure();
  }
  operands.push_back(resultTypeID);
  resultID = getNextID();
  valueIDMap[op.getResult()] = resultID;
  operands.push_back(resultID);
  for (Value operand : op->getOperands()) {
    auto id = getValueID(operand);
    assert(id && "use before def!");
    operands.push_back(id);
  }
  if (auto attr = op->getAttr("components")) {
    for (auto attrElem : attr.cast<ArrayAttr>()) {
      operands.push_back(static_cast<uint32_t>(attrElem.cast<IntegerAttr>().getValue().getZExtValue()));
    }
  }
  elidedAttrs.push_back("components");
  (void)emitDebugLine(functionBody, op.getLoc());
  (void)encodeInstructionInto(functionBody, spirv::Opcode::OpVectorShuffle, operands);
  for (auto attr : op->getAttrs()) {
    if (llvm::is_contained(elidedAttrs, attr.first)) {      continue;
    }
    if (failed(processDecoration(op.getLoc(), resultID, attr))) {
      return failure();
    }
  }
  return success();
}

LogicalResult Serializer::dispatchToAutogenSerialization(Operation *op) {
  if (isa<::mlir::spirv::AccessChainOp>(op)) {
    return processOp(cast<::mlir::spirv::AccessChainOp>(op));
  }
  if (isa<::mlir::spirv::AtomicAndOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicAndOp>(op));
  }
  if (isa<::mlir::spirv::AtomicCompareExchangeWeakOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicCompareExchangeWeakOp>(op));
  }
  if (isa<::mlir::spirv::AtomicIAddOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicIAddOp>(op));
  }
  if (isa<::mlir::spirv::AtomicIDecrementOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicIDecrementOp>(op));
  }
  if (isa<::mlir::spirv::AtomicIIncrementOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicIIncrementOp>(op));
  }
  if (isa<::mlir::spirv::AtomicISubOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicISubOp>(op));
  }
  if (isa<::mlir::spirv::AtomicOrOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicOrOp>(op));
  }
  if (isa<::mlir::spirv::AtomicSMaxOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicSMaxOp>(op));
  }
  if (isa<::mlir::spirv::AtomicSMinOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicSMinOp>(op));
  }
  if (isa<::mlir::spirv::AtomicUMaxOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicUMaxOp>(op));
  }
  if (isa<::mlir::spirv::AtomicUMinOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicUMinOp>(op));
  }
  if (isa<::mlir::spirv::AtomicXorOp>(op)) {
    return processOp(cast<::mlir::spirv::AtomicXorOp>(op));
  }
  if (isa<::mlir::spirv::BitCountOp>(op)) {
    return processOp(cast<::mlir::spirv::BitCountOp>(op));
  }
  if (isa<::mlir::spirv::BitFieldInsertOp>(op)) {
    return processOp(cast<::mlir::spirv::BitFieldInsertOp>(op));
  }
  if (isa<::mlir::spirv::BitFieldSExtractOp>(op)) {
    return processOp(cast<::mlir::spirv::BitFieldSExtractOp>(op));
  }
  if (isa<::mlir::spirv::BitFieldUExtractOp>(op)) {
    return processOp(cast<::mlir::spirv::BitFieldUExtractOp>(op));
  }
  if (isa<::mlir::spirv::BitReverseOp>(op)) {
    return processOp(cast<::mlir::spirv::BitReverseOp>(op));
  }
  if (isa<::mlir::spirv::BitcastOp>(op)) {
    return processOp(cast<::mlir::spirv::BitcastOp>(op));
  }
  if (isa<::mlir::spirv::BitwiseAndOp>(op)) {
    return processOp(cast<::mlir::spirv::BitwiseAndOp>(op));
  }
  if (isa<::mlir::spirv::BitwiseOrOp>(op)) {
    return processOp(cast<::mlir::spirv::BitwiseOrOp>(op));
  }
  if (isa<::mlir::spirv::BitwiseXorOp>(op)) {
    return processOp(cast<::mlir::spirv::BitwiseXorOp>(op));
  }
  if (isa<::mlir::spirv::BranchConditionalOp>(op)) {
    return processOp(cast<::mlir::spirv::BranchConditionalOp>(op));
  }
  if (isa<::mlir::spirv::BranchOp>(op)) {
    return processOp(cast<::mlir::spirv::BranchOp>(op));
  }
  if (isa<::mlir::spirv::CompositeConstructOp>(op)) {
    return processOp(cast<::mlir::spirv::CompositeConstructOp>(op));
  }
  if (isa<::mlir::spirv::CompositeExtractOp>(op)) {
    return processOp(cast<::mlir::spirv::CompositeExtractOp>(op));
  }
  if (isa<::mlir::spirv::CompositeInsertOp>(op)) {
    return processOp(cast<::mlir::spirv::CompositeInsertOp>(op));
  }
  if (isa<::mlir::spirv::ControlBarrierOp>(op)) {
    return processOp(cast<::mlir::spirv::ControlBarrierOp>(op));
  }
  if (isa<::mlir::spirv::ConvertFToSOp>(op)) {
    return processOp(cast<::mlir::spirv::ConvertFToSOp>(op));
  }
  if (isa<::mlir::spirv::ConvertFToUOp>(op)) {
    return processOp(cast<::mlir::spirv::ConvertFToUOp>(op));
  }
  if (isa<::mlir::spirv::ConvertSToFOp>(op)) {
    return processOp(cast<::mlir::spirv::ConvertSToFOp>(op));
  }
  if (isa<::mlir::spirv::ConvertUToFOp>(op)) {
    return processOp(cast<::mlir::spirv::ConvertUToFOp>(op));
  }
  if (isa<::mlir::spirv::CooperativeMatrixLengthNVOp>(op)) {
    return processOp(cast<::mlir::spirv::CooperativeMatrixLengthNVOp>(op));
  }
  if (isa<::mlir::spirv::CooperativeMatrixLoadNVOp>(op)) {
    return processOp(cast<::mlir::spirv::CooperativeMatrixLoadNVOp>(op));
  }
  if (isa<::mlir::spirv::CooperativeMatrixMulAddNVOp>(op)) {
    return processOp(cast<::mlir::spirv::CooperativeMatrixMulAddNVOp>(op));
  }
  if (isa<::mlir::spirv::CooperativeMatrixStoreNVOp>(op)) {
    return processOp(cast<::mlir::spirv::CooperativeMatrixStoreNVOp>(op));
  }
  if (isa<::mlir::spirv::CopyMemoryOp>(op)) {
    return processOp(cast<::mlir::spirv::CopyMemoryOp>(op));
  }
  if (isa<::mlir::spirv::EntryPointOp>(op)) {
    return processOp(cast<::mlir::spirv::EntryPointOp>(op));
  }
  if (isa<::mlir::spirv::ExecutionModeOp>(op)) {
    return processOp(cast<::mlir::spirv::ExecutionModeOp>(op));
  }
  if (isa<::mlir::spirv::FAddOp>(op)) {
    return processOp(cast<::mlir::spirv::FAddOp>(op));
  }
  if (isa<::mlir::spirv::FConvertOp>(op)) {
    return processOp(cast<::mlir::spirv::FConvertOp>(op));
  }
  if (isa<::mlir::spirv::FDivOp>(op)) {
    return processOp(cast<::mlir::spirv::FDivOp>(op));
  }
  if (isa<::mlir::spirv::FModOp>(op)) {
    return processOp(cast<::mlir::spirv::FModOp>(op));
  }
  if (isa<::mlir::spirv::FMulOp>(op)) {
    return processOp(cast<::mlir::spirv::FMulOp>(op));
  }
  if (isa<::mlir::spirv::FNegateOp>(op)) {
    return processOp(cast<::mlir::spirv::FNegateOp>(op));
  }
  if (isa<::mlir::spirv::FOrdEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::FOrdEqualOp>(op));
  }
  if (isa<::mlir::spirv::FOrdGreaterThanEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::FOrdGreaterThanEqualOp>(op));
  }
  if (isa<::mlir::spirv::FOrdGreaterThanOp>(op)) {
    return processOp(cast<::mlir::spirv::FOrdGreaterThanOp>(op));
  }
  if (isa<::mlir::spirv::FOrdLessThanEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::FOrdLessThanEqualOp>(op));
  }
  if (isa<::mlir::spirv::FOrdLessThanOp>(op)) {
    return processOp(cast<::mlir::spirv::FOrdLessThanOp>(op));
  }
  if (isa<::mlir::spirv::FOrdNotEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::FOrdNotEqualOp>(op));
  }
  if (isa<::mlir::spirv::FRemOp>(op)) {
    return processOp(cast<::mlir::spirv::FRemOp>(op));
  }
  if (isa<::mlir::spirv::FSubOp>(op)) {
    return processOp(cast<::mlir::spirv::FSubOp>(op));
  }
  if (isa<::mlir::spirv::FUnordEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::FUnordEqualOp>(op));
  }
  if (isa<::mlir::spirv::FUnordGreaterThanEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::FUnordGreaterThanEqualOp>(op));
  }
  if (isa<::mlir::spirv::FUnordGreaterThanOp>(op)) {
    return processOp(cast<::mlir::spirv::FUnordGreaterThanOp>(op));
  }
  if (isa<::mlir::spirv::FUnordLessThanEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::FUnordLessThanEqualOp>(op));
  }
  if (isa<::mlir::spirv::FUnordLessThanOp>(op)) {
    return processOp(cast<::mlir::spirv::FUnordLessThanOp>(op));
  }
  if (isa<::mlir::spirv::FUnordNotEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::FUnordNotEqualOp>(op));
  }
  if (isa<::mlir::spirv::FunctionCallOp>(op)) {
    return processOp(cast<::mlir::spirv::FunctionCallOp>(op));
  }
  if (isa<::mlir::spirv::GLSLAcosOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLAcosOp>(op));
  }
  if (isa<::mlir::spirv::GLSLAsinOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLAsinOp>(op));
  }
  if (isa<::mlir::spirv::GLSLAtanOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLAtanOp>(op));
  }
  if (isa<::mlir::spirv::GLSLCeilOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLCeilOp>(op));
  }
  if (isa<::mlir::spirv::GLSLCosOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLCosOp>(op));
  }
  if (isa<::mlir::spirv::GLSLCoshOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLCoshOp>(op));
  }
  if (isa<::mlir::spirv::GLSLExpOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLExpOp>(op));
  }
  if (isa<::mlir::spirv::GLSLFAbsOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLFAbsOp>(op));
  }
  if (isa<::mlir::spirv::GLSLFClampOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLFClampOp>(op));
  }
  if (isa<::mlir::spirv::GLSLFMaxOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLFMaxOp>(op));
  }
  if (isa<::mlir::spirv::GLSLFMinOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLFMinOp>(op));
  }
  if (isa<::mlir::spirv::GLSLFSignOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLFSignOp>(op));
  }
  if (isa<::mlir::spirv::GLSLFloorOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLFloorOp>(op));
  }
  if (isa<::mlir::spirv::GLSLFmaOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLFmaOp>(op));
  }
  if (isa<::mlir::spirv::GLSLFrexpStructOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLFrexpStructOp>(op));
  }
  if (isa<::mlir::spirv::GLSLInverseSqrtOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLInverseSqrtOp>(op));
  }
  if (isa<::mlir::spirv::GLSLLdexpOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLLdexpOp>(op));
  }
  if (isa<::mlir::spirv::GLSLLogOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLLogOp>(op));
  }
  if (isa<::mlir::spirv::GLSLPowOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLPowOp>(op));
  }
  if (isa<::mlir::spirv::GLSLRoundOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLRoundOp>(op));
  }
  if (isa<::mlir::spirv::GLSLSAbsOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLSAbsOp>(op));
  }
  if (isa<::mlir::spirv::GLSLSClampOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLSClampOp>(op));
  }
  if (isa<::mlir::spirv::GLSLSMaxOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLSMaxOp>(op));
  }
  if (isa<::mlir::spirv::GLSLSMinOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLSMinOp>(op));
  }
  if (isa<::mlir::spirv::GLSLSSignOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLSSignOp>(op));
  }
  if (isa<::mlir::spirv::GLSLSinOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLSinOp>(op));
  }
  if (isa<::mlir::spirv::GLSLSinhOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLSinhOp>(op));
  }
  if (isa<::mlir::spirv::GLSLSqrtOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLSqrtOp>(op));
  }
  if (isa<::mlir::spirv::GLSLTanOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLTanOp>(op));
  }
  if (isa<::mlir::spirv::GLSLTanhOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLTanhOp>(op));
  }
  if (isa<::mlir::spirv::GLSLUClampOp>(op)) {
    return processOp(cast<::mlir::spirv::GLSLUClampOp>(op));
  }
  if (isa<::mlir::spirv::GroupBroadcastOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupBroadcastOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformBallotOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformBallotOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformBroadcastOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformBroadcastOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformElectOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformElectOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformFAddOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformFAddOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformFMaxOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformFMaxOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformFMinOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformFMinOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformFMulOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformFMulOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformIAddOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformIAddOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformIMulOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformIMulOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformSMaxOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformSMaxOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformSMinOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformSMinOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformUMaxOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformUMaxOp>(op));
  }
  if (isa<::mlir::spirv::GroupNonUniformUMinOp>(op)) {
    return processOp(cast<::mlir::spirv::GroupNonUniformUMinOp>(op));
  }
  if (isa<::mlir::spirv::IAddOp>(op)) {
    return processOp(cast<::mlir::spirv::IAddOp>(op));
  }
  if (isa<::mlir::spirv::IEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::IEqualOp>(op));
  }
  if (isa<::mlir::spirv::IMulOp>(op)) {
    return processOp(cast<::mlir::spirv::IMulOp>(op));
  }
  if (isa<::mlir::spirv::INotEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::INotEqualOp>(op));
  }
  if (isa<::mlir::spirv::ISubOp>(op)) {
    return processOp(cast<::mlir::spirv::ISubOp>(op));
  }
  if (isa<::mlir::spirv::ImageDrefGatherOp>(op)) {
    return processOp(cast<::mlir::spirv::ImageDrefGatherOp>(op));
  }
  if (isa<::mlir::spirv::ImageOp>(op)) {
    return processOp(cast<::mlir::spirv::ImageOp>(op));
  }
  if (isa<::mlir::spirv::ImageQuerySizeOp>(op)) {
    return processOp(cast<::mlir::spirv::ImageQuerySizeOp>(op));
  }
  if (isa<::mlir::spirv::IsInfOp>(op)) {
    return processOp(cast<::mlir::spirv::IsInfOp>(op));
  }
  if (isa<::mlir::spirv::IsNanOp>(op)) {
    return processOp(cast<::mlir::spirv::IsNanOp>(op));
  }
  if (isa<::mlir::spirv::LoadOp>(op)) {
    return processOp(cast<::mlir::spirv::LoadOp>(op));
  }
  if (isa<::mlir::spirv::LogicalAndOp>(op)) {
    return processOp(cast<::mlir::spirv::LogicalAndOp>(op));
  }
  if (isa<::mlir::spirv::LogicalEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::LogicalEqualOp>(op));
  }
  if (isa<::mlir::spirv::LogicalNotEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::LogicalNotEqualOp>(op));
  }
  if (isa<::mlir::spirv::LogicalNotOp>(op)) {
    return processOp(cast<::mlir::spirv::LogicalNotOp>(op));
  }
  if (isa<::mlir::spirv::LogicalOrOp>(op)) {
    return processOp(cast<::mlir::spirv::LogicalOrOp>(op));
  }
  if (isa<::mlir::spirv::MatrixTimesMatrixOp>(op)) {
    return processOp(cast<::mlir::spirv::MatrixTimesMatrixOp>(op));
  }
  if (isa<::mlir::spirv::MatrixTimesScalarOp>(op)) {
    return processOp(cast<::mlir::spirv::MatrixTimesScalarOp>(op));
  }
  if (isa<::mlir::spirv::MemoryBarrierOp>(op)) {
    return processOp(cast<::mlir::spirv::MemoryBarrierOp>(op));
  }
  if (isa<::mlir::spirv::NotOp>(op)) {
    return processOp(cast<::mlir::spirv::NotOp>(op));
  }
  if (isa<::mlir::spirv::OCLExpOp>(op)) {
    return processOp(cast<::mlir::spirv::OCLExpOp>(op));
  }
  if (isa<::mlir::spirv::OCLFAbsOp>(op)) {
    return processOp(cast<::mlir::spirv::OCLFAbsOp>(op));
  }
  if (isa<::mlir::spirv::OCLSAbsOp>(op)) {
    return processOp(cast<::mlir::spirv::OCLSAbsOp>(op));
  }
  if (isa<::mlir::spirv::OrderedOp>(op)) {
    return processOp(cast<::mlir::spirv::OrderedOp>(op));
  }
  if (isa<::mlir::spirv::ReturnOp>(op)) {
    return processOp(cast<::mlir::spirv::ReturnOp>(op));
  }
  if (isa<::mlir::spirv::ReturnValueOp>(op)) {
    return processOp(cast<::mlir::spirv::ReturnValueOp>(op));
  }
  if (isa<::mlir::spirv::SConvertOp>(op)) {
    return processOp(cast<::mlir::spirv::SConvertOp>(op));
  }
  if (isa<::mlir::spirv::SDivOp>(op)) {
    return processOp(cast<::mlir::spirv::SDivOp>(op));
  }
  if (isa<::mlir::spirv::SGreaterThanEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::SGreaterThanEqualOp>(op));
  }
  if (isa<::mlir::spirv::SGreaterThanOp>(op)) {
    return processOp(cast<::mlir::spirv::SGreaterThanOp>(op));
  }
  if (isa<::mlir::spirv::SLessThanEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::SLessThanEqualOp>(op));
  }
  if (isa<::mlir::spirv::SLessThanOp>(op)) {
    return processOp(cast<::mlir::spirv::SLessThanOp>(op));
  }
  if (isa<::mlir::spirv::SModOp>(op)) {
    return processOp(cast<::mlir::spirv::SModOp>(op));
  }
  if (isa<::mlir::spirv::SNegateOp>(op)) {
    return processOp(cast<::mlir::spirv::SNegateOp>(op));
  }
  if (isa<::mlir::spirv::SRemOp>(op)) {
    return processOp(cast<::mlir::spirv::SRemOp>(op));
  }
  if (isa<::mlir::spirv::SelectOp>(op)) {
    return processOp(cast<::mlir::spirv::SelectOp>(op));
  }
  if (isa<::mlir::spirv::ShiftLeftLogicalOp>(op)) {
    return processOp(cast<::mlir::spirv::ShiftLeftLogicalOp>(op));
  }
  if (isa<::mlir::spirv::ShiftRightArithmeticOp>(op)) {
    return processOp(cast<::mlir::spirv::ShiftRightArithmeticOp>(op));
  }
  if (isa<::mlir::spirv::ShiftRightLogicalOp>(op)) {
    return processOp(cast<::mlir::spirv::ShiftRightLogicalOp>(op));
  }
  if (isa<::mlir::spirv::StoreOp>(op)) {
    return processOp(cast<::mlir::spirv::StoreOp>(op));
  }
  if (isa<::mlir::spirv::SubgroupBallotKHROp>(op)) {
    return processOp(cast<::mlir::spirv::SubgroupBallotKHROp>(op));
  }
  if (isa<::mlir::spirv::SubgroupBlockReadINTELOp>(op)) {
    return processOp(cast<::mlir::spirv::SubgroupBlockReadINTELOp>(op));
  }
  if (isa<::mlir::spirv::SubgroupBlockWriteINTELOp>(op)) {
    return processOp(cast<::mlir::spirv::SubgroupBlockWriteINTELOp>(op));
  }
  if (isa<::mlir::spirv::TransposeOp>(op)) {
    return processOp(cast<::mlir::spirv::TransposeOp>(op));
  }
  if (isa<::mlir::spirv::UConvertOp>(op)) {
    return processOp(cast<::mlir::spirv::UConvertOp>(op));
  }
  if (isa<::mlir::spirv::UDivOp>(op)) {
    return processOp(cast<::mlir::spirv::UDivOp>(op));
  }
  if (isa<::mlir::spirv::UGreaterThanEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::UGreaterThanEqualOp>(op));
  }
  if (isa<::mlir::spirv::UGreaterThanOp>(op)) {
    return processOp(cast<::mlir::spirv::UGreaterThanOp>(op));
  }
  if (isa<::mlir::spirv::ULessThanEqualOp>(op)) {
    return processOp(cast<::mlir::spirv::ULessThanEqualOp>(op));
  }
  if (isa<::mlir::spirv::ULessThanOp>(op)) {
    return processOp(cast<::mlir::spirv::ULessThanOp>(op));
  }
  if (isa<::mlir::spirv::UModOp>(op)) {
    return processOp(cast<::mlir::spirv::UModOp>(op));
  }
  if (isa<::mlir::spirv::UnorderedOp>(op)) {
    return processOp(cast<::mlir::spirv::UnorderedOp>(op));
  }
  if (isa<::mlir::spirv::UnreachableOp>(op)) {
    return processOp(cast<::mlir::spirv::UnreachableOp>(op));
  }
  if (isa<::mlir::spirv::VariableOp>(op)) {
    return processOp(cast<::mlir::spirv::VariableOp>(op));
  }
  if (isa<::mlir::spirv::VectorExtractDynamicOp>(op)) {
    return processOp(cast<::mlir::spirv::VectorExtractDynamicOp>(op));
  }
  if (isa<::mlir::spirv::VectorInsertDynamicOp>(op)) {
    return processOp(cast<::mlir::spirv::VectorInsertDynamicOp>(op));
  }
  if (isa<::mlir::spirv::VectorShuffleOp>(op)) {
    return processOp(cast<::mlir::spirv::VectorShuffleOp>(op));
  }
  return op->emitError("unhandled operation serialization");
}

#endif // GET_SERIALIZATION_FNS

#ifdef GET_DESERIALIZATION_FNS

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AccessChainOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AccessChainOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AccessChainOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AccessChainOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AccessChainOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicAndOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicAndOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicAndOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicAndOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicAndOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicCompareExchangeWeakOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicCompareExchangeWeakOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicCompareExchangeWeakOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("equal_semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("unequal_semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicCompareExchangeWeakOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicCompareExchangeWeakOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicIAddOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicIAddOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicIAddOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicIAddOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicIAddOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicIDecrementOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicIDecrementOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicIDecrementOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicIDecrementOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicIDecrementOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicIIncrementOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicIIncrementOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicIIncrementOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicIIncrementOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicIIncrementOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicISubOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicISubOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicISubOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicISubOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicISubOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicOrOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicOrOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicOrOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicOrOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicOrOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicSMaxOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicSMaxOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicSMaxOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicSMaxOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicSMaxOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicSMinOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicSMinOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicSMinOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicSMinOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicSMinOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicUMaxOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicUMaxOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicUMaxOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicUMaxOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicUMaxOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicUMinOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicUMinOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicUMinOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicUMinOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicUMinOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::AtomicXorOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::AtomicXorOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::AtomicXorOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("semantics", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::AtomicXorOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::AtomicXorOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitCountOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.BitCount", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitFieldInsertOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.BitFieldInsert", true, 4);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitFieldSExtractOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.BitFieldSExtract", true, 3);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitFieldUExtractOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.BitFieldUExtract", true, 3);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitReverseOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.BitReverse", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitcastOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Bitcast", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitwiseAndOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.BitwiseAnd", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitwiseOrOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.BitwiseOr", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::BitwiseXorOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.BitwiseXor", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::CompositeConstructOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::CompositeConstructOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::CompositeConstructOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::CompositeConstructOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::CompositeConstructOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::CompositeExtractOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::CompositeExtractOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::CompositeExtractOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    SmallVector<Attribute, 4> attrListElems;
    while (wordIndex < words.size()) {
      attrListElems.push_back(opBuilder.getI32IntegerAttr(words[wordIndex++]));
    }
    attributes.push_back(opBuilder.getNamedAttr("indices", opBuilder.getArrayAttr(attrListElems)));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::CompositeExtractOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::CompositeExtractOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::CompositeInsertOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::CompositeInsertOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::CompositeInsertOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    SmallVector<Attribute, 4> attrListElems;
    while (wordIndex < words.size()) {
      attrListElems.push_back(opBuilder.getI32IntegerAttr(words[wordIndex++]));
    }
    attributes.push_back(opBuilder.getNamedAttr("indices", opBuilder.getArrayAttr(attrListElems)));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::CompositeInsertOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::CompositeInsertOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ConvertFToSOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ConvertFToS", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ConvertFToUOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ConvertFToU", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ConvertSToFOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ConvertSToF", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ConvertUToFOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ConvertUToF", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::CooperativeMatrixLengthNVOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::CooperativeMatrixLengthNVOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::CooperativeMatrixLengthNVOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("type", TypeAttr::get(getType(words[wordIndex++]))));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::CooperativeMatrixLengthNVOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::CooperativeMatrixLengthNVOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::CooperativeMatrixLoadNVOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::CooperativeMatrixLoadNVOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::CooperativeMatrixLoadNVOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_access", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::CooperativeMatrixLoadNVOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::CooperativeMatrixLoadNVOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::CooperativeMatrixMulAddNVOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.CooperativeMatrixMulAddNV", true, 3);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::CooperativeMatrixStoreNVOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_access", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::CooperativeMatrixStoreNVOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::CooperativeMatrixStoreNVOp>(loc, resultTypes, operands, attributes); (void)op;
  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FAddOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FAdd", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FConvertOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FConvert", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FDivOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FDiv", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FModOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FMod", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FMulOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FMul", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FNegateOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FNegate", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FOrdEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FOrdEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FOrdGreaterThanEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FOrdGreaterThanEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FOrdGreaterThanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FOrdGreaterThan", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FOrdLessThanEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FOrdLessThanEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FOrdLessThanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FOrdLessThan", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FOrdNotEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FOrdNotEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FRemOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FRem", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FSubOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FSub", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FUnordEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FUnordEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FUnordGreaterThanEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FUnordGreaterThanEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FUnordGreaterThanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FUnordGreaterThan", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FUnordLessThanEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FUnordLessThanEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FUnordLessThanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FUnordLessThan", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::FUnordNotEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.FUnordNotEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLAcosOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.Acos", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLAsinOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.Asin", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLAtanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.Atan", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLCeilOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.Ceil", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLCosOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.Cos", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLCoshOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.Cosh", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLExpOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.Exp", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLFAbsOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.FAbs", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLFClampOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.FClamp", true, 3);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLFMaxOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.FMax", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GLSLFMinOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.GLSL.FMin", true, 2);
}

template <> LogicalResult
Deseriali’¯gş0Ø:JÚuä%ŞÚ=EôMğº+ûĞÈ÷bùÆqËN=ãdE³>‡ÒaãñFå>÷"{ö-Š,0: ÒG)7²B	‚¡;$İ5Ùx)RÒaw$é]Í<\ĞaaOõ~vâb¶--èÇVvï‹ päğNª8YÒ&é•l/üSá7Eª½rzrı&æ”E:ÇÈûHN]é'msô. ®ö©NÿpùgïÉHä¹v.µĞ4P2ßñ€I8uêõ^¨~j
FáîıS‡ )hò¹ôF5!3xÈô ‚ºÂLòDkæÏjÄMS~óÈÔfÌ©Ñ™O]n¸fø—tëö›"aG Vb²`;ó4æq¼%VVH&¦ñGÒŸ£$ÄMM>î²e²)ZA·¶Pc'édqÆ_Yøºå,2ŞÅa–!ox–Š 8R±õô¿4<‚êıSÄäBDhèW=²š6q.oğÜÁ=u)ñæ*=¡õşaÏm|
'{Xöê7äãu’cÏ]É¶êÛ3”ŸùÈøpp‹m!VG‰2šeÏĞç<Síög©lë¢»f(5ÿTvK‹™Ü¢%ç^ßæ¾•yNÉG=g{Z´èÆb<Çf aë¥pAä3Ô_½ÌdÈc 8á¼m‡JQè®X÷Ìá|agd vÍ,Y×à'ö•éx$Ë¥ ¸V Fù®íâYmZáèÕI)ß®Væ‡¤×{#Õ»{”ıÿÉ=Ş_\t¶¨iR*K2Z÷r"ô32íOå#UZx,”&tYòs‘S‹{3n-œYÁÍ×X…v}ê2àg8Àã`""òçAÔCk¤ğ¤ÖfafĞ^ÁZÀvUâe´ôÙAtwV©gC¨R‘äÜ6{{5çàh“är&Z{òß‚mÃ&ätÄbï8³‡Sà÷ùôé¦mEm\%8œ€XßO`_~r8Ígo"(Î¾Mò||ªN“$à0—ALÈ˜T÷ñFé‰a^û/0­ 1Dog.rëydheVÛCbp‹fiùi*wqƒLÓÚb¦wÓ^/Ş¢ ~_5c’NXc;bóP—Ü2êRj_¶à`¯3
Q ç@ÜìG}dgKx”H3Ïm¹ißîo®Cú1ÖÔİ°¾k¿’a{÷qşÑÎ­*•‹bñg_#O×šRj-ø¸AüÅ–ßMÿ£Õ5²aÛ/¨MXòÎ4ÉÉ (Ğóı»¾hlËTóVz~›ƒU.MÃ>±=Hir’å;…L{Û:h¬82,Œ”|LmRGXÇ<Lop«
œ}‡ 7ØP?£›‹©£ôqåÙ7¨6|FğKdÓånp"ŸAëú¡jomšäÒ*í©5ÃK˜ók£&çoqqFv·-^ş¸MÔ`›;åîÌs<ƒß 2âşo)r)<S2<İ¸Ru#;áÂWÏkmî~ˆ!áüi¤ÿ9BîÒÄ¸ópI»÷TO˜+,&zªHp+§ªxo1:GKâDaïFa(>QåY€ÍWSÇõ<
vf!6Í(
CÁf³Šª57Í
¯;D"k¼«$ü`s.Ra»
…g÷Ç0?cÁˆA’#ôAÛÕWeÊs’|ôG÷Ó*ÄW(é Æâùáf€Â8é]OG}çÆ,Jv\%Ö“CoêğíCÓG?–Lûvåpå&ÇHyº'æÃ¾aœŠƒû}hÌ;¼um)pè½bl(òtòö[t8`Ésú.r3äÒï+="MäœfCü02!òM5ªÆSÆz€gîsº²U´õİ–›r{cçy£bVßdbWùÚ*Rg}5™çX¬ßº¹' fò"¤!}|rnî%­]ƒ_ÖN=(¾ğå!3Y  ±òÁGÎ~Îq¬e”]?Ş3áQÌQåX?ì¬^æÅsr§Hi~ZPâ*:_Fá½9¥Ì¬?’}ÍÌ`I™óPcwšwÌÇüiñˆÇĞpD,s‡ş'Vs÷’)FŠp ÙE ¸2\âä;	#u—Xó¨¨«ãt¶ek¥UÓt?¦lwµ0#°qO=icaÔçäÿBùù;ğ­Èp¼.dpãrñÊo|Æ)uÁ–ş#d>ºñ (:øZŠâã÷LÇèTı“$ágEÒQ+4³tFz5Às¦2‹£Ï0jå†:°<n%F7'bIø"‰‡~\½Ôú{6¬zYI¨ktÍgÓR£,zpØ¼Tv5ôã[:2Í»Cşrê z¹¦H1cLümêåp9LK;DºU`ÚB·&á\hy+ìkW5ôœ%Snq-À’ü›vzÕ.}iˆ«AÍR(( 7ûÇEÉ;oë%Ë°i@Qa6a¦Ÿ­qgo÷ıÃ¥”©ÓŸ…‡·ØU×T‡é!ÁÌgr2dú3„wóÎ2-;<èô½v7SOácqóR
9#Üûdo&k @6æs¡v[=ûWÄ¿»(«T!’u%-ù}jX]¯¡+n3}œÈ³ •Ízb'bIÂÆk%áRÕŞ¥r£`çñ€êèÚ26›	,@)+`ç&åÓ®moËáâ, ÁYÍ¼ÅïhXS;"˜o¢åæl¬ı} ŞæGRÏL÷Ù·Ç ‘…qA'p¯tÃ`û½œx7
fÄ÷q‘æzc26 ióò¥ÂE×v
Y-Çp;×É<^t¼Bzñú%ü<’éâ]³lU7>zûv«YnY¸ı’rArEşÄ"Æ“×²%Ùq× ÕéTN'4îğÅaEAœcĞ=gèvj†&Œ)ês8Vs}Ë7ëIE1l%Eö¼Ï2 +¢_f'¤¤òÃYcx`àXdyu$’[#Uß|¼jÍ,ÓVJ(4iÁ˜Ú—0JşMf;#6ÍY&.Éd#sd!¥"Õ3?èÔOÒó¨NOV;AÃ@£lY¶ÃŒ#ìI’X6¤ u\{,Ó šù…¤wsÜMëqT°â9î[ÜRsÍºõ§Ø~İ—Aµ3@EÁ@³õìZ—÷¿è|½<µ¾P$T7NmTuSÅT577ætwU@xºM<n•K&.Ó.Eİwª60¦=EÖ›òzé4Wû÷ˆK…êstıT8W$+¸×1=Øô\Fëbó'ueWl¾Qµ6qğáñQ&ím^ãƒÛ´„Áç¾ùBğ2ÚaR=
ÜÛZ¨9“õ`fõ^W!øw"d~è‘8ü(jòÂD¶jóTódØv5}çWZü°7ÁWS9ŞïŞ~[ğŠyeú¾‰j$<qÏiÙ‡~¨fy7ùL| –}zo\5}	òA³– Ä€~ákEm[Ôeñ?,y#
8sgVÈl]qn³ºğ[÷k—vÿDÊ,¡¬lÉõ/"ß+ò_qâ¤¾jîé<C@g¬Éci9nZyÿé4{(_r_–ücFr
&RuVy|QÚtŠ-co$z…Û·+Êfì¼Õ9z¹İDÈm|\{öõ*³ Ká>¾eeR(Q4É~>,HˆÄ<«2ñïÈåÓi¾f¡um1¾‹âyWêîÈjü'bÿ“tPDÌq5p»LT&Y8±ËXgoe¿§ãxÔ:º0¯,‹š}4Åà.—º=,‰ITo=äàĞ5H¨PMyÏc¼WA,,‘2ûÄ.<•-@d…ä|#™h8QB'Ur|óqq¤ÃJØÆ^íAMIt”&ÙUWMbWpzjÊpRÛÕ¤ÊË@xvnËİt:¬pËxín	a±Xvñ'§”Ds¸u‡Pé=VÎIF1}QŞÍAÄcèpa\_wLùYi‰FeG0Ákßûêq{ØUlZ3Õ­êí2kR­Cè|ªT-=êUïs‡ğw)yZiH‘V«Æ$ :U*Péà?D$8iO˜~¨$2}
xğïû¤[ÿÜúçíÜr§ÛÑ·IA‘kø2Ô}s({İu,ƒ&n×~×H|Fø”&òñÀ<{Mje… G½¾Ë ¾]‡+³&ìa€ÖX	ÂiËíIùLZ°>nîtçÊsÀÒ¹Cú˜`a¸/¿S?Iãï³§ÕÎ6Z:æ‘õvŠš6¥¡Öãş•IXìà@"fû9OÀff¨bmT:}8Î­E¸|>ğN/X4}ó®s‹‚X—ª”ÓAí	ÜèÏŸ_ Y`®3:Œü>õdQMŒQC‡íìj‹‹MH)udÈ+'pX^ÎÅ:æwßN”%Õö%Õ<ªvÀ*Ò}.êqìqÄV²Ì@DFçœÀ5ÎpÿTñu3
Mò©faÇmö__2¾v*Úb…‘PjšU
@,È[
8Ñ9bsÍpÅClÕAÎÎ^Ù
ADâeZ¥ém/y^1±æ7«-!ŠeëSÛŒMLcØõ[vÔ(v&¬¤¶KkğÖKzüı$çjË@¢ÃNC–|æ¡§}ag@4•\{DK„Õzâx£)bó‡‘M<Š¨·díöçe–²öŸaSqşõè•V®CDàÒ¤>õçÕl³yŞ:
Ğ¹£“g{Ç€5RztlZáTr˜»9ÜUb9eÉhD÷–xGã… ÷Ôù#ëÔŒd%Ôd‚ÇùÏDº£æå9~TÍ!z¡zŞ5}–/Lø’ÄûuØW^^whüpÿ1uƒÆp„Mgs3–å²Ü+dY\ihÛá2¸®Ú4£;‚mCsŒ”"Œ÷ßÜ»é­ªf7Ì÷
5Ï0§Áˆ¸ô»ıØxp8rTàcæ¬(Upe®hUD÷zõR›Já%Ëof¹ßûøkÅ#xL§Ï$åkÙv‰å£/õwŒqÑmæg©6Zª_<Šø™ÁMóÙúoë6 –Ïa4^íÑNY;"ĞÃ¯óî|ÔıRbˆ¶o’<¯¡iqö°P-QUdVWÉëg± ›â²áVÒ#`:i&qÈµ5¦	ª
[=.Õ$Â¨ıU~XÏf¾i/æan¨$Rääv£jLoÆœªŠfjÚ÷Xì)^Q ¹ìJĞ;¨wM¡Z¤”Iw¹1mq6í·ß0©¦5'ÅğÁxÃYğfK¹x(ÀJ,º±`èç¢ÅéÒN$ã¸	cƒèq#Xw= c1s¯ŞLT†òT¼HUv%Õ0ñaƒ_²nŒÚÏ¨béMxÁártäHf$iµX{ MµÄ].Ghî8GL +â]Uqpë2wí®ùP’v!´ùj}$n\i¡I"í`"üÆP"ÕS^ Ox˜md•q¶XNqDŞ ¸cïóIP@Wai˜àD­;âW›çJÒ¦uğ¤¨P‘ui÷Á. ±H‡üàíleU&ô-i$H’ø5ucWmÌ;EŸC€ô#‰qïïIgşÒsûz5 H%Ús÷Vâ4·„˜Ò )0\Âm¬Sôv‡cŞï54ÍÌ…‚Õ0`Î MANåªUopåH¾_ç]K|ğMİôò~Krçx6Ê7c	ıwßD<ÉY|ÍWoNè¡ ¯ŞK.ÕÖ14¤óò ºlvé1LtjÛ|Ë ")	»óií¨.@'b‰z÷ëäÁõOÏØD)U °êIc45·E@¶(nH>¿ +)ù1×lxÊ<^+éóhá¼ÑéYG)õÚ\ì™âbáÔ÷¥ ÎoÊ"èKvubÆjoÁº(o~j2,àu¡ßäjOá¡¨›àkËğõJ tÒÉ\ØeˆÚtï^—_huöUÚÍkî i¹;ÈŠ’Ì3UœGl},¶esL?Í3$€"¶x-+¾!ØúF@As%BÌäYdEU:áj)ìYÔïüH<•‘  - G
uBÓˆç|K×£<Ì# {eK¬("ÒWd#wÛlÛ®,`m,MN]GÀM4÷$Ôv&Èl,W”(ç+ñÎuB[n‚ïIî†¦=ãZaÕ‹VV¸/8?vbcdyO×1[_’}‹å%	İqAúÆtLpD$d1•ÅmÙU\7{VÌ.Jùı#Lƒ+œ2»amãú.<¼ğZyÇjè¿r&`rx<Š= 2Lù$ñÎ3Jıh{;)åáX ‚hÌQ`f¶Z­$×DLvBäTfWËråëuÑ½ãTÔÆhoH³«9Ÿf&¢pg†±wüNÙaØãĞ'Iy¥Nğ„ ãºå]pwä KGz"-¦çÔbÑvÆLêêGÄ÷.h¼„÷zÛ^êil*‘-sb^_|ªù€’³ïzNFtV{ŒgïáÛFìã#$İA“  Ê4åÂdù·$QRV—èÁ:¸ÈÀr$zeF±b¥òçNÌæç|bk#ú®è{³$Â Uò|K/êLjšğ;š›95‡U#›àÃ&”  õgxì“{ehE§€çíş%åßşÃ‹ı-Ê1YñpgÒÄDoQ}Ô|[³8Mb!iÌPXO‹øç8éb" ¡…n‘ÎBZL2.÷´Ğ{™}üØå…q^™q¯Rİ×7§fQï¤2}sÃà1¤1ÿ€3!~!¼<56±øº/ÕK.Ò0IÍuÙ~?Ë*dnEi.¢€3ÈlX)reîñlûd¢"âç	ókcÖ8«ØÂŠLqùÆff…ø‡5ia$;P@ıh®É*ĞÕv_(šŸ\ç.,©Ï/qOE\/Ğa˜UÎ;3åÀX¦“Ğ1vÊ`yË&°}W=ãâÅìS Œ}Œî'jF+š„©ÆáãÕ[ë¨Ò‰w¼|SŒ #Äyo­8ÀÅcqMØf%MBn‚Næç3Z"ÁSSHCÄ¹U8­Ãrb82Ô	oe2…âÍd‰1 xÓô]`D@f.ª®NÖ+9¸|3Õ!zF j}Ëªº~W|x†EN¦ ú¸ ©ÌäX¼#?îáé Xu$kcëlûIü³eBl22‚¡ü¸*Ìt>á7#Ö«t–_bP›ZóFõb'zÂ'ˆ¨©L,Œ6$£T(uàÆç:e{.·%îdéî€ú9o&FYZ!é¬q§yHò½:H°jpæº™¨Y±"¸8IµDGD~‚F0'Z-PtF$ÚáVqüw+r×Ö©¼‚ a+eHóy\GÊ¶=ßY9B¸ÇŒeæî+­ù;×Á/B@u ¡#äÊzåoE›@ÈDV+Hg~‘mğ$e}9zJ0M1…A4*¹H íñGuSÎäsÂÌRkÔ¸o\?­®IPÿœà"h~´TêMë5"ÑGØ‹'ğÚ!v³Nl&$}q!ÿ6ì‰ğéli'Ì0–xh"Yqb•0KaîEFzÇıíºº7LèÏ¨ôSé3§Ã¨±şIVMÉyVT„qì<;YDŒjşO_j¬™µSÁiHÖ-&[È
¤Ó=È}âbª£B’rõ*60ğ5µÂÀmÚzÃ‡sQÆ{uË\ñ7›ñz£cO¾ Qx&ê$«e}Ía¥$6G{ÇrŠ	;(!*pEÖüQGRÕc“dÜS&İ
‹@gè#ë$m0“¾¿ÏÇ}ZBk»ãÈ6ñ+¹wÅÖgQèY‡c¥ùÚËƒGqûâÛ>jî_Y²s?Ê„×V=%Í a Ïİ¦Îeç` yI,cµC`5=»úªxôjwã5ãö/RôE‚Çaz}r!L2Chö¨w¶ä>GıFÅ8¶”ymH‰!©Î•œİgÜ°ƒ©;0˜ÒÑ7İ)¢ÅÇPfTnW¡x 4í› È~Oë$:ÉP¶igëĞrˆÿS„qİ}$aÜôgÓ­ D1ûØÑp¡¼÷w»:q*½Ea_=4báu ö#ñ¨ …w€z<MŒÖsù—â!Ò`¥(Ê	ÛT!G®QÊeo=ee0$eÔIˆu]òÜgÕûÎc*ªğOB,ël¾P+8]~â`bæ~dÔvêSeDCì`
‘Id2Ì%k¢ŠiÅiY¤
ÿå\l©yòÙ˜ãuÁ_€³	gbxp63ô`-;™çqGOÃä¶ Kc»Šíó«4š?ÆµjŞ"¿‚ˆª 7ıÔİ%)-$"fU™{/`I*HEúÍ6s0
*›
iÌYf©\ù,&êè‰Àä „p¡H [†\AôåÒ”°{«oş¡ú¯\­o+¥sj@|=MË1üaÁ“Ò·"sr—2òUŞ>*èş:x¸¿6÷9ºúw²M^|c<ˆ—z&V> Üª¤8%ri;x¾€üñÜ/4ğ¡NbÛ&Su
5t¾œË%çQ~-
AÚØ‡Q?C_Õ%²¢¢ä×»72~/mLÜ)+;ªö*OÂ(11ƒaƒ$Eı“dÄ )L±Ü•Ùz‘é]óaÒ:Æ(+¨Ş1³l‡n\}Ñ²*Di@fOçzA€rIÓ¼"íÁ'„BÓ”!l52² i¿ÛaîgPÖwÌj^ÅGe5ùkP;È]ÍRõg¶îA¾ş\ûÛL¤Y^Dj:@:‰z!ÊìÄ(:¹'e%ql6Q‹ªª'`hdõòªûZøİvŸ¢ƒ@ @‡ˆğÓçÅs)\Ÿñ2;ä¡<a®“¾âN¹%Jc ò£e¢CEn¨4[DaEıå®EÙkPğrÙp±"ıXBœ›cú!ùö\cÉ:˜`G8êN~“ pğÔslõ£	*•­×gØdö*yA.Æ¼?øiÔ´% vzî@DåÏ.q(â¥S@Û	çyœob<`S¾±r”DÀ²„Iìûe14¢ñ§€Ø<y—À¢ÇlƒÅÖOLmHlGˆ|´ïe»Ğ]\+V1¿ìü æSÁv@ú²4=n:/İ–`¾>Æ}	:,`e0 ~+nOí-à`”ğ®¼Ğ7şåpÕ¦nÓ~inùÕîÆ  Šv±jywCa KÌrŒ*‰ÿ¤àÄß¨äHã/m´q-H¤WÁnÙƒµ×`´£0ÿx¢oAyş7+[\)!n$&:ºkaåò^Ó]Ü¸kæi¾0cSOs»tûIØÍ"oéO™Ë×.–¡`Ò—<)”>ºq„ 	ì 9êpáÉ@I{g¬NÿDoöa§Eo!¸+ÍÙBT<@e5C&ÃF11ia—Ñ¯
¼tFÌ#sÈ/ú{RÀÒ€ÿPzÆÒÈøÔùpaÏ(¦ÒÈ&³·‰C„ëWlîO¦.µt¼¢åÌDò¨ÕA_ì+(è¹¨á«¶wR\¢F*Gk¢t¥‹ÔiøH~ *&W…@!w)Nê#³H=Ä2ç°êragœëê9p!8^(n8Vá\»ÄWÒ]ØñEèßIf•.W@Ñ+Âò8¢Ù`À–@‹q”vg¾¯å~<mJái#Z&ßæTlfdÍ]jš&ä"Sx‰†OşBí±i¥mKI»¨‚åU¶ ¡êtˆÇ]ş&Æ@;á¥C4´B R?ÎF+:qMd!=8T ³ÄXĞoMb‡şITPæ sÌã±uĞU¿çÉg5Dº'_Û ¬jßØk>áhaõÕã*v&å…âş’xP€í,ôç^\*f#eÁü™Se.;¢`Q¢˜c{|»Èe§™³@	]D`¬MÑ^s0îkKrÓ‡N6,?ZzOk%ø óVİ$vµÍçQtïº/Xf/>9ßHØÊ¼)ëL>H:~-XI¼”GZd¥ğÊüy·:çz­h	7qWĞ‰ç· À‘ -|ÙíÔ¶JíõLu'”>EïP¼Ø”EùJŞ*A_?}0nßvRş»ŞBkì{yµ¼1l;	fl0-€…QĞğüuf¢`vhÕ;Hctôòş`ğVõß3B@@„fÕèêÂ"ÖAÆº–¹`pvÁjä3uck[aMŠâä$09i:m-jè©y|º‚×E.f«DZ_Á¸»ÎXÅbqí˜j:íÕ»hQb)ÔZVÀ«ÒgLaw	!±$'Ãl7ïgSß(“KjãjâZ£ÀÕŒ|ûÊ,äuëjc`"ù£d¬h{m<ağí9üœ"/Wù¢²Ï²ƒw=YNF«cBŠx\í~`w¯¥àu‹jzäëlúåm»~]AM;PÕ÷ÛN_uHıÖŞA|ï˜dncÁks=öŸU:²9ò%{l½jÃ:òùòˆTAQdyïÓcla]S!ä)¦@ÊußÂ%Esl4ì¢#>RªÓ}YmÇ}8ñ)‹+¤z#¸İõ±m2V›ÔJ1ÜØ`3#éÒ¾/`'}noTô¥üäúSŠ¢
i*dßgoô
ÜĞ˜zwRJ­;)-jø¶ó+ÎÛ´êßö±iî®dØ«’‚i«t"£×‹p»{¬n‹4Š~p‡|<á59,K+Í±ÇFjö±ÉYÎ”Iéxbd²eÅ[wİºïbkûÍEUB«¼.ì8êBüd°`êSPÆ_fÔ ë%·Ju@¥\e%¾@^c#M|Yh×>Iÿ%¢o_û{rš_jIXN|Q‚.%±k-c§cA¬ïMiw¢a4G&2£İZ3-²H?€’n”Çªs®cÓp—Ôü!|[¥m5ü9ïøãçsğÃØwc²Ä	¨&Ùy¶ˆ“PŞÂaú¶+~Ë8aS2w4Ì;ıÔºr`ê„}ÿ.9÷d£X)EÛÇ¶±ªNMòì†<*êu
S•µPÄàüv1õÇüË<ùlq‘*(à3+8Œ.æop ³7,ÂÇÉîuù_WÂJ± E¾µ
zúsä$\L9ô°sğy¸ºiÊØaob}#ù
M,â5=³i’eó±d;=œç"{sí ¬5ºcRM-d²B) ÷áoñ7MqIJ%a~¨=$4Ğ!å ×'6õj¦¯mHağTçï°÷ºO*>›ÆV7ì•$!üA!7D®¡v;?}$m–!:älº•wLMCgafer`¦ö©^{riO/Ù©pi¥ğ¾P²ÛáVI8uâ¿_èNn*–$nõkb()hùôFq%7$< 
°"T:ÌkçƒxÄ!SZcHU¤H¤p™oºfÛß÷ë
ä‘š"ac HTB²vÊƒu"ì½¼VV~f,oáTÂ$ d-"·A&-b  ·¥Pm6éÔu{FO]yà<!öAa”iş´ZD8R±vği´t¢l¼õÄdB?(ìS4³Û7}~gôôÃ}})ñæ©s¡µ[eªù9c)ö+5du4‚eîeÉe£6‚wÌŸdx0piQµm!Ó–-2meOğõ$Q|4b¢mêj3 6f,ÿUcI÷™Ô	 -£B{ä¶•yn1Éšg=woz» ¨Òb:mM  ¨åtK¬1ÔC¯È `k’x¡·e¡ÊQì®|uŒEé(agL$~Ímyõh/Ú‘yZ$
¯("´TàVqªe"XOJál•a	? š¦ï—&Êw{#ä¿½~É;ŸNH3"è 0>ML3Zër{½3Ò­Ï¥2#PÚ|$,”mv2F°s	+#wMÌØÃÍÄ${K~ÿâ. grs‡d (øù!>:¤`¬†”,”q~“Táå-z\ $ex|Ùc0g&¡uÃ¬R€ä_4y?yQâŒ`hQådZ{rgb¥V
À "»A„Qêöı¨»é¢M í]5`†„(¿O`WVK8EB$~ )Îrn¶||£^1<$4…AM  •ñòå‹`´s^« 4å V1,o'nhr02heWbRklÉfiùk
÷0"LÑúã,{Ó+ü"q]$a‚Fug÷b÷Õ—)Ì#ãr6bvÀ`¯ƒbgáHÌ%ìg.D'Kx…J1Í4¹iÿe$O
3SĞ½"ıkµ²á_ïqîQJ…*Éc²vL]"o×h-p¸Aüô‘@çS¿±ÔQ5caŸ/ªMòãÛÉ	,åÑ½£º.l(TòNx•vh•*]Ã7m=e|p³½1.z{{x,ºZ­(,H–|¤"GÇ<D{úªHì=ç$2nñ?¢M›i×ôyEÛ vñK`Óesp¢3±'aªú¡*loAm›¤Ú aıù1‡[Xå+ bïwdó`v£=^şşM àŸ»emŞs8§ş3æzÏw©s%8Zg.UûPU#;¡òGÏMojg8á¼Mä¿0ÂmSÌ s|A1ŸTg),zª*p,#$ªxL16jvCãFqÍaè¿uÅj ä-oS)ç<fvg!6}*
B€m£ù«gèUik®º$ş ó.(e9
„!“…)<n:!„ˆ`•eôQÛÑ\deÃAôôcã"ÔÓ(Mù òaháeÂ@ëAOG}pÖÂŒJvZ%d“ã·è0üDAñÿšLqrà$¤C…rº'¦Ã{i(¹
ë}*Yå=e10h9ê u=0öK3)àésú, ÒsôŒÏ)½3M$<fO}p3)â1_cÎsÆzVDâsø¦E‚;õ òkõâx!rfÿgcU	økfôs¹ã:íÓ:İ¸7nf²p!|ürêú¥­ÛËƒæp(¾ğù!+IPR&±`Öß.Îs-a–:L2a[ÄÁå@=m,~æÕ5R£ÒhvZÑËn&:i4à­¹¥¯$­?P=Ém`qÙÇ@ w›}dÂÿ)qŠ×Òdf-†f'4;ò’;F_Sr,à]E)°
\çi9!+g•¿ñ*¨asß¾E£dÛß?¶$wµ5+°p?cg8„ãä
İ ø½kğí5ax}(4dçòu-ü&!qÉ½#^~ºñ68z¨Z^¢ãÿlşLıŠ&á7EQ;Eœ³ôXµas¦¨ªË0l%ğn¥k·%aiŞ"9‡{vMR¹ORy6¾yIÉrcpİ4gÓ¢2/A~pœ¼T{‹öàQ+²í#Eî0Mê>:…¦5{TtLl¦%;L
;R>dºUâdV'&ÂxQ;¨èu5Íæôc3}!-Ä“ì3÷n[emiÀ)cmT?1 ;ó®gIO9gk!Àk(eIpG2q+ß­ug5wcV ´©×¥·ÈUÑA&ô£€eZcal3¤5/n#/1Mö|yN!SkÅa1CR+#½û4 #4o  v?ófK%ùSpå>(¸t'¢~w,gè}#X­«!+oD“=  ³ İsje iÇF.)òZÑ¿æ1²bîóúí 3>›-@¡`'r`kdl7R7}d5oZ¡d. µáx­µÓEÿhPQ"k:lbõg,­miCşVòò^> Ñ·ï pWu)5pë~g"{~¤s'dæ÷;™"r#2w*€a1ğ¡-âW^k
y/ep}—95^T´Bz!òt=Òùâ]°=Qij«`íIhyd¸*
õØ½Rc@pE¿Ğ+®³×2 úQ¦ M©PL7$&¬`e`µp¼wQLçi"n¦è©ï#xVî{tË1ëMô1lRuTâ$<É2Ai¦<^ :g¤¥S%ÃyféEàåxLy‘«!uš~¸jå$SVW.´I`™²®1^^Lv;"2İ9â­ÉF"µd!‘'"I;%èĞs¢ªZg‰V{áÀ¦d\šÃŒT"àK'€_`bq\{,û¤:¹É¤sYÀm*…T°b)rB3É»ğ$˜~UÊ83FMÂw³áî^·ö²¬|<ç>t„ yre™t5ÑVe ö,gA`}g]lt[f.^}ÂË3®$p¶;IÖ‘şrè<÷›×‰CÔê{4\Ux'+ü• =Ú´L#`ó U!Wn¾Pµ>q²€°a]m=ó—° sş¶xJñ>fA¢?
Ğú—x©y ƒ“`fe#;øO5nd>4)•- l²±Ò$?³Tsixt,yõÇ^ğ²;oÁM{}yÚı^?[q9%4¹‰j$4YqâÁÜ—3z¨çq'òÈ8†~tY|U}	bö?M·×(æÉvàJD}İc©+$p!0rVĞ$Usn2¨’ô_µ{ÛÖïDJ$á¤HKİ/™pÏ)Ò[qÃ¤<.9¸©œ…e¬I-ç9.Zı*éty(4rs$ìnFbÊV1SÉlìt%aï$j‹3?+fä¼Õ9r°yDè-^u)	Àõ(²3hKá®aaXhQt˜?4,
ˆ SF<3u_oiÁ­sA/g¢çI‘@¢}jîLb½'"şiGV¸a?R)lde.Y<ô‹`gk%o§£xTo; Œ(ÁZ-?Åä/—²=,áiD.ç°@:B,œpL9ÿÓ½Wp,82ûÄ$/@f…ä_c±@<'QR'u32ocqqªâÉÈÌ\åCMpd&UTW`GR0jËp Üİ ÚOHtº.kIt:¬u”xm 	!±ZjğeóDs¸u4P¨FlYH{`±Å1ØÊaÄCº*{pa^Uÿ~Ìì\m™F%Ákß`5zøT.%mXc‘!è¡6kwïhtè»‰$7<ëuåW™twph@ki“ «Š -+Aad?e,8Œ}nšzwi$°ip¼ºdÛçüş­m,Pä;§c¯<(2„(&yu…Ãfw}zçÀ<W{”4äcY%{-ja§N]nÓ¼M[ (tÌ`ˆçØâ(‹nI¹lQ°ohîDåÊP‚}Súœ ñ¸/ò/IçÏ3MÎ6^zÂÔ~‚š&§¤S£õ•I$xêLf¾òiE`mm$*bm4:?’j­Ey\:óV­P´qú¤gĞÃx•ê¤ÓI}‰ÜìÛ½W p º#;„¸áå0>M¨³A¥÷ìhÓ‡a+ugÀ;4ğÛÎq;nws”%Õ÷!d<®fS(Rx,ê!>aäb&³È@åZçœÆ·Âpotúw3‚Mú6håÁïv}	¾v&Úà€•pêªW&ÈK
èÑ!ö5IpUe	J.µ ÉÌvıPEd4¥èm)y;¡ç3*)m i(Y“ŒMLgÂõ{wÔu&<¤"kº^cªìÅ¤¢®Ò@¦Ënc_`‘6É¯Jxçb4V~E;„Õjb™Ê9jqRÓM‚¨¿eqwÇ>Å”Ò¼™iSp;¼õòW®¢daIÒ¤õ¯An§{Ö2¯Ãz²“IWÇ 5QR0æñdz´†©¹j-%ùAøD7t'ùGË¤ÌvÔõ«kôŒ/n%¡Îh®e:rÌá™~Ôl1:µzÊ5m’\xR€k´å_^>lüz1¡p‚ÂtŒIgk7¶Í²İ‰ 8N`Ûá29'zú7£2 MÇ/…s¨œ*(·ïœœB;(i¯äD{-äş
%ÿ0¢À0Iòõ³ühxiyPàsî¢(uV`$.hdDo6´P›N¥$Ç.d´¿ò'ÿón‡#øL%í$¥íì„dj=mõ€@ñ7åt¹>®Z+M<šé™bÍàYsŠû6ğÇ:áG^ípÊ/;3PË¯¶mŞ½dRx¶m*¼-!tğµ@+q]gcÁég$›b¦á3KR!`;‡kqdqLFôuç,;N'S<&e¦­uUx6NÎù+m`n¨„EP?¡lw£häÆ>¢ªuzê÷R oWäj»mAfM!}dóı1q ­·~«"=‡1Äù×xóW°v[¿rlHK$¸ñi…J§¢ÁéÖN á 	#3è±"Øv@`{8XwoDldÆãT<JU¦50± ‡N¢şU¤EÍ©…béAx ñbt`Xg$b½X>`MxÀ?*Slæ$f,+bâU	añAo23í¤9&%¶ùz$t%$HA¤J"ÍcòœÏXgÕN Mxçt•q¶PNtd^8ºEOõ Ph!a’èl­;Bq³çIr¦Wà¤iSçÑ8÷å--²IüàålÏü&÷'il’}µekr%ÎD¿OÃ¢4;ˆq/¯M*ÒsñVtäl$Z{fàì ÷‚ºÓ"ir^Cm¨St7c¯54Ì$‰…Œ”o4l~"Je,Oeo8äIg~g]aøµOYö³|c:¬y4‡tyrCH]ÁwÿD<ÖP~é×ld—èà ¶ÙÊ,õµÜ34>ñbòbl-vë|Tê|5¬!°0ó	3åiïëÔ% )j÷¯èá±?2ËD)q0SÚ[st5³u]i¶*nm4F·)*!»{!lèx_AËöà´<ĞíaNmÑ[\ì›ãfâ÷÷àoMèé[v5çæboÁº o_a¢İâu¡O	¤rã£¹GcéùÓ@ØuòY<Ùp©Úvä~ºß)]ö6Q¸7sş*k½ÿ¨„_’à¢a},’eçE?/“34("†}=X>u£èüFább%BL¦YlD]d}áz;nuçÏÿx(•U€Q!HG‹uIÓ
ç%ÜKÇ§<ì#HnA-µh#Cvöc3]å["-`Mó$mï_OÀ“-?3&ğ6~J(	)Wq*çquFYb¶¯bgò=óXY ,i—[DV!'8;v— "`uM–1~<’}ûe ™pÁOÚC~vbE¤dñ™‰/ØU\5s^N·Xùı3CL70ëõáò$<´õz@'Iè¿`&`
x(²>ívÕî1Jüpw{!eñYfà@ÌSaGôx=e&Plöaä\ô(VÏ~äãuÑ¿‡tT^hoÄ³ªiŸfw¢7s~¼fZa˜as'q{unÖ¦  ã™xçm0{î%KE´3-2FÄ`6_L«ê[Å§j¸47jœ[:zIw²§j{Dxü:uàg’5".·¯’>
vrT»€j«áßFì÷"¬KŠ°=È¦ı%kõù75Y`'ğ–j<ê :,bhmV%er§Ìînz##v8éè³%â$sš'¨${—ğyR;88%T#‹ÀŠeœ$`uïxüƒÙdU£üú­oe6şşÃÅümB9YaxgÆD-`}”x{³:M#ã5iLĞYn†ìè8/É!8"P£…l°èkØ÷.÷P´&é‘pxÛã…ÃQ^©.
¿2×7'tSË ²kpÀÁ7K¤òÜ”3u=~!¬L56óİº.É>Ú0Àıùv`6SûdlMhnƒ@³M|èj½|êñ[l»fª óö	vkcW(«ø‚š|y±Fnb5xô¶as$&ztDõx¦Ñ/ÕÕ8~	jŸc&lìj/iFE0øù˜n{²åàx²¿G76Ê`xË%•\Ô–=¢âÅIQ ˆu› øgh(2¡Ì çU{sÉ,ò¨v<Eb"ã3yl¯ÆTgqÙf%G@l
j´g03ZÑQSJa,9E>¡ò
P'ÄI% „áÌì­=xÒ5Uèh6“¬Zt	PJk4~É&Õ!eE jeá5ªsW|ı†G÷(Â¸¤)8n<x"?õ-ñá¸Xu${fãtóhì£kbl"2â¡|xjÌv6Fi0ucÖ¢l€S4pZó+~'z«®œ 1«l,¬6bo'£T*4èÆo0e{.35§lú€z;O7dsbeª´y'øLâ=º±j:-Ÿ¹¬I³Y2½|YµDG\ú‚Æuµ^…I<g¤ÚñTCõå)r×Ö­Ÿw8 q/ewÙC‚3=¿UI1vgï÷Ê{ü—?Óâ/B;RÆE¡g¤Şzáa$Ÿsà—PT{iÍ7f¥iğ!éeqj`h°]!€4(t¹Ièa&6IÖ¡:bè
k(T©o]¿Í¦qĞÿLdfJ´àEû-7ôC’“uĞx!77
$%6x™ ·>pá²Àli¥Ä°Æjh.Y¦qj;WaæEF[¯íeº:W|i› örá5çãÉ±ú#Ia	ÈyDQL:zP$ŒkŞnb¡™¶S ÂxJÒ-b[h*ß¿J!}b² @ğb5
2Q¢7%‚E,`ó‡wá	4æ5g|ú‹B^ş”ÖhQyfÊn*d{è1ä$>ˆ:GšR{g(!qDŞêU	gLÇ™]Qƒd\©„c"eâ3ï-}°“¦¿ÏÇ•~XÓó+Ø6ñ+¹vmßdÑøXÇ#c¼ÚÈƒ$ù¢ÛP?+ ÉVM²q?Ã=šà5yÏ$!`7O¢Îeæ`=i8#!Ct5m$»úî7m´js#5Ëæ€­r°aÀCa}00dªEHö(W²ä?WıFÅ-E¨ùm`‰	U«J•>!Ü ¡*­;÷ºæ±ş!êÀ²Pfu.R "jgTïÙ ÀjD»d8ÁP¢!sé”ĞrŠÿ~¥q×÷~.pÜôwó}6iÿÜU`%tÕßtû>0ğ(¿c]t@å-0ökQ<…w J5dtöséR—â9’Ó¥)šYR#"®C¶ÏWwG<e	-t$´ÎHLıÕşÆç"uMÿÆA**òlJ_l¶U)0}=¦´~
´|pÕvhCi`×°üp
0	7ÅrM'd¤Xíi¤w »]e\l¹qÚ	„+U€} 5 k3pp7“è0³9›‚—mOb&6*OÃ¿gñ{©tš[?ç¯¤jÜb;‚¢M5İ„ß-`% "&E!>p]*Hfú'gs1nŸ
yİ[g!©<'jhÀät–`¡H¢Yfeñå±…òq«.¨°û-<­O)3sj|5Lù3¬7áÂ#&cs¨2ãtŞ
>êuÿ2{ı£ÿ>s5:®hv¶m^tk¨…b77ft&¤65X—)9<øòà<ïè.,plNrY¦Cô5v¼ôÓ-å]p)	A[0•=g_Õgh¢¦ögs7w~mØ9)6!9ªÖm	æ*50ãi³w*MíóÈd^Ôk)M±ü‚Ùš|™éUrËÒ;e+ Ü0£lntÒ7ğ"e)dMGz€zmÔ¼'iÅ·BƒÄ +3² ){!ÿgTbwoêÅGu=İ(k»è]<wÇ_òg6î¢}\kÛ^¤q_j:X8ÃGIx©ÏNåmz¹!u%±k&2†qºwõ'`èEd¡ò¾öZøYV\Ôƒu@RXÔS¯Es9tyb;t£,`!ÛşÌ`^¹Œÿò`ö£uèAnª1qõåm­¸*Yä Ùp5,¬ØBœŸC²‰yöyÉ@˜»«G8^ú.{´p°„v2t‚I4½Õ||÷ö ;K.Êó5ø{d½´=* úzÎZd$K±(§óÒ.	çy<UEê,dR6»:¢jäø%0<ªñ¦Ñ¾x“`Ãx&…ŞLíeeU/®íe°ÂU	^.WE5cät ¦Q`öAù°4-"k&-M–Â¾>GuY:,xg80~)fMé­ä pğ¯»Q?úáHı%îÖ¦`DôÕfÆ0bÊtñ{y÷caÁkäRˆz›‘«$©Lßªd%"ã.l<a-@äÙÂoiÃ1÷t–¯°ç9¦1}Ş7{Y|;!neuz¹zeeuÓ×½5U˜¸kâiü0`…G'2“2ûir]*oäm™Óæ.´¡i“†T5™:7aÅ9ˆm8ÂpáàC{'®`—Dgöyó7Eg!};Íøv—V<B#%@"uF!(i×Qs
½}fÌ sh/zst€ó ?8>#ÒÀxÔùxqçQ+dÒØ3·ég„óW©ª¦.­w­¨ğSåÄĞ95Y]^lb)hY»©{+–wfBcc¦dåçjûOr0"sH3vr;ïê'›H5d ¦°êæeeœë¯-p!<ª <Kã¸N$ÒYùõ_(šM$¡WêÑƒ+Cp8"Ÿ]aÀ¶l¨C9W¦fº…u¾~MHIÁh;&äAÖtHhMhª6f"søˆGŞC]ä±#¥ïKae»híV¶ ¡àšfÇßş!ÆA:a
 ^G($C¿‚ W/VL#}-d¤2--8tá·ìÙĞ_]tçö@ÖD¤ ĞÜçwPS¾oÊc9f02F[¤¤jş\k/Áèaw'Î~&ä´ıî²pA í,VôE^A\zä#m ê‰Wef,3cïAª™s;>
;è+Œ¿M1M	İeó­m^s0nm{RÛƒO7n}-?ZGK}‰ú RzVıær=5Õ¡;çWu¦¸«Pb?9{[Xì¾h™ofA;va¼„Êe xŠşy+çzîjI7sGÒÙæ3=Q¨Ôó l+’¼D¶IïõLqgnwöp<X¥gyKÎ&a_L0hŒºv26«îÌê;ñ÷üwl
:ş!ê0)€…a´ZpSœe&‚v&x5{I³t=âş(àRõß‡'YÊ@ võjjÂ+–‚²Â©ht6È"¤35sKZiEC‚òğ9‘`:9:gb6û¹s4û†õE*f+c_Á2¹Ö,eF áÉb:íS²hAb!•|wÁ‹«vgãuW1²0'£)¯	gWtkjå~æZïD_¨I»ˆ<$aofcn‚ù+à%i />câïyüÜ*[¾wÏû2Í³Ã7-YFfAªiRš?Üì>a·¥ t»H:tÇ	mğåmóîrÕLCE!04ûJ}8™mößAzïAdGl +Ãy{H9öwŸtz³ynò'{n,jL+òÅ0ò©PP`}nãbxa]Gaäk¦ ØQÔJaMrï4í£a<vª‘}]eÛ^8ğP)/9¥Ê#±±eûiRÒÛÔJ1OX?gsIÒö)<3|n}Vô¥üæ¶S²Ú
/jESg/Ôzİp˜rwZê«»tø´q'êY&î—–°iê¾*äÈŠÒÆIy)T€£Á’x2rªéÈ»|9~—<<%4}Lj.É‘•Åbkb½Ü]ŠIépväö$d„^wLºgb{ÿÁeUÂ¢ÖN%ş¨ãÂx ¨ºx;:ÄYÂÔ ‘ë%&›_Hi\2ÉcgM(q8—?Kß%ãN/_s{sˆJ«O.dÑ‚®!³c-o§k¯HSg M#wlº£°z:$¦A ‚´ß*s®mÕ8ÖD418x¨m1|9oğ9 £gòÃ¨Vsú¹®¡é1?¬/^qÉ`ò¶.~«2}Şpr4I©mĞzph$=¾«9ç6«<ytÓÅ–ñ)(ÊI6ñü‚8*j•<CuZÈò)6 ĞŸÊH& ¬qu.*q7xÍff0ñ(¸2®oçùî&_éïEÚ(J±{
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::GroupNonUniformFMinOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::GroupNonUniformFMinOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("execution_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("group_operation", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::GroupNonUniformFMinOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::GroupNonUniformFMinOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GroupNonUniformFMulOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::GroupNonUniformFMulOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::GroupNonUniformFMulOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("execution_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("group_operation", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::GroupNonUniformFMulOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::GroupNonUniformFMulOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GroupNonUniformIAddOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::GroupNonUniformIAddOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::GroupNonUniformIAddOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("execution_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("group_operation", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::GroupNonUniformIAddOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::GroupNonUniformIAddOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GroupNonUniformIMulOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::GroupNonUniformIMulOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::GroupNonUniformIMulOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("execution_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("group_operation", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::GroupNonUniformIMulOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::GroupNonUniformIMulOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GroupNonUniformSMaxOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::GroupNonUniformSMaxOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::GroupNonUniformSMaxOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("execution_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("group_operation", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::GroupNonUniformSMaxOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::GroupNonUniformSMaxOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GroupNonUniformSMinOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::GroupNonUniformSMinOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::GroupNonUniformSMinOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("execution_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("group_operation", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::GroupNonUniformSMinOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::GroupNonUniformSMinOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GroupNonUniformUMaxOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::GroupNonUniformUMaxOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::GroupNonUniformUMaxOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("execution_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("group_operation", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::GroupNonUniformUMaxOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::GroupNonUniformUMaxOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::GroupNonUniformUMinOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::GroupNonUniformUMinOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::GroupNonUniformUMinOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("execution_scope", getConstantInt(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("group_operation", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::GroupNonUniformUMinOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::GroupNonUniformUMinOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::IAddOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.IAdd", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::IEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.IEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::IMulOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.IMul", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::INotEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.INotEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ISubOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ISub", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ImageDrefGatherOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ImageDrefGather", true, 3);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ImageOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Image", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ImageQuerySizeOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ImageQuerySize", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::IsInfOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.IsInf", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::IsNanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.IsNan", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::LoadOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::LoadOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::LoadOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_access", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("alignment", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::LoadOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::LoadOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::LogicalAndOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.LogicalAnd", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::LogicalEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.LogicalEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::LogicalNotEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.LogicalNotEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::LogicalNotOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.LogicalNot", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::LogicalOrOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.LogicalOr", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::MatrixTimesMatrixOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.MatrixTimesMatrix", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::MatrixTimesScalarOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.MatrixTimesScalar", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::NotOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Not", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::OCLExpOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.OCL.exp", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::OCLFAbsOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.OCL.fabs", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::OCLSAbsOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.OCL.s_abs", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::OrderedOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Ordered", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ReturnOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Return", false, 0);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ReturnValueOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ReturnValue", false, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SConvertOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SConvert", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SDivOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SDiv", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SGreaterThanEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SGreaterThanEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SGreaterThanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SGreaterThan", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SLessThanEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SLessThanEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SLessThanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SLessThan", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SModOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SMod", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SNegateOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SNegate", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SRemOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SRem", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SelectOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Select", true, 3);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ShiftLeftLogicalOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ShiftLeftLogical", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ShiftRightArithmeticOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ShiftRightArithmetic", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ShiftRightLogicalOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ShiftRightLogical", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::StoreOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("memory_access", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("alignment", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::StoreOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::StoreOp>(loc, resultTypes, operands, attributes); (void)op;
  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SubgroupBallotKHROp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SubgroupBallotKHR", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SubgroupBlockReadINTELOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SubgroupBlockReadINTEL", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::SubgroupBlockWriteINTELOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.SubgroupBlockWriteINTEL", false, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::TransposeOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Transpose", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::UConvertOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.UConvert", true, 1);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::UDivOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.UDiv", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::UGreaterThanEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.UGreaterThanEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::UGreaterThanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.UGreaterThan", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ULessThanEqualOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ULessThanEqual", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::ULessThanOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.ULessThan", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::UModOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.UMod", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::UnorderedOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Unordered", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::UnreachableOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.Unreachable", false, 0);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::VariableOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::VariableOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::VariableOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    attributes.push_back(opBuilder.getNamedAttr("storage_class", opBuilder.getI32IntegerAttr(words[wordIndex++])));
  }
  for (; wordIndex < words.size(); ++wordIndex) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::VariableOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::VariableOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::VectorExtractDynamicOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.VectorExtractDynamic", true, 2);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::VectorInsertDynamicOp>(ArrayRef<uint32_t> words) {
  return processOpWithoutGrammarAttr(words, "spv.VectorInsertDynamic", true, 3);
}

template <> LogicalResult
Deserializer::processOp<::mlir::spirv::VectorShuffleOp>(ArrayRef<uint32_t> words) {
  SmallVector<Type, 1> resultTypes;
  size_t wordIndex = 0; (void)wordIndex;
  uint32_t valueID = 0; (void)valueID;
  {
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result type <id> while deserializing ::mlir::spirv::VectorShuffleOp");
    }
    auto ty = getType(words[wordIndex]);
    if (!ty) {
      return emitError(unknownLoc, "unknown type result <id> : ") << words[wordIndex];
    }
    resultTypes.push_back(ty);
    wordIndex++;
    if (wordIndex >= words.size()) {
      return emitError(unknownLoc, "expected result <id> while deserializing ::mlir::spirv::VectorShuffleOp");
    }
  }
  valueID = words[wordIndex++];
  SmallVector<Value, 4> operands;
  SmallVector<NamedAttribute, 4> attributes;
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    auto arg = getValue(words[wordIndex]);
    if (!arg) {
      return emitError(unknownLoc, "unknown result <id> : ") << words[wordIndex];
    }
    operands.push_back(arg);
    wordIndex++;
  }
  if (wordIndex < words.size()) {
    SmallVector<Attribute, 4> attrListElems;
    while (wordIndex < words.size()) {
      attrListElems.push_back(opBuilder.getI32IntegerAttr(words[wordIndex++]));
    }
    attributes.push_back(opBuilder.getNamedAttr("components", opBuilder.getArrayAttr(attrListElems)));
  }
  if (wordIndex != words.size()) {
    return emitError(unknownLoc, "found more operands than expected when deserializing ::mlir::spirv::VectorShuffleOp, only ") << wordIndex << " of " << words.size() << " processed";
  }

  if (decorations.count(valueID)) {
    auto attrs = decorations[valueID].getAttrs();
    attributes.append(attrs.begin(), attrs.end());
  }
  Location loc = createFileLineColLoc(opBuilder);
  auto op = opBuilder.create<::mlir::spirv::VectorShuffleOp>(loc, resultTypes, operands, attributes); (void)op;
  valueMap[valueID] = op.getResult();

  if (op.hasTrait<OpTrait::IsTerminator>())
    (void)clearDebugLine();
  return success();
}

LogicalResult spirv::Deserializer::dispatchToAutogenDeserialization(spirv::Opcode opcode, ArrayRef<uint32_t> words) {
  switch (opcode) {
  case spirv::Opcode::OpAccessChain:
    return processOp<::mlir::spirv::AccessChainOp>(words);
  case spirv::Opcode::OpAtomicAnd:
    return processOp<::mlir::spirv::AtomicAndOp>(words);
  case spirv::Opcode::OpAtomicCompareExchangeWeak:
    return processOp<::mlir::spirv::AtomicCompareExchangeWeakOp>(words);
  case spirv::Opcode::OpAtomicIAdd:
    return processOp<::mlir::spirv::AtomicIAddOp>(words);
  case spirv::Opcode::OpAtomicIDecrement:
    return processOp<::mlir::spirv::AtomicIDecrementOp>(words);
  case spirv::Opcode::OpAtomicIIncrement:
    return processOp<::mlir::spirv::AtomicIIncrementOp>(words);
  case spirv::Opcode::OpAtomicISub:
    return processOp<::mlir::spirv::AtomicISubOp>(words);
  case spirv::Opcode::OpAtomicOr:
    return processOp<::mlir::spirv::AtomicOrOp>(words);
  case spirv::Opcode::OpAtomicSMax:
    return processOp<::mlir::spirv::AtomicSMaxOp>(words);
  case spirv::Opcode::OpAtomicSMin:
    return processOp<::mlir::spirv::AtomicSMinOp>(words);
  case spirv::Opcode::OpAtomicUMax:
    return processOp<::mlir::spirv::AtomicUMaxOp>(words);
  case spirv::Opcode::OpAtomicUMin:
    return processOp<::mlir::spirv::AtomicUMinOp>(words);
  case spirv::Opcode::OpAtomicXor:
    return processOp<::mlir::spirv::AtomicXorOp>(words);
  case spirv::Opcode::OpBitCount:
    return processOp<::mlir::spirv::BitCountOp>(words);
  case spirv::Opcode::OpBitFieldInsert:
    return processOp<::mlir::spirv::BitFieldInsertOp>(words);
  case spirv::Opcode::OpBitFieldSExtract:
    return processOp<::mlir::spirv::BitFieldSExtractOp>(words);
  case spirv::Opcode::OpBitFieldUExtract:
    return processOp<::mlir::spirv::BitFieldUExtractOp>(words);
  case spirv::Opcode::OpBitReverse:
    return processOp<::mlir::spirv::BitReverseOp>(words);
  case spirv::Opcode::OpBitcast:
    return processOp<::mlir::spirv::BitcastOp>(words);
  case spirv::Opcode::OpBitwiseAnd:
    return processOp<::mlir::spirv::BitwiseAndOp>(words);
  case spirv::Opcode::OpBitwiseOr:
    return processOp<::mlir::spirv::BitwiseOrOp>(words);
  case spirv::Opcode::OpBitwiseXor:
    return processOp<::mlir::spirv::BitwiseXorOp>(words);
  case spirv::Opcode::OpBranchConditional:
    return processOp<::mlir::spirv::BranchConditionalOp>(words);
  case spirv::Opcode::OpBranch:
    return processOp<::mlir::spirv::BranchOp>(words);
  case spirv::Opcode::OpCompositeConstruct:
    return processOp<::mlir::spirv::CompositeConstructOp>(words);
  case spirv::Opcode::OpCompositeExtract:
    return processOp<::mlir::spirv::CompositeExtractOp>(words);
  case spirv::Opcode::OpCompositeInsert:
    return processOp<::mlir::spirv::CompositeInsertOp>(words);
  case spirv::Opcode::OpControlBarrier:
    return processOp<::mlir::spirv::ControlBarrierOp>(words);
  case spirv::Opcode::OpConvertFToS:
    return processOp<::mlir::spirv::ConvertFToSOp>(words);
  case spirv::Opcode::OpConvertFToU:
    return processOp<::mlir::spirv::ConvertFToUOp>(words);
  case spirv::Opcode::OpConvertSToF:
    return processOp<::mlir::spirv::ConvertSToFOp>(words);
  case spirv::Opcode::OpConvertUToF:
    return processOp<::mlir::spirv::ConvertUToFOp>(words);
  case spirv::Opcode::OpCooperativeMatrixLengthNV:
    return processOp<::mlir::spirv::CooperativeMatrixLengthNVOp>(words);
  case spirv::Opcode::OpCooperativeMatrixLoadNV:
    return processOp<::mlir::spirv::CooperativeMatrixLoadNVOp>(words);
  case spirv::Opcode::OpCooperativeMatrixMulAddNV:
    return processOp<::mlir::spirv::CooperativeMatrixMulAddNVOp>(words);
  case spirv::Opcode::OpCooperativeMatrixStoreNV:
    return processOp<::mlir::spirv::CooperativeMatrixStoreNVOp>(words);
  case spirv::Opcode::OpCopyMemory:
    return processOp<::mlir::spirv::CopyMemoryOp>(words);
  case spirv::Opcode::OpEntryPoint:
    return processOp<::mlir::spirv::EntryPointOp>(words);
  case spirv::Opcode::OpExecutionMode:
    return processOp<::mlir::spirv::ExecutionModeOp>(words);
  case spirv::Opcode::OpFAdd:
    return processOp<::mlir::spirv::FAddOp>(words);
  case spirv::Opcode::OpFConvert:
    return processOp<::mlir::spirv::FConvertOp>(words);
  case spirv::Opcode::OpFDiv:
    return processOp<::mlir::spirv::FDivOp>(words);
  case spirv::Opcode::OpFMod:
    return processOp<::mlir::spirv::FModOp>(words);
  case spirv::Opcode::OpFMul:
    return processOp<::mlir::spirv::FMulOp>(words);
  case spirv::Opcode::OpFNegate:
    return processOp<::mlir::spirv::FNegateOp>(words);
  case spirv::Opcode::OpFOrdEqual:
    return processOp<::mlir::spirv::FOrdEqualOp>(words);
  case spirv::Opcode::OpFOrdGreaterThanEqual:
    return processOp<::mlir::spirv::FOrdGreaterThanEqualOp>(words);
  case spirv::Opcode::OpFOrdGreaterThan:
    return processOp<::mlir::spirv::FOrdGreaterThanOp>(words);
  case spirv::Opcode::OpFOrdLessThanEqual:
    return processOp<::mlir::spirv::FOrdLessThanEqualOp>(words);
  case spirv::Opcode::OpFOrdLessThan:
    return processOp<::mlir::spirv::FOrdLessThanOp>(words);
  case spirv::Opcode::OpFOrdNotEqual:
    return processOp<::mlir::spirv::FOrdNotEqualOp>(words);
  case spirv::Opcode::OpFRem:
    return processOp<::mlir::spirv::FRemOp>(words);
  case spirv::Opcode::OpFSub:
    return processOp<::mlir::spirv::FSubOp>(words);
  case spirv::Opcode::OpFUnordEqual:
    return processOp<::mlir::spirv::FUnordEqualOp>(words);
  case spirv::Opcode::OpFUnordGreaterThanEqual:
    return processOp<::mlir::spirv::FUnordGreaterThanEqualOp>(words);
  case spirv::Opcode::OpFUnordGreaterThan:
    return processOp<::mlir::spirv::FUnordGreaterThanOp>(words);
  case spirv::Opcode::OpFUnordLessThanEqual:
    return processOp<::mlir::spirv::FUnordLessThanEqualOp>(words);
  case spirv::Opcode::OpFUnordLessThan:
    return processOp<::mlir::spirv::FUnordLessThanOp>(words);
  case spirv::Opcode::OpFUnordNotEqual:
    return processOp<::mlir::spirv::FUnordNotEqualOp>(words);
  case spirv::Opcode::OpFunctionCall:
    return processOp<::mlir::spirv::FunctionCallOp>(words);
  case spirv::Opcode::OpGroupBroadcast:
    return processOp<::mlir::spirv::GroupBroadcastOp>(words);
  case spirv::Opcode::OpGroupNonUniformBallot:
    return processOp<::mlir::spirv::GroupNonUniformBallotOp>(words);
  case spirv::Opcode::OpGroupNonUniformBroadcast:
    return processOp<::mlir::spirv::GroupNonUniformBroadcastOp>(words);
  case spirv::Opcode::OpGroupNonUniformElect:
    return processOp<::mlir::spirv::GroupNonUniformElectOp>(words);
  case spirv::Opcode::OpGroupNonUniformFAdd:
    return processOp<::mlir::spirv::GroupNonUniformFAddOp>(words);
  case spirv::Opcode::OpGroupNonUniformFMax:
    return processOp<::mlir::spirv::GroupNonUniformFMaxOp>(words);
  case spirv::Opcode::OpGroupNonUniformFMin:
    return processOp<::mlir::spirv::GroupNonUniformFMinOp>(words);
  case spirv::Opcode::OpGroupNonUniformFMul:
    return processOp<::mlir::spirv::GroupNonUniformFMulOp>(words);
  case spirv::Opcode::OpGroupNonUniformIAdd:
    return processOp<::mlir::spirv::GroupNonUniformIAddOp>(words);
  case spirv::Opcode::OpGroupNonUniformIMul:
    return processOp<::mlir::spirv::GroupNonUniformIMulOp>(words);
  case spirv::Opcode::OpGroupNonUniformSMax:
    return processOp<::mlir::spirv::GroupNonUniformSMaxOp>(words);
  case spirv::Opcode::OpGroupNonUniformSMin:
    return processOp<::mlir::spirv::GroupNonUniformSMinOp>(words);
  case spirv::Opcode::OpGroupNonUniformUMax:
    return processOp<::mlir::spirv::GroupNonUniformUMaxOp>(words);
  case spirv::Opcode::OpGroupNonUniformUMin:
    return processOp<::mlir::spirv::GroupNonUniformUMinOp>(words);
  case spirv::Opcode::OpIAdd:
    return processOp<::mlir::spirv::IAddOp>(words);
  case spirv::Opcode::OpIEqual:
    return processOp<::mlir::spirv::IEqualOp>(words);
  case spirv::Opcode::OpIMul:
    return processOp<::mlir::spirv::IMulOp>(words);
  case spirv::Opcode::OpINotEqual:
    return processOp<::mlir::spirv::INotEqualOp>(words);
  case spirv::Opcode::OpISub:
    return processOp<::mlir::spirv::ISubOp>(words);
  case spirv::Opcode::OpImageDrefGather:
    return processOp<::mlir::spirv::ImageDrefGatherOp>(words);
  case spirv::Opcode::OpImage:
    return processOp<::mlir::spirv::ImageOp>(words);
  case spirv::Opcode::OpImageQuerySize:
    return processOp<::mlir::spirv::ImageQuerySizeOp>(words);
  case spirv::Opcode::OpIsInf:
    return processOp<::mlir::spirv::IsInfOp>(words);
  case spirv::Opcode::OpIsNan:
    return processOp<::mlir::spirv::IsNanOp>(words);
  case spirv::Opcode::OpLoad:
    return processOp<::mlir::spirv::LoadOp>(words);
  case spirv::Opcode::OpLogicalAnd:
    return processOp<::mlir::spirv::LogicalAndOp>(words);
  case spirv::Opcode::OpLogicalEqual:
    return processOp<::mlir::spirv::LogicalEqualOp>(words);
  case spirv::Opcode::OpLogicalNotEqual:
    return processOp<::mlir::spirv::LogicalNotEqualOp>(words);
  case spirv::Opcode::OpLogicalNot:
    return processOp<::mlir::spirv::LogicalNotOp>(words);
  case spirv::Opcode::OpLogicalOr:
    return processOp<::mlir::spirv::LogicalOrOp>(words);
  case spirv::Opcode::OpMatrixTimesMatrix:
    return processOp<::mlir::spirv::MatrixTimesMatrixOp>(words);
  case spirv::Opcode::OpMatrixTimesScalar:
    return processOp<::mlir::spirv::MatrixTimesScalarOp>(words);
  case spirv::Opcode::OpMemoryBarrier:
    return processOp<::mlir::spirv::MemoryBarrierOp>(words);
  case spirv::Opcode::OpNot:
    return processOp<::mlir::spirv::NotOp>(words);
  case spirv::Opcode::OpOrdered:
    return processOp<::mlir::spirv::OrderedOp>(words);
  case spirv::Opcode::OpReturn:
    return processOp<::mlir::spirv::ReturnOp>(words);
  case spirv::Opcode::OpReturnValue:
    return processOp<::mlir::spirv::ReturnValueOp>(words);
  case spirv::Opcode::OpSConvert:
    return processOp<::mlir::spirv::SConvertOp>(words);
  case spirv::Opcode::OpSDiv:
    return processOp<::mlir::spirv::SDivOp>(words);
  case spirv::Opcode::OpSGreaterThanEqual:
    return processOp<::mlir::spirv::SGreaterThanEqualOp>(words);
  case spirv::Opcode::OpSGreaterThan:
    return processOp<::mlir::spirv::SGreaterThanOp>(words);
  case spirv::Opcode::OpSLessThanEqual:
    return processOp<::mlir::spirv::SLessThanEqualOp>(words);
  case spirv::Opcode::OpSLessThan:
    return processOp<::mlir::spirv::SLessThanOp>(words);
  case spirv::Opcode::OpSMod:
    return processOp<::mlir::spirv::SModOp>(words);
  case spirv::Opcode::OpSNegate:
    return processOp<::mlir::spirv::SNegateOp>(words);
  case spirv::Opcode::OpSRem:
    return processOp<::mlir::spirv::SRemOp>(words);
  case spirv::Opcode::OpSelect:
    return processOp<::mlir::spirv::SelectOp>(words);
  case spirv::Opcode::OpShiftLeftLogical:
    return processOp<::mlir::spirv::ShiftLeftLogicalOp>(words);
  case spirv::Opcode::OpShiftRightArithmetic:
    return processOp<::mlir::spirv::ShiftRightArithmeticOp>(words);
  case spirv::Opcode::OpShiftRightLogical:
    return processOp<::mlir::spirv::ShiftRightLogicalOp>(words);
  case spirv::Opcode::OpStore:
    return processOp<::mlir::spirv::StoreOp>(words);
  case spirv::Opcode::OpSubgroupBallotKHR:
    return processOp<::mlir::spirv::SubgroupBallotKHROp>(words);
  case spirv::Opcode::OpSubgroupBlockReadINTEL:
    return processOp<::mlir::spirv::SubgroupBlockReadINTELOp>(words);
  case spirv::Opcode::OpSubgroupBlockWriteINTEL:
    return processOp<::mlir::spirv::SubgroupBlockWriteINTELOp>(words);
  case spirv::Opcode::OpTranspose:
    return processOp<::mlir::spirv::TransposeOp>(words);
  case spirv::Opcode::OpUConvert:
    return processOp<::mlir::spirv::UConvertOp>(words);
  case spirv::Opcode::OpUDiv:
    return processOp<::mlir::spirv::UDivOp>(words);
  case spirv::Opcode::OpUGreaterThanEqual:
    return processOp<::mlir::spirv::UGreaterThanEqualOp>(words);
  case spirv::Opcode::OpUGreaterThan:
    return processOp<::mlir::spirv::UGreaterThanOp>(words);
  case spirv::Opcode::OpULessThanEqual:
    return processOp<::mlir::spirv::ULessThanEqualOp>(words);
  case spirv::Opcode::OpULessThan:
    return processOp<::mlir::spirv::ULessThanOp>(words);
  case spirv::Opcode::OpUMod:
    return processOp<::mlir::spirv::UModOp>(words);
  case spirv::Opcode::OpUnordered:
    return processOp<::mlir::spirv::UnorderedOp>(words);
  case spirv::Opcode::OpUnreachable:
    return processOp<::mlir::spirv::UnreachableOp>(words);
  case spirv::Opcode::OpVariable:
    return processOp<::mlir::spirv::VariableOp>(words);
  case spirv::Opcode::OpVectorExtractDynamic:
    return processOp<::mlir::spirv::VectorExtractDynamicOp>(words);
  case spirv::Opcode::OpVectorInsertDynamic:
    return processOp<::mlir::spirv::VectorInsertDynamicOp>(words);
  case spirv::Opcode::OpVectorShuffle:
    return processOp<::mlir::spirv::VectorShuffleOp>(words);
  default:
    ;
  }
  auto opcodeString = spirv::stringifyOpcode(opcode);
  if (!opcodeString.empty()) {
    return emitError(unknownLoc, "unhandled deserialization of ") << opcodeString;
  } else {
   return emitError(unknownLoc, "unhandled opcode ") << static_cast<uint32_t>(opcode);
  }
}
LogicalResult spirv::Deserializer::dispatchToExtensionSetAutogenDeserialization(StringRef extensionSetName, uint32_t instructionID, ArrayRef<uint32_t> words) {
  if (extensionSetName == "GLSL.std.450") {
    switch (instructionID) {
    case 17:
      return processOp<::mlir::spirv::GLSLAcosOp>(words);
    case 16:
      return processOp<::mlir::spirv::GLSLAsinOp>(words);
    case 18:
      return processOp<::mlir::spirv::GLSLAtanOp>(words);
    case 9:
      return processOp<::mlir::spirv::GLSLCeilOp>(words);
    case 14:
      return processOp<::mlir::spirv::GLSLCosOp>(words);
    case 20:
      return processOp<::mlir::spirv::GLSLCoshOp>(words);
    case 27:
      return processOp<::mlir::spirv::GLSLExpOp>(words);
    case 4:
      return processOp<::mlir::spirv::GLSLFAbsOp>(words);
    case 43:
      return processOp<::mlir::spirv::GLSLFClampOp>(words);
    case 40:
      return processOp<::mlir::spirv::GLSLFMaxOp>(words);
    case 37:
      return processOp<::mlir::spirv::GLSLFMinOp>(words);
    case 6:
      return processOp<::mlir::spirv::GLSLFSignOp>(words);
    case 8:
      return processOp<::mlir::spirv::GLSLFloorOp>(words);
    case 50:
      return processOp<::mlir::spirv::GLSLFmaOp>(words);
    case 52:
      return processOp<::mlir::spirv::GLSLFrexpStructOp>(words);
    case 32:
      return processOp<::mlir::spirv::GLSLInverseSqrtOp>(words);
    case 53:
      return processOp<::mlir::spirv::GLSLLdexpOp>(words);
    case 28:
      return processOp<::mlir::spirv::GLSLLogOp>(words);
    case 26:
      return processOp<::mlir::spirv::GLSLPowOp>(words);
    case 1:
      return processOp<::mlir::spirv::GLSLRoundOp>(words);
    case 5:
      return processOp<::mlir::spirv::GLSLSAbsOp>(words);
    case 45:
      return processOp<::mlir::spirv::GLSLSClampOp>(words);
    case 42:
      return processOp<::mlir::spirv::GLSLSMaxOp>(words);
    case 39:
      return processOp<::mlir::spirv::GLSLSMinOp>(words);
    case 7:
      return processOp<::mlir::spirv::GLSLSSignOp>(words);
    case 13:
      return processOp<::mlir::spirv::GLSLSinOp>(words);
    case 19:
      return processOp<::mlir::spirv::GLSLSinhOp>(words);
    case 31:
      return processOp<::mlir::spirv::GLSLSqrtOp>(words);
    case 15:
      return processOp<::mlir::spirv::GLSLTanOp>(words);
    case 21:
      return processOp<::mlir::spirv::GLSLTanhOp>(words);
    case 44:
      return processOp<::mlir::spirv::GLSLUClampOp>(words);
    default:
      return emitError(unknownLoc, "unhandled deserializations of ") << instructionID << " from extension set " << extensionSetName;
    }
  }
  if (extensionSetName == "OpenCL.std") {
    switch (instructionID) {
    case 19:
      return processOp<::mlir::spirv::OCLExpOp>(words);
    case 23:
      return processOp<::mlir::spirv::OCLFAbsOp>(words);
    case 141:
      return processOp<::mlir::spirv::OCLSAbsOp>(words);
    default:
      return emitError(unknownLoc, "unhandled deserializations of ") << instructionID << " from extension set " << extensionSetName;
    }
  }
  return emitError(unknownLoc, "unhandled deserialization of extended instruction set extensionSetName");
}
#endif // GET_DESERIALIZATION_FNS

