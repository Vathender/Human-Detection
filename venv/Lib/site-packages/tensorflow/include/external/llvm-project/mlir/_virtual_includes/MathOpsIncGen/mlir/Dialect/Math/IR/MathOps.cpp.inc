/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::math::Atan2Op,
::mlir::math::AtanOp,
::mlir::math::CosOp,
::mlir::math::Exp2Op,
::mlir::math::ExpM1Op,
::mlir::math::ExpOp,
::mlir::math::Log10Op,
::mlir::math::Log1pOp,
::mlir::math::Log2Op,
::mlir::math::LogOp,
::mlir::math::PowFOp,
::mlir::math::RsqrtOp,
::mlir::math::SinOp,
::mlir::math::SqrtOp,
::mlir::math::TanhOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace math {
static ::mlir::LogicalResult __mlir_ods_local_type_constraint_MathOps0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::FloatType>())) || (((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || (((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be floating-point-like, but got " << type;
  }
  return ::mlir::success();
}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::Atan2Op definitions
//===----------------------------------------------------------------------===//

Atan2OpAdaptor::Atan2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

Atan2OpAdaptor::Atan2OpAdaptor(Atan2Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange Atan2OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> Atan2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Atan2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Atan2OpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value Atan2OpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr Atan2OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult Atan2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> Atan2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Atan2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Atan2Op::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value Atan2Op::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange Atan2Op::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Atan2Op::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Atan2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Atan2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Atan2Op::result() {
  return *getODSResults(0).begin();
}

void Atan2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void Atan2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Atan2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void Atan2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void Atan2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult Atan2Op::verify() {
  if (failed(Atan2OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult Atan2Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(lhsOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void Atan2Op::print(::mlir::OpAsmPrinter &p) {
  p << "math.atan2";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void Atan2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::AtanOp definitions
//===----------------------------------------------------------------------===//

AtanOpAdaptor::AtanOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AtanOpAdaptor::AtanOpAdaptor(AtanOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AtanOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtanOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtanOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr AtanOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AtanOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AtanOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtanOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AtanOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AtanOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtanOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtanOp::result() {
  return *getODSResults(0).begin();
}

void AtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void AtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtanOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void AtanOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AtanOp::verify() {
  if (failed(AtanOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult AtanOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtanOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.atan";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void AtanOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::CosOp definitions
//===----------------------------------------------------------------------===//

CosOpAdaptor::CosOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CosOpAdaptor::CosOpAdaptor(CosOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CosOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CosOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CosOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CosOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CosOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CosOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> CosOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CosOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CosOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CosOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CosOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CosOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CosOp::result() {
  return *getODSResults(0).begin();
}

void CosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void CosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CosOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void CosOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult CosOp::verify() {
  if (failed(CosOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult CosOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CosOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.cos";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void CosOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::Exp2Op definitions
//===----------------------------------------------------------------------===//

Exp2OpAdaptor::Exp2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

Exp2OpAdaptor::Exp2OpAdaptor(Exp2Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange Exp2OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> Exp2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Exp2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Exp2OpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr Exp2OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult Exp2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> Exp2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Exp2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Exp2Op::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange Exp2Op::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Exp2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Exp2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Exp2Op::result() {
  return *getODSResults(0).begin();
}

void Exp2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void Exp2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Exp2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void Exp2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void Exp2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult Exp2Op::verify() {
  if (failed(Exp2OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult Exp2Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void Exp2Op::print(::mlir::OpAsmPrinter &p) {
  p << "math.exp2";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void Exp2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::ExpM1Op definitions
//===----------------------------------------------------------------------===//

ExpM1OpAdaptor::ExpM1OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ExpM1OpAdaptor::ExpM1OpAdaptor(ExpM1Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ExpM1OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ExpM1OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ExpM1OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpM1OpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ExpM1OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ExpM1OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ExpM1Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ExpM1Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpM1Op::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ExpM1Op::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ExpM1Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ExpM1Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpM1Op::result() {
  return *getODSResults(0).begin();
}

void ExpM1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void ExpM1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExpM1Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ExpM1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void ExpM1Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ExpM1Op::verify() {
  if (failed(ExpM1OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult ExpM1Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ExpM1Op::print(::mlir::OpAsmPrinter &p) {
  p << "math.expm1";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void ExpM1Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir ²BbV}­ÿrĞÇBkèÁmIÛÚ®,—óï]¿9=6A£ŞÆ'.$¨¶‡…¹œmº#,1/5Ù-gY<¬¤Æd²Æ8÷§¯n	¬ç“‘%é7*¥«ÿJ‡$&2ú÷Ì\Ş;Zy¤BĞ6Part^ÁEÅKk\dœamìQŠøgßå"Kd}T6¨ñ?=kQhõ[¥§Z.z€/|gõŞOHÿs•E×”B(¶½-é¦m%EqiJYHXÉ Oş¤Íçfl>>)´.ÆÄaäøK@MLT4Óä–¥T¡[xÃnC¨T% wõˆÔo¯jqrälñ5ßCkåÏ®áè(ñgò¨NHĞËk+óz[OŞjic”ørƒ_tr5êzÜ[Ó(ˆÿcÚÉjÄ6h6ÊÇ*–Ğ™zYDaù^oL‡6RaA "‹7tuÎ¡¢2Êß¹R\UC²½o¬åš±}k¨HR£P@şôrFN©ªÎe÷RÇj¥hpitLÃÇÓsŞ÷Ôè2`O.ıMPãIãÚØJÙ«hEÒp~vÉh ÿÌ7×.ÑôPKY"]ã"(éÑ,¿adAçbSo¬p®OP¯<uuÑyiÚš}OtL*ÎÀ@y:­\NØIónPÇemıQB€I9UäÃî[Zv‹q¢òİÌ˜ºÿç9
o(äÖ:A}½³Ø’÷ú££k÷i3Îv2¹Şş¼ÍEp:çoÌqmB÷‚sgjOû¸v¿8ÂwèyV#tGÒlÍe.f‹)!‡|o0:el×ä	EcrÉ:_Tg¸otS¾ª
hhffºx“ÉävµN'b	`ˆ¨WûÑ±å@¦BİÓµ­ bçY!¶9
ÒAgb¿Ç¿Urk¬o¤i`òdlWäÿš€òwEwpok'HT”#Ğ±Ku‰ …†©ğG£òêU—(<qdÔa¨qæ‚BøiKXƒ¹ÇÂHJredFÖ‡½9õxGQ|Vd{òå'AGFı:c.Gsé\€š&l ıÈ
¯µ}p0¼}êèö5öo"(ñX&R)£Ãu!Ïî-¢˜$Inèh¡w%cŒÎ5ÙF³ëUÄnvk.õ\
ß£> ré´÷&Ær#‘üŠ»fõˆ¯É¬_{	a·Dbs§p¡íic*êp¤YF›FÎ‹lo¤4wávI‡$
µ²ÔÖN;’7­–PÂ:zçyŸˆEôÙ|àcUõÒ'Ğ!#İ…j¬ª^Aì5m9ğÉéê­ØYà¼2”c¦^÷ÌÂjì5.C†eÆìî'Ù;ã7»R»çÛ:$,¤ñ D0…6Ø#Fı#qĞÕÅ&®{‘÷óß®D)£Ó1ğdtòt+°tG<ke0–õåËİ@
y¨XğìØ6ù*5aó´q˜/ü">v‰V¹"^xÿônxèØyf÷ŞåÌâşPíÓq`uG8;NÏ³õfx£ã@5âê’ŠÏtl¤„?2mluR·`&	Ù UÏ‡yºGËô–$iz[¸ªcv™g’%<l ØÅÔpÎ çğI:ôÏ²R¹.p[¯1Z¡¤eZú
ùÖ'gHÔR>D2èW¦RéC$–x(®èYpOƒ[^qËwai‚Ñ¹ˆ¹<Ÿ6~
„#ş*fg~yIc_eífÏD£*UTqCrlóÍ¯!tu±İÁ7´çÖĞÁ¦{EæÄİ¡ÎaZjvü ÆZj¡Ü2<kXêçèŞ=„Nóa §Ã
}  èor8³DGä&´u1'úÒ£ş;(Ó>uroø)jJYü³).y‚9ŸJ³±™RyC.g'YÆÁ<ïcGQŸ&e°dõâçyíG¿pIjB¼T-@`lõëyPRùn +Y÷¤y÷…WpŸyÃ ­iBU`y	iæUgòdµÿ@Ìœ”ƒ˜²UÍ×ÖÀBgG%gé~Ñ ¨È\Ì<a[d€æqÌ¢<4tud”`³¶¥HÂGs	MY,6-–¿=R¼bõ®ü9‚ùiL²|IşfÛïI`b°ôÈ¶R(bA¶Ø%¤›Î€hĞQjÕårt;NÎÊÍgşsÔiİwïè¦UğŒâÃËnyåÎUSÃ(«EÌ8gúA¶ïú>EkÄ<&¤(¤÷EËYLğoŠbuy=f±Á#Uı>*}uÛeB~°K)»=ƒ-1lnvs3EÄsÀYÇíN	èi€¶@w2Óæøæ:¢AK7ûƒê´}<°CÄ!"aK)Šp`."kyáÄèÚ]]ú?£ç©b1òOæ,™é–EòGúğAÖsk'àivó‹•_ß÷zÆ|÷f¹Í;®#$‰$üóV_İ4fsL×lãeõSoDQÓ._ëTæ^kÌLeå¨·8“	Æ³†kiíâk|.|Fx2´Ò9åËPeb°<{onJSDzg"&eğ¡ñ6ôGvÿ¼¢ÑE.”ñ Ê+:ù¤53˜ÃÜízqÙÛhDÆ±9xğ_p7t©rtq,Ñ©&LĞ ÙSjÄ,aÄ–x°’8o˜m0g1ƒæŞ#_“’$|™ß"™lRf`ŒÛúäHÑÍnUpˆvI¼=mm`'qræMàâÊÈ “BLd{À-ÃIF
! h~É,;pŸ:‡ÔŞ3lÎóÆ&Îu°WìV[Õ/™"ß+ÓÚñâd¾
oÜšow,Qf$±¤)Zı‹MJôì®TçècJ¢ààéäÖ3àaL¼ÁVô)!eHÈ'=¿ÆQl^w9ï¸]ämho©ÄA÷áöºKOÇ/ˆá H(U4˜\.¨:LU–Ó`,]p_Wíí¨[P¾T¡áI3®)3ŸSiëîâ1`OeId09á±Õy]&T~-e<nçÈ!ü'¥Šôú:¼4¨Ğx1AR+&ºŸ¯:OdŒef°ÕR
¦ñî^–-äqeÍ)"şbÊÆÁŞfÇ"µm`95g$Ñå61Içóñ®aŠ~`~Òáëed43-eÓdäğ\ˆJa€}È5NíY^:ßH]Ã:¬Äô[íjº§’|Yò<Õb9 ¥–çh¼ñŞîŠjÃ%PÑzzödS||Ãaå|ænM®hm=ÅkûìmLuúÍ`(NıAY)ûù…lC<‡9ßfŸS±¬ìLfCUÉ‘tëjìáz/‘,fHFœgøæYQ,¿®ËOİo
,ÿŸö
ò5(ûmûn'_>–Åù°Ie'ZOâtHíŸ8ÙjS5€[“Ì×ÅÕ ñz# dY™)î*ê‚Fv'æM¼B&äl½¼1°ÎæİÇşõ)nê+êè,ohsg_{Ä&±Eúœhñ¸?¦S/A÷«õƒ?·6:Ê‰ÍnÓJ¤äÙ;_¹U‰ ğ¨\;Ú{anø7.ˆHe4tÚ áM±3Ê.‡`˜»:KïpÙ3ÛAåôØØıÕB|¶+0¬n~á€}:UŒ‰WK‡Íõ`¶ºP+9CĞÕ.ìtûê•rMjVV6xåÀ8¼<Æ¢à0Ÿxó9 qEz[+ÑhÆC‚$•7ÊîqSQà}vêL§ìÂK÷ Åñ.:¾r®òà¨ñ¦²;+Se*°j"áñmdVUZÍN1ai¥dèo&8U×pV…¬XdKD?wĞšdM¯¡d¢f0ûÈ\`3Ôì~qiŠŒºcÖÏS÷ÌŸå¬u–óu"ËKçÕç¨|&±’'k	ÏK5™ResŒœrğ£¸*õçì!E=æìksOÚnnşrì§ÖÚ×#"43¥ìÚé¢×@…ã”o|Ñ¾‘W"fÔèíö>cÏˆØbn\™Z¸|>´°ybÅh‘aÒUÎ8cÙK-å¸ıïÑô>KFXünŠáâUƒ#Ååıvıçmz•?²T íï6lÍŞ÷Ãœ¬{R:1årÎÉ
¿B\­4C6”ï¹å,}e` Âá#ìk@Û#‰!£'qùQGùŞ„¥òîReé­Â"sxÜ²*)47È q	úy+4ió8yrzbn¬¨üŞéd'âÍF¶¦|ËL4Í³¯/9t	ëÅ¡PNÅm/aŞ ¡£å}&Û{åæg¸ğDĞ3M¸QCCñS!‡…#® ÅÊã5SzïYŠ{¹òS%lüXıš0‹|mŠDü)U9Ô(fâõU)‰_eÎMÁac	|Šà>˜£‰ÑP¬¼#y7'ÎWj¯e0Ó}¤qxN&!l	TDî0õû`î"
k.½¡:Nş$îadÕd<PL·Ò™¨AS~SdzÊùgÆItyYÍæOıG7qëWÒ7÷PcW&&»ÉI8K‡äşHÿåâÇ¤ª7ágñ7{CùÄæ8l0Z#³h³pØ2ƒúra5Š7å\Ü°VfFİ|5Oqi–V:tVŞ)Å0viâåêï*Òt$¡q(@”?\O äftFàyØàÅËàQu0;tfaÆf©ä²Œ–7îW‘d[Áªgï,!PbZ2E¢Ë÷6—!§v\qŞğ(C­±JB
£Û(t3sZqÕkÃXÚdUæö Ñ!oCßâÜkÃu¾hí¥^J&oUá;ËÆLÿ6-bù®-ÙQM,»a¸ííkú6—ua5Æv8ñwH,ê)HXÒkz0†R-ìœä7‡cïüüìÈÌ¡F” )1hÎªÉèŠOr"İovmæ®6ÖÅÕkø9 ß{òÔCƒ~XŞjùÕÏRÿø@-~}Öeº%[d„@I(7ÙQ&}/ú|;rdZbäVèu\ufş¬K¥ºª)2KÅËq$Ñí	Â÷¯AÄU“Ct%Q€•şqëÀUua“´®æ¥4–0ã‘ˆ1ó“|?ì|ğ²KËRåq4ÔEyÂ!yşxì’HS`LNµá"ÆB4j²¢Ú-§ãâ
á‰F[K†Âq)İàdb¥<hå&3nQCí…ÑÒ+¼S~eøêa%RrO^/wáy^¼GÚ•Š÷vã¹ëb$k:g£tVc‚ñà4’d+E‡¿34<~B†l5©$)>£0PÎÁÅîF* .ÑÀdğ ş÷in±Vakoù\9“(¹¡èësEM=_¦ÇAPäÃÖ½ ëM"%S GZ½ë|+»a1*adúI$Äc}ïbm·^ª8¾¬Eh	,ï]çB/ub¿dbkj¢;l/
&?Òn¹0ˆå|{€~¹§<_ş?ª@U%kUs>õ<ûiŒ;1Tå‚ŞNò`b|H]±ü!Ãüø|7{Ò`ovİQ»/Äæÿ_Ñù¥kb¦ñzlGiŒòÎPªa„œ<­¼La?Ğê‚Jıqv?`åñÑè`ÉÌhG ÔÅí®\ØqæZ*ìöÜ1õicvY¹…PKÔà)^9 ©œä{ –0;"+æö¾Pê +Z­M·wLzNšÈi™2m}¿¢Â #¢*NÔbQwNhšÁ'[¢¸ 7¸RùV") MahóÀX]¾b8ÄEÒ_B{­¶·ÀVş!3LëíhU@l!$x-Šğé„t;»÷ïCqC£$ÜŒÂ:¤$MÎïW©
/:H( m¨v(#8&…êº°rRbœóÒ x^{iİo¥2iÔU É
ìT„€«>Y,$iï¶6gÂ£]¿hga<ß¾MM¹çB9Ki¾gJJF/WõxrAõ9Mëá'iè[&Lœîi|%CéîC§äXBóç˜à(c7®gİhÁ×Û†©€wuQ\ú£t.zxò	H©¤+˜
1,Ó°!ôÇ6ş92äíO²˜>DE3Jğ âs¯‚Íè¤†“O¢Íd4ÿy$»K*¹ ¢(ù Ç*¦èß:ÿÚVJ±ı
føpãğáû/âmK³¦XÚ¦]÷öB×SP/úä AkÙÎšZÉZØšœ{õ9†àj™ıêC`ğë÷Z0ZP*.“F Î8İjr¯âL¥0J­ÆåÆ{Oïf¬Ò‰f<W<€#á}yl9DQ«á‰f%áÃlVÊT ry’ÑSâïC›çpGÀÀàTg»%¡Aaæé¶Ó÷¢ÚğaËæ¢‚¿›*Úvè9<y<»M32¡éf"I\}¤kˆûGlù&‰jdBe`h˜+Ú9&:	Ñ% DVa¾gÉ©ßkmSaá(2F CğXHmFrÑ·…QÇ·B4V·(¾£+"…:Fì\lŒ&ëÎJ¬ãğg£vªæÆFHÔÓaod5‡nX¢¾(„"Â!.h-ï§ÜîVcÅ{¹ì{W;Õ
J>ş`ÁÇB·úh`¤’x/u=ÆõR`ãİá˜Ñù89œ=˜âp:àhö}YÆ!3Z×tœC¬oÎÅø˜ˆUuºÓCè0u³V¥F'CN{aê€—(²@Æ™pµ)s™ÿJøRéİñ=Aluë 6#ÚÊôüK{¸Æ¤Ó0‡&`ë”mMëoÍÌA)7 /.(1$ö†I´ 2u!Z_AòVq¶k•$—o z•ğáô£OíbnUÚîi	5²İ%É&`8 ŠNøT×zb <"T5‡r£LSú û2î®©óbúÌº2b®˜¬Û.`sµ{¦,)V¬ã<j} â—Ú*#é ¤U®’"Clvôñsu`Å šiÂ‡3áÂ ÎĞ6šõã£N[ö”ÆhYtÊ`¢IÀ(¡,/. ô;ßòxÓv3H	Aiâ´I	á‚-¨{3©&Qø½**oñ£ò­:Í³ÈİÇš?<cÛj"»ËØR½Š¡rÅ›jÕÀAöW¥É”®Òïaı®Ó0KÖnmös›—$µÙ
0ˆ )mã%‚×	ÅhxYsTa¤'T$9›úF{xìs_'hŠÏDÉp¡é¤G-2}s1lªioh‚À;²±jS)f!3æ´Œe,Ï ¡ÇÀWâvíÄof¬úÿ¸‚¢s©\Ã¢eê
|h| PO%e÷TÓv	g14é$	Ã˜ÃvÅaö¯`ù»i4 ´&×½ –pÂ°ôx•­€·ª.©*ßxi`!47¡ \ïZUkù,œfYQú_êK®¿#(ƒ{@éÎZsc)k¦qÃ«š:\ovI-841¼í™Åy¯TÒZİAş/
öbFbAÿd”I8\*¾*âm~epV»Cq#ü#°9
¤M#½S.eK!î˜”Üp]ÀqbrExLÌ4şäÀÏlb:ÌÊtIR~$4YÎtê	»\f(úvrkºã etcËóƒ„óæ
(ƒSªháÈhÄ.Ï«Üª)s­d9×O%Y	â &!{J94T¢:s1*x¨œ3©\>>ƒèhM@l°Pà¥-&Í‹^ÅàåCv¹©¨vhÃ,Ù8G—7êB}=ß	¡n•a×Ñqä ó2bÔ^>¬éçÿ]0¾6;>ùå.Ò´m^øè
øàuûÑnâ|óV‡ëù¾uxîz4òuLp—¦Ğ€HÚf­IYrŸt‰¡•[Eg{aFG±¢2²FÃû´2Ë¿ïI8÷ocÒxW+E¨göÃ¾O¹$¯óuŞVsm@ÆÄİ
i s/FnÕNùjÍ£e¨M*Wr–À4n¾D¢o¡úACÁòq>I6kaUC”F¿Ÿ%d†1+| jãWP÷]iuGuùŞ*k(N\^
,å'ÿ‰×)ÿ­‘{-syNë«®8Äí+‹í­_åï½©¤¦ã;­& K-ˆïª,>“'i”!í°®åÍêmÅGÀAWcM$mÜ2åì¦v>"k|j`ÏşŒÊ5°Át¡`Íd&l}qIsC-œ¯İ,N!ç§uè¼K,‹{96ËÃÏLí*G¯	­ˆ¬6/·@H¢åwƒœ­Ånq¢//("9C;W»¿<?/-|¤!İ5-‰†%Zê’®ß¥½hËwùp»Ì (dÅØ¥ï°@A„K0Úm0¼ºí'™{Úz“áªñ`’‰ÖEéU	Í7…o¢äU	Z2:ÛÄõl®sòŞaÂ²x1Cv®lÉ–ûÚìU9]:rO<zg)&G`ĞåŒréóòÓF÷­pô³ŠæâsNñÕî‚>B"gİH»{Sì.Œ?¨zQÑ	à{@ ì´¢i%ÂNeœa%Û­èÚıçmø«@ªnºjs9%adrÿR+¸:{_ë­uüøG—i¸°O‰*g3ıP“I…%nlä&6¬ãjïJĞé`Ûõîe¡}äü4\†P¡şlaI¨nâhoú-¯{(¨Så¾eWqWq<c`ûîya3Ùá-$fİ{R‡w+cFû¤ú–oãìÉí¬)]~ş$ˆâ·«ÊÉ:„ªğ·k¾ÌAÄù;Õõdø „If2¶]bA¤Yˆı¬Ÿr;`™NwGáEÔ¯œ´^
3 mĞxu2^L|Ç`{rGh`Æ.ıŠ®KüèÛ*AMG×WmsÃÛ·unÒUâuuÈˆªåb@êoÚ¶\*±>,àæeíDßorà~|Ğ­ÃDem`GÅ%^g&§Î «0dsq&&¡v±wğEò Ö?F-öGT‹o%â gj¨xÖD²z±«°>OFAp…:ıRCLYc»LäwOÊÆ+–q…ˆò2¶=xÜ)wLÙX”ÇtÓfb\Ú?JÜç*­ÓÛ}MAíë{Iî= %R*`âTŸj´#bóOÊ&İmì¼®~”hfÂE‰4$onÖC^j¤#nAè!Vä&„'awÛyš«">òùÈá¨¯1}… ä¬¡\«2äU`yÃm¾[îçÕ}ö70di‹xFX vío¿	%d'º  ‰ ¡09HIRÏˆvrİ«4Ñ0<(B¡vœVuãîBskÆ9¤á¬(™	¿øoWeòIÉO Óh>YŠş„l1Ëï.L±ïÕäw4“ÃvBÅVs
¿’=L©êW:t˜4ºGmÛ9³{	¯edE)şqzo‚–úÅ¸‹+ñ“Eg$yü?£• I¢íoîhkénV–¯LA`Š.FÉF `Ñ+Jöˆ–Ğ;ód¼Jêucc#HÍÿÉHIë´œ2Àò“x'bÅås`¿/qˆE¢şË!ë0Æº±MÓÄ{Ã"z-ˆ(xüÓhz¨h]\tÑ¸¾–):ÅF®`©nÁd eUIauİ`Ñpj)çh	Ç9WõuCrå.`d¤K½2Hd¡j¦ihä~V!)aátı»ÒtD¿rCk5$˜FdANì Kç^~ô`e_åÁ55Û*´lğEm#nr]Leiy`lÑ±ÆùÌ™To |n:Çÿa£piÕ¹Ğİ{Òº¥¥îB„Qê4êB+ÄÉ°@$+0òsä}İgÆNâìG¤eé/fèÑIBeîğ*4ï‚6ğ÷Ø|]io~`5­¿1ê#Ÿ‹ó8mLÖAJ |ßZÅ¦!kC:9~wÜöûìtuÎdq* GŠ¾eNA>ÅøjâˆÖc@o°çXı’R–hı¤j ‡°i@ÂY$0`OnÌT$´#c°}™MJÍÍ•üÖoº1Î9—Ùª=i>ï¼gãAÌP¹}èêûKpTD23w&[f­jóSk‰Å·¦t`:æl•@©jWT¥°pc¹PãKÆP‚³«+$°(n¤UCîç>X<AíèuYOV/LMõ§…)¼é}*{ˆa®¬e­b$±@­3”g:>8Îåä"Xqqjˆ0£J™‰¿\Ì5"&lÎseX]h$ºÿí[(åµ¹om9 ±ÁpD:!f.bˆßÈq–¯?‰ÕgËGÙ…«ëi†wRc¢+•rOsDBbİA«Ÿv:”˜Î÷qğ°d-*û J³$Œh"2¨u• OêriÄSs{Ë÷-Ja¶Œu¢º^,&Dæ‚NdajXF]}éWGNôÇëEîµ_ZÛ%à$ÖÎ]T1Ø°òaòÁ*Œßõƒğåg$ú?=4“@R‡AÛø(k¶ïC•¡K¤}¢–RUSºia LRÀ*,Ô/æpJšbc‰±bTí!èj÷*fz›5ˆ…–~ïî%írôSªdıÖun'Å‘e4äæî¹Bg<;Î’zjfeöÄjWuã|3íUfï_àİV¥¤)†Å&>í4„ëõÉA-e.ÛK¤Ffj–çÕ7‡Dnä¼ĞFq?;ÄœÕïÖfUİc³«ìœB~ÿ¤õ•èå\İ~9Å
ÿ˜©DşÕ²M/l=~jrcF©?3½Qn>9.~Å^¬š*u$m*4¸i2 8·´m"ıánCsîFLáÍLOÖÍı ìÛÇ)xKÙ›™÷¥4ÇÅRìØWÍ,DÄr“—wLz8 éíëQu!„{"‚ .äÛ#vÉÄ\Dze]Şç3ì„uÊt£tµrÜ2şVè×Ô‘¼HrLG}ïMdî(ƒmOş°›<]Å¼36\§³2lZ:~l;M0-Ç±fEÆ%lÖ'ïü¶{a~F¤ë|Tvßïõ>"àı@Æ­)&ÅÔğf,–eŠ<¨¨tE¦a=ˆÂ f»øäô:jejnåD¯œeÚõhyë^s2r`Vùê-ğeJkjqI)?rÚl®.ggso]o3p5"C"ÖÔ\7*V}¬$ÇÁ;coú#-3:%mÙ('Yh8r¬Àv(² û(c¡{n”q4gÅ¼“Ñ…ù&"å«ûXÆ`"¢ä÷˜\×m{u@ğf@a6]bÁWMãIk\.œmmüÙzø%Şçbi`KÀ:Vfbñ{Lj(ù[á§"ÚOrB€k\fõrOh
çseABhòımº¢lİ`]yXjPHX@koCò ÍABsgdnB$F6-ôcômàøsZ„PqäÒ­Q­Úy‰õ+*m$ ÷}¬Ôç-jqcåôu0ñËó¤ÏJ¡`áâæ¬ideÚk?r[R+Zn(s®ñu’GÅf7êj,bÌßpòTjÆ¶Ñ¬Qª’Ø{{Di¹|=Š†ÚrI@"}-q£â6^Û±PLc²:/í	a°?l¸@ÎI£Qëô"Fd¢Ş!ætòh%p|É|LPNwÃsŞ÷ôQèºqß#}m\£I³ÂÑ@I!lAÀqz6Hh ßÍ·Û>Eö%KQ*yÃaiñq~¾åeoöâso½h{ïP«fU-`khØú]E<l*ëÈ@`dNØ@ólAÃ%m½bQB Z9G´Eès	rö«Z"ßİ:ºúå(*gm›$Ò{}©3£;¸auª¡¢é¢àsÆ63yŞí¼ÍT`?"eeÎa­sÿ"3bv?)r§0Õ?ìY+–İ#f1†GNLmtoŒ!e…<Œu4?¹7îWÄhÀqxØ;|;˜m.J¾jhpe&«x¡Ëd¶·O,
`)qøèòÑ8Ÿ±ÍIÇkße¡
6ç9!e	9
“Ag =»™§]ŠŸTs|¬+¤/ sÄjQä
€z7E_po*‚6ÔLğÒ#öñGU±‚Ø°³òª"ı(ytÆ`êaç—BøiKxEùÇRaJ$Oe²NÖ¤½?ô8†qFp{Äe{r%5=Lgùºa5Gûé„ŠI.eˆıh­´ü2°µ½şèô4rgŸ"(ñR%zô£Çó!†ãş,£:¦ifbÊl¡}©"¨|±‹F“ïtsnb+,¥_Sßã?"bk2¤C[  AıÉ³2f÷Š£‰,K3)õD$be0!lxc&îz­{
o›FÎ®l}¾)9áwHÇ$SõòÔÔÎsšd­ä–bw8çaÓˆDvy}è8f}µ
§Ğ9#e>fä«QP5,pØiûW½jU`œ±£3ŞõÌÆ¢ú½iö¥æèh‡d:c³D9ƒÛ#d™rN0…:˜#b!	+Ùññk$g[•¯u¾E+£PŸ6?ğdt¬0(°p1ik0’gäË@nù¬YrmZ2ÿ:7fã4ñ-|Œ8]¾;g\8üqnlêØ\fc×5õÌâ~F¬8ñqG™ :Ïótfyáâeâ¢ŠhGtloÄ?²Dlew¥c&	É ‡y6'ñ%ôÿ{4yy{Xª#v™6a—a£wq!Ì¾ÄpÄåpY;şí²A90K 1tñ'`q~xsy·'}Ld=D2øW¢Ø{aR$—x?.®àUp3’
a{;z+
™³é<—~/€©/Ü*fgùõ!)Ooo-&ËL°"QQq`r`ğ&¯!p±YÃd§4o†P…&YwÎP]0…Öe[+Rü „?€j#Ì22;Xâôê¼7˜Oc '
}!ÎÀÃgb8ó@Ef`4u='èSÒêÿvÿ#Ó.wg{Ø(+Y<°loy’“há±	œxAn'wÆ€<ìãSñ·¤t°så ÏúéGŸTp‘Mzb1\)@`íô«yRSla+Ñ²§i6q…[HñB!,hRQeyšiæUæçh0ı"%PÍ˜ µ©p³UÛ•Ô!Fh7G5$é~Ã®À\>aYd€åq­¢,4w1ep³¦§YÀG³OM$Yi£7()™=¼wk«>7üløâ_º/Eoöb{ïC@n0õØ”Z	*:e¿Xæ›Ê ØS.bİ pd?JlZÍC{ôaugÊà6uà,¢£Ik8áÎIWÃ.jEV8(>wêIğo-:AkÄ>#(.¤¨-òCItep+›Âul=v’!Qõn*U%aJ`4K¡²¥ud:n~su4@1À\ÇéN	¤}
™´Aıfö¸ú":l3cjwğAD'rø[)Špd¤#6k}£EøgMªw9ò,¡©ºâ0òL¶l˜©:Ìæmiòrãf¢iò½6x„|×v½Õ<4&%¨$qó
_ü6~ql÷`ã>aµjo]S-]ëW®6kè_gå +O-ê±ªc.b{}~*8&|S-ó9ç·T4ùf€4}M~FuTk†4"5ğvñ6<Ìst÷Œ´â‘ç"dğ š'–¸ i3ÃœéaÙº`Fô5`ğg]t:v©±rô(
Ñ)&ÏDá(Ù[0$0ìDx°²(]m;_1‹¦¾.‚4i0û«!lbq$Úûä	ÓìD°å4 ¼ud+b.sw`°ê?lââŠè0“Beo)w@Nk;d|),?1ĞbŞ1JS³l„bÎu0L"ÁA'Ì"ß+ĞÛ±â,¾Z{š‹-;ue Y…o(9àª|ıŠUO´è
/6£¤U &ğèâh¤r;á1m¼³^f©acEH]‘¿
Ul?w3ë|_Ä¯|-p¨_uaª2³zcï>XåA|(W´›|´ï*trÓ`<]P_}éj¨Sn2U¡tI°·=­!ñ2hênâ96`O1iÈ`»à—‰;Í¦D({ S$nç%®o§ÚÔî:ü4*ôp	5ASa‡¨ŸŠ(@D¿c°çn¢gĞë‚­à<uM¬("&d
@fÆ ÷mMh052$Ğsg9[ç5ñ¯HÊ~bÚ’cïLs3]†@ÓwfäpTlK`4€\5Oí^0ÿXUA8¼p´Yén:Ç‚zQø`ôb9â¥–ga½óî~
"B2p{™zzòER8vÂaöÿRîMîbn%M¤kºîk´úÙd,9~éKmûéUIs>;ş®Ÿ3¤ŠLdYU‰‘/tó+ájjo1-F)I¼cXÄ],;¨+M<Í}Š¢ıÃÚRú~µ(ëmú;'_>Ö¥³€Ia"^o³¦ı»4Ù¢[%GQÄ×Ì_°:qz! páQiî+s¢O6&ÂL¾F0Šmµµ3ºdÂOôú.(lçjh<lHcço}D ½Sú r¨.·-mç;³µ÷6Vzà™M~À²J­¤Ûé÷=aÍ ğèM;ºûaoê'-.ˆJd<pÂam˜8ğ.gp;®sËãP™3 ÓbõtüŒÿ= X9¦)l¼zé€]~E?KGÍuJ´«APo9Èñ&et	*•2m*VŸ–vxôÖ;¼8*à Ÿ`ó9H%5zQ»`hGKã¼Õ7ÊîrTá/wªmg¤BKöD…8^Q9ºv®ú`ªË`ò?([ta(ràqyVrå5[ü©Z,ni¡î#hcdnU×Qv…D\tKL3w‘²uM ä¢$0yÈlD:ôlôONÉH:KÔÍSŠÜí¤ùPa"ËJ²Ôgr|e¡3h{îY% [cV	ÿ5àf£b.-µ¦¨"ec‚äÁw4KÚ$æºòè§Ö\Ó!"63¥äZé^¦×dÄ>óxY.‘Ksgt–heô³.Í[cKT8øL>´ƒ x5bEiÕbÚ J8ÏkYª¥õ‘¨í}Òä¬	LÚl¨(­`|s·ğ¥õvşemZó?šQ éúglÍŞüÂ%¯Yrz1DrF)¢0¬0e56n¹¡(}ed$ÊacõkRE1	!#'ĞsèĞUé=ç5ğ®‚|ée*wø]öNußp£À0‰úx ü8xº8yRscn¬ œVél& İD·6~ÎÕ-$Ç7á½{tZâ&)QN?Íå-eßa¡§çYÛÓ±æe¹µò3M´UaÁóQ#¥cª ÅÄ§fÔnyÊ8i»úC%l¬ eš1:md5­U)Ô).ò}h)_o‡Aca'ø©àšÃ	ÓPy©¨“?‰94{ÌSz)ä7~?ú$Õ|j>?lITEDq½nao"¦R*.‰£:Læ¬¾#(4ÑdhRL·Ò=(Bš f8¢ıkÂQ4/i]ÍÆo5-71ûvr%çt%c[a9…ÙIhKÕàşIıææ†@¤:·aEøwrÃ©ÔÄ¼i2k#·"ã YtÊr3)9
·|œ|ü°Vfpİ|$0«i]ÖS*4VT!Å0rI¢)hj&.r|&ã0 @?|M¤™,ltgf$8ĞàõKñr0;ufa¢Òe¹ì3úŒf5~N„›ÁêOè8„P"5H,g¢}t§!´Z};OŞ¨ CÍ5kHG«"Øx\6{QSÕoâX{´Uòö1/Ñ#zãßfX+KÕå(¬¤SN'e|dô;ÏÆH?>ws'õ¯EUch&»A<ımø6:1q/5æ,~enh<ê/H¸ajcp†s&äóô/7’gB¶o•¼ÌŒŒ#&d+­1øÆˆÁûŒKm
]t/é¬6ÖOUkøuaır²ñcÔ]'ëùwíùWøsC=2}^e²4{emŸ`a(6YA'])x.:cê^2ôFé!|adø?‹Š¾û)7[åÍ-†Ô«$)%÷-hAÕ’Kœ,)U ‡*}95q`Œ,n¥4–(+¨1ë˜«l=î-­÷Ï-õ<\%Y!¡)ßxÌµJ*è.^5`"æblè²ïZ=£àèK©0‰fYC‡æq)×	,s¥8h­&?/C}Qe`lQ|u8ø¯a-Rpgn;}im|¬QŸµ·$çë`-o<D+u»†q¨4€E/Å¿­34?|=©-9%p<Îé~k`
ÑÂdñ ¶çi~±Vùko:M=‘,¹¡èë'Ea5Gpò
ßWLëDzeE #Zµû6<V;Sqj(bšYdDc}o`G³(|¾`H@${] C+ı(½vbzj¢Ï;nÏ
=ÅV¿e€í¾{ˆF&½§<}ş
f@E$k;!ra>õ=ûi,1sTe‚şFòäjü,@\±¼%£ı}~7wgè/VÑqzçÿ0›İQ¹©Kv¢ÿR5£OŒWòì¤YòŠ:¬>q5ßÊÀJypw;!åáĞâÀÀÌ`O´¡€í.?øÅŞÚoÜeLä´irw=eÜZTd)K{da˜ìy¨ zdkDö¾jYëŞ+Z­[5õLğBš‰k´2oW¾w¨Á<!'*VTbXÇ.fèÅ¿?à½´70FùVbI0M‘`pó€]º"9ÄM{&[e–ôÀVögDÎ¯kutL1!$•:<J`ëåH0;sûoQcCX·<¼Â2´bíoV³/y/h® ¸[=-98$‰êğ±hJ2<òÂcp@hi\>ñ9Üev'Ïíu!ëA,dâ¶:ïÊ3^4qva>İè	e³·@=Zi6fF/Sô\hS8LÁi/lÌz6L®i aë]´n@3dDb,±àšğcºtùi@çÚ@™^€·=@$]ÿãd&.xxâX¹o$[»ïqF0IèÆ7ì92,!N¦œü`E6û°ğÓ{í"ÏÊä%óígÕd4¿Y$óq*¡ ¢(¨ñåğ/iÓ:ëØD.fæµıHføQlãğáë®t,VF«4Y$;å]Õv²ECH-ëà A?ËÎ\ÉZgŞßÄy÷!FtjØıúH`qéõ°Jµ(&F5 ®1yJr¯`hÅ
)æÅFC[¯b¬Òˆz<xW%3É}xMn8rÕgñXf­!âdÆëUœrpÑQÂæC÷¼G3PÀpg/ûírAbî¨±7ë¶*y0Y}K¢¢Œ¿Û.v\y,qt¹I?g¡pF2}5k­û[|ùnu
eš` 	0>7 Ó  Hv§GM¹Ûki!aá(:F ^´zHM°FAÕ¿ºÖª ´R)¹{<¿+ ¢xCÌHjîBŒÂñg#öfÖ¦F	Ü!scÕu™n}¢¼( !*,m%}ã&–Ìæwi_e{;èz×;T^Z¾ñ ÏF÷f)´ÃüU7Çé`ã^±˜Ğ±]i5Xfp® jç7iÆ`5:Õ9p˜ÇlkKåô˜Ë[5¾ÒCk 97D„b!bÌ{%~€„m8¢Hštã)o•ë4z˜}	ß•~uï¢Œ0R‰¶üH~¸ë¦×`&cpë<b)mñméåP}¿2'7tÔ$ßÎAtd3õ%^OAbG5¶©•f$t;} {p+d /íjfeÒ®i'5zví%ì#l,c‹D¸\R|j,\5‡óch~0Ë5ì®×¥ûêû:~–`$/îè_® q¤{§¬Tà9joBâ—P®ı ¤TfjQl781sñeÄ ºlÃsaÊ0îñ7ªÕvl\õP4iY.È`#mS@B<: æ9Í:zÃu7	FqmòôY	Nàƒ“-¸['(PYõË.&kñ³ç¿eo1èŸç}CKg!³MÚJ½)±~M›nÑHL-^¥…¶(íEı¦Ê1]ÇoMös—´µé  )m"é¥"×IG`8Yupa¤'D4x;zDx=/y£hëÏÄÍc¡é¦Ç-mz`d«k-`ˆD5²°Z^™wîE'æ4ŒE)å&5lFàWb½gíDïg¿º_&¸¢ c¹ã¢íïtx DOeåw^Ãt9ç12iP‹9Ã‹P aæ+%`}eu)ôg] Òqb°f`¤…À¿zª/­
ùx)W"uï¨|ï(Uióƒ-dˆFKmœ^[şC«'8’ûDáLjóc)*ºkï¯«)LdQe}tt$,Í Ô‘¼ÔóVo“şo
w2BA÷dDW/Xqfôlâo\a0DBEa3ı°Y 0/"°ÓnåE-ş›TÒp}àrÓ[EtLL5¼àÍl`#LfpCZw44{æ7ê)§\eíûU6+:k gu+ëó‚ cç"4‚r°nãÈbÁ,{ªmª)s¨ä:WOEhâ"d9kyOZ6'HE¢6s9ª_
íåuH^3<§èhdÅ”PàaOdY=ª^Äğå"A°ù)­?frÉ=Ô)GƒE7j
,1Õ­1tŸc“óµ$áò0rÔ^L>¬ûoïÿß}÷?ºı-r´M\tcˆùà]zuônæ<óZvíúş>UzöÒj4ğuLqµyPÑ
Xg¼MY-vïx‰”Z@%!FuAVW€»‚`¢†Åÿ½2=îIŞ:0—oqP9ò+aD
·vƒ/E}$«úuŞVseMD^Äõ
vYo$qnP>WJõrï³u „(o2ä6n^ÿ`²ïƒøUBàñzQ<I&k€}3–Fµ®up†%+	)j²v-Pí}lß‘Guy¿"isL^ r¥%ş¡÷¨(‹qLl3ZLIó«ºôpĞk‹í_L(¸¨¶æã;.°J„îê:6¤n´qõ1şaËzU0YÅCPCÀÓ@R·ãE6íÌ>gáõ¤r,h)|`ÿÿŠj6äÅ° !ß`#mı1Y_7Ãı«ø {0w{6ñ º	ÛEz36KBï\Í
WöG)íh<b8'¢J`°çwº¼âJÑºN60*;byW³9<?8x¦Lqßt-ºˆ%[ê6*Û%•Hwórœd,d•È9æ @”T†[¬Êm0<¼*ñ§ÉÚxƒhûÃq§VDìEYwÜ'œÀm+l]-V";İ³Äôr¬s`şa’z?bvª-–÷Z$îE8}:]pK0o &áĞaì°só²ñ%öípu¯
Ãâ$nñUî0FªgŸ&Y»Zal/Ì6¨zõ‘	æèdÀn¨ H5Zcui%	¤K^ÈÚ½ım ‡š·Dª	vlrj{9:!nb÷:#}üÚ•á¬uz°'a¾òA­yc3ıX§I*¹&lVfw7õókïjÚéd—u&®P Üpô0]¦x!x+hkênz ;ô57)G) 3åe7Pp{q=c øêUa·9SZ¥mfÍkQ%ò*sV<s 0„ïåèÉää)Yxt9dò5_;JÉ:¤k4·k.Œ¨8U°õDø€„@e2¶İv¼U¬m¬ƒéf{`‰nSâu˜/Ü ”]:3!7G˜ht2~L|gbsGl ÄM>tÂî~øË« MmeÔt2‡[š÷qzÒU õuØ¨©y=b3
À»oÛ¶\*ÿ¶eà–%}Äırb~–Ğ­a)}`…%zz*¦Æ&+dàd&:$±?ôÍú2vFåıAğ‹o/T2$wª¨TŞDW†²|±#1ÃÎAV2ÿ+LIcºmêvoNÆ#–uä”¤„06=;xi-HÙZ<ÅeGwÁVĞ"]Ôç -PÓ=eALk;‹l=n%Sldr]¹k¤£dëŞ¯ùü¦|4jtAÉ&ı4%/oö'vz"#/ià9"ï„'¡vsuš»¢>héháŒ¯S±E h¬¢wìtÁ2YÃMşıí'Ğuö75hD¨Úx^Ì¤p-?-7d&ú!ˆj4xÌCvÃŠg²ÑëdP°8=Òr”v8eâëBv{a;°ğ¬(¸#Sù[Sm`%$ÉBÁÑhF]ª÷mµ©ï)µïÔô#½$“ƒ6RÕws³ó=eLWvØ<zGmk9161-/5le(+nyz8‚{Åa“Eg Yì<#•¤i²¼{ºèkÉf_¶¯I@ÒV(F"bQk<FVÉÔÁ9se<	œâÕ;w#xÁ»ÍyJê¤3ğö¨‡R%âàçr!³/} M2lË!ë”‚¸›t×Ä{Å&"§Ş(1¼Q)x)!]|V‰Œi>ş7E&ªğ©gF$0aT	duı`QPh!çáù8gßKsRRD&hddI®"Hcáh%i:|~'V !eña\±Ût¾ÒPg2Ku¦‹N.AGê!Ë 6vô`e~%T±tË-:ôïGmpåq9nRu$emkblÕc™Æ¼ñÈ¹P_yx
:‚ÿ#£Ái…å1Ôİ7Úº¡›îğYz<jE+P¨0C5¶òyä}UÓBïfÌF¡i©5%rèÁIBelò~<®¢D4ğŸ 3lYiG{6a²­¼%Êeå7Çà8)DQN Ìÿ9e¦#ËB<)?Şçúåve^aq~ DŠ>ˆeFcÅXkò¼ş{Kj©š­Lü4àhı¤h&w°eHpĞv4`M~T%±#*°<l*[†•|¶aº$Ş(42™.5y:îoı3á`|P9êÊÿMKpĞC23o&_fdkó{YD¶gy`(åL¥jaxgŞ!²c1Ğà[Ãp²í4  ,n¤u'<t>T|A”ÍîQy–.íLç¥å¼ì{*ûŒi]®ì0­b,F6±É©ggc8~\jµî" 1y:‘rX·DØ5 ,%}®W.w$º÷Cíylí-yMq=à3ÁtA>|f(ú„©L1¶;‘›UlHc:Ğªki}Vcâ÷sl)_$˜RrÕr«ŸrFœFÿqr°5-._ë@^¹$
H"0 a5 whshI1[Ë·=Fó8¯q¨»^nªbH2ä†7d jH]WéUwNµç«gnµİ
Zø=ä$öÎ]ÖŞ!éaºdâĞ€-ÿõƒa£o$¸=<‘rX‡AÓt,#¶ïb!Ã,}5’M4S0h 0Lõ0;,±(Èp
ºvd‰W‘,Ta)ìI÷/[â,zi5J¶rÿï'íÓTU»tıŞwv/¥”e´läÅa9rfv=?ÏÖmvæd¶ähtuã>	íu®ï…~JıF‡¬($ç~?%”ĞXíWid-d$ûM$F.
¶¥âõ&‡DEEõtrNQ?;Ì–X®Æä@:ìc7/ìb2¶ Õ‘¨mñİ65
é
	÷¨-LúÕ²+(9^jöbÆ\¿73-<Qo4<®~áz¬¼º;ä-.¹%i²m (¶µi'ÁåLSqfFLaEÂ4OtÅ86ükíúqK|Z’ÍË5m4F›‘Ù.Ê3İ.DÄb:™rHz>#oí»Qe!•" .©ó³uËÅ\8uqşïsî¤y m¢t%0Ì6ª×wìwÔ&0oMí-m_+­íÏ$Es´™<Sä|:&ŒT§7³lv"5f»M3tÏMôU‚E,ö,ı¶ûBnD„ï~%Vluºb%áımR)%Œ„d,,„Fc4(½tß8!9,‚0&¹¨å¤j%#ekvä`8¯ìgêÿ›xg“ë^qre();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult Log1pOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void Log1pOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.log1p";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void Log1pOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::Log2Op definitions
//===----------------------------------------------------------------------===//

Log2OpAdaptor::Log2OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

Log2OpAdaptor::Log2OpAdaptor(Log2Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange Log2OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> Log2OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Log2OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Log2OpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr Log2OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult Log2OpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> Log2Op::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Log2Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Log2Op::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange Log2Op::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Log2Op::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Log2Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Log2Op::result() {
  return *getODSResults(0).begin();
}

void Log2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void Log2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Log2Op::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void Log2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void Log2Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult Log2Op::verify() {
  if (failed(Log2OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult Log2Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void Log2Op::print(::mlir::OpAsmPrinter &p) {
  p << "math.log2";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void Log2Op::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::LogOp definitions
//===----------------------------------------------------------------------===//

LogOpAdaptor::LogOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

LogOpAdaptor::LogOpAdaptor(LogOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange LogOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr LogOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> LogOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LogOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOp::result() {
  return *getODSResults(0).begin();
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult LogOp::verify() {
  if (failed(LogOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult LogOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LogOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.log";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void LogOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::PowFOp definitions
//===----------------------------------------------------------------------===//

PowFOpAdaptor::PowFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PowFOpAdaptor::PowFOpAdaptor(PowFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PowFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PowFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PowFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowFOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value PowFOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr PowFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult PowFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> PowFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PowFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowFOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value PowFOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange PowFOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PowFOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PowFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PowFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowFOp::result() {
  return *getODSResults(0).begin();
}

void PowFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void PowFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PowFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void PowFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void PowFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult PowFOp::verify() {
  if (failed(PowFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult PowFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(lhsOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void PowFOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.powf";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void PowFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::RsqrtOp definitions
//===----------------------------------------------------------------------===//

RsqrtOpAdaptor::RsqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

RsqrtOpAdaptor::RsqrtOpAdaptor(RsqrtOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange RsqrtOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> RsqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RsqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr RsqrtOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult RsqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> RsqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RsqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RsqrtOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RsqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RsqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOp::result() {
  return *getODSResults(0).begin();
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RsqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult RsqrtOp::verify() {
  if (failed(RsqrtOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult RsqrtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void RsqrtOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.rsqrt";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void RsqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::SinOp definitions
//===----------------------------------------------------------------------===//

SinOpAdaptor::SinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SinOpAdaptor::SinOpAdaptor(SinOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SinOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SinOp::result() {
  return *getODSResults(0).begin();
}

void SinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void SinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void SinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SinOp::verify() {
  if (failed(SinOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult SinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SinOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.sin";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void SinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::SqrtOp definitions
//===----------------------------------------------------------------------===//

SqrtOpAdaptor::SqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SqrtOpAdaptor::SqrtOpAdaptor(SqrtOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SqrtOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SqrtOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SqrtOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SqrtOp::result() {
  return *getODSResults(0).begin();
}

void SqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void SqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void SqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SqrtOp::verify() {
  if (failed(SqrtOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult SqrtOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SqrtOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.sqrt";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void SqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir
namespace mlir {
namespace math {

//===----------------------------------------------------------------------===//
// ::mlir::math::TanhOp definitions
//===----------------------------------------------------------------------===//

TanhOpAdaptor::TanhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TanhOpAdaptor::TanhOpAdaptor(TanhOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TanhOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TanhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TanhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr TanhOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult TanhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> TanhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TanhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TanhOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TanhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TanhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOp::result() {
  return *getODSResults(0).begin();
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(result);
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TanhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult TanhOp::verify() {
  if (failed(TanhOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_MathOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult TanhOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operandRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operandOperands(operandRawOperands);  ::llvm::SMLoc operandOperandsLoc;
  (void)operandOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  operandOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operandRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(operandOperands, resultTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void TanhOp::print(::mlir::OpAsmPrinter &p) {
  p << "math.tanh";
  p << ' ';
  p << operand();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void TanhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace math
} // namespace mlir

#endif  // GET_OP_CLASSES

