/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Interface Declarations                                                     *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

namespace mlir {
namespace linalg {
class ContractionOpInterface;
namespace detail {
struct ContractionOpInterfaceInterfaceTraits {
  struct Concept {
    Value (*lhs)(const Concept *impl, ::mlir::Operation *);
    Value (*rhs)(const Concept *impl, ::mlir::Operation *);
    bool (*isRowMajorMatmul)(const Concept *impl, ::mlir::Operation *);
    bool (*isColumnMajorMatmul)(const Concept *impl, ::mlir::Operation *);
    bool (*isRowMajorBatchMatmul)(const Concept *impl, ::mlir::Operation *);
  };
  template<typename ConcreteOp>
  class Model : public Concept {
  public:
    using Interface = ::mlir::linalg::ContractionOpInterface;
    Model() : Concept{lhs, rhs, isRowMajorMatmul, isColumnMajorMatmul, isRowMajorBatchMatmul} {}

    static inline Value lhs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline Value rhs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool isRowMajorMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool isColumnMajorMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool isRowMajorBatchMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
  };
  template<typename ConcreteOp>
  class FallbackModel : public Concept {
  public:
    using Interface = ::mlir::linalg::ContractionOpInterface;
    FallbackModel() : Concept{lhs, rhs, isRowMajorMatmul, isColumnMajorMatmul, isRowMajorBatchMatmul} {}

    static inline Value lhs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline Value rhs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool isRowMajorMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool isColumnMajorMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool isRowMajorBatchMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
  };
  template<typename ConcreteModel, typename ConcreteOp>
  class ExternalModel : public FallbackModel<ConcreteModel> {
  public:
  };
};template <typename ConcreteOp>
struct ContractionOpInterfaceTrait;

} // end namespace detail
class ContractionOpInterface : public ::mlir::OpInterface<ContractionOpInterface, detail::ContractionOpInterfaceInterfaceTraits> {
public:
  using ::mlir::OpInterface<ContractionOpInterface, detail::ContractionOpInterfaceInterfaceTraits>::OpInterface;
  template <typename ConcreteOp>
  struct Trait : public detail::ContractionOpInterfaceTrait<ConcreteOp> {};
  Value lhs();
  Value rhs();
  bool isRowMajorMatmul();
  bool isColumnMajorMatmul();
  bool isRowMajorBatchMatmul();
};
namespace detail {
  template <typename ConcreteOp>
  struct ContractionOpInterfaceTrait : public ::mlir::OpInterface<ContractionOpInterface, detail::ContractionOpInterfaceInterfaceTraits>::Trait<ConcreteOp> {
    static ::mlir::LogicalResult verifyTrait(::mlir::Operation *op) {
      return detail::verifyContractionInterface(op);
    }
  };
}// namespace detail
template<typename ConcreteOp>
Value detail::ContractionOpInterfaceInterfaceTraits::Model<ConcreteOp>::lhs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOperation()->getOperand(0);
}
template<typename ConcreteOp>
Value detail::ContractionOpInterfaceInterfaceTraits::Model<ConcreteOp>::rhs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOperation()->getOperand(1);
}
template<typename ConcreteOp>
bool detail::ContractionOpInterfaceInterfaceTraits::Model<ConcreteOp>::isRowMajorMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return mlir::isRowMajorMatmul((llvm::cast<ConcreteOp>(tablegen_opaque_val)).indexing_maps());
}
template<typename ConcreteOp>
bool detail::ContractionOpInterfaceInterfaceTraits::Model<ConcreteOp>::isColumnMajorMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return mlir::isColumnMajorMatmul((llvm::cast<ConcreteOp>(tablegen_opaque_val)).indexing_maps());
}
template<typename ConcreteOp>
bool detail::ContractionOpInterfaceInterfaceTraits::Model<ConcreteOp>::isRowMajorBatchMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return mlir::isRowMajorBatchMatmul((llvm::cast<ConcreteOp>(tablegen_opaque_val)).indexing_maps());
}
template<typename ConcreteOp>
Value detail::ContractionOpInterfaceInterfaceTraits::FallbackModel<ConcreteOp>::lhs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->lhs(tablegen_opaque_val);
}
template<typename ConcreteOp>
Value detail::ContractionOpInterfaceInterfaceTraits::FallbackModel<ConcreteOp>::rhs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->rhs(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::ContractionOpInterfaceInterfaceTraits::FallbackModel<ConcreteOp>::isRowMajorMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->isRowMajorMatmul(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::ContractionOpInterfaceInterfaceTraits::FallbackModel<ConcreteOp>::isColumnMajorMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->isColumnMajorMatmul(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::ContractionOpInterfaceInterfaceTraits::FallbackModel<ConcreteOp>::isRowMajorBatchMatmul(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->isRowMajorBatchMatmul(tablegen_opaque_val);
}
} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {
class LinalgOp;
namespace detail {
struct LinalgOpInterfaceTraits {
  struct Concept {
    unsigned (*getNumParallelLoops)(const Concept *impl, ::mlir::Operation *);
    void (*getParallelDims)(const Concept *impl, ::mlir::Operation *, SmallVectorImpl<AffineExpr> &);
    unsigned (*getNumReductionLoops)(const Concept *impl, ::mlir::Operation *);
    void (*getReductionDims)(const Concept *impl, ::mlir::Operation *, SmallVectorImpl<AffineExpr> &);
    unsigned (*getNumWindowLoops)(const Concept *impl, ::mlir::Operation *);
    void (*getWindowDims)(const Concept *impl, ::mlir::Operation *, SmallVectorImpl<AffineExpr> &);
    unsigned (*getNumLoops)(const Concept *impl, ::mlir::Operation *);
    bool (*hasSingleReductionLoop)(const Concept *impl, ::mlir::Operation *);
    ValueRange (*inputs)(const Concept *impl, ::mlir::Operation *);
    int64_t (*getNumInputs)(const Concept *impl, ::mlir::Operation *);
    ValueRange (*outputs)(const Concept *impl, ::mlir::Operation *);
    int64_t (*getNumOutputs)(const Concept *impl, ::mlir::Operation *);
    int64_t (*getNumInputsAndOutputs)(const Concept *impl, ::mlir::Operation *);
    OpOperandVector (*getInputOperands)(const Concept *impl, ::mlir::Operation *);
    OpOperand*(*getInputOperand)(const Concept *impl, ::mlir::Operation *, int64_t);
    OpOperandVector (*getInputBufferOperands)(const Concept *impl, ::mlir::Operation *);
    OpOperandVector (*getInputTensorOperands)(const Concept *impl, ::mlir::Operation *);
    OpOperandVector (*getOutputOperands)(const Concept *impl, ::mlir::Operation *);
    OpOperand*(*getOutputOperand)(const Concept *impl, ::mlir::Operation *, int64_t);
    OpOperandVector (*getOutputBufferOperands)(const Concept *impl, ::mlir::Operation *);
    OpOperandVector (*getOutputTensorOperands)(const Concept *impl, ::mlir::Operation *);
    SmallVector<MemRefType> (*getOutputBufferTypes)(const Concept *impl, ::mlir::Operation *);
    SmallVector<RankedTensorType> (*getOutputTensorTypes)(const Concept *impl, ::mlir::Operation *);
    OpOperandVector (*getInputAndOutputOperands)(const Concept *impl, ::mlir::Operation *);
    bool (*payloadUsesValueFromOperand)(const Concept *impl, ::mlir::Operation *, OpOperand *);
    bool (*isInputTensor)(const Concept *impl, ::mlir::Operation *, OpOperand *);
    bool (*isOutputTensor)(const Concept *impl, ::mlir::Operation *, OpOperand *);
    bool (*isInitTensor)(const Concept *impl, ::mlir::Operation *, OpOperand *);
    int64_t (*getRank)(const Concept *impl, ::mlir::Operation *, OpOperand*);
    ArrayRef<int64_t> (*getShape)(const Concept *impl, ::mlir::Operation *, OpOperand*);
    bool (*isScalar)(const Concept *impl, ::mlir::Operation *, OpOperand*);
    AffineMap (*getTiedIndexingMap)(const Concept *impl, ::mlir::Operation *, OpOperand*);
    OpResult (*getTiedOpResult)(const Concept *impl, ::mlir::Operation *, OpOperand*);
    ArrayAttr (*iterator_types)(const Concept *impl, ::mlir::Operation *);
    bool (*hasDynamicIndexingMaps)(const Concept *impl, ::mlir::Operation *);
    LogicalResult (*verifyIndexingMapRequiredAttributes)(const Concept *impl, ::mlir::Operation *);
    ArrayAttr (*indexing_maps)(const Concept *impl, ::mlir::Operation *);
    SmallVector<AffineMap> (*getIndexingMaps)(const Concept *impl, ::mlir::Operation *);
    bool (*hasDynamicShape)(const Concept *impl, ::mlir::Operation *);
    bool (*hasBufferSemantics)(const Concept *impl, ::mlir::Operation *);
    bool (*hasTensorSemantics)(const Concept *impl, ::mlir::Operation *);
    std::string (*getLibraryCallName)(const Concept *impl, ::mlir::Operation *);
    bool (*hasIndexSemantics)(const Concept *impl, ::mlir::Operation *);
    AffineMap (*getLoopsToShapesMap)(const Concept *impl, ::mlir::Operation *);
    AffineMap (*getShapesToLoopsMap)(const Concept *impl, ::mlir::Operation *);
    std::pair<int64_t, int64_t> (*getResultsPositionInLoopsToShapeMap)(const Concept *impl, ::mlir::Operation *);
    SmallVector<int64_t> (*getStaticShape)(const Concept *impl, ::mlir::Operation *);
    Optional<SmallVector<int64_t, 4>> (*getStaticLoopRanges)(const Concept *impl, ::mlir::Operation *);
    Operation *(*clone)(const Concept *impl, ::mlir::Operation *, OpBuilder &, Location, TypeRange, ValueRange);
    Operation *(*cloneWithMapper)(const Concept *impl, ::mlir::Operation *, OpBuilder &, Location, TypeRange, ValueRange, BlockAndValueMapping &);
    std::function<void(ImplicitLocOpBuilder &, Block &, ValueRange)> (*getRegionBuilder)();
  };
  template<typename ConcreteOp>
  class Model : public Concept {
  public:
    using Interface = ::mlir::linalg::LinalgOp;
    Model() : Concept{getNumParallelLoops, getParallelDims, getNumReductionLoops, getReductionDims, getNumWindowLoops, getWindowDims, getNumLoops, hasSingleReductionLoop, inputs, getNumInputs, outputs, getNumOutputs, getNumInputsAndOutputs, getInputOperands, getInputOperand, getInputBufferOperands, getInputTensorOperands, getOutputOperands, getOutputOperand, getOutputBufferOperands, getOutputTensorOperands, getOutputBufferTypes, getOutputTensorTypes, getInputAndOutputOperands, payloadUsesValueFromOperand, isInputTensor, isOutputTensor, isInitTensor, getRank, getShape, isScalar, getTiedIndexingMap, getTiedOpResult, iterator_types, hasDynamicIndexingMaps, verifyIndexingMapRequiredAttributes, indexing_maps, getIndexingMaps, hasDynamicShape, hasBufferSemantics, hasTensorSemantics, getLibraryCallName, hasIndexSemantics, getLoopsToShapesMap, getShapesToLoopsMap, getResultsPositionInLoopsToShapeMap, getStaticShape, getStaticLoopRanges, clone, cloneWithMapper, getRegionBuilder} {}

    static inline unsigned getNumParallelLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline void getParallelDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res);
    static inline unsigned getNumReductionLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline void getReductionDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res);
    static inline unsigned getNumWindowLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline void getWindowDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res);
    static inline unsigned getNumLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasSingleReductionLoop(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline ValueRange inputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline int64_t getNumInputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline ValueRange outputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline int64_t getNumOutputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline int64_t getNumInputsAndOutputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getInputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperand*getInputOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, int64_t i);
    static inline OpOperandVector getInputBufferOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getInputTensorOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getOutputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperand*getOutputOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, int64_t i);
    static inline OpOperandVector getOutputBufferOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getOutputTensorOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline SmallVector<MemRefType> getOutputBufferTypes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline SmallVector<RankedTensorType> getOutputTensorTypes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getInputAndOutputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool payloadUsesValueFromOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand);
    static inline bool isInputTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand);
    static inline bool isOutputTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand);
    static inline bool isInitTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand);
    static inline int64_t getRank(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline ArrayRef<int64_t> getShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline bool isScalar(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline AffineMap getTiedIndexingMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline OpResult getTiedOpResult(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline ArrayAttr iterator_types(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasDynamicIndexingMaps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline LogicalResult verifyIndexingMapRequiredAttributes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline ArrayAttr indexing_maps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline SmallVector<AffineMap> getIndexingMaps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasDynamicShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasBufferSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasTensorSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline std::string getLibraryCallName(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasIndexSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline AffineMap getLoopsToShapesMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline AffineMap getShapesToLoopsMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline std::pair<int64_t, int64_t> getResultsPositionInLoopsToShapeMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline SmallVector<int64_t> getStaticShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline Optional<SmallVector<int64_t, 4>> getStaticLoopRanges(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline Operation *clone(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands);
    static inline Operation *cloneWithMapper(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands, BlockAndValueMapping & bvm);
    static inline std::function<void(ImplicitLocOpBuilder &, Block &, ValueRange)> getRegionBuilder();
  };
  template<typename ConcreteOp>
  class FallbackModel : public Concept {
  public:
    using Interface = ::mlir::linalg::LinalgOp;
    FallbackModel() : Concept{getNumParallelLoops, getParallelDims, getNumReductionLoops, getReductionDims, getNumWindowLoops, getWindowDims, getNumLoops, hasSingleReductionLoop, inputs, getNumInputs, outputs, getNumOutputs, getNumInputsAndOutputs, getInputOperands, getInputOperand, getInputBufferOperands, getInputTensorOperands, getOutputOperands, getOutputOperand, getOutputBufferOperands, getOutputTensorOperands, getOutputBufferTypes, getOutputTensorTypes, getInputAndOutputOperands, payloadUsesValueFromOperand, isInputTensor, isOutputTensor, isInitTensor, getRank, getShape, isScalar, getTiedIndexingMap, getTiedOpResult, iterator_types, hasDynamicIndexingMaps, verifyIndexingMapRequiredAttributes, indexing_maps, getIndexingMaps, hasDynamicShape, hasBufferSemantics, hasTensorSemantics, getLibraryCallName, hasIndexSemantics, getLoopsToShapesMap, getShapesToLoopsMap, getResultsPositionInLoopsToShapeMap, getStaticShape, getStaticLoopRanges, clone, cloneWithMapper, getRegionBuilder} {}

    static inline unsigned getNumParallelLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline void getParallelDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res);
    static inline unsigned getNumReductionLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline void getReductionDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res);
    static inline unsigned getNumWindowLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline void getWindowDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res);
    static inline unsigned getNumLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasSingleReductionLoop(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline ValueRange inputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline int64_t getNumInputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline ValueRange outputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline int64_t getNumOutputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline int64_t getNumInputsAndOutputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getInputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperand*getInputOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, int64_t i);
    static inline OpOperandVector getInputBufferOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getInputTensorOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getOutputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperand*getOutputOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, int64_t i);
    static inline OpOperandVector getOutputBufferOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getOutputTensorOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline SmallVector<MemRefType> getOutputBufferTypes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline SmallVector<RankedTensorType> getOutputTensorTypes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline OpOperandVector getInputAndOutputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool payloadUsesValueFromOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand);
    static inline bool isInputTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand);
    static inline bool isOutputTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand);
    static inline bool isInitTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand);
    static inline int64_t getRank(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline ArrayRef<int64_t> getShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline bool isScalar(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline AffineMap getTiedIndexingMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline OpResult getTiedOpResult(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand);
    static inline ArrayAttr iterator_types(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasDynamicIndexingMaps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline LogicalResult verifyIndexingMapRequiredAttributes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline ArrayAttr indexing_maps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline SmallVector<AffineMap> getIndexingMaps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasDynamicShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasBufferSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasTensorSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline std::string getLibraryCallName(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline bool hasIndexSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline AffineMap getLoopsToShapesMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline AffineMap getShapesToLoopsMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline std::pair<int64_t, int64_t> getResultsPositionInLoopsToShapeMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline SmallVector<int64_t> getStaticShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline Optional<SmallVector<int64_t, 4>> getStaticLoopRanges(const Concept *impl, ::mlir::Operation *tablegen_opaque_val);
    static inline Operation *clone(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands);
    static inline Operation *cloneWithMapper(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands, BlockAndValueMapping & bvm);
    static inline std::function<void(ImplicitLocOpBuilder &, Block &, ValueRange)> getRegionBuilder();
  };
  template<typename ConcreteModel, typename ConcreteOp>
  class ExternalModel : public FallbackModel<ConcreteModel> {
  public:
    unsigned getNumParallelLoops(::mlir::Operation *tablegen_opaque_val) const;
    void getParallelDims(::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> &res) const;
    unsigned getNumReductionLoops(::mlir::Operation *tablegen_opaque_val) const;
    void getReductionDims(::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> &res) const;
    unsigned getNumWindowLoops(::mlir::Operation *tablegen_opaque_val) const;
    void getWindowDims(::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> &res) const;
    unsigned getNumLoops(::mlir::Operation *tablegen_opaque_val) const;
    bool hasSingleReductionLoop(::mlir::Operation *tablegen_opaque_val) const;
    int64_t getNumInputs(::mlir::Operation *tablegen_opaque_val) const;
    int64_t getNumOutputs(::mlir::Operation *tablegen_opaque_val) const;
    int64_t getNumInputsAndOutputs(::mlir::Operation *tablegen_opaque_val) const;
    OpOperandVector getInputOperands(::mlir::Operation *tablegen_opaque_val) const;
    OpOperand*getInputOperand(::mlir::Operation *tablegen_opaque_val, int64_t i) const;
    OpOperandVector getInputBufferOperands(::mlir::Operation *tablegen_opaque_val) const;
    OpOperandVector getInputTensorOperands(::mlir::Operation *tablegen_opaque_val) const;
    OpOperandVector getOutputOperands(::mlir::Operation *tablegen_opaque_val) const;
    OpOperand*getOutputOperand(::mlir::Operation *tablegen_opaque_val, int64_t i) const;
    OpOperandVector getOutputBufferOperands(::mlir::Operation *tablegen_opaque_val) const;
    OpOperandVector getOutputTensorOperands(::mlir::Operation *tablegen_opaque_val) const;
    SmallVector<MemRefType> getOutputBufferTypes(::mlir::Operation *tablegen_opaque_val) const;
    SmallVector<RankedTensorType> getOutputTensorTypes(::mlir::Operation *tablegen_opaque_val) const;
    OpOperandVector getInputAndOutputOperands(::mlir::Operation *tablegen_opaque_val) const;
    bool payloadUsesValueFromOperand(::mlir::Operation *tablegen_opaque_val, OpOperand *opOperand) const;
    bool isInputTensor(::mlir::Operation *tablegen_opaque_val, OpOperand *opOperand) const;
    bool isOutputTensor(::mlir::Operation *tablegen_opaque_val, OpOperand *opOperand) const;
    bool isInitTensor(::mlir::Operation *tablegen_opaque_val, OpOperand *opOperand) const;
    int64_t getRank(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const;
    ArrayRef<int64_t> getShape(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const;
    bool isScalar(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const;
    AffineMap getTiedIndexingMap(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const;
    OpResult getTiedOpResult(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const;
    ArrayAttr iterator_types(::mlir::Operation *tablegen_opaque_val) const;
    bool hasDynamicIndexingMaps(::mlir::Operation *tablegen_opaque_val) const;
    LogicalResult verifyIndexingMapRequiredAttributes(::mlir::Operation *tablegen_opaque_val) const;
    SmallVector<AffineMap> getIndexingMaps(::mlir::Operation *tablegen_opaque_val) const;
    bool hasDynamicShape(::mlir::Operation *tablegen_opaque_val) const;
    bool hasBufferSemantics(::mlir::Operation *tablegen_opaque_val) const;
    bool hasTensorSemantics(::mlir::Operation *tablegen_opaque_val) const;
    std::string getLibraryCallName(::mlir::Operation *tablegen_opaque_val) const;
    AffineMap getLoopsToShapesMap(::mlir::Operation *tablegen_opaque_val) const;
    AffineMap getShapesToLoopsMap(::mlir::Operation *tablegen_opaque_val) const;
    std::pair<int64_t, int64_t> getResultsPositionInLoopsToShapeMap(::mlir::Operation *tablegen_opaque_val) const;
    SmallVector<int64_t> getStaticShape(::mlir::Operation *tablegen_opaque_val) const;
    Optional<SmallVector<int64_t, 4>> getStaticLoopRanges(::mlir::Operation *tablegen_opaque_val) const;
  };
};template <typename ConcreteOp>
struct LinalgOpTrait;

} // end namespace detail
class LinalgOp : public ::mlir::OpInterface<LinalgOp, detail::LinalgOpInterfaceTraits> {
public:
  using ::mlir::OpInterface<LinalgOp, detail::LinalgOpInterfaceTraits>::OpInterface;
  template <typename ConcreteOp>
  struct Trait : public detail::LinalgOpTrait<ConcreteOp> {};
  unsigned getNumParallelLoops();
  void getParallelDims(SmallVectorImpl<AffineExpr> & res);
  unsigned getNumReductionLoops();
  void getReductionDims(SmallVectorImpl<AffineExpr> & res);
  unsigned getNumWindowLoops();
  void getWindowDims(SmallVectorImpl<AffineExpr> & res);
  unsigned getNumLoops();
  bool hasSingleReductionLoop();
  ValueRange inputs();
  int64_t getNumInputs();
  ValueRange outputs();
  int64_t getNumOutputs();
  int64_t getNumInputsAndOutputs();
  OpOperandVector getInputOperands();
  OpOperand*getInputOperand(int64_t i);
  OpOperandVector getInputBufferOperands();
  OpOperandVector getInputTensorOperands();
  OpOperandVector getOutputOperands();
  OpOperand*getOutputOperand(int64_t i);
  OpOperandVector getOutputBufferOperands();
  OpOperandVector getOutputTensorOperands();
  SmallVector<MemRefType> getOutputBufferTypes();
  SmallVector<RankedTensorType> getOutputTensorTypes();
  OpOperandVector getInputAndOutputOperands();
  bool payloadUsesValueFromOperand(OpOperand * opOperand);
  bool isInputTensor(OpOperand * opOperand);
  bool isOutputTensor(OpOperand * opOperand);
  bool isInitTensor(OpOperand * opOperand);
  int64_t getRank(OpOperand* opOperand);
  ArrayRef<int64_t> getShape(OpOperand* opOperand);
  bool isScalar(OpOperand* opOperand);
  AffineMap getTiedIndexingMap(OpOperand* opOperand);
  OpResult getTiedOpResult(OpOperand* opOperand);
  ArrayAttr iterator_types();
  bool hasDynamicIndexingMaps();
  LogicalResult verifyIndexingMapRequiredAttributes();
  ArrayAttr indexing_maps();
  SmallVector<AffineMap> getIndexingMaps();
  bool hasDynamicShape();
  bool hasBufferSemantics();
  bool hasTensorSemantics();
  std::string getLibraryCallName();
  bool hasIndexSemantics();
  AffineMap getLoopsToShapesMap();
  AffineMap getShapesToLoopsMap();
  std::pair<int64_t, int64_t> getResultsPositionInLoopsToShapeMap();
  SmallVector<int64_t> getStaticShape();
  Optional<SmallVector<int64_t, 4>> getStaticLoopRanges();
  Operation *clone(OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands);
  Operation *cloneWithMapper(OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands, BlockAndValueMapping & bvm);
  std::function<void(ImplicitLocOpBuilder &, Block &, ValueRange)> getRegionBuilder();

    /// Return the flat list of all operand dimension sizes in the order they
    /// appear in the operands.
    SmallVector<Value, 4> createFlatListOfOperandDims(OpBuilder &, Location);

    /// Return the flat list of all operands' static dimension sizes in the
    /// order they appear in the operands. All operand dimension sizes have to
    /// be statically known.
    SmallVector<int64_t, 4> createFlatListOfOperandStaticDims();

    /// Create the loop ranges to materialize the computation over the current
    /// operands. This is done by applying `getShapesToLoopsMap` to
    /// `createFlatListOfOperandDims`.
    SmallVector<Range, 4> createLoopRanges(OpBuilder &b, Location loc);

    /// Compute the static loop sizes necessary to vectorize ôu‡cìüÄŒŒå¦„*©1è†Š‹­„Om"İktyaï7ÆÇÅJùiá]~ÒĞC†/¸Gêù×êqVÿsA=}Öaª5[m ßDI(4ÙB&;ú |ycòZ2äITÉaTtnş¼ïô:ÿis[ÅuaÆÔëYÂÇŠ`ÁÕ’GÌd-Uëp¾œq “´®æ¥4æ3nb‘ˆ!ó˜“|xn|¤ãYËyğõ4ĞEYÂxÏxÈ“
 \~ô?àbÃb%è²æÚ=¡ââSá2ˆNO[†$ÂsiÑlv¦}håvİ3kC}•ñWbüQ~uéúq%PfG^;sáy.½qš¡Ê'vãUÿp%kzD§tzÂã 0‚oñS%¿w4(>hÇ|5¨$)^%¢rTÎÑÉî$k`.ÑÀñ!^^÷(~1BákdıN^9€(©!haceM7ZÖÓ@rÇ×ÜDóDzek½Z½¹0	\K»W`U/(dIu ÔcmëàOM·vâlşP	,ë]¦Ã+õ"{eczj¢;­ï
D-Ù^)$£åô+€fz=§lırˆ®IU,+ò]6õ=ÿm˜11Tå¢ÎNöärtL]¡üeƒÙıt7wÒí;Vİqºd‚¿šÁ1¥j2¢ñzi‡iìúÍ®qÀ‹|¤¼\a7ÑÄÆJõys+ á¡ˆàÀÄ`G–ĞsĞm®_ØÍö›.ŞöDÜômsqY¼…<œàaO+d¡ho —sû^Lvş
Yï[kz­[·õLğ^Òˆk‰"h ªu¢'Ã
d%¶+JUb°TïfèÅ·K`ô7ğRY^`Y¸M“apò€	]º"8ÄE²B$¹¶¢ÀRş6DêhUDd9!$t8ˆ}Ë ëAH9»¦qPBaH—$YÄüÌ£:¬$ËkR°
mz-I˜`}¨W6mc¹f…n¿±cHbòÂfpÁRkÍ~¡9İ~'ÌíU¤¯\$$ï°2İkÂM£\¾pga>]ªA#£B9Ki¦c
F/Qõ\2SõxIÉá'mÄ×L¼îix!GëîB£ğCD÷ {˜àbêpİ)ÁçÛ†¹ZQÄ?4T\ïã4.*xòH¹¤U¿
1)Ó´%ğÆ7ºy r¤OæÜü@Dbi´ òÚso£Ïøä†ÖÍ²`$¿P%s[j¸ ¢ ù¹Çğ£ùß*ïZnFö¥û
fìpÃğàû®¦RN³ôL$_æ\Ôö¤ÃqCX?êë A:ËÎ!ŞÙZ/^ßÌ{wy&ğjÉZ½òB`¡ëçZZõ.ƒf ÆpÍÈr­bÀå4J©ÆEÆÅ[W¯fôÒv¼S€#M<yM^xDôçqˆZf%¡à,ÆŠE2y–ÁAÀ®G,ç¸G3Ğ@ğgo¾e´eaî©˜2Ë÷ Û51‹â¢†¿›-ÊVìx,z<‘Iuv¡í/2=¥*ˆë|¹lt%:}-˜)Ú$?­!x$¿gY9[m=aa)2N±^[XM”=WkÕ·…¡Ö;´R‘·¹?=·;6…zGÌ"ªêJŒ¢ğg£öú–†GIÄ“ikU5™‡nX®¿_("Æ`+$(Gï£ÌÌîVk›å{9ìz×;Õ^K>jñÀÖF÷ød!´Òì/8£ >tñú¡Ğ±}#%˜öa® jòHç$%J¯Ç[tÜ¦¬kÎ€éHè[%¸ÒEª`p·FF"Ì{eş‘†>(¢H‡ºtµ-?µïJüR4½ßµ?E|u}¥•"×”ı	>8‚¥1/—c0ëœ-mû-™UP9? /?4T4ÿ†]´d7õ5|Qö5²!•dE—s$z„ğ­ğ"BíboPÑ®y‰54¦ıelgz,C‹N­Pö~b.lCU'‡ã£T¾°ë1nìŸ-³âûÎºx”"L¯˜¨›æ Xqµ{¦NìT<â=jMJâWÊ®#õ!†T%ì°bSl5¹#óaÄ$˜hr‡wàÚA N|Ğ7šõâƒJVöQ„¦hQU*Ê`¢mQÀ(Ál~ ä;Šª*Ãw7HIqmö´Y[îÇ“-®{géAØ­Û.*owæå­eÍÊÆÖŸ}c'ßob;ßXR½‹3bà›lÑ€Ak_%®£¯%ù›0[+×oOæwŸ´4Ù5‰@ mFjå†×IÅh0]u@e¦'$9£¸¦{x¼/S£hÏŞÄÉf¡áãG,mc5dªik`šT;²±9‰#M…&æ´o8Í!¡ÆÀcâ½v½Ä.f´¢Nº ‚ sÿê§õïTJt(? do1ÌãEÓvä!1©PGÃğÓR€aê
§eıeF}©ôg_­@ÆxÃ° r”ˆ
¢.¥*Ÿ8ig`$wåôx÷
Qkéƒlˆf~IQúiúOª#(‚{ ¡ÜJóAS)(¦	ÃÆëÏnlo5%<p4¼éÑ•¿Ü’œ’¾*"÷òFGAetÖ\M9LRk­?*àm_a0VzCMqgô#àQ[1M&åÃ.åKsî›ÔÑpÀg ×Cä|DÌ5ºà„â,à*hŠ2G:ot$yÎ7è!ûUæí{U"+ªãä§e+Îã‡÷ç
uƒW3håÈ`ÅgÛŠİ*)p¨d=ÏGKâc68Í{Nt	TaD+6ssë
)ÅuéNj8§øh@e‚¸Pc¡"ÜF\Çå¤A8ùììorl†Ü-VÜiG“”îê"9mÏ±~”cÓÄwäáò22rô_Ü>¼ıëëİ0c¿şkºøœ.Öğ>i¸cŠqâQûÕÜnâ,ón—où¾7qøşÚj4rmMp—¦pÑœÀg´M kwßq‰¯„~W{AFuĞ±âa²ÓÇÿå2‹¿ïA~õkÒ0Æ*F¨³ö£¯e½$«ât¾rm%Â^¤!Vi 1/ .°Jün£ğ¨…*"–€r~VşH¢ÏƒyABÀSr:`'iO26Bıšup‡1+I5jóVMR÷}xß’g5ék(.NHT
p¥'ÿ×¨ÿËÑztsHNÁî«ú(Ğøkmì‘_dş8¨4æá;Œ& J	Èïê86“$(„1õ°úåÙúUQÅCbEÓAV7ãEdíì|7Áıfv8d+<JpÏÿŒË5dÁt¥!ÍäF#hı1Q0Çyˆ¿Ü J0çR¦ñì|K6úD{;r^ËÁÏ\íC~ÇO­È¬&&¶pM2å‚’°¢jÑ²^#°¢7C{W÷¿,>5u¤Nqß4eŒ‚$[êæÎÛ¥İHŠwêh›œ$,`5É1ï‚@„T¥]ÌÚm0¬ºù'œÙÚ8ÇaëCaFÇDmD	WŞ'Åy¢àUeN";›Ä„h.c(ş`Â°8%6®$ˆ»zîA)Y*pK:g)&ñĞáÜñùó#áöírõoŠÒâ4NåÑ¤‚8Búg=i»ZCloĞ<´nó‘‰ààQpî+¨X*Ã !İa„ËÅoIÚ¼÷eøSÔ§D"Wnªjs!B`frÿR!¸òû—ã¬uüè'šiŸ°K{b#íX·i… 2nJdf6Ù`koN×©`š‡õ îP%üäü0}†8¦ù?hFKèoâa;ş=ƒ+)èåd³ x[t|cqù¯4 a÷ÙÁ[¥!vÙ+Y—ójcVóô¿‡ïãèÍé­)Xrîd²°ºÊY*„ê:°5K.FÎF…©ºÅ0õDøˆ„Hdvçİf¤]È¬¨£‹N;`‰
`T•¾î „^>	7A{Øhu2NX|Ïão×hdÄO·ùÒîìxË«UieS×,2Ã[çqzràôeÈ¨«{)b"¬€ºkÊ¶X"°¶-à¶%½öÜ­vãoÀ­Óe}`b^r&®Ê «2$ğ0
&«$º7ôÁó6ÖGíõGPŠ-!u¢$wª¸\ÂDÄ®²~¡«õOæAV…nıDIC»J ToNÆÃ†u•â„2&ö<G|Üi?MÙXÕÕtÂ&\Ø?
JÚæ ¼ ›-MAÍâ{îieNU+dã]œY° bkO;Ş¦İøÉ®v”rvÂJ4$ooÆ^zä)ka¨Wå'Äg±vûyÒ»c~ÈùÈá¯SV1M…%à¼M\ªrîTARYÇM¾]ê¡¦À}Ä-p@ ŠxVN p¬+)d'ú!$æ´w9LIVNªr°©ë0Ñ 0(Âv”Ve`ï@vK×- ô¬(™¿rS;SjâAAÅJÃÓiJYªúmµ‚mn-µıÔğw4›Ã2RİVqÿP×-ËêW2
4˜,»O-Û)³j(®5lÍ8+ú`qú:‚–îÅ0Ÿá‘Eg$]|¾£…à(¢,;¾¨jÀlT—çXPašR¨F&`q+|NÒÖÁ?óe¼bõrw#XáûÍIHª¬œ1ñò¨'òÅàs`»/q0ebş‹!ûÆ"º«C„K×drïØ(8-Ö¥{s¨)Y]$€¹¾3)6Åªğ©!À eÔ	eİ`ÑĞj9æ`	Ù<_Ss{RS¤.adäK¬3HDåjil;ğzv!mağeÜ»İt«°XO*Iq"ˆN%ANh!‹ ²2ô*d
¥Ôp4î:ôïeğämqkrYDeE)((Ñ{šæ–øÀ™ÒP_Azo8Æ‚ÿ%ãåyÁÕ
¹ôİÂn°ÛîU”Yê<ªC:ğÍ A3+&òcä|İĞÃÍãîG¡d© &h‘HBaş‚n0§¢E>ôˆ|iG~aªíÿ%ïåŸãó(hÖADÅŞUÑ¦!ëBQ}’7ßîÛìvuŞak[ Eª¿eÎ@ÁüjrØ™#j© %\ø’â—iüd*$¶¸iH)ÖZ$0`FjìT$±b°|MÍ•Ÿü÷~ºşiSYª]};­˜ë£ \ ¹ÿ¨JşMCpàF"3g'Mf<¬có;éÁ²#cd(æMÅJ­~Wşµ³0+¹ÀóZ‚`Â2ê  <N$UCûô6\nAÕÍìqiÖ.íL´ç”¡<ì{nóŒ)ªì5‰"$µá©g”fn>]Ê®â&Pq1:‰öÚ›·Lì1PG&!}¿w.HU8º6KüK(í±Z¹l|y ³Åt~df>ö˜.Œ1”¿;	”vÉcÜ.ëmÖuRg£”sVL\T˜Rpİ «3r˜Îmqq°4,._oWBO±,Œh"¨q O""hP—Y3[ëå=NDóJŒtâ¯^n‹ç@Wç†·NpezH][éO³×/EöõßJHÚuìŞÔ]Ô!ÌY°ºa Ğ ~áBõ«&$û}=U“^S‡šAËş(ã]·ïB‘!Ë$=² ’ ºh!<LWĞ;lõÀ`J2]v`!\ì)íHö/[r_ò0ÌFÖoëm%íñôú`ı–u&2•e¤äÅêıVf½Ï–}~âä¶„hu¢-íU¦ïNîïW÷¤(Æõ6Où”Ô`ïÖÉè,	d„ÛN¤Bo—¦õ' DEõìuFP?;Í´Ğ&VæP»Ìr°§V|œb?ï¤ğU ÷±İ99
Ä
´ˆ®DúÕ¤+*<vjægÇß¾o£½Qm~8N®~A^¬:uät³-$  ·±h+Éå}[q®@LaİÉGÖÉücéşÇCxb™íÉ¦¡uÆŠ•ÓìèRİjDÄc—2Lz:­Í«Qu Äz[2Ü.*Û³vÃÄM@:qUŞåsü€
e¢l¥0Ì0ŠÕwì–Ôœ2F\m	gîa‡}ÏQş´›,}Å¼:&Œ\&·l*-<k\3-Ï±uEcd(ÖÿÍ¶ø`nFTïzFFVÏ¨õº"¡½Â‰!!ÁRÔğ¤,%GaÚ&9½p×¦a=8Âqfºøå´j"$h~å@5®wŠİJxïúzs°Fêfpª¥¢òÇJcèÑI	>›X*,Ös¯\¿;2faæşÖ\7je¨¶G¶Šoêc-suVÙ-&QG,ì¤VÂtH2Â÷(££ÁnY”Tˆ“Ñ¤r¹¦"ä+ºx‡y&"úñˆ+Hy¤`ĞfParE^Á_MÁHkäekø™ê gŞåbO`C}V6bÑoÙbWhñKä²CXfvB3o~gñŞWHlÿs€m—– ²å@lé¢m]ueqxJT\@Ê<`Jú°ÍÉFPçfhF¨Â8(ğoÂÄ!áøK\XŒTÓf©TíÚKÇmC¨Pe Sµˆc¯*ab¡ ¡ ßÈVóå›ªáèá÷ælNÀXk>ò]J+Şn Kw]Öxr’J€21ªjÌĞ(€ósøˆjÄwÑi6šÇ³ÖZœwYDa½^=Ì„'òáI@"Ï°1,Î£¢RŞi½P\uC²¹/¬á±?h°Xb¡Q2ëö"„Jª
"FRÇb±dtÉtLçÆÒgŞwÄAè¶`_/¼MLãEóÊÙ@Í¨,ÈÆq~6È`àİÍ£×6ÑvQkY/\ÅfnùÑntàd²ãSO¬`úGª(e. ĞKhÚšMN<L"ëÀay¨NØHónÖk 	m¼€Q Z94Ãî[)RôÏpòÏİüüú¾e9omšäv.}¹±^™’÷º³â¢æ s€63ùÔş4İT *åoşq©Q’3$n·ùö¯hÇ7ìY{”Õ ? ¦ÇHÍe.*‰ma|ì!?`î×ÄMÂspÜ;Df˜j,B¶ª€`g"®pƒèä®ÕK$BtIdøèÿÔŸ°ïIWÛµ­Šfâ!¦-*ÓAbc»g¿Us/¬« * óDjSåóöw_pm*€5Tlp•)ÕÙ[U±…‚© !ó*
Á—(idÀ`àa ‡Bø`JHùÇJLJ2E`’Dæ£?8ô8QjV@iò%5@g+ı¸c'Cûé€®^.l˜ıÊ
½ñu5ñ½½ªàv5òg>" ğp6j¼ªÂñ!®Ïş-3Í¤IdJhasåbÏ ™FƒëÀj"+‘.åQJ÷ã6`bé"—çÆO2"‘áî«$P¥˜ãÈ¬[;!§`#bç0¡l<s.îq?*G0FÄh¶t|åwI4Ç$uâôÒ?*7!…–ÂKçaŸæÙ{|hnUtÒ'Ô9#ıÔ*îä«}AĞ5<;ğÈé¹šÉMàœ2…£óş÷äÂ(ü¾	–¡Æ î‹ˆ>ãgòV±Ç[[$¤³D1…²¸#bè#¡sÁæî[‘«gPß(E+£$×ıW2ğÊ$t¢2/°a<eet–æäëİP}¬	ğíØv}j7bãôs˜-ü¤:e‰’¸gN8ª}(hêØßæçš|UõÌÂşDùaaqGŞ?3ôVxòà%âª
ŠÎdnä>³I}Á¢#" ˜lÇ}²=yÕ‚{4y;[Øzcv™g•’ (,!Ü²Ôpß¤ç°Xyôí²Q¹-0m®q_õå`s~øy·!{Ì*?@ ¸C¦ÜéS.—
x;i¬ì@qƒ^^aGt)Â©Ìù(›4z,€!'‚*ff{ùÙD{Xg­wËLó*SPA(hrß­1p1)‰Ã¥´¯ÆŒ€€¦[UD!Dİ¡•ÏeZ!2ì ††jáÌr<3
öè7„.’b 'Ãxa¬ø'orM³aWáf¤5'äSB£®;ïA5“bu&o¸8#^Ù¼²9oIƒqŸÎ³a™xA>'w-Ìªãà$u `åâÃúéFª ™$*B¸d}``ìõãmRSìl*¡²&i^â SHOÒÁéiRQfa	›9öUæãoıÿUPÙÜDÔ‹˜³Uz‡ĞCÒÂ7Gu+)~K ®ÈTˆ< MtŒöaœ¢|4t1`°p³²£\ÃcÜ	mQ-¡6 Ñ˜-X¸oå.å=øâ]²=M~cyíYHcq° õØ–R*hD¬Øä™Î”ØQjÕ¡pd>NÏÍC®sÔoØeïËâQàŒ¬ƒÉk(åÌPsƒ.ëEÜxWuëiôÍúsAc„<#Xe¤¬¤òALXeğ+šBt!%fÓ…Up~+Ve»e@jµJİºø“­1dŸn~K24Ä3ÀÇãJ è}C‘4Bö"Æ
¸ââZMw«”}eğÁå¡"øK-cd$6k})ÔøÏÎDiê>çøbqò^¶(˜©–H¢mæpA†sá ¢m}³ƒ…6›ûê¦|…r5Í~®6P'a$ü³(0Ø4zsålce4Se4ÒOãuê7jLcå¢«Ç,Æ³Ş }¬âOü.8Fyr¥÷)§‹r" 8&ojNUÔzf6k1ô±á6/ìW|ûŒ°â…Õg”ñ š/¨¸¤4˜~éqq{›jæe5xàG_DN]'f¹0pup
Ñ©?ÑĞ²ˆdqæGz°Ğhwœu1O0¢&—"$1m˜Ëa„nDbe¤ÚzäOIS‰*Eˆ X 9l-j'aTv:öMbÆÏHB<e{„bÃIF;[;l,‰ ;!‹Ğ‚€Ş1.OÖ¤&âuà®BûÕmİ"ß.Òsñâ$®y˜‹'#",…#hy¤£ZíŠoK¶èŸá½]fNòàê¨d×3à1M½‘:ôc!c\6Èg)¯
Uıe9é¸_„{%84©@à «»JÆ>ˆ%B¤X(U´˜v´»*U’õ`<0[ıj©SP2P­ái³–¿¥2{xúnâ97@^u	âdúá{å{Ü¦D_mS<n÷!îwçÚÔúp¬s¨Ğx1A+‡º®*OLµc°İRÚ¡ĞëG†­äNqEŒ(bî>Š’ÛvÆv5lh(5w$sw9Yçõéê`Ê~`ÚÒ ïLe3]DÖ?tdğLÈkq€}ì5N¥Y:ÿL}Ã:¤p¥ZınúSÇzYcòO<ur9à¤–ç(-ñÎşjÁ D{{:âDR(*Ãağ½æÿm®jma"S„súî}OõøMexNõA¬»à…hW,‡)ÊŸSñ¼HMfC]‰‘eò‹èezm‘$yC	§	!¨Â ,¾©Ë^Í¢D$Áøúrul{mú?g_>W„½óAebM£.Há›|Ù‚C'gÓÌ×ÌØ zñr'd‘Ù
¬+êG&"âL¾CŸ6Ši1¼3²Š@Çşõ(në[âh;jHb'JzÀ"­Û)ñ(/'/Eç«3Ç7÷fFpË™Ø~‚N­åı®Õ½A‰`ğrL;Úûaièc"ˆ``$\ÎÒ`Mœ>Ë/‡fœ}ÿ®Roïq³„ß@õô|ˆÿ•XÄoz¬¼za€unUˆAWc‡IåK¶«`+9ÈÓNølÛf•3L$V-Ôjxõv(ú|nââ(Ÿhã	¥%zY»Ñ(ÆCƒeÑ7Êì`‘i|vªM§åÆJt •´\S9¿v®°à¨ñ@‚²;
Su.¨~àñmöCôÍ	J,ài¤æèkd<u×UV…­|tzDruÚw\¯ g²&0ûÈ]F2ÔìBo¤Nn
€ˆ"+Ïc÷NŸéìq†S5ëÏK²İo¨~6¥–3(]ÏK5œ{uv¬í"¤#¨* ¥#¸%E-
èÁwOÀnşîòí§ÒŞÓer4Y3¥,Ú©¦—„
â½|Ù¾‘G1sfvì©ö{>[ß©Ùc~T‰ù@>5¥ğøbÑq•`Ç Êh3Ù‹£å³¸}î€ô¨KDØü*ª-âUƒ7Ô´ı6¸`mR•‚Q éú6lŞıËœ­;fZzaÔrÀŒ4ÿ",$C7–‘ïè¡)|gtdâákäk*šUß™!£eDsèğWéš'´âªué­dbwøÜ²N)İp£ÌVƒûq0|xº:y`zcnd¨œÏ`4N¢ıF·¶fÚ½.d!®½ùp"„¨Q.Ëì'eß d¦ç}ËÂñvb¸´%Â'M-UCÅáS%Ç†Õc» ÅjãURûYŠ){ÿÑW$l0V­
0¡|`ŠF¼©A)ô(fğå@-Od‹ÉÅ`gøŠb>óëÑtZª¹wEx43ÆWxïd5^“}¤xhg=lnî!áç!î M†k ½¢*Lî¤®# Õd(PHÒ=¨@Cd;¢¹gÆqtOipÍæO§G2q¯tÒ!÷T`hge»Íi(KÇhşPÿçãVÃ$ª÷á\ø;{ùÆ$h0Y!§$³pÙwƒor#e{Ú•õ\ü)V&Âİl Nq€éôCrpÅVß3Å sMò_åâè.Òd$éu,@µix- ˜änt B`!@àñËwàup{wf-ÂÂf™ä5òe–}îN‘ ŸìëEë<¤PaO¡zb.£ ÷6‡1¶\3Šşğ!BÄ¥CB‰Î*£Ú(07{ZPÑgÃHš U0æ AkÑ#oÃßæØmÃİ¾*¬ Kfo‘Dõ)ËàH=~wcıVŸİqOdlN»Kù}íMú%!0Oe‚ f8ñnH(ê!H€Ãb+ †Â-ìœvw7ÇcS¯½fÌ!†®+m1ìÎ
ÁíŒlm"İ~)á+6VÆÕKp}!ır’DCÓ. êé÷kÁ=şù@5-}ge¾YodŸtI*6IC%_'ò}0sêz2ä>é5|nfî¿ ¼ñ!3YÄíe¦©,‰Ô×ïHä×[sd!V€—úy{¾!`± ²  §%3"f€qû˜£l>îm¤SKÇ_åõnÔd[Â¡x÷nD“JGà^õa"Gj `sïš5+¢ I :ˆNRK$$Ns-U$r§0h´V3sRıĞWbõscwøºaoPOF\3sáy^(Qš‹·0 ú`,c>duû„õd<>GoÅ.3%†|-©.1sptNAÉnj`6ñNdñ œÿin¡Fùxg?<,‘ ¹1¡ ë#E5Ww@òB×/ÒDëDzdœ€ Z°ùF8òSaj d)%Äa]aàzm7
|ü@@),»]¤‹*õ"·tbsk¢Ï;ìçNcs^=$€à<*¯¨F~½ã=	ş/Š¦@u$I;5r=>å=-Kˆ±1Tà8nräbüdw±$%ãıu|Âè7Ò`Q2e„µîİF±¥kr¢qR,«j„ ú¢ÌïÑä m¬¾e5UÊÔjızw;(åpPÈÂBì6`$6àÄÏòPÅşz*ÜûLÜôicwI­Ø#Ô`)`3val¨†rÿ)Äç¼rÙëŞkZ-[tõMğ¨cpmÕ>w`ë‹4!¥*VşrqÅf(?m·Ià¨”1°0ÙV`I°D‘cxã P]ó"9Æe’[${ ª@6şbGdëiUDd:#%Í9¨uÊ`ëH;1wûKC@Ÿ(9ĞôÌB;®%Ïï±*/c-IŒ!}(W&-"¹.ñê)±b`rğKâcpÑJi>µ9L2h%é3åU„¡+H,2å¾
 ïB#d qea6İ:	D»åB5[+¼`
f/Sô\`sı8Méa'iNX–\œîc
ëœîB¢	d$B4wâ°bb3htÛkÁÇû2 ™N?1P®]òãt5.#prL¹o¦G»Ü1-Ò°+èÆ7.92¤I¦ô@Ew{° zÓsé*Ïèä;†SínÕ`4¾Y ó#*¹   °±Åòçëß8fÚlwÆ»ıd(ÑpÂğáñ®uVF³4x$å]×öG!cY/jàkaOCN^IZoŞßÌ}÷)®äj¹½ú``}k÷H5~.ƒF n9ôÂs¯jÈEN©Æåæë1{6/bŒp‰v¼Ws#,Á}9M%8GÕêñ‰X`%±BlÆîT%¼2xPSSB§c›ç¼gTÀpe/kåtAaîª6ëç¢Ú0q]Š,b¢†¿,ˆVäi,y4½I7réefc}uc€ût¹lt
 š`(¨Ú7Ó' ­Jg$ögi9ûilyá(0 F`ÜIZLe<CÙ·‡Öª ´R7¹¼47`2zJœÌ &ªîHŒ ñ`eöêÖ†Äc|ÃqiÕ50lx¢½f¢!+.0%ë¥„êVkùÅs»àxÓDB¾“ ÇõÒdb´Rv%<çâ0_Ü¡¸ğ±t)hµf0® nv=sÆ(7ZG•Op×`knÅèšÈ[5ºÀAª ;·d…V#Cn[%w¢e†58*HÄt÷)k©øBéİõ>>|eíá¤ R!´üHj8b¤;S0&§cp¨”)keLÅP)¿  m<Ôeÿ•I d3Õ%^aâ54£—/o {5|«t¢Oé&nTÒ¦iÍ57²í$LcdmcNü\s|r$|@5¤ñáü°h5l®¯%°âûÄ0~—b­Ğ¨Z® 8q5{ä©V¬â-hTâ·X,*ı+„T$’ S(7ğ1uqcä yÃs`Â!8á7Õoƒn^÷–†`Y~ê`"MpÁ(…,> m3O¸{Ãs7d	 Q]ò°Q àc³-¸'éÙıK .gq6çeeÏ“ê¿Ç›}=›oj9Cø6½‹±~åİnahA¯^¡­9–,‚kEp#0[WkM`s®·Á@=- )mDá ¥‚×IÅh8pupc¤'Lpy»`Ækxa/[£iËfDAc!é¦E)r dªioh Ä;²±Z_›wM¡%d´ÌeTÍe©æ@uzµvíÌçr<^]ú° c¹lã¦eçh|j}"DO;G!T£v8ç!12é	ãcPàaæ¥dı¶e}éthİ¸ „qÂ°ip´­µVg'
•xkG 43å|.p+x%g fCmœşYúKî#(°ûtéiÎ[ñ!C- ïAÃ£,L?5	e<tq `í‘Õ™®dò\½	›~.
àòFBAwd´LO8|Sï|"âe^a¸e÷OEs1}0ymôójåO/î›ığX]Dw ÛUm$LN5>à¤OláznÈ0bPo4OyG7à)´\>oÿu*+şápåu)¯û €òï#4*g²láhbÁ.Yªıª)q(ä0W.Eh ",9Í{Ftq@P¢Ì6s1ª["}ÍMu«^84cêd
díTà¥bÙ\®^eğ÷k0-©ì=vZ5	>ü)f³ 7;89F!~¡cQ7¤aøtrÔ~T>ìóïğ]1¾÷/²Ø,Ò¤i^8ãªù Uòõtnâ<ùZÅå¸¾>uxÒ/<óulpqâğXg¬MYovœx‰ĞRF{AkWˆ±¢`2„¡ÿµ2‹?íaU24—l{Ğ9+Dì·ğkE9$*«ë¾=ŞWcmOÄ~eİVi@q/PnÕJılÍ£u "u€4,Vì@bëƒĞ@BğIQ>C`apwVD¿
} †+< j"VmĞõ]h×guyßkn.D\zo'÷¡õ¨ÿ€{lsXnAé«6¸ÒÙ‹u›^Äé¸p´fc$°
Šäª06æh”!u°vuÉğ]YÅc`AàÑAVµàE mÄ6á$¦t,`+_|gbOÿ,J$äa<£!üà2½1Y6g)íX(c0ï[´ñè¼K&]Ûz;p~gÂÏ\í"WşéíÎˆ v'ş`@²ew‚™8Â*ñ2!0"3C{W³n<s5p¤N1Ş /ˆ¢%ZêJªÚ%µ­hw÷Z$.,•Ø±kˆed„K¤[ep®ªù¥¹ÙjxQà«Ëpƒ¯Öd­e	#Üe¼EmãàE^";¹äôt®sèßab|5Bvë-”áÚvît9y:8pG8:g).dáPáÌ°Xs±Ñ&öíP1§ŠÒ¢$.ñEê*8B¨feq1ZGì'Ì: auUàèt oª!JeZÂeœa„[<Èºr-h°—D¨:wudòjs /efb÷r!jşy—c®@ut¸/™m¾ K={
1mx“i9 nväg7ÍsiïkĞ¹`i	ñîP%ü!üp\&p%ø&hVKànâ")ü}7*!.ge‡%p_q|c`ønUHa7ÙÃ¤QfEsÑFqzsVœó¢´0nïièKí¬(xîu†ò5¹jË:„ 90·K®&ŒE'óºİådé‚FH 2³İb ]ˆí|d{`lsSâœ-ÜN:A3!?^˜(}>vLÜÇb}ghaD¾|Â$	=x«©GmEW(2AÛ<š÷sjò6àå}Kˆ®k½`àzoß¶tª±6lâ°%ıÆÙ­\àoĞ­åe`'%^r&&n$ë(à3 ¸&3f7ğEp2VFmsõbĞˆmgV#$uª°TòD×¤ |1«µçÆXV…ıDc)Î V/ÎÇ Ïu%¢„0>=9üi?MñX•ÅtÇ8ÃNØwz\ç(õĞÛ?EaÍë9ï	%„S.dâ]i´£báF—’¦Äé„®|”jv!Â‰4$ogÆZp¬#_K`1Wå4„5¡tÛyŠ²¢rÊùHã-{±M!j¬¡\*2ä^KpYâM>ßî†¥Ğ}V7 p$¨¨xì¤pê=Ÿ/'l$ú!‹êf}9ÌOVÌ(.ºGë4Ñ°|=#‹v”WmâÿBv{Ó1¼ğl(Ó)?qsamà)1ÉJÁQ`Yª~mµ‹ï*1ïôV703#>BÕFqJı÷?«êWt6ºmû9±9-¦5jÅxz*zú"¢†Ò°&á³Eg%Y~¾£•`Iâ<G{¾hjAfUV¯@Q@Ê.N("HÑ)OÔÖÀ3óeôãõwgRÁûíIHû¬3ğò€£X âÅÅs!;-r 
m¢në!ì”Æƒ:»WD{Ã.roPh8œÑ©j()\T­0/Ö-7Eëp gÅ¤1et),UİpÕğj)êà	Y|_WÿasWRi.albk¸"Laj'm:ô~t=(móoÜ¡ñp ;ğpG"k}¦¬NaF` Ê0¦tt`$g|§Ø±,ëß:ôïeğÍm3jR]umxblÕ{›È È/\_Axe2åÿ#+ãyÔ°ôü?‘º±›®ğ”yè4êG(pÀ0`5cµòräĞÓâçãLG!e©'$èÁKFeşr~4ï )>pÌlYtG~>a²¾¥a%ê§meçs8iTAN(LßE¦!I!)–5şnûzve^a[ eŠ·ˆeN2Tğjò|wCb-y~­TüÀ´h]¤h$°hHØ$4`GfU'ÿ!jº~‘M
í—“p¶n¸3^)–—ny:o?¡s`ØP¹ıìjeÿMk`Ğ@29G&_fékåkÙÅ¶ s (kL
©XWş¡’tkñĞà[ÂP†²kS í,n¤tvìT>l| ”Iì1y'4 å]´ç…¹”¬q(ó™iªî}b$,‘éîgTga:_P µo"\1q:	0²ØŸƒ§lL5&}®8.LWxºkíQ,í4¹Mi9á34tg>tn ĞÁÌ1”¿;)³UlËAØ€ªãiVuZcj+”s0l	_|˜RRİ /÷Ÿg´:l2ğ05-&_ã&@l±$ŒHn,s¨cèRhQ¶IhK¼=KDsÄsb¿^n¡æA2t†·dkbr}_kWEµÕ«GôµÕ*ZŠ=¤$ÖîYÔ!¨]°²!âò€µÿJõƒé¢g$r}yRRAÛ<)+¶i

³ C$}¢²$Sòj!0D×ñ3 ñ?àQI˜<v`‹oTi)eH÷/â
ú…5è– zíå'ïóôW*tÖuV7…$e´4àMê¹Dd_½oÏVMfh¶ğ`wUã6íM¤ífjİ0‡¤(tÅ2?ì”p×ÌÄ=	m”œO¤Ff"–d×%§eEuçĞfQ4=?í”]®ææt¾Lc²¯ìŸ`=¿¤U•(åéå>;
D*wˆ¯Lúµ²N-"(=~btsä~?w±½œo6<¤rÀ&(ªqä-³ß4²=0 4µi/ËõL säFÁl@(GVÅ¶|kèØÃIlx‰Oá·¥4F»„Ñ|È]"DÄr›“r\z:ãnÍ«Qu!¤¢¨ .)j36Ë€\B:eQVorì„yêe#|¥0Ü¶Ò÷vî¹ÜÈ4l0	GYoee¦+¥íÏEªôù>UDò:&Œ§§³lVx=$;A3-ïÉôU¢%,Î¿]rú`nF¤-~1
Tìtº áuDÄq%„W ø,+„aÊ4r½dß¤k=¬Rd»je°j%#ai~w`5§Hgâÿxq›è^s°WáWy¨-"ĞÖltàÑK	ñx$®.öó|]·;y7vAõŞF\5($*¢Å€›Zoz+$35OY<2gqF0­$>bv8’ä9õGa©qn	œ0OÅ„³afÙ¬ l«Şxƒ`f¢üõxT;Hq4BrfsinUTÁhMAI+|ì>amüùîøgşabC`K yT6âñsÜhQj {å§@Úzr`€n\nõTue(ÿqEQ¶`hºı$má¢hÕ!Uqx
PhXÖ(GøğÍËBYædlF¦f>it,Äe%ôğkPX0Óæ–)T%Ê{‹ÿc¨P% ÕôŒÄå¶npcåşá2ÿK7ó¤Í®¡m!bæ¨_LĞHkñY(+İl$s_Vùw²^Á:7*nÎ~\cÚíhä¶Q¬6šG¨fØ”{QFg¹Z<Ì†2Òá! "/µU-n¡h6ÜÓ¸^4Aòµ/¤õ!?i:hÊ#aëô0Æn³£ÖcæbGjapué8NÆG+CsŞ·Qè²yß'ıMt iöÊL@i!lÁâq6>hh _Õ·g>åvUkY*mãrIùÑn¾
ç$eóâ#o¼`G «%u.+Ğk`Ò²]O|m*Éà`(:$L
Ø@ótòË%m¿Q` z9Q´aèI)RöopªßÔ0:¼å]i!i›$Ò*})°=˜’ÿ:¡bé·¨sDv3y^ø¼Dtb`eoÎp/ı¨3f~¿-òë8Ã=è]{–Ì#o0¦ãnYmnnÉ!a¯:Œ<7¹7N¶Ä9@qpi;^gm,[ ˆpg&¢x†Id¶Œ•K&!`	ağá6ùÑ1ÍmGR××•¬Šrmx!¦	u(SA/"];'*<¿]s&¤½$
 gF*Se$ ö7E_`e'¢'ôlĞµ#åÑZUX…±)‚©0³r¨FÕ– ytæOè,g·BpiGxƒ¸ Å@`j2Mq@Ö¡¿}ö8Q'zVÌC{v§5qÇí:d7aûéÌŠs.lˆ]h
-0ü%°M½ëh vargŸ áXfr¨£Gó#©ö£Z¤Ydjl!s¡hˆ.±¹FO«ÖDnf##.õ]J×ã?`bé²¦Î}r"‘ıß;1ä	õë‹($R;<!¶L bæ8sl8cflpm
G›FF¦tm¾49íui%$uâTWì-7­…°¨/gaŸ¨EôY|è:fmµ'Ğ9#¿næ©_iP<l9ğéiù%½É}äœG³Ä£¢ŞwDN¢>·*—¥fèä‡‰:ê:¹D¹SY
5æF2%rbı	añsÛÅfìSa¯S9_6u#§4S?òet0#°peid0’ç$ËÏ@+ñ¬Yñïø0ı*7gã4ùŒ-|Œ:w‰–8o^4fñnyêÚÌ®ãì=õÍ@şDıaáqG;¬±ÖDhş@5bª
ªÍ|l%„/²Hlàw—cb˜ &­Æyò=#yÔ–{4ysrşªkvÜo;¡<|!Ì¾ÌpŞ¡çğI{>Ï2Aé-1kæ1^ñ¤`qWøNù·'/NOv=d0_dØ0àQ&—
r7h¬¨WyšNa.S}t)Cé
¹<å6n/Œ©'ş2*Geùİaog­aÀm3(Q`Sxhòï¯3z4±İÁ§$íÆĞ¡¢[Uæ2Õİ¡ì-B#nø`
n¡Œ:<;8êFêŞ7DOôc$/ë}ma‘or:6@Cäf¶u7è{Ğ£ÿ?ÿ+.uekø*+Ù0°)obY€9ßÊ²±}a./ufE<æá'Y–¦`° eâÇücf½Rt¸MhBºt-@`ms«|òRìtñ¶§y6r…UfNùÆùhRqf{(æ=ægb5ß_%Pm €³WÛôæâ7O-?ivA!,L\<aYi äsì¢u4G5n’p³v'XÂk“	MP%£u(q™=<[ke¾ş=˜í`m²5Msşbû@ïY@2ñ&uH–Cjre¿Ø¯.øQ®JÕárg?i®RíCksÒkùuïÊb]`¬¢Óèk8eÎEWa.ªEÌ83w`I´çü:ak <Z,d¨%òEKQeñ!£BPuy=b“éUı~+ÕoÛeHl4[vº«­qDšnzs2Ä3À<‰ëN	ì|+‘´@÷"›öV¸âb2eëƒª‘muuËÄ%(øI#ªpd$h.cq¡”ğšOU)ú>¡çøä1òN¶)9Ø‰5Ìroæpq>;c'¢mñ‘,İõø}×w=å>í1b%ˆ$ıóF~İ4rslgmâ eµco,,ÓkU§iÌ,gå çÃ-D³*q.¢{Oül8f|2¥÷1çÇTGq"¨<OnFGÔzf"1ø·q68nWvó¯Œ´î•ã.Pñ šip¤%šËMiqq{`F`5hæE[^%v¥‘fôa‘ñù&ßlÑ Ñ[ºˆ$pìçx°²(ˆm13‹ç'“ne˜¿«ntj`$Úòä_+ÓÏ
e°ˆ4}´}Leh'y?WfÆâŒÊÌÊ‘bt3¨)CHFa#);l|œ,=1]Ğ‚Î9n‚C›F„&fu0_ìËÔ/Ù ®+ÒSñàdº
û‹'g Ye(»$ª{}_A¼x"Šë-_N&Fúhbø¤t3g1_¼vå)aLÎ'pû‚qìw1é8]Îw-pu¨°Aõaª6³:kM>ˆåK®M u´ˆ|M>ş(,u°s`|'P_Wïê¡SU½\©áI3µ[­3Û;Hêfà;6@O1-àpºå¯Í;Í¦D({,S>fç‰!®/§ØTÿ:=4îøx5AS+‡ø?$*Kfˆ¿s°u5Fª¦Àæ}"­äqE*p"ÿfÂ62fÆ+õmT`85v,ó59sïññ¦`š^pÚÖcíDl3]Œ@ñ?enp\IKa6Àwp5OmM^:_`}C:,rä{enòg xX"ò=]b9b/Pç,=qÆîªbÂ0P{‘zzúLR8lLËiäıfnwO®`m-=…cnÆ}L·úíD(néC$¯ûéiW4€9Ê®6±¾¨mfKu	™Otã‹èèzo‘6+F	&McşÆQ$½![GÍˆ& ığ6ú¿hëmj>'o:W¹³¼Ém"Wf£¦Lİ<¨ªSGwD~ÎX iñxC dQé)n+j‚F6.ÂL>`—6ˆi—ü0²jÂœÇt|)lékè<jHbg_}Ä
=úĞ }¸#5/aï«3¿5÷6fxë›Ñ|ª’H­$Ûë×tA‰¨ğâz;Êûaoè/.ˆJe4OÂãM{:K.çpœ5·¬VËkpY³„ÛOåğ|Kÿ…XK¦+2í¼zá ]=eÈSK¢mtB6«ÂPk9sÈöëd*T2M¢gŸ?¶xõÖ9¼-F¢à(Ÿ [¥uzZ»XhOC!¼W7Jöt± é}wªM¶¤ÊK§ö… ^;gv>òp qPdò3Ct.¨z áóm^cåSÍ	J,ài§æjod(}ÓPtìl}Kd3wœw]m æE¢&8{H|drÔìtNFL@ŒºxK.t&QçÜílûÓe¢A O²Øç*|%£ö3(yMY%-E[%vÌßgàd£¨.%µ2æ¨!E-ŠìK~OĞkîşúo'ÒŞ×!b4m1õdzéo&ÎD¤»^|¾™S“sÇt¶èív›v3CˆÉc6T;xD6´Nƒ°x|jÁi“` a0‡cè©%ì¨ıoÒe,bLø|ªò¥`UÃ·¶¥õtâemZ…?“p íú4l…V}Ê/9R~qäpÆÿ"¬d)i40<9¡(}ed$Âákük¾`ä3!«'ñwàğé%¤ò|‚eé®"uêİ²N	ß#ğ‰øysÜxpø8sZ:Ao¤­œŞèd&bİF·$^Rš$Ì—$½]yÅtb¡vN;Ml-m1S ç#ï}$àÓôä&9¤Dá3M´BuEÁñA#	c¯ Åî£'VoYˆ3òQ%,¼6
 š0 |m2l¨­q)Ô)f²c@i	>g/éÁa'	ø¢`,šá«ÍP^)¨»‰i47îWz§ì,%.?S}æÕ|J'57lt n3µ¯aî*¦3k.ô£2ln„®!İf!PLµÄ¨â
SfzqcæQt/a}ÍÆI½k7EªtØ%÷TcW.s%;…ÍIziO`~i¿ÆêC¤ª—åoú?tÃ}Ôö¾k2o#õ ³ ÙuƒJza1ŠŸ|œDT ~llÕ|$g0€é-ÜW*8TW!E0gK0eèn.Òt$ã} @±?\Mô¹änpGF`(ØàõçŸêx09wea¢Òb»ä1ÒÆ7~F‘dŸÁêgk8 Œt"=Zr3‹õ—!¦ZY3Şt gÅ1KJˆN«ƒø$\5{XSÁotXZ¤tòä! Ñ£oÃíæø+sÕ¾(î$N&oDõ#AÂH¿?gciPUN@$>A#ıì+ê6w1q5&t¸ql.r-h˜Ãh?pÓ-lumOutputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getNumOutputs();
}
template<typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getNumInputsAndOutputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getNumInputsAndOutputs();
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getInputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getInputOperands();
}
template<typename ConcreteOp>
OpOperand*detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getInputOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, int64_t i) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getInputOperand(i);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getInputBufferOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getInputBufferOperands();
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getInputTensorOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getInputTensorOperands();
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getOutputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOutputOperands();
}
template<typename ConcreteOp>
OpOperand*detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getOutputOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, int64_t i) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOutputOperand(i);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getOutputBufferOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOutputBufferOperands();
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getOutputTensorOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOutputTensorOperands();
}
template<typename ConcreteOp>
SmallVector<MemRefType> detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getOutputBufferTypes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOutputBufferTypes();
}
template<typename ConcreteOp>
SmallVector<RankedTensorType> detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getOutputTensorTypes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOutputTensorTypes();
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getInputAndOutputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getInputAndOutputOperands();
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::payloadUsesValueFromOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).payloadUsesValueFromOperand(opOperand);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::isInputTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).isInputTensor(opOperand);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::isOutputTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).isOutputTensor(opOperand);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::isInitTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).isInitTensor(opOperand);
}
template<typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getRank(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getRank(opOperand);
}
template<typename ConcreteOp>
ArrayRef<int64_t> detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getShape(opOperand);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::isScalar(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).isScalar(opOperand);
}
template<typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getTiedIndexingMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getTiedIndexingMap(opOperand);
}
template<typename ConcreteOp>
OpResult detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getTiedOpResult(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getTiedOpResult(opOperand);
}
template<typename ConcreteOp>
ArrayAttr detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::iterator_types(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).iterator_types();
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::hasDynamicIndexingMaps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).hasDynamicIndexingMaps();
}
template<typename ConcreteOp>
LogicalResult detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::verifyIndexingMapRequiredAttributes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).verifyIndexingMapRequiredAttributes();
}
template<typename ConcreteOp>
ArrayAttr detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::indexing_maps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).indexing_maps();
}
template<typename ConcreteOp>
SmallVector<AffineMap> detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getIndexingMaps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getIndexingMaps();
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::hasDynamicShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).hasDynamicShape();
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::hasBufferSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).hasBufferSemantics();
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::hasTensorSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).hasTensorSemantics();
}
template<typename ConcreteOp>
std::string detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getLibraryCallName(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getLibraryCallName();
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::hasIndexSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).hasIndexSemantics();
}
template<typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getLoopsToShapesMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getLoopsToShapesMap();
}
template<typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getShapesToLoopsMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getShapesToLoopsMap();
}
template<typename ConcreteOp>
std::pair<int64_t, int64_t> detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getResultsPositionInLoopsToShapeMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getResultsPositionInLoopsToShapeMap();
}
template<typename ConcreteOp>
SmallVector<int64_t> detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getStaticShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getStaticShape();
}
template<typename ConcreteOp>
Optional<SmallVector<int64_t, 4>> detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getStaticLoopRanges(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getStaticLoopRanges();
}
template<typename ConcreteOp>
Operation *detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::clone(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands) {
  BlockAndValueMapping bvm;
        OperationState state(
          loc, ConcreteOp::getOperationName(), operands, resultTypes,
          (llvm::cast<ConcreteOp>(tablegen_opaque_val))->getAttrs());
        for (Region &r : (llvm::cast<ConcreteOp>(tablegen_opaque_val))->getRegions())
          r.cloneInto(state.addRegion(), bvm);
        return b.createOperation(state);
}
template<typename ConcreteOp>
Operation *detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::cloneWithMapper(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands, BlockAndValueMapping & bvm) {
  OperationState state(
          loc, ConcreteOp::getOperationName(), operands, resultTypes,
          (llvm::cast<ConcreteOp>(tablegen_opaque_val))->getAttrs());
        for (Region &r : (llvm::cast<ConcreteOp>(tablegen_opaque_val))->getRegions())
          r.cloneInto(state.addRegion(), bvm);
        return b.createOperation(state);
}
template<typename ConcreteOp>
std::function<void(ImplicitLocOpBuilder &, Block &, ValueRange)> detail::LinalgOpInterfaceTraits::Model<ConcreteOp>::getRegionBuilder() {
  return ConcreteOp::getRegionBuilder();
}
template<typename ConcreteOp>
unsigned detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getNumParallelLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getNumParallelLoops(tablegen_opaque_val);
}
template<typename ConcreteOp>
void detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getParallelDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res) {
  return static_cast<const ConcreteOp *>(impl)->getParallelDims(tablegen_opaque_val, res);
}
template<typename ConcreteOp>
unsigned detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getNumReductionLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getNumReductionLoops(tablegen_opaque_val);
}
template<typename ConcreteOp>
void detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getReductionDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res) {
  return static_cast<const ConcreteOp *>(impl)->getReductionDims(tablegen_opaque_val, res);
}
template<typename ConcreteOp>
unsigned detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getNumWindowLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getNumWindowLoops(tablegen_opaque_val);
}
template<typename ConcreteOp>
void detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getWindowDims(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> & res) {
  return static_cast<const ConcreteOp *>(impl)->getWindowDims(tablegen_opaque_val, res);
}
template<typename ConcreteOp>
unsigned detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getNumLoops(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getNumLoops(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::hasSingleReductionLoop(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->hasSingleReductionLoop(tablegen_opaque_val);
}
template<typename ConcreteOp>
ValueRange detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::inputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->inputs(tablegen_opaque_val);
}
template<typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getNumInputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getNumInputs(tablegen_opaque_val);
}
template<typename ConcreteOp>
ValueRange detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::outputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->outputs(tablegen_opaque_val);
}
template<typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getNumOutputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getNumOutputs(tablegen_opaque_val);
}
template<typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getNumInputsAndOutputs(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getNumInputsAndOutputs(tablegen_opaque_val);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getInputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getInputOperands(tablegen_opaque_val);
}
template<typename ConcreteOp>
OpOperand*detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getInputOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, int64_t i) {
  return static_cast<const ConcreteOp *>(impl)->getInputOperand(tablegen_opaque_val, i);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getInputBufferOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getInputBufferOperands(tablegen_opaque_val);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getInputTensorOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getInputTensorOperands(tablegen_opaque_val);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getOutputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getOutputOperands(tablegen_opaque_val);
}
template<typename ConcreteOp>
OpOperand*detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getOutputOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, int64_t i) {
  return static_cast<const ConcreteOp *>(impl)->getOutputOperand(tablegen_opaque_val, i);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getOutputBufferOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getOutputBufferOperands(tablegen_opaque_val);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getOutputTensorOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getOutputTensorOperands(tablegen_opaque_val);
}
template<typename ConcreteOp>
SmallVector<MemRefType> detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getOutputBufferTypes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getOutputBufferTypes(tablegen_opaque_val);
}
template<typename ConcreteOp>
SmallVector<RankedTensorType> detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getOutputTensorTypes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getOutputTensorTypes(tablegen_opaque_val);
}
template<typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getInputAndOutputOperands(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getInputAndOutputOperands(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::payloadUsesValueFromOperand(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand) {
  return static_cast<const ConcreteOp *>(impl)->payloadUsesValueFromOperand(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::isInputTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand) {
  return static_cast<const ConcreteOp *>(impl)->isInputTensor(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::isOutputTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand) {
  return static_cast<const ConcreteOp *>(impl)->isOutputTensor(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::isInitTensor(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand * opOperand) {
  return static_cast<const ConcreteOp *>(impl)->isInitTensor(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getRank(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return static_cast<const ConcreteOp *>(impl)->getRank(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
ArrayRef<int64_t> detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return static_cast<const ConcreteOp *>(impl)->getShape(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::isScalar(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return static_cast<const ConcreteOp *>(impl)->isScalar(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getTiedIndexingMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return static_cast<const ConcreteOp *>(impl)->getTiedIndexingMap(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
OpResult detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getTiedOpResult(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpOperand* opOperand) {
  return static_cast<const ConcreteOp *>(impl)->getTiedOpResult(tablegen_opaque_val, opOperand);
}
template<typename ConcreteOp>
ArrayAttr detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::iterator_types(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->iterator_types(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::hasDynamicIndexingMaps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->hasDynamicIndexingMaps(tablegen_opaque_val);
}
template<typename ConcreteOp>
LogicalResult detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::verifyIndexingMapRequiredAttributes(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->verifyIndexingMapRequiredAttributes(tablegen_opaque_val);
}
template<typename ConcreteOp>
ArrayAttr detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::indexing_maps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->indexing_maps(tablegen_opaque_val);
}
template<typename ConcreteOp>
SmallVector<AffineMap> detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getIndexingMaps(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getIndexingMaps(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::hasDynamicShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->hasDynamicShape(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::hasBufferSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->hasBufferSemantics(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::hasTensorSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->hasTensorSemantics(tablegen_opaque_val);
}
template<typename ConcreteOp>
std::string detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getLibraryCallName(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getLibraryCallName(tablegen_opaque_val);
}
template<typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::hasIndexSemantics(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->hasIndexSemantics(tablegen_opaque_val);
}
template<typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getLoopsToShapesMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getLoopsToShapesMap(tablegen_opaque_val);
}
template<typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getShapesToLoopsMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getShapesToLoopsMap(tablegen_opaque_val);
}
template<typename ConcreteOp>
std::pair<int64_t, int64_t> detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getResultsPositionInLoopsToShapeMap(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getResultsPositionInLoopsToShapeMap(tablegen_opaque_val);
}
template<typename ConcreteOp>
SmallVector<int64_t> detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getStaticShape(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getStaticShape(tablegen_opaque_val);
}
template<typename ConcreteOp>
Optional<SmallVector<int64_t, 4>> detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getStaticLoopRanges(const Concept *impl, ::mlir::Operation *tablegen_opaque_val) {
  return static_cast<const ConcreteOp *>(impl)->getStaticLoopRanges(tablegen_opaque_val);
}
template<typename ConcreteOp>
Operation *detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::clone(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands) {
  return static_cast<const ConcreteOp *>(impl)->clone(tablegen_opaque_val, b, loc, resultTypes, operands);
}
template<typename ConcreteOp>
Operation *detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::cloneWithMapper(const Concept *impl, ::mlir::Operation *tablegen_opaque_val, OpBuilder & b, Location loc, TypeRange resultTypes, ValueRange operands, BlockAndValueMapping & bvm) {
  return static_cast<const ConcreteOp *>(impl)->cloneWithMapper(tablegen_opaque_val, b, loc, resultTypes, operands, bvm);
}
template<typename ConcreteOp>
std::function<void(ImplicitLocOpBuilder &, Block &, ValueRange)> detail::LinalgOpInterfaceTraits::FallbackModel<ConcreteOp>::getRegionBuilder() {
  return ConcreteOp::getRegionBuilder();
}
template<typename ConcreteModel, typename ConcreteOp>
unsigned detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getNumParallelLoops(::mlir::Operation *tablegen_opaque_val) const {
return getNumIterators(getParallelIteratorTypeName(),
                               (llvm::cast<ConcreteOp>(tablegen_opaque_val)).iterator_types());
}
template<typename ConcreteModel, typename ConcreteOp>
void detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getParallelDims(::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> &res) const {
return getDimsOfType((llvm::cast<ConcreteOp>(tablegen_opaque_val)), getParallelIteratorTypeName(), res);
}
template<typename ConcreteModel, typename ConcreteOp>
unsigned detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getNumReductionLoops(::mlir::Operation *tablegen_opaque_val) const {
return getNumIterators(getReductionIteratorTypeName(),
                               (llvm::cast<ConcreteOp>(tablegen_opaque_val)).iterator_types());
}
template<typename ConcreteModel, typename ConcreteOp>
void detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getReductionDims(::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> &res) const {
return getDimsOfType((llvm::cast<ConcreteOp>(tablegen_opaque_val)), getReductionIteratorTypeName(), res);
}
template<typename ConcreteModel, typename ConcreteOp>
unsigned detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getNumWindowLoops(::mlir::Operation *tablegen_opaque_val) const {
return getNumIterators(getWindowIteratorTypeName(),
                               (llvm::cast<ConcreteOp>(tablegen_opaque_val)).iterator_types());
}
template<typename ConcreteModel, typename ConcreteOp>
void detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getWindowDims(::mlir::Operation *tablegen_opaque_val, SmallVectorImpl<AffineExpr> &res) const {
return getDimsOfType((llvm::cast<ConcreteOp>(tablegen_opaque_val)).getOperation(), getWindowIteratorTypeName(), res);
}
template<typename ConcreteModel, typename ConcreteOp>
unsigned detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getNumLoops(::mlir::Operation *tablegen_opaque_val) const {
return getNumIterators((llvm::cast<ConcreteOp>(tablegen_opaque_val)).iterator_types());
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::hasSingleReductionLoop(::mlir::Operation *tablegen_opaque_val) const {
auto iters = (llvm::cast<ConcreteOp>(tablegen_opaque_val)).iterator_types();
        return iters.size() == 1 &&
               getNumIterators(getReductionIteratorTypeName(), iters) == 1;
}
template<typename ConcreteModel, typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getNumInputs(::mlir::Operation *tablegen_opaque_val) const {
return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).inputs().size();
}
template<typename ConcreteModel, typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getNumOutputs(::mlir::Operation *tablegen_opaque_val) const {
return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).outputs().size();
}
template<typename ConcreteModel, typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getNumInputsAndOutputs(::mlir::Operation *tablegen_opaque_val) const {
return getNumInputs() + getNumOutputs();
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getInputOperands(::mlir::Operation *tablegen_opaque_val) const {
int64_t numInputs = getNumInputs();
        OpOperandVector result;
        result.reserve(numInputs);
        llvm::transform(
          this->getOperation()->getOpOperands().take_front(numInputs),
          std::back_inserter(result),
          [](OpOperand &opOperand) { return &opOperand; });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperand*detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getInputOperand(::mlir::Operation *tablegen_opaque_val, int64_t i) const {
assert(i >= 0 && i < getNumInputs());
        return &this->getOperation()->getOpOperand(i);
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getInputBufferOperands(::mlir::Operation *tablegen_opaque_val) const {
OpOperandVector result;
        result.reserve(getNumInputs());
        llvm::copy_if(getInputOperands(),
          std::back_inserter(result),
          [](OpOperand *opOperand) {
            return opOperand->get().getType().template isa<MemRefType>();
          });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getInputTensorOperands(::mlir::Operation *tablegen_opaque_val) const {
OpOperandVector result;
        result.reserve(getNumInputs());
        llvm::copy_if(getInputOperands(),
          std::back_inserter(result),
          [](OpOperand *opOperand) {
            return opOperand->get().getType().template isa<RankedTensorType>();
          });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getOutputOperands(::mlir::Operation *tablegen_opaque_val) const {
int64_t numOutputs = getNumOutputs();
        OpOperandVector result;
        result.reserve(numOutputs);
        llvm::transform(
          this->getOperation()->getOpOperands()
            .drop_front(getNumInputs())
            .take_front(numOutputs),
          std::back_inserter(result),
          [](OpOperand &opOperand) { return &opOperand; });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperand*detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getOutputOperand(::mlir::Operation *tablegen_opaque_val, int64_t i) const {
assert(i >= 0 && i < getNumOutputs());
        return &this->getOperation()->getOpOperand(getNumInputs() + i);
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getOutputBufferOperands(::mlir::Operation *tablegen_opaque_val) const {
OpOperandVector result;
        result.reserve(getNumOutputs());
        llvm::copy_if(getOutputOperands(),
          std::back_inserter(result),
          [](OpOperand *opOperand) {
            return opOperand->get().getType().template isa<MemRefType>();
          });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getOutputTensorOperands(::mlir::Operation *tablegen_opaque_val) const {
OpOperandVector result;
        result.reserve(getNumOutputs());
        llvm::copy_if(getOutputOperands(),
          std::back_inserter(result),
          [](OpOperand *opOperand) {
            return opOperand->get().getType().template isa<RankedTensorType>();
          });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
SmallVector<MemRefType> detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getOutputBufferTypes(::mlir::Operation *tablegen_opaque_val) const {
SmallVector<MemRefType> result;
        result.reserve(getNumOutputs());
        llvm::transform(getOutputBufferOperands(),
          std::back_inserter(result),
          [](OpOperand *opOperands) {
            return opOperands->get().getType().cast<MemRefType>();
          });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
SmallVector<RankedTensorType> detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getOutputTensorTypes(::mlir::Operation *tablegen_opaque_val) const {
SmallVector<RankedTensorType> result;
        result.reserve(getNumOutputs());
        llvm::transform(getOutputTensorOperands(),
          std::back_inserter(result),
          [](OpOperand *opOperands) {
            return opOperands->get().getType().cast<RankedTensorType>();
          });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
OpOperandVector detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getInputAndOutputOperands(::mlir::Operation *tablegen_opaque_val) const {
int64_t numInputsAndOutputs = getNumInputsAndOutputs();
        OpOperandVector result;
        result.reserve(numInputsAndOutputs);
        llvm::transform(
          this->getOperation()->getOpOperands()
            .take_front(numInputsAndOutputs),
          std::back_inserter(result),
          [](OpOperand &opOperand) { return &opOperand; });
        return result;
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::payloadUsesValueFromOperand(::mlir::Operation *tablegen_opaque_val, OpOperand *opOperand) const {
unsigned bbArgNumber = opOperand->getOperandNumber();
        // Safeguard against the named linalg ops that are manually defined and
        // that only support buffer semantics: we should not be there.
        // Such ops have an empty regionBuilder and are not constructed with a
        // region for now. In the future they are slated to disappear.
        assert(this->getOperation()->getNumRegions() == 1 && "unexpected "
               "missing region (calling `payloadUsesValueFromOperand` on "
               "manually defined named Linalg op?)");
        Block &block = this->getOperation()->getRegion(0).front();
        // Init tensors have uses.
        return !block.getArgument(bbArgNumber).use_empty();
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::isInputTensor(::mlir::Operation *tablegen_opaque_val, OpOperand *opOperand) const {
if (!opOperand->get().getType().template isa<RankedTensorType>())
          return false;
        if (opOperand->getOperandNumber() < (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getNumInputs())
          return true;
        return false;
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::isOutputTensor(::mlir::Operation *tablegen_opaque_val, OpOperand *opOperand) const {
if (!opOperand->get().getType().template isa<RankedTensorType>())
          return false;
        if (opOperand->getOperandNumber() >= (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getNumInputs())
          return true;
        return false;
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::isInitTensor(::mlir::Operation *tablegen_opaque_val, OpOperand *opOperand) const {
if (!(llvm::cast<ConcreteOp>(tablegen_opaque_val)).isOutputTensor(opOperand))
          return false;
        return payloadUsesValueFromOperand(opOperand);
}
template<typename ConcreteModel, typename ConcreteOp>
int64_t detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getRank(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const {
assert(opOperand->getOwner() == this->getOperation());
        if (auto shapedType =
              opOperand->get().getType().template dyn_cast<ShapedType>())
          return shapedType.getRank();
        return 0;
}
template<typename ConcreteModel, typename ConcreteOp>
ArrayRef<int64_t> detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getShape(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const {
assert(opOperand->getOwner() == this->getOperation());
        if (auto shapedType =
              opOperand->get().getType().template dyn_cast<ShapedType>())
          return shapedType.getShape();
        return {};
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::isScalar(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const {
assert(opOperand->getOwner() == this->getOperation());
        return !opOperand->get().getType().template isa<ShapedType>();
}
template<typename ConcreteModel, typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getTiedIndexingMap(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const {
assert(opOperand->getOwner() == this->getOperation());
        return getIndexingMaps()[opOperand->getOperandNumber()];
}
template<typename ConcreteModel, typename ConcreteOp>
OpResult detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getTiedOpResult(::mlir::Operation *tablegen_opaque_val, OpOperand*opOperand) const {
assert(opOperand->getOwner() == this->getOperation());
        int64_t resultIndex = opOperand->getOperandNumber() - getNumInputs();
        assert(resultIndex >= 0 &&
               resultIndex < this->getOperation()->getNumResults() );
        return this->getOperation()->getResult(resultIndex);
}
template<typename ConcreteModel, typename ConcreteOp>
ArrayAttr detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::iterator_types(::mlir::Operation *tablegen_opaque_val) const {
return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).iterator_types();
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::hasDynamicIndexingMaps(::mlir::Operation *tablegen_opaque_val) const {
return false;
}
template<typename ConcreteModel, typename ConcreteOp>
LogicalResult detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::verifyIndexingMapRequiredAttributes(::mlir::Operation *tablegen_opaque_val) const {
return success();
}
template<typename ConcreteModel, typename ConcreteOp>
SmallVector<AffineMap> detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getIndexingMaps(::mlir::Operation *tablegen_opaque_val) const {
auto range = (llvm::cast<ConcreteOp>(tablegen_opaque_val)).indexing_maps()
          .template getAsValueRange<AffineMapAttr>();
        return {range.begin(), range.end()};
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::hasDynamicShape(::mlir::Operation *tablegen_opaque_val) const {
return llvm::any_of(getStaticShape(), ShapedType::isDynamic);
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::hasBufferSemantics(::mlir::Operation *tablegen_opaque_val) const {
return this->getOperation()->getNumResults() == 0 &&
          llvm::all_of(getInputOperands(), [&](OpOperand *opOperand) {
            return isScalar(opOperand) ||
              opOperand->get().getType().template isa<MemRefType>();
          }) &&
          llvm::all_of(getOutputOperands(), [](OpOperand *opOperand) {
            return opOperand->get().getType().template isa<MemRefType>();
          });
}
template<typename ConcreteModel, typename ConcreteOp>
bool detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::hasTensorSemantics(::mlir::Operation *tablegen_opaque_val) const {
return
          llvm::all_of(getInputOperands(), [&](OpOperand *opOperand) {
            return isScalar(opOperand) ||
              opOperand->get().getType().template isa<RankedTensorType>();
          }) &&
          llvm::all_of(getOutputOperands(), [](OpOperand *opOperand) {
            return opOperand->get().getType().template isa<RankedTensorType>();
          });
}
template<typename ConcreteModel, typename ConcreteOp>
std::string detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getLibraryCallName(::mlir::Operation *tablegen_opaque_val) const {
return (llvm::cast<ConcreteOp>(tablegen_opaque_val)).getLibraryCallName();
}
template<typename ConcreteModel, typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getLoopsToShapesMap(::mlir::Operation *tablegen_opaque_val) const {
auto r = (llvm::cast<ConcreteOp>(tablegen_opaque_val)).indexing_maps().template getAsRange<AffineMapAttr>();
        auto maps = llvm::to_vector<8>(
            llvm::map_range(r, [](AffineMapAttr a) { return a.getValue(); }));
        return concatAffineMaps(maps);
}
template<typename ConcreteModel, typename ConcreteOp>
AffineMap detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getShapesToLoopsMap(::mlir::Operation *tablegen_opaque_val) const {
return inversePermutation(getLoopsToShapesMap());
}
template<typename ConcreteModel, typename ConcreteOp>
std::pair<int64_t, int64_t> detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getResultsPositionInLoopsToShapeMap(::mlir::Operation *tablegen_opaque_val) const {
int64_t inputRankSum = 0;
        int64_t outputRankSum = 0;
        for(OpOperand *input : getInputOperands())
          inputRankSum += getRank(input);
        for(OpOperand *output : getOutputOperands())
          outputRankSum += getRank(output);
        return {inputRankSum, inputRankSum + outputRankSum};
}
template<typename ConcreteModel, typename ConcreteOp>
SmallVector<int64_t> detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getStaticShape(::mlir::Operation *tablegen_opaque_val) const {
SmallVector<int64_t> res;
        for (OpOperand *opOperand : getInputAndOutputOperands())
          llvm::append_range(res, getShape(opOperand));
        return res;
}
template<typename ConcreteModel, typename ConcreteOp>
Optional<SmallVector<int64_t, 4>> detail::LinalgOpInterfaceTraits::ExternalModel<ConcreteModel, ConcreteOp>::getStaticLoopRanges(::mlir::Operation *tablegen_opaque_val) const {
SmallVector<int64_t> viewSizes = getStaticShape();
        AffineMap invertedMap = getShapesToLoopsMap();
        if (!invertedMap)
          return {};
        return invertedMap.compose(viewSizes);
}
} // namespace linalg
} // namespace mlir
