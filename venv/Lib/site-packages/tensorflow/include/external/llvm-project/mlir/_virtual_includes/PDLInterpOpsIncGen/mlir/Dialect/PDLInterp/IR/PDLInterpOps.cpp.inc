/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::pdl_interp::ApplyConstraintOp,
::mlir::pdl_interp::ApplyRewriteOp,
::mlir::pdl_interp::AreEqualOp,
::mlir::pdl_interp::BranchOp,
::mlir::pdl_interp::CheckAttributeOp,
::mlir::pdl_interp::CheckOperandCountOp,
::mlir::pdl_interp::CheckOperationNameOp,
::mlir::pdl_interp::CheckResultCountOp,
::mlir::pdl_interp::CheckTypeOp,
::mlir::pdl_interp::CheckTypesOp,
::mlir::pdl_interp::CreateAttributeOp,
::mlir::pdl_interp::CreateOperationOp,
::mlir::pdl_interp::CreateTypeOp,
::mlir::pdl_interp::CreateTypesOp,
::mlir::pdl_interp::EraseOp,
::mlir::pdl_interp::FinalizeOp,
::mlir::pdl_interp::GetAttributeOp,
::mlir::pdl_interp::GetAttributeTypeOp,
::mlir::pdl_interp::GetDefiningOpOp,
::mlir::pdl_interp::GetOperandOp,
::mlir::pdl_interp::GetOperandsOp,
::mlir::pdl_interp::GetResultOp,
::mlir::pdl_interp::GetResultsOp,
::mlir::pdl_interp::GetValueTypeOp,
::mlir::pdl_interp::InferredTypesOp,
::mlir::pdl_interp::IsNotNullOp,
::mlir::pdl_interp::RecordMatchOp,
::mlir::pdl_interp::ReplaceOp,
::mlir::pdl_interp::SwitchAttributeOp,
::mlir::pdl_interp::SwitchOperandCountOp,
::mlir::pdl_interp::SwitchOperationNameOp,
::mlir::pdl_interp::SwitchResultCountOp,
::mlir::pdl_interp::SwitchTypeOp,
::mlir::pdl_interp::SwitchTypesOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace pdl_interp {
static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::pdl::PDLType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be pdl type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps1(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::pdl::PDLType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be pdl type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps2(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::pdl::AttributeType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be PDL handle to an `mlir::Attribute`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps3(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::pdl::OperationType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be PDL handle to an `mlir::Operation *`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps4(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::pdl::TypeType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be PDL handle to an `mlir::Type`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps5(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::pdl::RangeType>())) && ((type.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>())))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be range of PDL handle to an `mlir::Type` values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps6(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::pdl::ValueType>())) || (((type.isa<::mlir::pdl::RangeType>())) && ((type.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>()))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be single element or range of PDL handle for an `mlir::Value`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps7(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::pdl::AttributeType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be PDL handle to an `mlir::Attribute`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps8(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::pdl::TypeType>())) || (((type.isa<::mlir::pdl::RangeType>())) && ((type.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be single element or range of PDL handle to an `mlir::Type`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps9(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::pdl::ValueType>())) || (((type.isa<::mlir::pdl::RangeType>())) && ((type.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::ValueType>()))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be single element or range of PDL handle for an `mlir::Value`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps10(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::pdl::ValueType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be PDL handle for an `mlir::Value`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps11(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::pdl::TypeType>())) || (((type.isa<::mlir::pdl::RangeType>())) && ((type.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be single element or range of PDL handle to an `mlir::Type`, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_PDLInterpOps12(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::pdl::OperationType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be PDL handle to an `mlir::Operation *`, but got " << type;
  }
  return ::mlir::success();
}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::ApplyConstraintOp definitions
//===----------------------------------------------------------------------===//

ApplyConstraintOpAdaptor::ApplyConstraintOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ApplyConstraintOpAdaptor::ApplyConstraintOpAdaptor(ApplyConstraintOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ApplyConstraintOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ApplyConstraintOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ApplyConstraintOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ApplyConstraintOpAdaptor::args() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr ApplyConstraintOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr ApplyConstraintOpAdaptor::name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr ApplyConstraintOpAdaptor::constParams() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("constParams").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult ApplyConstraintOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_name = odsAttrs.get("name");
  if (!tblgen_name) return emitError(loc, "'pdl_interp.apply_constraint' op ""requires attribute 'name'");
    if (!((tblgen_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'pdl_interp.apply_constraint' op ""attribute 'name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_constParams = odsAttrs.get("constParams");
  if (tblgen_constParams) {
    if (!((tblgen_constParams.isa<::mlir::ArrayAttr>()))) return emitError(loc, "'pdl_interp.apply_constraint' op ""attribute 'constParams' failed to satisfy constraint: array attribute");
  }
  }
  return ::mlir::success();
}

















std::pair<unsigned, unsigned> ApplyConstraintOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ApplyConstraintOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ApplyConstraintOp::args() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange ApplyConstraintOp::argsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ApplyConstraintOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ApplyConstraintOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *ApplyConstraintOp::trueDest() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *ApplyConstraintOp::falseDest() {
  return (*this)->getSuccessor(1);
}

::mlir::StringAttr ApplyConstraintOp::nameAttr() {
  return (*this)->getAttr(nameAttrName()).template cast<::mlir::StringAttr>();
}

::llvm::StringRef ApplyConstraintOp::name() {
  auto attr = nameAttr();
  return attr.getValue();
}

::mlir::ArrayAttr ApplyConstraintOp::constParamsAttr() {
  return (*this)->getAttr(constParamsAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > ApplyConstraintOp::constParams() {
  auto attr = constParamsAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

void ApplyConstraintOp::nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(nameAttrName(), attr);
}

void ApplyConstraintOp::constParamsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(constParamsAttrName(), attr);
}

::mlir::Attribute ApplyConstraintOp::removeConstParamsAttr() {
  return (*this)->removeAttr(constParamsAttrName());
}

void ApplyConstraintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr name, ::mlir::ValueRange args, /*optional*/::mlir::ArrayAttr constParams, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(args);
  odsState.addAttribute(nameAttrName(odsState.name), name);
  if (constParams) {
  odsState.addAttribute(constParamsAttrName(odsState.name), constParams);
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void ApplyConstraintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr name, ::mlir::ValueRange args, /*optional*/::mlir::ArrayAttr constParams, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(args);
  odsState.addAttribute(nameAttrName(odsState.name), name);
  if (constParams) {
  odsState.addAttribute(constParamsAttrName(odsState.name), constParams);
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ApplyConstraintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef name, ::mlir::ValueRange args, /*optional*/::mlir::ArrayAttr constParams, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(args);
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  if (constParams) {
  odsState.addAttribute(constParamsAttrName(odsState.name), constParams);
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void ApplyConstraintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef name, ::mlir::ValueRange args, /*optional*/::mlir::ArrayAttr constParams, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(args);
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  if (constParams) {
  odsState.addAttribute(constParamsAttrName(odsState.name), constParams);
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ApplyConstraintOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ApplyConstraintOp::verify() {
  if (failed(ApplyConstraintOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult ApplyConstraintOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr nameAttr;
  ::mlir::ArrayAttr constParamsAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> argsOperands;
  ::llvm::SMLoc argsOperandsLoc;
  (void)argsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> argsTypes;
  ::llvm::SmallVector<::mlir::Block *, 2> fullSuccessors;

  if (parser.parseAttribute(nameAttr, parser.getBuilder().getType<::mlir::NoneType>(), "name", result.attributes))
    return ::mlir::failure();

  {
    ::mlir::OptionalParseResult parseResult =
      parser.parseOptionalAttribute(constParamsAttr, parser.getBuilder().getType<::mlir::NoneType>(), "constParams", result.attributes);
    if (parseResult.hasValue() && failed(*parseResult))
      return ::mlir::failure();
  }
  if (constParamsAttr) {
  }
  if (parser.parseLParen())
    return ::mlir::failure();

  argsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(argsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(argsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      fullSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        fullSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.resolveOperands(argsOperands, argsTypes, argsOperandsLoc, result.operands))
    return ::mlir::failure();
  result.addSuccessors(fullSuccessors);
  return ::mlir::success();
}

void ApplyConstraintOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.apply_constraint";
  p << ' ';
  p.printAttributeWithoutType(nameAttr());
  if ((*this)->getAttr("constParams")) {
  p << ' ';
  p.printAttributeWithoutType(constParamsAttr());
  }
  p << "(";
  p << args();
  p << ' ' << ":";
  p << ' ';
  p << args().getTypes();
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"name", "constParams"});
  p << ' ' << "->";
  p << ' ';
  ::llvm::interleaveComma(getOperation()->getSuccessors(), p);
}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::ApplyRewriteOp definitions
//===----------------------------------------------------------------------===//

ApplyRewriteOpAdaptor::ApplyRewriteOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ApplyRewriteOpAdaptor::ApplyRewriteOpAdaptor(ApplyRewriteOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ApplyRewriteOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ApplyRewriteOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ApplyRewriteOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ApplyRewriteOpAdaptor::args() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr ApplyRewriteOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr ApplyRewriteOpAdaptor::name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr ApplyRewriteOpAdaptor::constParams() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("constParams").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult ApplyRewriteOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_name = odsAttrs.get("name");
  if (!tblgen_name) return emitError(loc, "'pdl_interp.apply_rewrite' op ""requires attribute 'name'");
    if (!((tblgen_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'pdl_interp.apply_rewrite' op ""attribute 'name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_constParams = odsAttrs.get("constParams");
  if (tblgen_constParams) {
    if (!((tblgen_constParams.isa<::mlir::ArrayAttr>()))) return emitError(loc, "'pdl_interp.apply_rewrite' op ""attribute 'constParams' failed to satisfy constraint: array attribute");
  }
  }
  return ::mlir::success();
}

















std::pair<unsigned, unsigned> ApplyRewriteOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ApplyRewriteOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ApplyRewriteOp::args() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange ApplyRewriteOp::argsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ApplyRewriteOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ApplyRewriteOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ApplyRewriteOp::results() {
  return getODSResults(0);
}

::mlir::StringAttr ApplyRewriteOp::nameAttr() {
  return (*this)->getAttr(nameAttrName()).template cast<::mlir::StringAttr>();
}

::llvm::StringRef ApplyRewriteOp::name() {
  auto attr = nameAttr();
  return attr.getValue();
}

::mlir::ArrayAttr ApplyRewriteOp::constParamsAttr() {
  return (*this)->getAttr(constParamsAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > ApplyRewriteOp::constParams() {
  auto attr = constParamsAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

void ApplyRewriteOp::nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(nameAttrName(), attr);
}

void ApplyRewriteOp::constParamsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(constParamsAttrName(), attr);
}

::mlir::Attribute ApplyRewriteOp::removeConstParamsAttr() {
  return (*this)->removeAttr(constParamsAttrName());
}

void ApplyRewriteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::StringAttr name, ::mlir::ValueRange args, /*optional*/::mlir::ArrayAttr constParams) {
  odsState.addOperands(args);
  odsState.addAttribute(nameAttrName(odsState.name), name);
  if (constParams) {
  odsState.addAttribute(constParamsAttrName(odsState.name), constParams);
  }
  odsState.addTypes(results);
}

void ApplyRewriteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::llvm::StringRef name, ::mlir::ValueRange args, /*optional*/::mlir::ArrayAttr constParams) {
  odsState.addOperands(args);
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  if (constParams) {
  odsState.addAttribute(constParamsAttrName(odsState.name), constParams);
  }
  odsState.addTypes(results);
}

void ApplyRewriteOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ApplyRewriteOp::verify() {
  if (failed(ApplyRewriteOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult ApplyRewriteOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr nameAttr;
  ::mlir::ArrayAttr constParamsAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> argsOperands;
  ::llvm::SMLoc argsOperandsLoc;
  (void)argsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> argsTypes;
  ::mlir::SmallVector<::mlir::Type, 1> resultsTypes;

  if (parser.parseAttribute(nameAttr, parser.getBuilder().getType<::mlir::NoneType>(), "name", result.attributes))
    return ::mlir::failure();

  {
    ::mlir::OptionalParseResult parseResult =
      parser.parseOptionalAttribute(constParamsAttr, parser.getBuilder().getType<::mlir::NoneType>(), "constParams", result.attributes);
    if (parseResult.hasValue() && failed(*parseResult))
      return ::mlir::failure();
  }
  if (constParamsAttr) {
  }
  if (succeeded(parser.parseOptionalLParen())) {

  argsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(argsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(argsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (succeeded(parser.parseOptionalColon())) {

  if (parser.parseTypeList(resultsTypes))
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addTypes(resultsTypes);
  if (parser.resolveOperands(argsOperands, argsTypes, argsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ApplyRewriteOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.apply_rewrite";
  p << ' ';
  p.printAttributeWithoutType(nameAttr());
  if ((*this)->getAttr("constParams")) {
  p << ' ';
  p.printAttributeWithoutType(constParamsAttr());
  }
  if (!args().empty()) {
  p << "(";
  p << args();
  p << ' ' << ":";
  p << ' ';
  p << args().getTypes();
  p << ")";
  }
  if (!results().empty()) {
  p << ' ' << ":";
  p << ' ';
  p << results().getTypes();
  }
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"name", "constParams"});
}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::AreEqualOp definitions
//===----------------------------------------------------------------------===//

AreEqualOpAdaptor::AreEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AreEqualOpAdaptor::AreEqualOpAdaptor(AreEqualOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AreEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AreEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AreEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AreEqualOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AreEqualOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AreEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AreEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AreEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AreEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AreEqualOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AreEqualOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AreEqualOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AreEqualOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AreEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AreEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *AreEqualOp::trueDest() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *AreEqualOp::falseDest() {
  return (*this)->getSuccessor(1);
}

void AreEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void AreEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AreEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AreEqualOp::verify() {
  if (failed(AreEqualOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult AreEqualOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);
  ::llvm::SmallVector<::mlir::Block *, 2> fullSuccessors;
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      fullSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        fullSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.resolveOperands(allOperands, ::llvm::concat<const Type>(::llvm::ArrayRef<::mlir::Type>(lhsTypes), ::llvm::ArrayRef<::mlir::Type>(lhsTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  result.addSuccessors(fullSuccessors);
  return ::mlir::success();
}

void AreEqualOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.are_equal";
  p << ' ';
  p << getOperation()->getOperands();
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << "->";
  p << ' ';
  ::llvm::interleaveComma(getOperation()->getSuccessors(), p);
}

void AreEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::BranchOp definitions
//===----------------------------------------------------------------------===//

BranchOpAdaptor::BranchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BranchOpAdaptor::BranchOpAdaptor(BranchOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BranchOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BranchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BranchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr BranchOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BranchOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> BranchOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BranchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> BranchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BranchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *BranchOp::dest() {
  return (*this)->getSuccessor(0);
}

void BranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Block *dest) {
  odsState.addSuccessors(dest);
}

void BranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Block *dest) {
  odsState.addSuccessors(dest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BranchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BranchOp::verify() {
  if (failed(BranchOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult BranchOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Block *destSuccessor = nullptr;

  if (parser.parseSuccessor(destSuccessor))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  result.addSuccessors(destSuccessor);
  return ::mlir::success();
}

void BranchOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.branch";
  p << ' ';
  p << dest();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void BranchOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::CheckAttributeOp definitions
//===----------------------------------------------------------------------===//

CheckAttributeOpAdaptor::CheckAttributeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CheckAttributeOpAdaptor::CheckAttributeOpAdaptor(CheckAttributeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CheckAttributeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CheckAttributeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CheckAttributeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckAttributeOpAdaptor::attribute() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CheckAttributeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::Attribute CheckAttributeOpAdaptor::constantValue() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::Attribute attr = odsAttrs.get("constantValue").cast<::mlir::Attribute>();
  return attr;
}

::mlir::LogicalResult CheckAttributeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_constantValue = odsAttrs.get("constantValue");
  if (!tblgen_constantValue) return emitError(loc, "'pdl_interp.check_attribute' op ""requires attribute 'constantValue'");
    if (!((true))) return emitError(loc, "'pdl_interp.check_attribute' op ""attribute 'constantValue' failed to satisfy constraint: any attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CheckAttributeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CheckAttributeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckAttributeOp::attribute() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CheckAttributeOp::attributeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CheckAttributeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CheckAttributeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *CheckAttributeOp::trueDest() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *CheckAttributeOp::falseDest() {
  return (*this)->getSuccessor(1);
}

::mlir::Attribute CheckAttributeOp::constantValueAttr() {
  return (*this)->getAttr(constantValueAttrName()).template cast<::mlir::Attribute>();
}

::mlir::Attribute CheckAttributeOp::constantValue() {
  auto attr = constantValueAttr();
  return attr;
}

void CheckAttributeOp::constantValueAttr(::mlir::Attribute attr) {
  (*this)->setAttr(constantValueAttrName(), attr);
}

void CheckAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value attribute, ::mlir::Attribute constantValue, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(attribute);
  odsState.addAttribute(constantValueAttrName(odsState.name), constantValue);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CheckAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value attribute, ::mlir::Attribute constantValue, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(attribute);
  odsState.addAttribute(constantValueAttrName(odsState.name), constantValue);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckAttributeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CheckAttributeOp::verify() {
  if (failed(CheckAttributeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult CheckAttributeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType attributeRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> attributeOperands(attributeRawOperands);  ::llvm::SMLoc attributeOperandsLoc;
  (void)attributeOperandsLoc;
  ::mlir::Attribute constantValueAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> fullSuccessors;

  attributeOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(attributeRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("is"))
    return ::mlir::failure();

  if (parser.parseAttribute(constantValueAttr, "constantValue", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      fullSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while©CzúaÛËo∑S'@ÂÎ≥”5Û6Vr ”Õn¬íJ≠§ŸÓWÌAâ†‡#	+ {a/Ë" ,àh%$<™bWaMP:»*ápåøÆCÀÎpù3Ñ€u·Ù‹âœïh¶+(®¨zaƒU:nà°OáÕÒB∂c¡X+yI“π\€™ï0	 õï6|ıWiº=á¢‡ ª(NÛû`-ÂUj[£—h√S√<ë7ä¨0± ·}w™Eß$¬[ÅÚ E∞;ævÆb‡∏PÜÚ;Ctn z‰‡i¬BÂYÕI,‡(‰ÊC`ob<E«PB•å\tG;w¢ g]˚°f¢&h˚Ë\RrtÏpOv»Ã≤kQ€AˆXèΩ¨ÎÇÛ%"À2KÚ›Á™|'°÷/l[œIu›qddå›‚‰"Èj]Â£° A-BÓÉ3GO—jn~hÌ·¬|◊pr0I1•‡⁄Â^ˆ«dÑ~„|ŸøÅs¡r ¯Ìˆ>Kãöõc.TŸ˘dr,ŒÉ∞˝bëiï`“@ }èrÿÀÂıì´ÌÔ“ÙÓKQ Ë¸ÍÆØ‚uÉ7’u˝vÒÂmZï7◊U$Ô˙4hçﬁÏAú≠;rZz!ƒrfâˇÇ]¨4/C_ñêÁ®•h}Ad4b·*ÙOéPè2Ÿa£'–a∫–WÈü„¥ÚÆ"aÈÌÇ"g¸›ÛB)ˇ0£àâ™y:¸p∫pypzcn<®TﬁË$fÊ›Fø≤~⁄R…
$œ&ØΩ∞Ã`∂Ñ-@N?å¨-aè§#Áfx$À”ıÊdπ±í3]†<CCè±S&óàÑc˙ ≈Œ#%ñÔä<z;; C%l<V*Èö0»|läDËmQi–+g˛ı`)Æ_GãÈ’a'xã°?õ‚â—PJÈ∏;âyvwÓWnÌ‰5\¬y§’x
"µWmIUÆ55ÓaÓ`&
*.Ω£:NÍÑØc’diPlß”â®√FöSg:ê˝c∆Qti]ùé
!C7u´wí%ß\aW.&ªâ…I8 ó‡˛IøÊÍ
√§™∑·O¸/:¬˘÷∆=h4[c∑ ≥ ‹√är3aq
∑pú\Y0Vf«‹|%OrÅÎˆW*eõPã!≈0sI≤+‡™Ó.√t$„alAï?\K‡ÂntGD¢8“‡UÀüÂu0;%v)ÇVg¯§1Ûç«%ÓNëÂõC˙GÔxÑ:]z2£ˆv◊!∂ZX3éﬁ CÃ•CR»Œ≥≥ÿ,T'?z[—n√Rö U‚ˆkUÊn¡ﬂÙÿ*√’æ(≠ß^6kêdıjÀC\?wc≠>è›L,8ÎAπ˘Ì˙tß1u=é`g⁄ÒL$Í/Hà”j+rÇSmÏúÏ3ácÿØçº‘å·‘kÈqËÎäIÈOm"Ìot,·Ø6÷G’RË·Ÿ~“Gñ.j˝óœW=ˇøA=n=ñeª5/$è@I(6›E&;˛<-c†2Â-FÌ%p'æç¨ã¥>˚)3_Âmm‘©âáıØ¡C&)U ˙y˚úpdÆÊ§4C¢Òà1Û∏á|oÓhßÛiÀ]Âı$‰EQ√my›xÃÚKJ§_ı‡"á"$i≤Ô -£f‚·,àNOÜ∆e-ùÅ,g•<,•$ç3kCÌïq«b¸Q~ux.a%CrG;qÂyNº]ü•èµvÒΩ˚d$k:F¢eÎáÒ†tíen≈óÔ3$~&¬t5©$:F£pDŒ¡yÓTcj.S¡E _ﬁÛl~∞F·ne¯6\=ë8∫°Ëı#SI5_á√1Ql««Ñ ˚Dye	›ÄZ˝s\CªSqQ*8döIt‰s}È`M∑˙x∫û@jI,Î_Ê√/ı"wub{jsœ+†k
/=”^<eÇÂº?áÄv{-ß=}/äÓ`U {s0ı=ˇcà∏0GÂ≤ﬁOÚ·b~ \Òº-√˝˝l7{“®÷›S˚≈ƒJˇûﬂ—|Âkb¢4·Ziciå˙éŒÆ”D¨,,ºe4¡Í∆J˝xw0)·Òƒ»“DÓ`G¸—Ñm™WÿÂÊTkÕˆL‹Ùmcs9µÖ‹‘‰9O3dc›ÏwaÜv˚~«ˆ¥NŸÎ⁄kZÌ[¢µL‡
àk…4}’æu£WÉè6#ß FTb@CJnËo¡≤K‡∏è7 CyVbI0M≥asÛåX]æ"yDEêKjj≠ ∂`V~;D™i]Day#$â<àx»`kÖH{+ı˚KQBaPádÄÏÃÊ:œpŒkV0/z/L m∏U2mg©Y&Ö"ª±b`rúv¬be≈Ç[y›vµ~$›~ÕSÌDÑô´SX$$Ô∂"?çÁ¬ £Uæsgc.›˛I„¶`i[mægF.Sı\bUı8II·faÌZñæÓalESœîÊc„H‰(DBTH˜Êo	‰s∫uŸ{¡ÁﬂÜ°^TÑ/5)äY´£d.zp‚)H˘N‰W˚*1≠”†5J¬7æ=z‰J¶ú¸AEr€Ù$Ú”sË£gÈ‰ÑíÕ≤Te4ø[$”[*∏!¢ ˝qü˙Á·ﬁ;Ô⁄^W∆µÏ
f®’tC·˚ß‚,Rn≥µX  È’ˆ"«cXoÍ` @oÍŒﬁIZ/~œƒ{Á9¶kÕ
πÓBaÒÔvïZ7*nÉdU†ŒxÕ+r•‚JÂPKË∆D∆CKøf%“v¨WTÑ#L…}=LN<D≈Ôiâf••Al∆ÀDE‘&zêSÙ©k∫£¨B–Ä');Â‡an©y∂j∑"€0pE⁄L‚‚«øõ.ÓGÏ9,-<¸I7vÂËGfl•k»{W|πçlte`(î	⁄8`?Õ—•)âL^,øcI©Àkmqal03FÄ˛ÄCHM–5Fa≈uW™ïRA˜π¸∑R+2≈rFDÃo™¨J®Ú¯g6≤Ù™÷ÜÊ	.á{{’$álX¢æk,Ñ"0É *,,A^©ßõ‹ÔV+õ»˘ÈzW;‘HKÍÛÜ«FÛ˙d p“ﬂ+5-g·rpr„~§ö‘Ò|8‹ı…Êp™‡kˆ?[Ê`7ZØ◊±I`ú«¨kŒ¡Ëö»Q5∫”AÍ 9∑FÑFcBﬁ{e˚Äé?8¢hñXR|µ	n5ÔJ˙R˘ˇ•#@}uÔ°§"RJƒ¸Jzº¬Ù”0ìgwzú!Mq˚lâ≈-r8∂@;$‘t>∆@ıd3‘$~ˆûF%Ê£—$ó2$kì‡;Ù¶OÌboD“ÆiÕ/uL¢ÌeÃed<CãK∏\ñ b>|Dtás£˛±‚UÓÆû•Û‚˙B∫ógøô‰÷‚!#Xqµ*¢¨T¨‡(+
‚ó⁄,"ˇ!§TÆ≤cc|7î±s·a‰2∫hás·ÍA4Œ—wäu„#ZˆÑÜ(. b2MQ¿)Ö,u>‰;œªk„g7K#T}“ıyH[‡Éi8{'πi˝K*,kq£ÊÌeÕ”⁄ºáåKc#€gcaÀÿRØè±r≈õn—àA/N§OççÓ÷ÔiÈÏ˚0[◊ooLˆcøg¥¥ŸU]â@-%Gb§Ç≈#(8YePp$&Ld9€ÍFzyº.[¢h÷Œƒ…k°ÎÊ˜-}r0d™in(™≈?≥ÒC[ÅclÑ'‚3Ãe(Ã!5§ﬂAW‚5vÌ@Ôf¥∫}∫∏≤•c˘\´¶ÂÔe|hu†FO!ÕÛD“vÁ>0iT•I7√X¬ê3CÓµ`˝üo}Èdw◊ΩQáq“†Â@î°√g^§?≠
ﬂ}iV`$3Â§yÔQkπÉ-çvËNiò˛Y˙KÆ
2(ñÎTÒXœNÛki*§i¬ã™.@jeMu<p1 ÏE”’ôæTÜ~≈ÇˇoÛÙFrAÁdá\(\GÔ¸0*#)^`∞VIa3¸/†Y
2M'Ù[/aksÔ˙‘P`=ƒoaÛSÁ|LÃ%˛‚ÑÆl‡*‹¿0CS44zŒ6Ë	˚[ÊM˚t2+∫Ó§Ôu+œ˜ÇÑÛg
4ÉS&iÒ…r≈.œ™‹‰8q®Ùx’EIM„"&=Õ+N4!@.ç03!™BÈLUw©_z}ÁÏl-@eŒú°k€ä^’‰ÁB`˝yº?&9áû)ú!9î≥Í"<+ﬂèµ~Öc≥—≥‰§Û2n≈R›>¨ˇÌ˚›0æ˜?æ∏-.vÙmZ∏Â™˘‡U˚E‘l‚?ÛJñÁÈ˛:u˘˛ +!Úu,rñX¶P‘ùZgæMKotüpââêR FoAFSê:¢l≤Ü«ˇµè˜Í]û:óoy÷yÊk@®/˚ìØEΩ$+Û41å3)IBZƒ›R`Eu/Tn’Z˝n»£ıÈ*.6÷¿4oD˛`¶ﬂÉ¸B¿Ú[U>A6iÄwUWáF˛ûu ¶1+$q`≤V¬˜]m8ÉGuÒﬂro (lNLn
rÂ'ˇÅ◊®ˇQ{MsqNSÎÎ∏í ÷Zk√ÌôZeÔ;Ï¥Á„;-&ÚNåÓÍ0tì∂h1t∞˛ÂÈ˙]êHƒCE¿–AqR«„D$Ï¸W7a˝6v$ ;lJtœzå⁄4`Å§µq›†lm%}s«˝Ógÿ4J0˜{∂¯ºO]—~;2^À÷œ|Ì
G|«≠ ¨D6cˆ@£µsÇΩBj¿∂Z'Ò£oG{w∑æ<;Gyt§N1”4-ÄvÇ%ZË≥*ﬂ%úçhöwÎ^€|$geÿÒÔaA¥TÑK¨ﬁl1˝®∏ß‹Ÿ⁄pì∫o«pÇç÷BΩ(	]'⁄≈}£‚U)_f{ù˚¿¸x*rÍﬁ$¬íx4Btæ-çñ˚⁄VnU)]k{O:g)&G—··Ã0¯Û≤W¶Ìpıˆ R„fNÒ’*É8G™fÖ]ÎxFÏ/\>¨z‰ë‡È@ ˛Ø†C!X√"dŸ!Ñ€˝~»Àç˜m¯1‘óD™	W|ªnwE! "rˇR ∏~˚≤„Æt˝xg)æ±Kç{s2˝}óAÖ˘r*^‰f?›skÎJ“©bäé ≈ÆX°·|t|ñP°˘o,KËnÊ +ˆ=á,C)®Âå%∂x[s}Gp¸jE`∑›J•afŸ#Uá‚*sV¨Û`æ áÔ„ÈÈm¨m\|˛tƒ≤ı_ª i*ƒÍ;∑N•,Fçπ∫‘RıD¸ÄƒHd2Ê≈f)§uàm¨Éèf;zànkG∫UÎ‹Ñ^:)?;∏it2nLﬁ«‚{s◊ a‰˛¯FÓ)x¯À´AM]D”*<2«€ö˜qzRT`˜tÿà;{ybçƒ∫k⁄∂\™±4)‡¶$˝∆‹/rfzû‘≠√e}`Ö%^tv.Œ$´0d‚p&:6∑‡eÚ2÷/FÌH˘CRÀm%!≤†w*∏e“E–é≤|Ò7µ2O∆ARÖ˝NIG˚«‡ZOŒÜ´ñwçêÊÑ2f¶=F=‹i?hâXïıtGv„\ÿ>CZúÁ)¯–€Ω	£:†Í)%c.fÊ‹òk¥Âbl_áﬁ%›%˝àÓ|Öov:¬å40Vnm÷_zÂ#.ihWef’'Sv€y∏ªfnZ˘»·™VV±¡ ‡ÏÖ\™"ÏD¡y√IæﬂÆØ¶P|ﬁ°7pD®À}F»‰a©kûY;lf˙a4âÊµs8ÃITœJwˆôÎ4ë∞<“Åv¥V}ej´bvc÷]§P,(ù øËTS=„	…NÈG€h
XÌ˙él¥ãÏ.∞Ó‘Ùwù0ÉR≈VqDˇ ◊7)ÍQFdò4˙EUmÀ=≥&z/˛0lÔx˛atj:Çñ˜≈0œç·Ef!I∏∏£†I¢∏ {æ`jÌ*GñÓXQ@ä,R¡F``P+Z÷ã÷¿3ÛeºûÚµ36#–˚LIXÎ†ò:Qt‚@á:'ˆ≈es)ª/q†A¢Ê !Óƒ∆É∫!ﬂ¿Y√$rÌ»h8º“°{®c}\Tëç∏
æV)≈™p©g¡§eïeX›r—‡j*Á‡	Y<_G€KsBvÂ,!t‰C¯bLBß*Ái8‡~va(e„d‹ø◊t$ˇpX"*ku¶åK$aOia 6vgÙ`Ed^%ƒÂ4Îù8‰Á+eem!nRE,eM)clPk∆º˝“òPOAho8Ü ª#£Å}Éî
ª‘‹Y“∫±õ˛AîIÍlÎG+ÿÿ∞A5k¥Ús‰ÕSÇœ„ÏG©e°GfË‘KFuÓÚntÎ¢E»|Aig~q:ﬁ-øaÓßè¨eˆ iPVAJ ﬂ[≈¶!ÀCL-∆6⁄Ó{Ìb%ﬁaeNB™æ\d÷A≈ÙjCÿ¸fGj!aûÈLt“¿ó(Ω§j$ñ∞i`(¬Xd40_n-T%∞#c∞}M
Õåïü¸0kæ1⁄!€Íx:éÌù cl‹TπÌÏIPˇOKp\B"sc&/f©"£
{àÖ∂¶# 2ÁDÖZ©oW‹±R0hπPÛ[¬PÇwÔ%†,oÒUm˛‘<^lMàçÏ0]VnEX¥ÁÖÈÏ{zÛåi-∂‡d≠b&L±Õ≠gîc~>lœªßbX2q:çP≤⁄ôã∑LÕe&A}≠gnXT8R™Ìw,|µπLix·3ƒdU>d.*ÚàÅÃ1îø2…ì‘hﬂH—Å™ÎióuRa¢ÑsOSoTâR›

´Õvîé÷q†7).[Í`nøè%å`"©sùlO rhñY[…∑=JDÚ)s¶∫nÎ‰EÊ£dajHOÈvGYNa◊£A˛µﬁ
:⁄-Ï$÷J‘ê!…}∞˚`f–∆›˛ı·£g$˙;=5ÉRPäA€¸,ßM2ÎCÉ•√§y≤÷c∫j!0L˜–w,Ù?†`4JIv ãUï$UÌ)ÌH˜/_‚Úéu–ññÔ´-ÏÛÙ]™t˝÷u23•ïu∏‰ÂÓ9bOΩ?œÜ`oÊÙ2‘hG5¢^ÌFU∂Îá^ÍÕV≈Â(ÜD6ÌŒÑPÔ◊»D-`ÜÀO§fnóÖÊ«&áDEıÏ‡FqP#?Ãî’Æ÷‡T≤Ã ¢?dúr>?‰◊’ ·Ù›28
≈>úwåøDz’≤/h=|nVgÓﬂ?;£πéqon>Æ~·ZÆû∫uÏ)f6ü5Úm  ∑µi/aÂlSc˛OL„…‡\O÷iXñ¸mÌZ√Y|Zô]»¶%$«ãÅÍMW]*dƒbáz\{>#Ìm´Au1ÑØØnj€„v ≈P :eQﬁkblƒmä)"l§4›4 ÛWeá‘ëû!XC]ÔMeÓ+álBØ-˛dõp\¶º.&ƒU'ˆlX*?,øM3-œÛ|!,÷gˇ˘ˆ˚`nFÑÔ|$V€ÆÒˇ`·}A∆åieÑ2– Ô,Ñaöt∏†`ﬂ¶q-ç¬g;¯·¥j dk~Â@∑ò)⁄πùph˙Î\sF‡Vu™≠¢`«(nı—M	õz
Ø.«ıÎ]ª;!nAßﬁ÷L7"$}Ë∑ÁÄ;⁄o˙#,!5BY-g}Czº¥F¬f4∆YÛG£*—n	úPBGù–Dr{ß*Ù´˙Pá`v¢™wô]ﬁ{H|ÙrƒgPebY¡Ol¡ik‡úeo¸…˙lg⁄ÂbKbC0mVfÊ¡sŸbUlı[¶BÎozB¢oHfuœkYˇs∞UC6BlvÌD,8ÇmÕeAqtZPHp `OÍ∞H…BQafnF/∆>)Ùo‘ƒa†ËOPXMPT”Ù÷©T%ﬁs√˛Spe`ﬁ•åîÂØxqiÂ™Ò0üÀÛ‰O˙·Ë·‚ˆ©JM¿Jk?‚uK+ﬁ~A?sO÷ÈvñO’rp˙*ÃW“IÃ˝cZ…jƒ∂’l6ö«™÷¯å}YDaπ^=ÃÇ6“·I@bœ%t,Œ¢‚2⁄õπz]UC≤˘o¨ÒÆ±oiÚH cQÎt2ÊJ3™÷&·G.«i•1|y@L«√¬Cﬁg‘yË2tzo}MM„E'RÿP…∞l’¬`n>ÿj†ﬂÕsñ>’ˆIYh]√ba¯˘nÛJÂeMÛ‰S.∏`˛œP+</–IxÎñMO>Mj”ƒ`<o¨bû–HÙoñ !+mΩ‡QB§z|Q¥ÇËY!rÊœq¢œ›©ú∫Øe)nm˚§÷+y©∞!òí˜ªÎÚÍÒ‡s«r7ÈŒÓ≠ÃV *ÂoÀqΩˇÇqfoNæ©‡Ô8√7Ëso∆’b0Üá`…i.nâ3`+|¨o4?8Ê◊E	¿wsÿ(\fåohC∫™à|-c#™xÉÀ‰7èîO6 !0®˙SøÒ’MÊS÷∆◊πävgX ∂)9(”ac2øù´ä∂Uakè´$+`ˆƒnAÂˇäÇˆsWqj+äg÷l–ï%‘U[må°Å© WÒ∂™N≈Á(xd«ahaÔóJ¯`Kl"È#«BHR6AdöG’Áø-¥xÄqhRAD{Ú•qU∆¸˙c2GˆÌ<Ä.K,m@˝»,µu14Ωº˙xÚuw&"(ÒX"v≠¶√ÛaÑÀ¸=£ÿ§IfRœm°W·b»Ã±ôFÔ‘ƒ*f*ëfıu^€„/ rÈ¢ó∂÷_2"ëÙ€∑ÊPıà°â¨Z)a∑@"bÁ0°l8cÓ`≠ICüFœéno<6)ÂuIá=ıÚ‘÷œ÷#È≈$V¬Tk„iütÕ|ËfU5◊ß¿9:>Ö\ÍÊ´?A–umyd…h˘ÈmÕ}‡ú°ƒ%‚lÁﬁÇ,¸Ò@íß∆ÈÓe»y„Fw≥Fx◊€J%`†@D Ö¢ò"i˝	3Û—ﬂ¡Ô[ÅØ˜Y€æE+£,”ü7ı$pÆ0-dpG=)epñÁ‰ãÕp
˚¨\‡Ìÿ&˛*wf„¥˘òm¸$swçñπg^v¯Ò||Ú»\Ê‚û<ÂÃ‚˛D≠ìqiqlö;èæÙFx—Ú@4b´´äœtl•t>≤I|ÒG∑{&Iÿ öqÊ]y–î{4˘{sY*gfô6gì <|!Ã˛‘0æ`Á‡YoÙÌÛQπ/0KÆ0KÒ•Y`q^}
i∑'oHÃJRD∏W¶E·S.ü
x;*¨ËM`ìﬁNpé~tCñî∏…©}^gn/Ñ9'ﬁ fb˘Ÿaço~Rg-g…L∂*APerhrﬂøap=3ù‚Â¥ÔÊé—…¶€UÊ$‘E°ûmJs6, ÜÎj·»6,;Íˆ ﬁ6ÄO¬g Â√Km_ Ó¯ëf8£@Gƒ&Ùu'ËSö£ˇ;ˇ#ì/ufo˝(+Q®Æ-iCX∆!ü ≥°ôic.&7}Ä<Ô„Qü¥e∞`d‚G˙„GèVqùKr ¸PmA`mı˘yìRËl?jŸÚÊyvÛ,SLûy¬Å©iRQgx	ö9fTfÁhΩw	Qú Ñ+ô˜U˘ñ‘B∆«,WU#˘~√ ˇ»|å<aHd¥Êpç¢<6t3dqÛˆ%H Gì	M	Y-«v —º=|l‰∫¨=öq‚]"=]?˙fÔ cMhfY∞&ıÿñR,zD˘ÿ•ŒíHAÜj—°pd{Näœ»aæsƒbŸwÔŒ‚Tå"ÉÈk8°:QW∆.ÍP‹xWwÍI¥OÍ2EkÑ|CHf‰∫•2E´YM·"õÚqy{fñÅGUÒ~C*’ueho˜Sôª:É)1,ﬁlos3‘#¿]≈În	Ï}Jë4@,"5ìÊ>≤Ú¶MzÔÇ™}g—¿ß"¯K+äbd-6k}‡D¯è¡éU˙?Á∏r1ÚJ∂(àåñŒÚnÊÙAñsFgÛy>Òï>ﬁ˚˙Ü<Rf≠Õ/Æ'eâdÌÛ/Z[ÿ$2sHwlÛe∑Se√_ÎTÓ.kHcÂ†ØT«-ˆ≤ä™in‚[Omnxir‰«9˜ãBUs&à}O~NW‘zÜ6+% ·Ò6>`WdæèÃÙ‚Åƒ.Öa í'éË$53òCù|Èzq—Ài¿Ù5xG_
ifv©≤r‰e¡Ÿ≠fèM—B–K∫ú$1å«z∞ì(~òm1_1ãÊ.&*ì¬d2mõùlVbq§⁄‚‰	ìÕEQ»0Y¨=H,l'qwb∞Ê=‚é√Œ»”@Ld	ƒ)√|C[#;lll?1ü‘Évﬂ!n”÷$&Œu1WÌBÈ’/ô"ﬂ!“◊¸bdæ
y©/+,›N(±§™[˝äAK¥Ë(èfTu≠_"Nˆ‡cË§÷s·5M6î^Ù(! ]…'yÅøOEÌt9˝∏Iƒá-z©∂A˝·"1Jfá:àeCÑX+UÙò_µª*LQÇSa,OUÌÓÈST∫T©·Hß øÆ7ﬁZ∫zcy&@O1	‡p∫·áƒ{›dLsiq,jÁâaØg&⁄D˙8¸!®—l4AWcß∫Ó*_Dà¥c¨ÑB™ßqÓZû•‰^u@ç($Óbäûëæf∆#ımE 89w$êÚ79]·ııÆ`ŒvdZ“‚ÎLe42]éH◊7dÌH»Ka~–,»5NmY\:oHU¡:¨`¥OÏn∫oÉzYc‚<Tb9‡4ñß(Ω·NÎrj¬ po¡z ¢DR8/√aÙ≠‚˛{OÆjh-ßcÍ™}Mµ˙ÕD%ViAy%˙ÔÖIS|áuﬁÆﬂ9Ω¸aLdCU…1pÛãËÏ{o≈59B)ÑM0›S¸fE,RøÌÀoÃÇ4Å¸ã{˛>qhkm˙?/O,÷≈πsêÈugn£§H˝û(Ÿ¢SÅAìLGÃÿ†·~#e—Ÿ!ÓqÚÄGv2¬\ÈBwi˜º0	∂ﬁ√›Á˙Tı.)lÎÎÏ&j`fw_	{ƒ"=kzú Ò8/7a/Ae)≥•µw60z ôµ~kr≠tQg◊,A	†‚d;h˚egl'A.mJe4#~¬5·IêX2&Npú=≠ÆvÀ[pµ≥€Bıl\àˇ¥hSR¶+:‰ºrÈ«]>E tI•≈ı@≠´ÒR 9- ≈¯t˚¢‘2}"FTî2xÒ÷xævÜÚ‡ ?`Fgçl•z≥˘`ÛCfºt7jÏt·cw´O≥¨¬cvÖÒ^C;˜v-Ú` Ò`cÚ;
Q4b(s‰ÒdV`eR[A	J$‡i°¨# of$WPRç-\}iT3wë–uÌ†Ê%¢f0{¿\D6‘j=˛NN»$˙K‘ÕWa‘4ÂÏ˚”$¢Oc≤‹«∏te°é3(YœYvù![eVåıC‚Ê£®.!eß†&EOÄ,„7i–nÓ>ÚmßSˆ€!O4I3-‰ˆ·V¶˜d¢ù\p€:ìrór«vñËÌvt«àKctTŸ8yL7¥ÑÉ8x5j—ió`˘  0cu(•ı∏˝ˆ–q$KF¯¯*+≠ÍUÉ∑‘•lvÏÂeZ∑?,≤q ˘˙&lw¸¯ º≠<R~z1ƒr∆	 W¢$¨4+Iê˚ªâ(med$b·#¸kçPœ3˘!d'XsË–E·	«πÚÆÇa„uÜ"wx›rNzˇ<°»3âzy9¸xø81Pjc.§†úËl&"›h∑∂~⁄3ùE4…∑fΩ6Òbt	b)pf#ÕË-%œçı£¶Á|J—dÊoπ4“;EˆUc¡VÒj#áåóC¶†O∆„Ùmq*}πM–u%mº(=í8àteöl˛•p)ı)fÚı@!âwgìI°ag}¯™‡~öa´rrY©≥©96 ŒWz/f5]”}%’aJgµl	TÓqµÔaÏ"EÜj.=£znÔÑÆ+4d(p]µ”ùe¬Cf:"uc¶Ste]\ƒ{µG7q?v¬'˚tMik&{+ii#kÕ‡ˆIu‰fÜ√¨¶∑ÎOp?zcÎ‘«ºq0[#≥"3"Qw¬sa1´ó†úX‘∏vdC›t$l0iÈˆ_"dØ VÕ!≈0wiO·jÓ.‘v6·|,`?nE`ìantE‡9ÿ‡’ãùø1e0+ufa†R`πd1pW7ÓN¶π≈kGÎ8$Ñ@"Wï^!¢ã'6ì!¥Z3Œﬁ˘"CÕ$Kj™Ó´Èÿ)d1{ZRÛoÈXi§UÚˆ!90°m„«fX+‡uÔ(-§GnogDµ)I¬iø?wc˘¥rç˝UkH0;A9˝Ân6”9q5drö¯@,c% ò”j+r$q%ÏîÙo7”cûØ,Ã¨å°ÜT+§1ÍŒè¡Èåkm"]otm·*÷«UI¯Ì˝í‘c3.]ûËyW_ÛO<ˇˇB=k}ˆe∫5Yon=eI YC7]sx0<rbvzn-È$|pnÊùl¥>q)3[¿Õo&‰£â∆◊ØH¡’ísúe) 0¯yzò!q`5Ñ~>•}º"≤ëƒ1Ò”l5Ïx†sIK_`u0ÙGYŒ°}ﬂ:LÉj †]^`l"áb Í0gí5≥Í‚Kg2†NXK¶«q(_ $zß<`Ø&≈3k1a˝Ÿ”€`¯qnu¯≤!!RjG~;r·iT8Yöµ¯7>0ü˚`$kzD)}{«Ò 2"EmÕó;34r|;©$9>ßpTÓ√…Óhh.—‹Dq ?~i~°nÒgg˚T,ë,9!ËÎ#EM5Gé·!@Ú√˜OÎdzt=¢gZΩ˚D>X#∫[ak(díI1Dc}Ó‡Im∑Í|¨Æ:H	,˚]¢√2ub?tj{s¢œ;Ïo
.5”^Ω Ä%<;èÄF>Ω%<˛?ä§@Q$x;Ú]>x?œaÑ≥!T‰Ä¸NÚ‰b¸-@e±¨%¬˝˘~~–Ë?ˆƒQ{ß≈Üû0_≤π§kp¢pRh£{6˙
ÏØ—mä>¨nA5›J‰jsxv;+Ìp–p¬¿L`E¥|%ÌØ»≈Ù⁄jÃrLXÓhcwiΩ¸3‘a+N;`·Ol}†6zˇ)ƒ6æ*˘Î˛Z≠[7ıLpöàk]2eı©™√Ép#n*N‘k2Zœ(fËˇM∑M`o67∞R›Vbl∞}ëapzÄp]∫"9Laíz{≠ñæ»H˛63DÍÖ|UT$y'$‰8å7 ‡·†H;ª-˚oQCió$tfB>Æ$
Kmd±/z/Hé#}(W6-"ª &•Ë9±pjc“Ú‚cr	éiu6°qﬁWv'|~U•£?z,&}m∂:Üm£T≤qca4›∫Iªß@9Yhækf/sÙ\pSµJ…†'iÃZ≤TºÓi|GkQñdB≠b4@0v‚Ï8e¬txceœÛ∆€NË?$Pº]· .8xÛA±_§Wª˛a-”∞!‡Ê7(92¶Å\&Ó˛@Es[∞ Ú”sÌ≤OËÃ+ÜìÌ≤‘ 6∑Y%s["∫(m(y3V˙&ÈM:Ô˙.Ê+}*f‡Òx√pÒ˚¶‚,vF3∂Y$Ûe]◊ˆ0Ö5C/©b A'„‚vX…z%˛ªÏn˜(¶∞jÒºÛb`8;ˇêzµ".CF3†Ó9]»r/‚»`L°n≈¬√YW/v¨NâcºWƒ#¡)yM0a◊˜ÒâX%%·¬h∆Í@º2x*—c¿¶AAõÁæO3p¿e-f/˚ÂArÓi*Î!¢ˆ∞uUK‚"•ø?.⁄vfyly<πr7'©ÌF0,}tkÿ{s|9.èLt
uöH(0	˙D="ÉS† µ@V$gg‡π{ko!d·(2F†˛ZlEÄBC–∑ÖÅﬁ™ 4BÅ≠πo¥2)2ÖzVN‰E&ÆÊHåÒ-≥ˆÆ‘ÇFM‹{k’!±glUÍæ §f¬!*,tÎ/û‹ÍTkõEq;Ïz;’^iæ˘@„Gˇ˙f ¥Å|)œax„V£òPªp)¥µà∆pÆ)jÊ?Y∆07Rç«pÿ«?kÓÂÌò–Ssª“aË 1?ÖD#cNs%¸Ägé,:¢IFòPv¥)iïo4Jx2
Îﬂ 6AVtÔ‡§2“âîÏhj0r§”0S•+pÀú)m;˘m≈GP9øI -?6‘d}ÎI4d3U%^NI†úg52©$$"zïÚ©u¢oÌ*nTÚÓiå=52Ìg‰gd<CèF¯|‚|3(xP5áÛ´H˙±o5ÓÆeqbsÙ2~óbUØ“®˜¶ q3y¢†T¨‚(j]
‚ó”,#˝.ÑPÆlSm7 π0qKƒ$íh¡$c‚ 2„a5‹ı„ÉJ^˜¶jy. `†mQ‡(Ö$? ‰3Ô:z√m7	Ywb8YYm‡ì∏;'(0˘=À*oq3Á+eM≥¬ügê}cŸOcªœÿøk±f¡;n» ß<•çî"ÉÎeeA4[vom|qﬂó¥∑Y )gfÎ•ï	Gh8Xu`0!,wD%5}õÙFwxx'{£hÀNƒIc„È.«%}v!l
kmh‰;∞πZ{w≈•'¢4¨E-œ 5qFRWÊ∑vm`Ôsº⁄_b∏@¢s9T„ÁÂÔ7|†DE!≈qT£v5Á1pÈã	I”RÑaÊw•a˝üg|)twﬂº Ñqu∞lPÖ¿5{¢/≠
µxxu`65Âv|c
Qk˘°+-*àI%<‚Q|K™é" ì{P·YŒ
sCi*.k√Ø˝/tLm5e,ti<mFôu¯ÙÇ^›˛k
wrFBA˜tñEOx\EÓ∏*‚m^d8Pˇ Eq±Ï/2Y∞L*Ú”/Âa/m≤d–|]Ëw S ≈;L@5˙‡†Ìx`jÃÌ0jRm4>{ﬁ7H)y|ÊÌ˜W0+xa4gtkÎsÄsÊ4c~≤k·BbU.]™’™iq¨Ï8˜EI9‡"u9≈{NtAhD™ç6S1® 
iÕw+^:<'ËiJdÊîP‡°$Ÿä^·rÂe∏+$=dZ%-|)Oì55Í|9ﬂ•°vÖcAõ“∑©Èì2r’^}>¨˘{Ô˘›hw∫˜;∞o”5?m~ä„ä˘‡EÚ’hn„<ˇZÁ1˛}¯~⁄o4ÚwLrù[dP∞ÿeº>Yv◊xÈâÙz"Qf3A@U±™`"f‰˝50ãødI:VóosR;C+D®óˆÅoE°$X+Ûæuﬁvs)OÇ\@›ta q$Plıj˝nœ£W†Ö(/2 4&V∫@"œ≥x!B@Ú8Q>I6i¿w	#ñDøòu0Ü!#1*:V%–˜U*ﬂÇGq˚Ø
j:$N.^re'›°W¢z#{LsXeA´8–îX)´˝ôZƒˇ∏(4&„3ç$∞, Ó¢886√¶`ñ1’∞:}…˙}YïK C¿”IrîpE$ÔÃ7a|&r,`+?tG`Mˇ 4tY¥Â)›`kt›1Y>=˝û/\(@0m[6˘x¥k€z*;2NK¬ŒLÈ*G~À)≠J, &'¡@l≤aw£0‚j¡∂Z 0‚;W{W≥ø>/5rÆN1˝0-Ä%SÍw™˛•Ω0ç@.vªZô.,dï∞±Ô†c¥7Ñk¨ a9<<™ŸßòŸHx2`´√ ãã÷ DÎe-'^;úÊm„`]-^";ùªÌÙ,ÆwËŒ`¿2y5BvÆ-â>ZVÏQy]2Epg8:g)$f··o∞˘s*—FvÌpÂ•fÚk&HÒvÏÆ0B™gù&YpZCÏmlE®zuãbËXÄl*°J%ZSua§Sçr»Zùwm¯´	d™WUllkrY!"anzwr!i˛rók¨$u|∞%ª)æ!K≠{*3ÕPI•π5fVdg5ﬂ˚zÔj“©`ø$˜ÊP°–d¸0]P¯h$K®n‚ a˛=Ø3)!†1ÂùeµGpmq9cp˙ÔU cµÕ√$!fÌ—„Ú.sVÛ†?«ÌÔhIÂ,+h˛9dÜÚµ;ª»È2$O+‡µKæÑBè*∫≈êıD¸†Hd26]o!≠]Ì,Én)`NS'‚ºØ‹ún8	3?/ò(u=^L‹áb{:ghdÃæ}¬Ó	º¯ã+%M<E›,-2√€öÁqz‡ısHà‰[ΩbÑ¿ro⁄6|®Û6M‡¶%ÌÊi-n‚oûÙ`d}`•-^z/¶Ó&+$‡<&∏&ªo5‡Eø2mm=˝G–o-|&§7*º\´dÏé2|!©ΩO-ƒeVm	LMC=Ã†\/ŒÜ£ºuÖ∞ßå=ß==<i?LŸXQ≈e«n√\ÿv"Z|o(˝P_ΩMAEk1âls-:Snd„›‹k•£cÎ{óNÁŸ-Ùå™\¥jt!2»û4loo~z‰#IÍ7wÂvÑ$°f”m∫ª¢> ˘»h¨ØS±I°, ‡,	°T*2ÏT¡Ry∆M:ﬂÔØ$p<˛ë7#pL™ãxNL$pÍ?o-3d&z!0)ÍÒ9Ã@DŒäv0î·¥q≤<=rÉfUÿubÎ`p{Ù;6¨(9;˘[Qm‚+ÈLASjyä˛ÜlµOf•ÔÙtpΩ0ì√6ZwFq9Ô◊=´Ú_*u»4kGm€9≥i-/=mÕ xpz8Ä«⁄(ê≠è·≥GeeY|∂„µ I·º{æjjI)w∂ØX&PBNGb*`—)J÷÷·3se¨é‚ı3i#h…ªmlH√§‘3SvÄz'‚≈≈s!:qÄEÍÓk#Èúé)æªl’`[Á&zÔ˙((æ”©>SÏ)WfTÖèp:Øˆ(7πp)o¡§heS)eU≈`—PJ)Á‚	˘v_u◊KsRPf.qdÂK*"LN·kßi8Ù~BV")eÒo‹;”tØO(K{¶†ndAnjcÀ66~p`5eN%R±6ÎôıÓm≤ei3~tueM)beuiªDûuHπèaIxK8∆ÇÎ+3¡{ÖÙ;TÕ“∫9õoPîYÍ<‚G:ÚÈ∞G5+psd}mÛ¿ÔÂÃD°f©AG&‚ÒIHeÓÚj4Ô¢E>hü¨3xY)Oj 2Œ≠?%nßç6«„8iqYNhLŒ;i¶!ÎS<9ñ!‹f˚‰vegﬁayEäàeŒA≈xJ›\{A`!1%ñ/V¸¿uh˝§Z$ñ∞x@^‚Xd4cOfçt%0!f∞|MÔì}ñx: ÷)ûóöm2loù°„`\Z®ˇË 4˜MKt–B2#e_dÂkÁ	{YÂ∂Áq`*kLJ†zVﬁ∞
 k˚Pp[¬R§≤˚V†ar§V~ÙV>x|AîŒÏ1i&ñ.ÕL¥fÖoúÂ{fÒöi\ÆÏq≠b$ 1…©g$gA::\Í5Ï Xqu:ç§⁄m´ˆLÏ5#d}Æ}.xw<~◊*g[,Ôµ>ÒE)9 ≥AtE˛tfjÚ°éÅÃs¥~3âìQlkK⁄•™Îi6wZc£+4s Lk}T∏NrM ´üv‘8Ó˜q∞5l&oÎ>`n1ç$ƒ@j:®1=†OÍrhrˆP[À≥<CFˆåsèπ^n)f@dÜ(∑daih_®WKnΩ˝´A˛∞ﬂ
ZJ5ifˆN‘Ä!|_0∫`‚p
ùuÉy£g&p=-íP@Ö∞a[¸*´∂ÓRë·√Ê}∂ñS∫J 0LW–;8˘8¿p@ö<vaâ&\x+mHu'Z‚¯75ÍñzÁo'm”ˆ_*tmVuv3≠éa¥d≈Ó9VfO∑>œ∂eÊ‰6†ju#MeU&oÖVÍ’R†(≈2?-40pÁ˜…ƒ=d¶˚o§FnÁçÊ’eáTE$ıÏPFQT=sÕ◊ÆSŒp∏c™Ì‰òb>ø§’ó*AÒ˝>)≈
ö˜®≠Er’0"&(>~nÙn∆˛Ω?≥Æ<ol<Æ:√n.û™udT-≥è@≤<>(´5I˚ÂLSsÓFH·Ï¿:OÙÕ∂:iÏz√kxX´œI∑•4÷Â—l»SU*D@bõrLxj´ÌÕ+Qe‡
¢ò /´≥v„`|:`Y˛oqÏ‰y:m™|e0xvN◊WÏ\†ú
0<o]Â-e<)ámPOTGÌ6õ<]Ã¥:,å\ßwëdtz=.ªM3-GÔÙM %,µ›>˚`ngb~+VÏÌ∫`!ÒtD∆è)%DtrÆ.Ña+4∏Ωtﬂ∂alé¿f9jı$je!ak~e@4Øåo˙˝zyYÈVa∏P‡Vq≤•¢GJo‚–Ix2˙Æ,ŒÛÔ]?;5VA¢˛ñ\7* ®∂« ≥‘oz+$3%KQ-{YI8i¶¬vz∏n:ÛD£+n	ú`g≈Ωì„Öd˘Î"Â+˙Xß`n¢zıà\è3HyåB‹dPav_¡_maKkT‰úem˝y˛ÿo^Ì`G`k†yT6‚Ò{–jQhÒ{‰ßn⁄jz†n|jı‹O`ˇqëE◊ñbhrıCmÌ¢m›e]wxzP[X jO˙M√HSÁfdF.é:(ÙoFÑ%‡up\TÛ‰∂)rØ⁄sáˇC®Q' ◊˚éugØjAc·˛‚0œÀ˚¿œÓ·¯q‡Ó®^d‰Zi˜[L+ﬁnb'i_N˝rGEx7ÍjÕ?Úiˇk⁄Kj‡º’,6öG™˜PsYDa9R5n¶vÚ·Ip"o5u-Œ£Ú<€yx5C≤0-(·ñ1?h∫  £AoÙ2¬^ì™~g∆Z„n≠Ru…$L(Œ≈)‚s⁄˜ÙQ˙2t/˝\oi∑ÍŸ@≈!x·Êq~6IhÂÛK∑”>”ˆk}j]AciŸ—>æÂdOgB_oÏbvœP´(u)‡Kj ]O<l(
…@@y†F¨ÿhÛf‰O%mΩAqB†r9Q¥«‡S	Pˆop¢◊Õ‘8>Â8om3ÙÚ*}©1ëòÇw™£‚Ôu`c∆s3˘÷ææÃTh*eeÓy≠gˇ¿3e~.Ω©zØ8@7ÍQ{ñ’#u8Âlçl.nM!e4åw4.πn≥ƒ	Ä[p¯;?Taêk,Aºjàpg.¶x¢…Â6Œùi&`1aÿËÌ”oﬂ1œiGC_cïßä~ÂI! 	9
—ag"Nøïßä^?Us/¨/$+ eƒj[e˜*w7e_po;*"‹–ü#‘ŸkW:¡≠%∞π‚*’ı(ydŒaÓKÁáB]iX+É%≈Bhj~MaíB÷§µ4t<Ñ'Y&zWÃd[Ù•5A«2˝∫#5i˚h<Üäo,-âπ»
≠=|=∞ΩΩÍjˆ4Úfø&(ÒqfzÓ£CÛ%«~# §kFr `°w)bàŒ±ÈDì∫VÂnb#ë".d]r◊„> b®0ó¶ ""’˝ÔªRÊ\ıM£¨7Q+eE"bg0!l k.Ó`≠I
EõFŒlzæ09µwI4÷$puÚT–Œ?òg≠ƒ.∂÷=)Âaü†ˆÒ|Ëfwµßı9#îµ6kd´_A–5,!ÈÈ˚%∑I]‡î,≥∆£fﬂ˜L”†˛˝ößFËÓè‡:d+w≥tπv[;3¶πAD ≤#je	!Òÿs√&g[QèÚ9◊ºt+£€ùg=˙é&|&0#2T?ee0:ÁEK\@ÒlqÙÂ–6}*7n„=q®-d§ywçñ}'.>⁄qn|ÍQTÊ„∫uƒ¿|dµë9·uOä$:O≥f:âq¿1‚¢®Ôœ<lµ§0ll¡wµcgi† èáyªE˙6‘í{t€{[y™cvôeµì!=t!TºÙpé°ÊY;Ùœ2Aπ0K.1PÒ¶ s}¯O˘∑'~LÕ
R?f08W¢˙·G$
|?)¨‰UgçáöOa8åee+ ë),,<6~/ °#˛2"fg}˚ÛAçOg≠wÀL3(YpQpdrˇ/08%1√•Ùe^–"€$f8!P˝!%ŒEB#v|"Ü*j°Õ:3b0Í 5$O∞c2ß¬y!é±opz≥@W‰64}'hr„{˝!&ugi¯(+.Ÿº≤-o![Å9óÍ+≥ô¥qA,'r/Ê∞<„„—o&u∞`ÂÊG¯È#üVPöM:j¸t0@jmÙ+iZSÓD!€cßy4ÚÖShû˘∆-hRQ&{∫uÊDfÁbΩˇ%@Â¨ ‘	ò≥|S>÷ƒ¿7E5&ÈlAÆA|¨<aYdÄvqØ™<<p3,∏h≥6ßZ¬IìO [g*”õ82<igæ|}í˝bX≤eE?˛b” ÔpHc¯"ı“îr*zeø∏lõ⁄ê(⁄géz’!re7Wé⁄c.s@kYwÔJ„U‡¨¢Éas8mŒAwF.ÍE»(33GwÎIµOi:ck≈=x..®•ÚEÀ|up+¬U9=vì†VÂ:*UeõeJo∂kô±∫≠0$ûnosAd3@œÎ.	ÌtJ4`˜ 52Ê!∫ˆ™Mç3{É
±yw‡√D•r¯[)
zF¨
>km°Ù¯™O«UYx.°s∫bqÚd∂+Yò)≤ÃvoÊCwc/¢isùﬂ˝xl◊2µÕ6.&1b%à$}sWU‹4vshw·$eµugM”PnUÔ6CÃeÂ†/0-∆F™iÆ¢{o¸.8|0%◊9[ÁèTU˚"p?OkNW‘p&6"1!˘h2?nWtÚÃ¥¬ë’.a`Z/ûË§-0„Ωiqq{hƒÙu|8pO_N^'v‰bÙd(q(&ÉLÒ QJ:å,1ÃEx0í(8myw5ãÊ∂%õä!mòõ´ôlubq§ò∫Í_	€M*b∞òYº}L-b&qWríd-beBÏ»B,lÑ)ÀHf;a#	;l|®(w1ù–Étﬂ1|éì‘>Ne∞WÓrÀ◊/© ﬂ)Ú[Ò‚`∂H˚ﬁ/34o,Yçg8πd™Z˝UR4Íé„-U&Nz‡b(¨“3‰3Mº	~r)%g|@-0ë∫®Tl>7:„8]ƒØ9-|}Èê@ue*2≥Jk∆<®edÑZ(Q4Ö|	¥˚*,Uí”`4owmÍÈsD∫T©{K≥-3€UH‚Ób16@M1	‚h∫ÂÂ9›¶|d {=Snm©).'ß⁄‘¯:<>®Px+5ASká∫ø™
nDâ∑s∞U5Päß–Ó_ñ≠aqG⁄(4"hfäû@f«dı)h<5s$¥Û71xeııÆ` ~`˙ÚkÓL`a}@G?b‰∏\HKa§Ï%ÌY^"ˇJ}e:Ë¥[ÏN∏G"zQÚu’h1hßæÌlΩÒn˛
j¬0X{ëgzFZ0n◊it˝fÓnOÆjm-MçcxÓanÂzŒE81\Èa1o≠ÛÈÑIU<Ö9˛Æ?33∫]nQUõq.tÛ´hËze=<nÑ}(c˙ÊQ<:©…OUÂ:ä $Å˝˙z˙>µjÎm˙k':>VÖx≥‚KA"O°¶h˝ø<i™S¿EÃ◊Ãÿ†k:`z# d¡»!z+ÓÇ
6' LæBü»m5Ï39≤Í‚Ω«FÛ.)dÎbËv>zJtÁUD dOperands(operation);
  odsState.addAttribute(nameAttrName(odsState.name), name);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckOperationNameOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operation, ::llvm::StringRef name, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(operation);
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CheckOperationNameOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::llvm::StringRef name, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(operation);
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckOperationNameOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CheckOperationNameOp::verify() {
  if (failed(CheckOperationNameOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult CheckOperationNameOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;
  ::mlir::StringAttr nameAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> fullSuccessors;
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("is"))
    return ::mlir::failure();

  if (parser.parseAttribute(nameAttr, parser.getBuilder().getType<::mlir::NoneType>(), "name", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      fullSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        fullSuccessors.emplace_back(succ);
      }
    }
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(fullSuccessors);
  return ::mlir::success();
}

void CheckOperationNameOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.check_operation_name";
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p << ' ' << "is";
  p << ' ';
  p.printAttributeWithoutType(nameAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"name"});
  p << ' ' << "->";
  p << ' ';
  ::llvm::interleaveComma(getOperation()->getSuccessors(), p);
}

void CheckOperationNameOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::CheckResultCountOp definitions
//===----------------------------------------------------------------------===//

CheckResultCountOpAdaptor::CheckResultCountOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CheckResultCountOpAdaptor::CheckResultCountOpAdaptor(CheckResultCountOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CheckResultCountOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CheckResultCountOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CheckResultCountOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckResultCountOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CheckResultCountOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr CheckResultCountOpAdaptor::count() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("count").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::UnitAttr CheckResultCountOpAdaptor::compareAtLeast() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::UnitAttr attr = odsAttrs.get("compareAtLeast").dyn_cast_or_null<::mlir::UnitAttr>();
  return attr;
}

::mlir::LogicalResult CheckResultCountOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_count = odsAttrs.get("count");
  if (!tblgen_count) return emitError(loc, "'pdl_interp.check_result_count' op ""requires attribute 'count'");
    if (!((((tblgen_count.isa<::mlir::IntegerAttr>())) && ((tblgen_count.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!tblgen_count.cast<::mlir::IntegerAttr>().getValue().isNegative())))) return emitError(loc, "'pdl_interp.check_result_count' op ""attribute 'count' failed to satisfy constraint: 32-bit signless integer attribute whose value is non-negative");
  }
  {
  auto tblgen_compareAtLeast = odsAttrs.get("compareAtLeast");
  if (tblgen_compareAtLeast) {
    if (!((tblgen_compareAtLeast.isa<::mlir::UnitAttr>()))) return emitError(loc, "'pdl_interp.check_result_count' op ""attribute 'compareAtLeast' failed to satisfy constraint: unit attribute");
  }
  }
  return ::mlir::success();
}

















std::pair<unsigned, unsigned> CheckResultCountOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CheckResultCountOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckResultCountOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CheckResultCountOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CheckResultCountOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CheckResultCountOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *CheckResultCountOp::trueDest() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *CheckResultCountOp::falseDest() {
  return (*this)->getSuccessor(1);
}

::mlir::IntegerAttr CheckResultCountOp::countAttr() {
  return (*this)->getAttr(countAttrName()).template cast<::mlir::IntegerAttr>();
}

uint32_t CheckResultCountOp::count() {
  auto attr = countAttr();
  return attr.getValue().getZExtValue();
}

::mlir::UnitAttr CheckResultCountOp::compareAtLeastAttr() {
  return (*this)->getAttr(compareAtLeastAttrName()).template dyn_cast_or_null<::mlir::UnitAttr>();
}

bool CheckResultCountOp::compareAtLeast() {
  auto attr = compareAtLeastAttr();
  return attr != nullptr;
}

void CheckResultCountOp::countAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(countAttrName(), attr);
}

void CheckResultCountOp::compareAtLeastAttr(::mlir::UnitAttr attr) {
  (*this)->setAttr(compareAtLeastAttrName(), attr);
}

::mlir::Attribute CheckResultCountOp::removeCompareAtLeastAttr() {
  return (*this)->removeAttr(compareAtLeastAttrName());
}

void CheckResultCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operation, ::mlir::IntegerAttr count, /*optional*/::mlir::UnitAttr compareAtLeast, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(operation);
  odsState.addAttribute(countAttrName(odsState.name), count);
  if (compareAtLeast) {
  odsState.addAttribute(compareAtLeastAttrName(odsState.name), compareAtLeast);
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CheckResultCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::mlir::IntegerAttr count, /*optional*/::mlir::UnitAttr compareAtLeast, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(operation);
  odsState.addAttribute(countAttrName(odsState.name), count);
  if (compareAtLeast) {
  odsState.addAttribute(compareAtLeastAttrName(odsState.name), compareAtLeast);
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckResultCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operation, uint32_t count, /*optional*/bool compareAtLeast, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(operation);
  odsState.addAttribute(countAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), count));
  if (compareAtLeast) {
  odsState.addAttribute(compareAtLeastAttrName(odsState.name), odsBuilder.getUnitAttr());
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CheckResultCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, uint32_t count, /*optional*/bool compareAtLeast, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(operation);
  odsState.addAttribute(countAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), count));
  if (compareAtLeast) {
  odsState.addAttribute(compareAtLeastAttrName(odsState.name), odsBuilder.getUnitAttr());
  }
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckResultCountOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CheckResultCountOp::verify() {
  if (failed(CheckResultCountOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult CheckResultCountOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;
  ::mlir::IntegerAttr countAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> fullSuccessors;
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("is"))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalKeyword("at_least"))) {
    result.addAttribute("compareAtLeast", parser.getBuilder().getUnitAttr());
  }

  if (parser.parseAttribute(countAttr, parser.getBuilder().getIntegerType(32), "count", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      fullSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        fullSuccessors.emplace_back(succ);
      }
    }
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(fullSuccessors);
  return ::mlir::success();
}

void CheckResultCountOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.check_result_count";
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p << ' ' << "is";
  if ((*this)->getAttr("compareAtLeast")) {
  p << ' ' << "at_least";
  }
  p << ' ';
  p.printAttributeWithoutType(countAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"compareAtLeast", "count"});
  p << ' ' << "->";
  p << ' ';
  ::llvm::interleaveComma(getOperation()->getSuccessors(), p);
}

void CheckResultCountOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::CheckTypeOp definitions
//===----------------------------------------------------------------------===//

CheckTypeOpAdaptor::CheckTypeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CheckTypeOpAdaptor::CheckTypeOpAdaptor(CheckTypeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CheckTypeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CheckTypeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CheckTypeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckTypeOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CheckTypeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::TypeAttr CheckTypeOpAdaptor::type() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("type").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::LogicalResult CheckTypeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_type = odsAttrs.get("type");
  if (!tblgen_type) return emitError(loc, "'pdl_interp.check_type' op ""requires attribute 'type'");
    if (!(((tblgen_type.isa<::mlir::TypeAttr>())) && ((tblgen_type.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'pdl_interp.check_type' op ""attribute 'type' failed to satisfy constraint: any type attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CheckTypeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CheckTypeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckTypeOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CheckTypeOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CheckTypeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CheckTypeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *CheckTypeOp::trueDest() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *CheckTypeOp::falseDest() {
  return (*this)->getSuccessor(1);
}

::mlir::TypeAttr CheckTypeOp::typeAttr() {
  return (*this)->getAttr(typeAttrName()).template cast<::mlir::TypeAttr>();
}

::mlir::Type CheckTypeOp::type() {
  auto attr = typeAttr();
  return attr.getValue().cast<::mlir::Type>();
}

void CheckTypeOp::typeAttr(::mlir::TypeAttr attr) {
  (*this)->setAttr(typeAttrName(), attr);
}

void CheckTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::TypeAttr type, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(value);
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CheckTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::TypeAttr type, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(value);
  odsState.addAttribute(typeAttrName(odsState.name), type);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::Type type, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(value);
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CheckTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Type type, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(value);
  odsState.addAttribute(typeAttrName(odsState.name), ::mlir::TypeAttr::get(type));
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckTypeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CheckTypeOp::verify() {
  if (failed(CheckTypeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps4(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult CheckTypeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::TypeAttr typeAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> fullSuccessors;

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("is"))
    return ::mlir::failure();

  if (parser.parseAttribute(typeAttr, parser.getBuilder().getType<::mlir::NoneType>(), "type", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      fullSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        fullSuccessors.emplace_back(succ);
      }
    }
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::TypeType>();
  if (parser.resolveOperands(valueOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(fullSuccessors);
  return ::mlir::success();
}

void CheckTypeOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.check_type";
  p << ' ';
  p << value();
  p << ' ' << "is";
  p << ' ';
  p.printAttributeWithoutType(typeAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"type"});
  p << ' ' << "->";
  p << ' ';
  ::llvm::interleaveComma(getOperation()->getSuccessors(), p);
}

void CheckTypeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::CheckTypesOp definitions
//===----------------------------------------------------------------------===//

CheckTypesOpAdaptor::CheckTypesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CheckTypesOpAdaptor::CheckTypesOpAdaptor(CheckTypesOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CheckTypesOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CheckTypesOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CheckTypesOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckTypesOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CheckTypesOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr CheckTypesOpAdaptor::types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult CheckTypesOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_types = odsAttrs.get("types");
  if (!tblgen_types) return emitError(loc, "'pdl_interp.check_types' op ""requires attribute 'types'");
    if (!(((tblgen_types.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_types.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); })))) return emitError(loc, "'pdl_interp.check_types' op ""attribute 'types' failed to satisfy constraint: type array attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CheckTypesOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CheckTypesOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CheckTypesOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CheckTypesOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CheckTypesOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CheckTypesOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *CheckTypesOp::trueDest() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *CheckTypesOp::falseDest() {
  return (*this)->getSuccessor(1);
}

::mlir::ArrayAttr CheckTypesOp::typesAttr() {
  return (*this)->getAttr(typesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CheckTypesOp::types() {
  auto attr = typesAttr();
  return attr;
}

void CheckTypesOp::typesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(typesAttrName(), attr);
}

void CheckTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::ArrayAttr types, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(value);
  odsState.addAttribute(typesAttrName(odsState.name), types);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CheckTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::ArrayAttr types, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(value);
  odsState.addAttribute(typesAttrName(odsState.name), types);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CheckTypesOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CheckTypesOp::verify() {
  if (failed(CheckTypesOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult CheckTypesOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::ArrayAttr typesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> fullSuccessors;

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("are"))
    return ::mlir::failure();

  if (parser.parseAttribute(typesAttr, parser.getBuilder().getType<::mlir::NoneType>(), "types", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      fullSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        fullSuccessors.emplace_back(succ);
      }
    }
  }
  ::mlir::Type odsBuildableType0 = ::mlir::pdl::RangeType::get(parser.getBuilder().getType<::mlir::pdl::TypeType>());
  if (parser.resolveOperands(valueOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(fullSuccessors);
  return ::mlir::success();
}

void CheckTypesOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.check_types";
  p << ' ';
  p << value();
  p << ' ' << "are";
  p << ' ';
  p.printAttributeWithoutType(typesAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"types"});
  p << ' ' << "->";
  p << ' ';
  ::llvm::interleaveComma(getOperation()->getSuccessors(), p);
}

void CheckTypesOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::CreateAttributeOp definitions
//===----------------------------------------------------------------------===//

CreateAttributeOpAdaptor::CreateAttributeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CreateAttributeOpAdaptor::CreateAttributeOpAdaptor(CreateAttributeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CreateAttributeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CreateAttributeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CreateAttributeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr CreateAttributeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::Attribute CreateAttributeOpAdaptor::value() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::Attribute attr = odsAttrs.get("value").cast<::mlir::Attribute>();
  return attr;
}

::mlir::LogicalResult CreateAttributeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_value = odsAttrs.get("value");
  if (!tblgen_value) return emitError(loc, "'pdl_interp.create_attribute' op ""requires attribute 'value'");
    if (!((true))) return emitError(loc, "'pdl_interp.create_attribute' op ""attribute 'value' failed to satisfy constraint: any attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CreateAttributeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CreateAttributeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> CreateAttributeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CreateAttributeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CreateAttributeOp::attribute() {
  return *getODSResults(0).begin();
}

::mlir::Attribute CreateAttributeOp::valueAttr() {
  return (*this)->getAttr(valueAttrName()).template cast<::mlir::Attribute>();
}

::mlir::Attribute CreateAttributeOp::value() {
  auto attr = valueAttr();
  return attr;
}

void CreateAttributeOp::valueAttr(::mlir::Attribute attr) {
  (*this)->setAttr(valueAttrName(), attr);
}

void CreateAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Attribute value) {
      build(odsBuilder, odsState, odsBuilder.getType<pdl::AttributeType>(), value);
    
}

void CreateAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type attribute, ::mlir::Attribute value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  odsState.addTypes(attribute);
}

void CreateAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateAttributeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CreateAttributeOp::verify() {
  if (failed(CreateAttributeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult CreateAttributeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Attribute valueAttr;

  if (parser.parseAttribute(valueAttr, "value", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::AttributeType>();
  result.addTypes(odsBuildableType0);
  return ::mlir::success();
}

void CreateAttributeOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.create_attribute";
  p << ' ';
  p.printAttribute(valueAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"value"});
}

void CreateAttributeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::CreateOperationOp definitions
//===----------------------------------------------------------------------===//

CreateOperationOpAdaptor::CreateOperationOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CreateOperationOpAdaptor::CreateOperationOpAdaptor(CreateOperationOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CreateOperationOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CreateOperationOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange CreateOperationOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange CreateOperationOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::ValueRange CreateOperationOpAdaptor::attributes() {
  return getODSOperands(1);
}

::mlir::ValueRange CreateOperationOpAdaptor::types() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr CreateOperationOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr CreateOperationOpAdaptor::name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr CreateOperationOpAdaptor::attributeNames() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("attributeNames").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult CreateOperationOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 3)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 3 elements, but got ") << numElements;
  }
    {
  auto tblgen_name = odsAttrs.get("name");
  if (!tblgen_name) return emitError(loc, "'pdl_interp.create_operation' op ""requires attribute 'name'");
    if (!((tblgen_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'pdl_interp.create_operation' op ""attribute 'name' failed to satisfy constraint: string attribute");
  }
  {
  auto tblgen_attributeNames = odsAttrs.get("attributeNames");
  if (!tblgen_attributeNames) return emitError(loc, "'pdl_interp.create_operation' op ""requires attribute 'attributeNames'");
    if (!(((tblgen_attributeNames.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_attributeNames.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'pdl_interp.create_operation' op ""attribute 'attributeNames' failed to satisfy constraint: string array attribute");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> CreateOperationOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range CreateOperationOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range CreateOperationOp::operands() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range CreateOperationOp::attributes() {
  return getODSOperands(1);
}

::mlir::Operation::operand_range CreateOperationOp::types() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange CreateOperationOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange CreateOperationOp::attributesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange CreateOperationOp::typesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> CreateOperationOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CreateOperationOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CreateOperationOp::operation() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr CreateOperationOp::nameAttr() {
  return (*this)->getAttr(nameAttrName()).template cast<::mlir::StringAttr>();
}

::llvm::StringRef CreateOperationOp::name() {
  auto attr = nameAttr();
  return attr.getValue();
}

::mlir::ArrayAttr CreateOperationOp::attributeNamesAttr() {
  return (*this)->getAttr(attributeNamesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CreateOperationOp::attributeNames() {
  auto attr = attributeNamesAttr();
  return attr;
}

void CreateOperationOp::nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(nameAttrName(), attr);
}

void CreateOperationOp::attributeNamesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(attributeNamesAttrName(), attr);
}

void CreateOperationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, StringRef name, ValueRange types, ValueRange operands, ValueRange attributes, ArrayAttr attributeNames) {
      build(odsBuilder, odsState, odsBuilder.getType<pdl::OperationType>(), name,
            operands, attributes, attributeNames, types);
    
}

void CreateOperationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type operation, ::mlir::StringAttr name, ::mlir::ValueRange operands, ::mlir::ValueRange attributes, ::mlir::ArrayAttr attributeNames, ::mlir::ValueRange types) {
  odsState.addOperands(operands);
  odsState.addOperands(attributes);
  odsState.addOperands(types);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(operands.size()), static_cast<int32_t>(attributes.size()), static_cast<int32_t>(types.size())}));
  odsState.addAttribute(nameAttrName(odsState.name), name);
  odsState.addAttribute(attributeNamesAttrName(odsState.name), attributeNames);
  odsState.addTypes(operation);
}

void CreateOperationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr name, ::mlir::ValueRange operands, ::mlir::ValueRange attributes, ::mlir::ArrayAttr attributeNames, ::mlir::ValueRange types) {
  odsState.addOperands(operands);
  odsState.addOperands(attributes);
  odsState.addOperands(types);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(operands.size()), static_cast<int32_t>(attributes.size()), static_cast<int32_t>(types.size())}));
  odsState.addAttribute(nameAttrName(odsState.name), name);
  odsState.addAttribute(attributeNamesAttrName(odsState.name), attributeNames);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateOperationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type operation, ::llvm::StringRef name, ::mlir::ValueRange operands, ::mlir::ValueRange attributes, ::mlir::ArrayAttr attributeNames, ::mlir::ValueRange types) {
  odsState.addOperands(operands);
  odsState.addOperands(attributes);
  odsState.addOperands(types);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(operands.size()), static_cast<int32_t>(attributes.size()), static_cast<int32_t>(types.size())}));
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  odsState.addAttribute(attributeNamesAttrName(odsState.name), attributeNames);
  odsState.addTypes(operation);
}

void CreateOperationOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef name, ::mlir::ValueRange operands, ::mlir::ValueRange attributes, ::mlir::ArrayAttr attributeNames, ::mlir::ValueRange types) {
  odsState.addOperands(operands);
  odsState.addOperands(attributes);
  odsState.addOperands(types);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(operands.size()), static_cast<int32_t>(attributes.size()), static_cast<int32_t>(types.size())}));
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  odsState.addAttribute(attributeNamesAttrName(odsState.name), attributeNames);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateOperationOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CreateOperationOp::verify() {
  if (failed(CreateOperationOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps6(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult CreateOperationOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr nameAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> operandsOperands;
  ::llvm::SMLoc operandsOperandsLoc;
  (void)operandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> operandsTypes;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> attributesOperands;
  ::llvm::SMLoc attributesOperandsLoc;
  (void)attributesOperandsLoc;
  ::mlir::ArrayAttr attributeNamesAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> typesOperands;
  ::llvm::SMLoc typesOperandsLoc;
  (void)typesOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> typesTypes;

  if (parser.parseAttribute(nameAttr, parser.getBuilder().getType<::mlir::NoneType>(), "name", result.attributes))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalLParen())) {

  operandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(operandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  {
    attributesOperandsLoc = parser.getCurrentLocation();
    if (parseCreateOperationOpAttributes(parser, attributesOperands, attributeNamesAttr))
      return ::mlir::failure();
    result.addAttribute("attributeNames", attributeNamesAttr);
  }
  if (succeeded(parser.parseOptionalArrow())) {
  if (parser.parseLParen())
    return ::mlir::failure();

  typesOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(typesOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(typesTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  ::mlir::Type odsBuildableType1 = parser.getBuilder().getType<::mlir::pdl::AttributeType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(operandsOperands, operandsTypes, operandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(attributesOperands, odsBuildableType1, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(typesOperands, typesTypes, typesOperandsLoc, result.operands))
    return ::mlir::failure();
  result.addAttribute("operand_segment_sizes", parser.getBuilder().getI32VectorAttr({static_cast<int32_t>(operandsOperands.size()), static_cast<int32_t>(attributesOperands.size()), static_cast<int32_t>(typesOperands.size())}));
  return ::mlir::success();
}

void CreateOperationOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.create_operation";
  p << ' ';
  p.printAttributeWithoutType(nameAttr());
  if (!operands().empty()) {
  p << "(";
  p << operands();
  p << ' ' << ":";
  p << ' ';
  p << operands().getTypes();
  p << ")";
  }
  p << ' ';
  printCreateOperationOpAttributes(p, *this, attributes(), attributeNamesAttr());
  if (!types().empty()) {
  p << ' ' << "->";
  p << ' ' << "(";
  p << types();
  p << ' ' << ":";
  p << ' ';
  p << types().getTypes();
  p << ")";
  }
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"operand_segment_sizes", "name", "attributeNames"});
}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::CreateTypeOp definitions
//===----------------------------------------------------------------------===//

CreateTypeOpAdaptor::CreateTypeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CreateTypeOpAdaptor::CreateTypeOpAdaptor(CreateTypeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CreateTypeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CreateTypeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CreateTypeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr CreateTypeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::TypeAttr CreateTypeOpAdaptor::value() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::TypeAttr attr = odsAttrs.get("value").cast<::mlir::TypeAttr>();
  return attr;
}

::mlir::LogicalResult CreateTypeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_value = odsAttrs.get("value");
  if (!tblgen_value) return emitError(loc, "'pdl_interp.create_type' op ""requires attribute 'value'");
    if (!(((tblgen_value.isa<::mlir::TypeAttr>())) && ((tblgen_value.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())))) return emitError(loc, "'pdl_interp.create_type' op ""attribute 'value' failed to satisfy constraint: any type attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CreateTypeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CreateTypeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> CreateTypeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CreateTypeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CreateTypeOp::result() {
  return *getODSResults(0).begin();
}

::mlir::TypeAttr CreateTypeOp::valueAttr() {
  return (*this)->getAttr(valueAttrName()).template cast<::mlir::TypeAttr>();
}

::mlir::Type CreateTypeOp::value() {
  auto attr = valueAttr();
  return attr.getValue().cast<::mlir::Type>();
}

void CreateTypeOp::valueAttr(::mlir::TypeAttr attr) {
  (*this)->setAttr(valueAttrName(), attr);
}

void CreateTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeAttr type) {
      build(odsBuilder, odsState, odsBuilder.getType<pdl::TypeType>(), type);
    
}

void CreateTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::TypeAttr value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  odsState.addTypes(result);
}

void CreateTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::TypeAttr value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Type value) {
  odsState.addAttribute(valueAttrName(odsState.name), ::mlir::TypeAttr::get(value));
  odsState.addTypes(result);
}

void CreateTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Type value) {
  odsState.addAttribute(valueAttrName(odsState.name), ::mlir::TypeAttr::get(value));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateTypeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CreateTypeOp::verify() {
  if (failed(CreateTypeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps4(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult CreateTypeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::TypeAttr valueAttr;

  if (parser.parseAttribute(valueAttr, parser.getBuilder().getType<::mlir::NoneType>(), "value", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::TypeType>();
  result.addTypes(odsBuildableType0);
  return ::mlir::success();
}

void CreateTypeOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.create_type";
  p << ' ';
  p.printAttributeWithoutType(valueAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"value"});
}

void CreateTypeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::CreateTypesOp definitions
//===----------------------------------------------------------------------===//

CreateTypesOpAdaptor::CreateTypesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CreateTypesOpAdaptor::CreateTypesOpAdaptor(CreateTypesOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CreateTypesOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CreateTypesOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CreateTypesOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr CreateTypesOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr CreateTypesOpAdaptor::value() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("value").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult CreateTypesOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_value = odsAttrs.get("value");
  if (!tblgen_value) return emitError(loc, "'pdl_interp.create_types' op ""requires attribute 'value'");
    if (!(((tblgen_value.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_value.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); })))) return emitError(loc, "'pdl_interp.create_types' op ""attribute 'value' failed to satisfy constraint: type array attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CreateTypesOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CreateTypesOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> CreateTypesOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CreateTypesOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CreateTypesOp::result() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr CreateTypesOp::valueAttr() {
  return (*this)->getAttr(valueAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr CreateTypesOp::value() {
  auto attr = valueAttr();
  return attr;
}

void CreateTypesOp::valueAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(valueAttrName(), attr);
}

void CreateTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ArrayAttr value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  odsState.addTypes(result);
}

void CreateTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ArrayAttr value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateTypesOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CreateTypesOp::verify() {
  if (failed(CreateTypesOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult CreateTypesOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::ArrayAttr valueAttr;

  if (parser.parseAttribute(valueAttr, parser.getBuilder().getType<::mlir::NoneType>(), "value", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = ::mlir::pdl::RangeType::get(parser.getBuilder().getType<::mlir::pdl::TypeType>());
  result.addTypes(odsBuildableType0);
  return ::mlir::success();
}

void CreateTypesOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.create_types";
  p << ' ';
  p.printAttributeWithoutType(valueAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"value"});
}

void CreateTypesOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::EraseOp definitions
//===----------------------------------------------------------------------===//

EraseOpAdaptor::EraseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

EraseOpAdaptor::EraseOpAdaptor(EraseOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange EraseOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> EraseOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EraseOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EraseOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr EraseOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult EraseOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> EraseOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EraseOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EraseOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange EraseOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EraseOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EraseOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void EraseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operation) {
  odsState.addOperands(operation);
}

void EraseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation) {
  odsState.addOperands(operation);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EraseOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EraseOp::verify() {
  if (failed(EraseOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult EraseOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void EraseOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.erase";
  p << ' ';
  p << operation();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::FinalizeOp definitions
//===----------------------------------------------------------------------===//

FinalizeOpAdaptor::FinalizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FinalizeOpAdaptor::FinalizeOpAdaptor(FinalizeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FinalizeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FinalizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FinalizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr FinalizeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FinalizeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> FinalizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FinalizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> FinalizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FinalizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void FinalizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {

}

void FinalizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FinalizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FinalizeOp::verify() {
  if (failed(FinalizeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult FinalizeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  return ::mlir::success();
}

void FinalizeOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.finalize";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void FinalizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::GetAttributeOp definitions
//===----------------------------------------------------------------------===//

GetAttributeOpAdaptor::GetAttributeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GetAttributeOpAdaptor::GetAttributeOpAdaptor(GetAttributeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GetAttributeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GetAttributeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GetAttributeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetAttributeOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GetAttributeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr GetAttributeOpAdaptor::name() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("name").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult GetAttributeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_name = odsAttrs.get("name");
  if (!tblgen_name) return emitError(loc, "'pdl_interp.get_attribute' op ""requires attribute 'name'");
    if (!((tblgen_name.isa<::mlir::StringAttr>()))) return emitError(loc, "'pdl_interp.get_attribute' op ""attribute 'name' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> GetAttributeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GetAttributeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetAttributeOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GetAttributeOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GetAttributeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GetAttributeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetAttributeOp::attribute() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr GetAttributeOp::nameAttr() {
  return (*this)->getAttr(nameAttrName()).template cast<::mlir::StringAttr>();
}

::llvm::StringRef GetAttributeOp::name() {
  auto attr = nameAttr();
  return attr.getValue();
}

void GetAttributeOp::nameAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(nameAttrName(), attr);
}

void GetAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type attribute, ::mlir::Value operation, ::mlir::StringAttr name) {
  odsState.addOperands(operation);
  odsState.addAttribute(nameAttrName(odsState.name), name);
  odsState.addTypes(attribute);
}

void GetAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::mlir::StringAttr name) {
  odsState.addOperands(operation);
  odsState.addAttribute(nameAttrName(odsState.name), name);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type attribute, ::mlir::Value operation, ::llvm::StringRef name) {
  odsState.addOperands(operation);
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  odsState.addTypes(attribute);
}

void GetAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::llvm::StringRef name) {
  odsState.addOperands(operation);
  odsState.addAttribute(nameAttrName(odsState.name), odsBuilder.getStringAttr(name));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetAttributeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GetAttributeOp::verify() {
  if (failed(GetAttributeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult GetAttributeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr nameAttr;
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;

  if (parser.parseAttribute(nameAttr, parser.getBuilder().getType<::mlir::NoneType>(), "name", result.attributes))
    return ::mlir::failure();
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::AttributeType>();
  ::mlir::Type odsBuildableType1 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(operationOperands, odsBuildableType1, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetAttributeOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.get_attribute";
  p << ' ';
  p.printAttributeWithoutType(nameAttr());
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"name"});
}

void GetAttributeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::GetAttributeTypeOp definitions
//===----------------------------------------------------------------------===//

GetAttributeTypeOpAdaptor::GetAttributeTypeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::Regiœ$C»fÈ™y{ÙzÓ:)R*cnÏ®÷œd&¢›F∑¢v⁄ù%é£Ó=˘çt„Å©P^?Ô®-$ﬁG§£Á„}&€”Ò‰g˘¥$“1MµC¡é¡Sb√æïc˛`≈¸gUC÷ÔKöXj+{“G%l<@Ω€0XxmÍeº≠Q)–igÚu@)^o˙…¡a'D¸⁄`>ö„·—xz©∏±ây&1NzÔ‰IW”y§U|j'Ωl	TDÓpıÓaÓbHÇk&Ω#;NÓÆ#U—$(qLı“]B€SvzNÌcÊQdi}Õ∆O±G7qmÎf“!ÁPkW.gWª•…Oh{«È˛˚N‚ÜÉ¨™∂ÈNË?zK˘≈∆ºmKg≥$≥G…wÅ ra"œïıú\ÿöRd¬›|$O0Ä)«W*páUﬂaÁ0sr
·*n$“ttbpIlBÖ1LI†ﬂ‰vtGF YÙ’ ü‡u0;ufsÉ”f9‰)≤î÷wÓN¡$õ∏¢GÎ8ƒP"OïZ"O¢JÁgñ∂R\3œﬁ:C≈µOFôŒ„ß⁄(d6[ZC—l√Z⁄¨U˙ˆd—™oCﬂÓÕ(√’ÆlÌ rOê Ù)⁄”Hø?cOıè›qKZ,\∫Aπ=ÌK˙6ó1a5≈rÏÒuH-Í-Iò”b+`Ü’m‰úÙ7¬cBöˇ›˝˙öé•ƒîÌÌ^ä@Ìåom"›opi·Ôu∆¡’J¯}‡ù~˚îCíjYÍ¯◊œqWTˇ˚@=:=¬g∫4[GfﬂPAh6…E#l/˙P<<c‰J#‰LVÈ5def˛¨´¥~Á13[≈}¶‘¢ã∆◊ÆXÄU”Gúd!UbÄ≥˛qÔ∂OqhñæIÊ•5÷¢ıå1Ûò”l:Ó8†± u†$EY¬alˇxÏ”HB†^Ò‡`”b$ÏÛg⁄5£‚‚K·2àN[KÁ∆a(œÅ.f•<a•$â3C˝’—◊j˝E~u<˙æ`drrO^=sI8^ºMöóõ>v„Î`$g>D£uÎÇq†5íEoE◊ør0>Çx=¯$9V#xPŒ¡@Ójp?–¿dÒF¸˜I~'VÂaÌV\,=(π·Ëk"AI<_éá X‚√—DÎD{eI›äZΩ˘\øcpS*,d´I_$≈r}˙‰U∑´|æŒ@&˚U¬P;Ù#?ub{j"À;ÏÌ
>-“_5`†Â§;âƒFz9ß,˙?ä™DU,krgı?ˇmàq1TÂﬁGÚÙc¸Lb]pºdá}˝|7“H}‘›Q˚Éƒ&˛ûÀ—π°+r¢0zl mÃ¯
ÃÆ·Ñä<,º
a5—Í∆r˝xw+ £Â¿»“¿JWpCtƒSÑ®™»Eˆ⁄*Ã∂L›ÙicvY≠ó‹‘‡)O/daùl ísˇN‰ˆ∫›{ﬁkX¨ywı\‡öàkù0}ïæw¶G√ì$aß*O¸bò@G
fËœ≈øKhπñ70vySkI≤Më pÁƒ]∫ yN≤[s,ñ¶¿W~3LÍ	iUDe9
4<ç8®9z·ÎÖZ;¯˜kJQRgX Q‘¸å¬{Æ$LÇÔV¥
/zmH`u®U7)#˘:ÖÊØubHrÿı¬fp¡ä^kŸ>µ9Ï9n'ÕÌU≈+=X=$≠ˆ1ùÔ¬¶lÔqg .ı∫MªÁ@)[iÆf
f/sÂ|vIÂ8MA·#iÏZñLô˛)xSÈ]tÓB¢+‰B4˜‚à‡	b˙dÿi¡«€Çπ^Ñ±5rÀ]˚Îp%-~hÚªO‰W9‹1m”8$Ë∆wæ9:§ÅO¶ål E"[∞ ˆSskÊœËÙ¶UÌ≤ıd4ª]d{_*π$¢a˘·”p¶Ïﬂ*Ô[HV«µÙ
fÏUu¬ÒbÔØ¶VRÛ¥X!äÁu˜ˆê”QCX/Í· GnÕœG_ÕJ.˛ﬂÃ{Ò*Ü∞jŸ˝BdÒÎ˜PZ≥:.ÉD‡œYŸ rß„»Â5©∆U∆¡RGΩf¨÷âv'w_¡#·|ye8D]Ó…xb/†√hŒ Eò2lÚŸS–ÆCMüÁ∞G––`g/ª„±Ba‰®ô≤˝∑‚⁄2a\€Ê&Ü8œ.⁄VÏ{-i}ıM7v!·FcyÂkàiCu˘âttn%8`(ò⁄8^D?Õ”° ‹@V.Øg…)€lm!ea(@:F†êHJ–\FS’6É«®tRë˜1|¸≥7+ÅkBòÃÃ#™ÔOÛuw¢ˆ™‘ÜL	LÉyo¥uô«lH*æ(¢6¬!*l-e„ßÓ‹nV+õƒ{´Ër◊}ëJæÄ«F˜˙d µ¬¸.U=G·?p!‚û°ú‘Ò}a‹5òÊq¶°|ÚYFp3ZèÁp–∆≠kﬁÂÈò»qe∫√A‚@yˆF5F#CÓ{aÊ Ü/8ÊLñx d±)j§ÔUNyRjÈ[·nALuÔ†îsÚä‘Ï:∏B§”0!gpÎºiL˙e…«MX|ˇB /?4ê$eñI¥d2≈$_NeÚúF5∂;î
$óOgzïÒ+Ù∂_≠cnUÎÆiÕ\u≤Ë%ÏcL<BãL∏}ñ~b,}Paás£˛°Ô?ÓæÂÛfÎ∆∫nábÔå®ﬂÓ c\y°{¶Ìp≠´9h
Ê÷⁄b&• TAÆ≤fSl7î°wÒetdh”ác‰ä0—3ﬁƒ˜JNˆîi}. `£MP¿,á,.~)‚3œª.Çb!	=  YS`Ç3-={'®’≠Kjfoı≥Á≠dÕ3⁄€«˚ü}c_⁄ggªœ»RΩã4b‰õo—»E'M-OçÅñÆÉÔ!˘€5[√ègE∂sá•7Ÿ^=à (m&ÍÏ¬r	nh8IuTe•'A$uyõ˙«z}º-[£hKŒ…g°È¶Á-ms(d™{oxûv>≤°ZOwÃ≈&ÊvåElq °Ê¿W‚Èf®ƒÔf¸∫Zæ˙É†cπ]ıßÂˇ|i~‰Dj!«Û|“vÎt0*…	U√òÉJ–a„J§`wçeF}©‘wÎÏÜq¬∞‰RïçÄ≥¢/Ì*üxiW`T6Â¥]Í
Uc˘ë-ÂfAU<Ó{˙KÆå#-ÇÎ˘¨„ a)jfI«≠´è.Yku	m<d1$(Õë’qæ‘“^Õgí˜/JÁÊFBQ6d≈\O8\Sn¸[.¢|^q∞VˇCEqæ¸†I M&Ù—?ËK'Íêp‘w ”≈|LÃ5æ‡¿Omt/‹ 0CS40kŒ=Ë ∫<ÊÌ˙u2+∫o‰fukÀ·É¿Ú¶$√WÎlÂ»bƒ,⁄∫›™iq®f9’pI‡"&‹{N4	dR çvs1™
ÌÕs∏~z<ˆmhAvŒ‘PË°2YFä^≈“ÂC0˘®≠owzá-‹!Ga’˜˙c81ü-±nÖs3—7§„≥"r‘NÕ:¨∏>Ôj˚0æw*¯Ã.–∞mV∏„€yeª’‘j¢tÛk«©ôævtp˛[b4ˆu\y”A¶–êâ–g<Mx/:ül…πîz  FkIFW–±¢`Ú««ˇı2ãÁÔIû:›nk“8÷D®µˆÎØDô$h≤˜ÑeVsi|¬~ƒ›vm y/Rn’J˘o«£w®Â("÷–<nV˛p¢œÉ‡ B¿ÚZQ>Y6iêwBSFıﬁ50F1#Nqc≤V	˜?h˛“Ou·€Cj9NLvI"Â+ÔÅ«)ˇÔëz\g[_‰˚)T8–Z‘ÿkÎÌ9ÄÔ∏®4Ê#*ç"¢J»ÔÍ8<”¶(Ù1ı†d‰¿ÎoêQ≈CF–SAó„A$m‘6a˝§vid"|^aﬂ<ú pÂ≈4°qÿ·#l?q[7«˘úØ‹	J0ÛK≤ı¯˝K˚r
;r|À¬œl®
GÓ«	Ω⁄Æ 6'ˆ@LuÂvÇö∏ *qÚo#∞¢QcV≥ˇ8?9t•n1≈$-àVì4JjÁ™ö´úçh 6∫Z€X%d’ÿÂÔÄ@TƒO<⁄aq\º™˘/à»€xìËÎ√p«ç“dÌE›v‹ƒm£(E^,:_›‘Ù|ÊsË⁄a¬ö8;GvØ-â∂ˇŸnE]:qK]8e)"GÂ–cÃ¯Ò≤—∂Ì`ı£ rÚ$NÒ’ÓÇtB™gΩªKBÏ/Õ>8{uë†ÏP†Ó™·Y%X„t`L€K‚⁄è˜-¯A–ìD"Wo™jc!!frˇR%ºˆ˛„(u|∫&€)ˇ∞Mçan&˝HìKÖ9flZˆgg›eoÎJ“©düAqıÓP°–‰Ù0Y∆T•˘k(K‡l‚!+Ï=è(!ÈÂïeópq=rd∏ÔTa7Ÿ„¶!&›{UÉt+sV‘ÛhøeÜÌ„ËÕÌ¨)Hx˛tÜÚ1[ª »:-Í	†˜JæîDπ∫’êÙD¯ ≈hd2∂}ba§]àÌÌÉè&;yâN‚UºØ‹Ö_z	1>me2NLıÁ„{◊i`dJÆ¸Ú˙Ïxãª@M\EX◊-:√j∫˜0z“hÙeÃà´{Ibú·∫g⁄Ù\*±6-`∂eÌf›≠v`~¿©√et`G≈$_r&&Œ$´$§4O't6≥{3ÒeÚ2í
FÌÛG¿ö/%\¢¢3*ºT”DT.≥,°´±#OO@VÄ:ΩkiICØŒ§FŒ∆·“uÖê¶2v}8¸i>D…xïEtDvÄ]ÿ?¸„l˝–ﬂ˝MAŸ;:âÏ})%éP~f‚˝òk¥•sk_ßﬁ¶›ÏÑÆîhv:0¬Ì6$oo÷Vz§#*JËWegÄg°v”iò˚:à˘·®ØB1Ä‡¢äL®2ÏUƒ]«MæÔ˛«ßƒ}÷Å/ApDàéxVÃ•s¨oS_Y!Cl&˙!âjµ~9ÓHWﬁj6"˘„4–48=“„gåRπ%"Îbws◊9¥¨(ôÆ∞Ycm‚)QNC‚hLX´æÅm%ãÔ.±ÊîÙwºtìÉ6R“VxFø◊)≠nW0uò$∫Bm€9≥Zk-Ø4,≈8˛q :†∂Z¡êãã·ìE%dX¸º„e°I¢¸DØ¯bynWíÆXVU@éGéF"p—+4JˆâS¿uÛdº!ŒÊıGwkXAªÕIHÎ$ºQpÚ§áS'Ú’≈s!ªp e¶ÓÀ!Î∂R„∫ªX◊ÑZ√&vÔ»"(ºS©{(i]6^U±â(æ)7ƒ™©gÅ§f’	ev›`–Qj-Á‡	€|MW_sSRÂN`f·C∏
H!B·o'i>ÙvWva(eQe‹Ë”tˇÚXGz[u&åo$EJË!√P*fÙ``^ß‘±4ÕŸ2ÙÓm∞„mwnp\%M)alU{õ∆˘âPkA8k2∆Ç˛c£≈y	êπ‘›ÚÒªÓPîY*(:G+–…0@ +3Úo‰}›˚ÇÀ£ÃF•d!&‡–IGeˇrn4Ó¢E.a∑xYiCnza∫ûØøuä#üéOÛz)÷K@n ÃŒ[≈¶1ÎC)Ü7˛Ó˚Ïvdﬁi0qUä˛	p A,¿∏jÚÿ˙{;n°Y1û†\ì¿ñ`˝`k`ó‡h-“}$$`o.MT%Ò#c®}ÿY2Õåï≤¸ñi≤qL(ñ€™ ):ûÔú·„:‹Qπ˝ËÍˇMKp–B23g&^f\¨pÛy—≈pßu`*Á\ÖHÈrSŒ°≤0{π“¢ZBzÇ∂Í0¢,n∞Q%˛Ù>\|E…Í1[*ÈL¥„5©º¯zjÛåiÆÏtÕbd±¡®gîg:~\ µÁ"Xap>Õ≤[ùõ∑P…,C"=†w:\e<∫vZÌ_(§Ùº]i)†!—uD<pDjÚòÅå0îø+â	ÙmÀCÿÖ#ÎañuRc¢KïSHN8RS›[5™‹tfîHŒwqÙ¸5-*[ÎVB9è$àH"RÌpù¢O‚rx@ñY3ZÀ∂aJfÛ8å0¶ªNnã‚@#Ê%P∑dakJ]^Èg=NÒ◊´UÙµ^JR⁄Ïd÷Ó]‘ê!…Y∞:e‚êÄù{‰Ò®v ˙==UópS«öAﬂp)≤I∂ÔBC°s•≤«s˙j!p\ı–;(Û;‡pJ≤vpâì0LÏ)È(Ûo[czœ5»èóZÎÈId≠CÙS™vÌˆut3ïLe4ÈFÔyVt˝/…í}~‚‰v’lw7„<Ì&U¶ÔQOÎM§8∆Â7;≠î0ÔÁ…t-dÊ€oµFn
ó-Ê†'MDm¯rFU=;Õ’Æ÷‡Tº»b¢ßËîf>ø§—ê®ÂÛ›>)≈^ùıàlD˙”≤o,}^kvg∆ö∫o¢Ωﬁo~dNæ~A^∫û\u‰/±ü4≤- d≥3)
…MÓbLaÕ‡TA∆Ì]ñ¸jÌ√I|RŸ_Ÿwı4∆üÖ”ı»B˝.Fƒbﬂ◊rLz:ÁÌ™YuaÑ†é@.©€≥v√¡d 0eTﬁÏcÆÄyä(¢t• ‹7évVÌó‘–˘0Mn]e∂kámŒE˛π€<\¿∏:"ÑXÁ∑ÉlTj?,ªM3-OÌ‰Eáe(÷b´›ˆÛ`nFLÔ&V€lı˚f%·˝D∆©)%ÖS‘ft¨,•eö4¯Ωt˝¶b=,Gf˙ËÂ¥h #%kzÂ`UØåfö˝ùhy€´s∞R‡V¯™)¢ÿ«Jkh’H	?õÍ
™nZóÚÔUø#1vA¢z÷|'*6o®W¥GÖ∑ o˛s)#5G‹-gYS8¨†.¬v:∆Ûh2£k¡NK‹PgNùì—Äv˘£"Â´˙ í`f&˙3òdﬁH~§D–rew}^¡_D¿Ij|‰em|˘˙Ëw⁄§b[`W¨m2£—yŸ*QlÙ[ÂßB j0ño]fµûHˇ2êL◊ñCh∞}dm©™l’eGpxJ\HX ;`+Nb§……BQ«fjFÆ∆:9loG≈%‡xKP\TT”Ëó©≠⁄sÜÔC(P%0WıL‘gØjq+ı\ı€˚&a‰ÕÓ·ËÙ‚Ê®[d¿ŒO;ÛSKkûn s_ñxc2^·"7∫iÃ“(åˇciÃjƒÙ¡,6Z√ÓñHú:D`©Z= bBÂM@"œ#ueﬁ™‚vﬁkπZ\-C≤π.©°±/l˚H ÉQÎp3FNß™K'ˆR
«j‰tt‡tN∆««wﬁ˜‘1®2pôI|„)≥"ÿ`…•l¿„qo4…d†ﬂÕø◊>—k	*]√bi˘Âjº
gdMÛ‰Yo∏h˙ÌTÎ,E)POh¯⁄=OL(¡¡@y¨éƒLÛn◊À$(=Å@C†Z94√Ë)BÓœ<¢Øù-çªæÂ9m	--§÷*!}≠µèúíıæ!ÊÎÁ†sNg=˝ﬂ˛ºÕEh/•oŒq≠C=Ü3g>-≠ÍØ8«5ÏMz’!:;4D«^Õ..nçGaŒ<ç4;8nóƒI¿s`ÿ?Ecn$CΩ™xMw-ÎxÉ ‰¶Æï&)	e›®ÎÒ?•çM«S]áÖ≠vÁI!∂	9-«A'&øùØèøE3/≠Ø§+ Û§jÂøãÑ∂7%Odm+§'åL1#‘√[A≈¥Ö¢©¥/Û™
E◊)ytƒa`cÁó@¯mK\Ká˘C«CHN2A`≤FVß˚=∞8,%QFz‹DyÚÂ%Q«W˝∏c7G{≠Äänmä∏»
-µ|!>-ΩÍ¯Iˆ5r#è&,ÒP& º¢√˚!nœ˙}#òÂInJl°w°b¨Œ°…F£ÎÙ‘*c)WëdıMZÊ„.``Ìˆ◊g«"*—˝À∑ˆ°âÁù®[+(∑D2bÁ0°Ó<c*˛pØYOOsbŒéh{æ4ÂgIT«$Ê‚t÷œ?ﬁ3eÖLñP√S;:ÁaûÙŸomË^gU7íe–9#ñï6ÍÁk_@–5hyyÃÈ˚<»Oâ0î¢ÆFwN¬Î¯µ#”®∆‡Óüà=Êv±R©◊Ÿ{!	§êdqÖ∞∞#r˘#°—Ô¡∂Ó[î∂Ú	œˆE/¢”=Òå$u¶r;°w=ha(ÜıÂ⁄›@ZÛ≠]Ìÿ6Ì*1f¢∞ıò
ºÑ;wçíº^}˛ÒjxÓ‹ÃÊ„ûuÃ„ÓD˝Sq·qDè${œÎÙNxÖÛÙ%™äãÓtk§,?ÚHd‡vÁs7Iú Ud«{≤˘Vƒí{4˝zÿ∫cvò6g´í°<sx)‹æ‘dﬁ°Á¯Y)ˆÓ≤A9-5KÓ!ZÒ§
`wNxB˝∑%LÏR;Dºg¶€ÒW&ó`l¨ËDaﬂÉ∫Nd[nSvd+Çπ©π<œ4z/Ñ·'¯"cf?ÈŸaÕO8gøcNL˜*pP3hÚﬁØ1ruºô„+#ÙÌ∆G≈ë¢⁄Ue—‹°Üa^#v} Ç»j$…2<;XÍÚÎﬁ7ÑOíc`ß¬2}C!éÌV—or<∑`G·&¥u' S£˚;ˇ#É>uox(+^«¨≤)/ByÇOû ≥Òùñie.gw-DÅ|n„G”è4p∏`Ê‚≈˙iGFpôMzS¯V-@`Ïı´9÷SÏlk»Û/yfÛVD⁄y¬Å≠hRi&i	r)dUeÛhΩPIÿ0î´à£Pì‰¬¬% "{~¿ *»\Ã|aId≥ÁqÃ‚,tt1dPt∑¶gH™G]M]-Éwj—->∏v†Æ¸9P˝„]≥=e?˛b„AoHLj1≤ΩòíK.yEªÿV§ôŒÖÿQåj’°rd?nŒZÕcÁr‘j›uÔ:‚Udå‚ÉIk9ÂÏAw√,ÎGÃ8WtÓI¥œ˙3AcÑD=,§†•ÛEÀI-Ò+ü¬ qy-f”¡!Q‰n~—uaJmîKòª≤-5Dén~w3Âw¿”ÀNaÏr}ë0DıbEìˆ8‚{ÚZM¨1˚™ }w≈ƒe"¯K)ärdrX;6k}´Ñ∏çÕãU˙.ÂÁD∏‚1ÚNÚ<òâÜÕvnÁA¶c„'´hÛìÖ~ﬂ˜ˇ÷|SvΩÕyÆ2%à ¯Û_‹4fsH˜l„eıSo 2RSÍTæ6kLHgÂ†Øp√)∆≥é™iÆ‚{K¸.8.2t«9ÁèY˜6 <ooNGÙ{Ü6k!±Ò&?ÌWtÎ¶d‚≈.ê˜`ö+áË¥5 òGô8¯qqÔõh∆Ù5xgNj't©≥cÂ`)î—©fœL—QZ®úv1Ã«r‡íh{úm1z1‚&óÇ lŸûÎô,VJq§⁄r‰ISÕ*E0âpYæ|Lmj&go3w¿Ê\‚Ã‚ŒHÉBt:ƒ)√HFK@{l|â${1ü‘Éﬁdf∆≥÷Ñ'Na0WËRã’e+€;“KÒÊ Í
wÃ)/g,YÃc(8§∫[ÔéMJ4ËHèÔ≠_$N≤‡ÓÏ•“!‡9M§ë]ÙΩ!g\»59±ªäUxv-Î∏Mƒœ!x©Ä@u•™GÛJk«~àÕCÑXhUºòL
6ª*e“—`=_KÈr©[T:D(‡£óø≠#9`ÍÏÚ96@[1	≈p∫≈≈;›fD()s<n˜Å1!&¶⁄T˚s∏$®–h%Eu+á™ﬂÆ+Odâ˚c0’™£‹Ó_ñ©‰Oaå,bÓfãûêöfÜ#Ù}h807T¿Ú59«ııÓa {dÀ“cÔHe3û@∆}e‰Ò»J 4ÄuÃ5OoI~zuH]√s¨¥ZÌn∫CÇzY‚E,≈b8‡•Ügã±ÓjkR 8kë~jÚDR8:¬aÙÌˆÓoGÆjm%]DFÖc˚n}NÍÕ(U_ÈQ•Û·ÖiW<á)€äõ0Ò¸´MbCTâë|ÛËÏooë-FLòk¯«QlØ©ÀOÃ~à%Å¸ãzx±hkl˙?gK2÷π3î…e"O£ßH˝ütŸ¢Se¡C√Õ◊Œÿ§ız#  qÿ(˛kÍÉG&&‚læBè68i¥¨7≥ ¬G˛=ı
-™Óh>jhbÁ_{≈"ˇSÍú ∞n≥/Ag´3«ÁvVv …ÃmÇˆJ≠•€™õΩA®ÇCLm⁄˚eoË'oòKddﬁc·M{À.Üq‹´nFÀÎqå≥ÑJAıÙ\âˇï KX]&/x¨∞;eÄY>Eà≤WoáÕÒb∂¡D;)È◊.¯6€Æï6l¢Gæñ&mÂW<º<ÖÊ` ˇhÛéh©m[—b÷AÉ¥’5⁄jpíP·}v™M£§¬NÅ ±Z+ˆvÆb†®·@Üı;CBf.®z"‡ÂdﬁBÂ_Õ)J,·o•‰»of<u÷QVhåxtI2wôäq]Ô§Ê &qˇLXdrƒÏeOFOXå:EN«œs˜ük≠sá€5äÀ&KÍ‹Ê®|&µ“yhYœYeΩNdvå›b‰
®. -°£†!-Ï¡6Oƒjˆ¯rÌ7◊‘◊ b4yg•†öÈ^∂◊sÖÛu|yæÅWì3÷v^ËÂˆª>œ(‹i>VŸ8˘d>∞Œá°⁄Ab≈mµb“!À.ècŸÀÌıì∏ˇÔ“Ù§[\Ÿ¸+™°¬U√7’¶˝~¸omNï≤mÏ6lÕ˛˝∆ú≠;r(1@f∆âˇ†Æ4CñêÔs±(}a` Ç¶+dkû À3à%£&–cË¿FIü÷¥vÆ™fÈ≠Ü&w¯ÿ≤N)]h#»	jyi¸z8Cricl¨®ú∂Íd&"›F=v~Z$o∑~ø˘tXbt©RNÌl=eﬁè‰#◊ge&œÛ•ÊfπdÚ3Y¥QUeAèÒs#gÑ˝cæ†•Œ;=L÷˛Yöiπu“s'eº7(-ò:älm D±•P)Ù!frtD)â_goÎaa!)|«‡+ö‚	∞pN)ÚÛ7Åm6sÃfr/‰D5?p}§’tJ'ΩlTÓqµÌal"&n.Ω£:nÔO#8Td(pDµZ(Í∫[.r˘cnYdiPn∆G≥B5q·tÚ%†Tk.g;Ö…I(CE`ˇKˇÊ‚Üe§"∑·O¯=i·u‹¶ºh0J#20; ŸwÉ¬qa1óı]‹>∞Vf¡ı,$o0ÅÈ=V*táVm!e0uI‰aÍ.Rdd„q!@≈?EM§ŸÙntgF‡yÿf’œùe902ufa¬“v9,1˜å7dNÒ§¡jGÈ:Dp"ï5¢Év6?!wZ\3Æ‹·` mµIB® ++¯ T7{WRTo„X⁄§qÚg!1ı£}√.‰‹#√’∞ i§NfodU+s¿hø?weÈæ;âdUGH,±AÈˇi˛6˜pq5ƒdê j,Í-j::j)p$”mÏÌÙ7ác*ûoºÃÆÖ¶e+≠1ËÓÓ√dåem"›otmaØ6÷GåK˙yi›í2K.Y‚Ô◊œ—W˜˘h=~}÷e;5 nhøDI(>[C&];rn8q‡[2‰'AÈt^ld>=,ã∂º∫+QsfÕeÜT£â*ﬂØh√ﬂ:ícúd)U 0óyy˜u!`t§æÊ•t¥3 †ëà1r∏”lmÓx§wAEWÂwtTMQj°yœ8LëHB‡|~∂‡"Ob%Ë£ÁZ5„‚‚KÒ:‡fSKÜ$Fq)ﬂa,v'lhµ&3mÙSS`¯qvw4a5Prg^1sÈm^,QzΩ7|ÀùpbdkzD£uD˚!Ò êEn≈&%ø30,* D~5°u9©pŒ¡¡Ógb>ŸbdÛ oû˜ip°WÒ{gˇL91=π!Ëk&Ec5_é«!PÚhWGêDÔdjeùà#ZÙ˘t6\+Sqh(böK$Dg}„‡Mµ*|æéPHI$s]¢C+ıbøUb{j¢ã;˝Ô
?—nπp¢Âºè¡fxΩ¢=?˛?ä @U$ker|,˜=Ôa±2tÙ^N‚‰(|@±8%b˝˝|1Ù‡n÷›QªèdÜi0>ﬂ—π1kr¢ÒZlÉ(é˙Ã/ŸTä4¨º,i5xÍ j{x/;%ÂÒXK¬‡Ã`¥ÚÑÌ™–≈ÚZ*\vLzQaigwY=Ñ\÷‡)N`·Ï™zk>e‰Ù∫
Yoﬁ+Z¨[7ur/öÄkY2lU˛s"¡ã$#ÁbnÙbêDÂjfﬂe7k‡9ñ7∞TŸTBK∞Mëap„ ]8"	ƒd∞2&.{¨¥6¿|˛!3DZçhUEd9!4◊;<} ‚Î•H;π7˚Kq cXó ¥¸®J:Æ$H÷Ôz≥@/z-LåO]Ì]$%#9$&çÍª±bHg˝r3 cpK¶pi≈:Ω6[‹Wz'Õ3vUçÅ£=x$e}œ6qM‰H¢|≠q'c.◊™)MªcB({h>&
D>QˇTrSq8L¡Â'iÃ8ñlúÓa|CÎîÓB£§B,˜b>:‡iSÚtâi˘«ô  Çø%Pû]˙„
5,:xz`πO§;L( -”∞g‡ 7Ó1 2ÂÅO¶X¸UE3€∞(ˆÛ{Ì£œÍ‰eé≥Õ≤’ 4'Ydsp"π 1 È±ÁrgiR8Ô“FFw˝fËŸtc`·˚ÆÍRD ¥X$õex◊Ï∫œCZ-Ë‡ A/ÀnvÈZ}ﬁ⁄Œu˜!Üpjà(Ú@`cw8òzµ(.ìF¢Í9MHvØo»Âi©ŒÕD√[_/d¨_	wºW#h#LA}{E8D’ÔÒôPf•i“`∆Jeú7x¢—Q`+K,ôgºC.@G/ªÂ(A)Ó*π≤Î7¢˙0q]…d¢é?.V‡q$y4±7e°ÌFj)
}ekà˚_|ˇilu*eö`(	h:2)”• MHr, gI9Ÿk%}¡(2F‰ÙZêFCˆ∑$Å‘¢¥s1πºˇ*2¥zFú$L.&(ÓJrqw"v™÷Üƒ‹{k’tõOl\†>x§rƒ!*,<%jÎ¢æ\ÊBk}≈{≥czv3&^k∂ÒbGD˜zd(¥“~?}«‡toﬁ°ú–±|)4˜ΩÊtÆ jb?H∆ 7/ÏùZrö«ÏKSÂ…∞HSu:∫Cj %7Dd!cŒy%~Ä,&=8¢HW∞tv•)m◊ˇ\xBÈﬂ1<d\uÔ"ÑbR√î¸Hr∏Ú®n⁄0èCpaº )M˚mÛ«,Xp?" .7tÙ4Üa¥d3ı%_cAÚûN%ˆ´ˆlo {µe#Ù¢LÌ!n@ÚÆiÏ='5(≤Ì%lgd6AJN∞\÷r,~u5«Ûª˛∞Ô=f,ü•È‚˜Œz|`lß≥®ﬂß+8q9{n,V∏‚ujy*‚óXÆc} ÑuË≤`Sh7ú33q!Œ8öl√ás„¬Q0A—5ö’„+m\ÍûéHYQ&Ó`‚EU‡,Ö<,@Ï3A∫z¡w7:	1q}Úµy
(‡B,∏a'ÒY}K*.eÒuÂ=eFìä∑«û¢}#€g!≥ÁÿPΩ⁄1`≈:n–Ë@´•!≠mñÓÉ≠ªé⁄0zÂgEosµ∑t∑I7^=â )mÎ•d◊
«m8AuPa§%D-aõÍŒ~x®/[£hKŒ‰c°·¶«our2dÓkx`Zƒ+≤°ZcôwÕÇgÊ¥Äeh≈!!÷ Ubµ>ÌƒÎdæ∫_:é†2π\cÂÂøBxi†FL!EìT°~yÂ	1!aãYpòÚRÄCÊ• ˝ùeu Ùw_Ω ¬q`∞ÙpúÖÇø:¢g8≠ñp(Wje4\Ó
1aÈÉ+çràVITú¸Yzk.c êÛE·∆X˚Ac;j§I√-´',Le5e}vk∏œëıªæ‘ñ\Õìˆe
ıÚFBudLO8\SÓ|x‡l^a≤vˇCEu≥|	4YJ∞I"ÙÛsÂC/Ïõîp]@w ”QÂrLÃ5æ‡ÑÔr‡zÃÍ8Z?4<{J?¯
9LÊÌ{U0+;À$ßq+KÛ…Ä˚Ô4Q≤l·¿`¡.d™‹*!q©d ◊EI‚"b9Ã{Nt5HD¢6(!*™ƒÕ=u≠~:<'ËbPdÃ¥P‡çd˘& ^Õe"C∏˘)Æ?`záû-|9oìƒ7‹09˜çq~5c%≥t∑§·˜6zp^>®˚7o˘›0º˜{∫ËÖ.“to^r„TàwÒ‡up’nb<ırOe∑>tpn˙b4ˆuMpY&––mºmY"tx¨âóX#%1FrAGwî±ÆhÚÜS˜µ2KømI8óg{‘9“/
L8ΩÏ°?eπ&+lu÷vs9O§^‰›:v[i q+XnUbˇ:œ„ı`•b:ò4oVﬁb"Õg¯A–Q<Ini4WBñFΩu~!+	0jÚV–˜]i]RGu˘ﬁb1&,N^
p'ˇÅ÷®Ò+[,NqXF·´∫ë8’ziãÌôoDÔ∞"ºÇ„:Ö&0LâÏ+84¶h∂1ı¢~•…x]úYEAC@s 6≠e4Ì‹7·)¶V,`+|`¨»4ÏÅ6©#]‡`˝0Y7«Ì3û´\ l0d[>Òh¥k(€!z	;R\ÓbK\Ì*i˛	Ì Ë >%v`H≤Âw*:~‚z—∫\!∞ 9s{F≥ø<0=p§Nq÷9-äH%Xjwä€•˝àj;wyZõº>,e–±Ì @ú§	¨⁄e0º©‰ß8Ÿ“x`+√pÉ≠÷	DçE‹gú’m„‡q^"wîDv>Æqhﬂabír5ctÆ-Mî˚Ú:ÓU9Q:pEzgiO·p·ÿ≤¸Û¯—>˛˘pÙ•ÜR‚%gÒ’Ó≤8b¢eùIæRwÏ/Lt(z˝ã‡hXÄl™-h'X√vc-Zç~»ÈΩ˜m∏É≤ód™(WUn∫js)q&{ˇR#∏˛a`¨Buº0gπæ0Cç{c3}PØIÑ;4nN‰g7ŸÛ#ÌN“„B5wÏp•‘Â¸q_¶P•¯/hdK‡f‚ #˛--W)),uùuópq=ai˙ÏUa øY…,)f≠yŸ•+sVú£®ø9ÔÎËâÌ,)yx¸9låw5-ª …:Ñ©©∑O,9∫ÕêıD®†h,:>›bØ_ Ì¨ÉØfs`	LscNîØ¸ñ23?íhvd^D‹«‚kFhdÏ
æ¸JÔ	|¯K´iMe◊-8Î˚öÁy?–ËuuH®)iΩg»ªoY∂\™±∂-‡?%˝FÕ-vboæ¿-m}-•%r',,$´$‰*.:&≥w7Âr3˛-NÌ˝co&T*Ñw™ùTÚ`’$mÒ´∞EEÊcV©˘+(lbCøŒ°^GÊF£∂uÖê6$b∂=1⁄imLŸx9EDEb√}XR¸Á <““ΩdaŒÎ>âæ?)%≠S.d“uók}#bÈ_◊ﬁ•“Ù¨Æ|jv3cü60koÓ^xt#.IÏu• å'°r€xís¢> }hs¨,s±Åh,É\∫rntCrY¡m>ﬂJá.–}÷Öpf®äxNDApm6ﬂ-:d&vAiÍe1ÃiVgÇt≤]Î4Ò∞}=„ÉfúVöd‚Ô@q’9§¨(õ5˘s[UmÍ	Õ¡ShiänÜmµ´Ì/, Ô‘ÙCù4≥<J’WsN&˝◊=´ÎSDv»t∫em…9˜s/•5lM<~p¯>“Vgè·≥ue%Yxæ£ï®K
ºy˛Ëz…*WA≠]Q@é.GàF"dQ#<B÷i÷B3Qe‰‚Ò3v#E·€ÃA@Î¶3p‚äX"‚≈≈s!ª'e 
O¢ÓJ!ÎîÊÉ∫;◊‚Y«.zÂQ(:º”©s'+]\@èÛ∂÷i5œB©ga§Re}	eUÕ`aPt)ˆ‡){=WGﬂsrRÂ&hdƒK8"Hn·N•i2Ù~-Vl)eÒn\ÙÛq?Xm*K5&†FeatËa√¥>vÂ`5e\•V≥|Àõ:rÌmÂ=3dP],`E.bmU∑vû¸¿±èT_CxG:∆Çv#cA;Ö’ =‘Ÿ_r:≥õn–Ryu<{E+–Ì0`5j∂ˆsh=€€Çœ„Ïf°$´1%&Ë“IJg~Ú<4Ô¢E>‘üä1|QaG|a0Ñ≠Ω'jßüçwÁÛ8i8÷;hJL˙;◊§aÀS)∂3\f˚®~e/˛iHq7 UàælNa„¯crn‹sC*)%6≠X¸¿ój˛§j&÷∏hH8‡¯$4`Cdçd%±!k∞~ôM¨é5ìlñk∫1^(∂ªÏy:¨ÔΩ£„`\p9_Ë ˇ-Ky–c23g&b<%kÚ	{Ÿ≈∂˜s`*ÔLÖJ;zWﬁ±í0kÈ–s[“P"∏}6  ,o§e‰ÙD>||dîM‰qy6oÕL∂Á%©Ó{jÒIrÏub,#…≠ggz}\ ΩÁ"81i:´Úz,	øLà="}.w&XwX;˜Ô[pÌµE!‰≥Ete>tf"‚†éÄÃ1îÔ{´ìWdıCÿA™ÍiîuRc©[ls]T∏RR≈Kævî∏˜s¯07m,]Î>@O±$ÜHr®q†GhthñY1[À7=HF„(ty¶ªZnØÊ`bÑ∑dabIe_q_OOï˜ØDˇ1_*ZZ=Ì$·∆]V1!Ò}§∫a‚X º˜/ıÉÙ#w$¸=-ëPr@œ˛(´∂oJì·ÀÏ}≤!ñ-Qªb"0d˜p3hÒ5¿0∫lv`Åuë&^·)uHÁ/Z‡˙™5ÃñÊr˝Ì8-Ì”tw:t]÷tv't¥d&e˛rfΩ=ÔVmh‰d∂ƒhSu„-ÌU¶∫•^Í›C'l«E6=%$ópÓW–ƒ+)fÜ€OƒFfçb’'DE-ı¯ÿ.Q=yŒ‹ØˆfT∫mc†/gÊ-b:ª§’Q
!q’<=
D é˜ÅØd˙U≤F.(=|kˆg∆ˆΩ;3Ωao>>oÓvA^.ü™t‰-&≥ôt≤,$ ∑µiGÈÈHRsnfFkh¿M‘Õ8∂˝km⁄CI<H+Õ¿7-6¿õ’—Ï»W˝&dﬂb|õ∑rlx2£Ô≈®Qv"Ñ[¢≤@:©k≥vK‰\ :eQ˛Ô{Ï§yáe"|Ö0<∂’VÏõ‘0ú0G]ÔEeœ+ÆÌœm¥ú<YÃ|:6é<ßˇìmV"=%ª}3>O9ÙE¢%$D&ø’∂˚dlNÔ~eV_dÒ∫h%˘˝d∆ç)ÑSuÒÆ$ta48Ωtﬂ∂a9å¿kªËÂj%#mk2~e`≠dg“˝ëxyÈ~3∞V‡p˘*≠"ÿGhjxÒI)8⁄c¨_f'÷so]ª;vAd~G\3(t™36«Ç≥VoÛ#|11…!gQC0®§Ç6≤¬0Ú'≥´al)úpG«-ìÅçwÒ, d´pX≠hf¢Úwê\~;Hq4bpfRavuO`_M¡Ij\‰tm‰—Ú¯cVmbK`k¢=Df‚—{QjQh1[ÂßK“nz`"o^bıVoh(˜{êE”úbh≤˝dmm™l›gU1xJPeXÀ`G¯pÕ BQÁbdhÆC>!ˆcÓ’%`¯KP^n4Û‰Ü©T≠÷sÉ˝C(@%)◊Ùå“Áo`pcÂ˛Ò0ÃkRÛtœÓ·‡qbÊ®L»Zj?„[Œn
_˘p†~≈r7ÎbLÚ»˜c⁄Ih ¥Ã$4:«®§⁄4{qDi9f?lÜ6ZIX"œµm%ﬁ#r6ﬁ˚9Hwg≤∏/ÆÃºj?h∫(‚N£aÍtp∆oõ`V+Ê*!pt…tD(∆”	‚s÷˝§Qx0q_}}^ÚI≤ ÿHÈ!`¡¬q~4œj∞ﬂOµ◊>Ò~eKQ(]√ba”—fæ(edM~‚Sgº`~Ìp´,Q)aKh⁄û]4n"MÀ‚@x:-n§ÿHÛf
¡%m=gAr†x9E∂Ah[	rˆÕp‡ﬂ_çôzºe{n!m§“*})µ°r}8£ÍÎ˜‡+Œ.3˘ﬁ~¸’Tb*ÂnÃy≠FˇÇ3f~+∑ÔÚØ0√7ËKnu+0¶bDœmnnÈ#iØ8<4?1FÓóƒ)¿wpÓ;mVwò+,B>™x#&(xÉÀÙ∂=k&F`	a¯Ë˚q0±ÕI«q_œ<Ø™vgQ#6	p*WAg"-ªÑ'äVøTqo¨+§k(ÚÊvS£ˇ¢Ä˛5_po+Ç'÷M–µ#Ù—y]çÇ©∞M3Ú™NU] ydÊ`HaÂ2@xiKX
ãÔ«B@J0maa‘ßø8Ù8§QRzpŒe{ß7E≈Ì∫a7j˚©Äà,là˝Ë
-Øû3∞ΩΩÍh(~rtõb(·X`zÏ!¬Ûéo˛5°Z$}NBt°w°O jπôF5cTinb	ë".}]Zﬂ„? `(≤W§Êr"ˇG±0Êpuà£Õ¨_;)sd"jÔ0°lac&Ït-Q(BõNæli469ÂwhÖ$uÚ‘VN;ò7≠ÅŒ∆5/gaàA˛OxËDf]µ∂Á@9#û˝/Ó#Ar%l:…a˘ΩQ}‡º,≥á£#^Lc*xµ
ñ%ÊhÓÖË:‚u7Vπ◊€[:%§ôL4å¢∞*b]	#˘—S¿$n[ô≠Û;œ4t£”ü=‡é$|Ê0jê~mid0ÚÔ§À‹@	ylUÙÌ¯4˝h=d„äÒ∞%¸Ñ}wèîΩg~<tÒnxÍòﬁÊ√ul ÚDºìqasGTD;,™≥ÙFzÅw–7‚häœtd•§∞Al·_5C"	∫ ááyìe˘‘¥{,y~[¯¢ktÑ6aó≤°<3t!ä∫‘p‹°ÁpS;|œ6A±/gKÆ9
ÒdmQ_˙˘∑-|LŒ
P?@†U¶Zp·k.9
h5x,¯U!ØªnaZé1t+&≥πà9<>~/¥	g^*dg˚hAçOwg≠fKL≥mQxqzlrﬂØap5±„ß$ogé–Å¶€MF0˝†%e`#w¸$Ü>™`°Ã26;jˆjﬁ7OÊc ßO}3#éË”or8„Bf‰&¥u'‡g“£ˇ?#˘.ueb¯(+B›º∂yoNYE9 £=Àî)A.w	nò<o„W—û&q∞`Â`«˜·GügpômhJt)@`Ìı©)“Ï+˘°ßyÛ•SJµ˘√Å©htQvy,ö9‰uÓbhΩˇpÕä îãò≥uŸ[‘
ŒB?E5gÈ~A0¨ é4e[tÄÊqÏ¢?4t1l∏`3∂ß\BCª	EY-6$Uë?<?klæU¸-2Û‡|2=E7¸c˚ ÔI@b∞#ı»òR	*ze?X§ën∞K–SÜ~U©rl?F>æÿocmsƒkIu~JÊE‡ä¢
Ik8ÂŒQWÀ,aE‘8_wÎi¥œz:akn44X.§™â$ÀYeÚ!Û¿0uy=&s™AUı}û"U,ômJj4K±~∫"≠1dûf~{3D3`<EÈj)¨3m*ô¥`˜"ëv∏b™NN3iÉ®uw˝√≈•c¯irp§$i]!T¯™›™u-¯:°Ê∫‡eÚO∂`<!"Ãrof ﬁs„&™iÒë≥ﬂˇÚÜ|◊vµ…>¨&+%Ñ$˙clMÕ4vqHupcuµon5Û}ˇU66cl*eÌ Ø¬-fªL(+ÆÁyoÙ*8t"•”9ÁóT5Û`B$oOnnW‘x6 }pÒÛ>9‰wt¸è¨º“ë·.‘Ò"$ûÒ§%1ùÎÅÎqu˘öh<∆¯5ppeN^#v´±|Ù`(í—in≈l@ Qz2<,1Œox∫íme8_1´Êû&$nõ´Ùl^b0≠⁄˙‡Ûﬂ
A0à4q4tN-h3qUsêÊ-‚‚n»J`Ô!√@F9C#(;l|â,53“êîÏ1oéë“Ñ&Nu∫QÏbK’/—"V+VQ˘‚$æ
˚®/ee,yõg π¶™r˝ÓUR¥Ï Øå„Ω_&nrË‚Ë§h3Hº\Ù!Ac\Ë'91´à]ÏxÎπ}ƒè{.i©ê@ıc™≥HK∆4∏Âb§H(Q¥˘lN¥;*u≤Sh<<^Gib:ST∫u©¡i3óµ≠2˚"H„Ó„8e`g3	¿x∫`óƒ;]ÊD({/s<vÂ´5Æ'ßŸ‘Ô:¨4™?Px+5CsRá(üf"oDhøc∞≈jäßRÆ]÷-Ù>sMé(T"‰fâﬁÄ>`ƒ.ım5hxt$pÛw3QÁıÒ.`¬~e““coLe4:]û@w?dÏ{^»K4†d7_ÌI~mˇ@]¿:Ï2[Ín0Á xYr%|Ur9l•VÁ(øaÓNäj‚ x{±zÚD8.Âa¥˝bÊgfjm-3ÒeËL]n¥z—D ^i-˚·ëIG4&9˛Æ?[14ÄMdCç±Otsã(Ëbk?F&G0=k¯∆$Ql≥)√GÕm*d$Å˝/⁄
Ú<5hÎlz?%e>¶Ö©≥ò»v">O°ÊDu4Y*qG—ÏWÃX®nyz3 l—Û)>+ËÇG6&¿Dæó~àiáı3≤¬BºCæ=ı)n˙kË>i@jgo{ƒ2Ωqz¨ Ò∫-7S/%Á´≥Õ=Á66zŒô›~"íh≠§€-ı<@Õ†ÒbN;RÒmo‡'&Hba4#^¬·I2j.pΩæ¨VKÎrä±€A˜r‹	˝≈ PE&8;¨ºz·¢}E sCãÌw@∂´aP/9#¿UptŒ™ı2M¢F˚	vxıV8ºt™‡ ó`·ú(•zs±—hßcº≈7ÍÊz°2AuwÏE•$bC°Ù '¥\;˛vÆÚ‡®a@óÚs
Mt$®z·Òm÷FÂY€	j,ei•Êhco~U◊p^°à\pC,3së∫uUÔ†‰¢20{»\D`ÙdTONH∫iÙ˝CÒ‹[Ì¨Òq:¢ÀK∫‹Â™|/©ú3*[OY'	Ydtb’7b‰#®.)µ≤®!O-™l√3“jÏ~ÚÌßvﬁ◊!b4u3'‰∆È^&—DÖ< ù>=|Ÿ∂ëZqEdñËÌvô>ÂŸk<Tôz˝L>¥ÆÉ$¯9b–ió`‚ o8Øc’Î•yì∫˝ ÚqÆfDÿ|™ÍØfUâ∑U•®v ÌmZQ?ma Ì˙4l˝÷˝¬,≠;R[x1ƒrÊâÔ*¨4K◊ê9•(<ed$B·,Ùiœüpœ3y#„'spPs…Ìµ/ÇdÈΩÑ4wn›≤N!), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), index));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetOperandOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GetOperandOp::verify() {
  if (failed(GetOperandOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps10(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult GetOperandOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::IntegerAttr indexAttr;
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;

  if (parser.parseAttribute(indexAttr, parser.getBuilder().getIntegerType(32), "index", result.attributes))
    return ::mlir::failure();
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::ValueType>();
  ::mlir::Type odsBuildableType1 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(operationOperands, odsBuildableType1, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetOperandOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.get_operand";
  p << ' ';
  p.printAttributeWithoutType(indexAttr());
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"index"});
}

void GetOperandOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::GetOperandsOp definitions
//===----------------------------------------------------------------------===//

GetOperandsOpAdaptor::GetOperandsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GetOperandsOpAdaptor::GetOperandsOpAdaptor(GetOperandsOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GetOperandsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GetOperandsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GetOperandsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetOperandsOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GetOperandsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr GetOperandsOpAdaptor::index() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("index").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult GetOperandsOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_index = odsAttrs.get("index");
  if (tblgen_index) {
    if (!((((tblgen_index.isa<::mlir::IntegerAttr>())) && ((tblgen_index.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!tblgen_index.cast<::mlir::IntegerAttr>().getValue().isNegative())))) return emitError(loc, "'pdl_interp.get_operands' op ""attribute 'index' failed to satisfy constraint: 32-bit signless integer attribute whose value is non-negative");
  }
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> GetOperandsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GetOperandsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetOperandsOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GetOperandsOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GetOperandsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GetOperandsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetOperandsOp::value() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr GetOperandsOp::indexAttr() {
  return (*this)->getAttr(indexAttrName()).template dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> GetOperandsOp::index() {
  auto attr = indexAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

void GetOperandsOp::indexAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(indexAttrName(), attr);
}

::mlir::Attribute GetOperandsOp::removeIndexAttr() {
  return (*this)->removeAttr(indexAttrName());
}

void GetOperandsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, Value operation, Optional<unsigned> index) {
      build(odsBuilder, odsState, resultType, operation,
            index ? odsBuilder.getI32IntegerAttr(*index) : IntegerAttr());
    
}

void GetOperandsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value operation, /*optional*/::mlir::IntegerAttr index) {
  odsState.addOperands(operation);
  if (index) {
  odsState.addAttribute(indexAttrName(odsState.name), index);
  }
  odsState.addTypes(value);
}

void GetOperandsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, /*optional*/::mlir::IntegerAttr index) {
  odsState.addOperands(operation);
  if (index) {
  odsState.addAttribute(indexAttrName(odsState.name), index);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetOperandsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GetOperandsOp::verify() {
  if (failed(GetOperandsOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult GetOperandsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::IntegerAttr indexAttr;
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;
  ::mlir::Type valueRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valueTypes(valueRawTypes);

  {
    ::mlir::OptionalParseResult parseResult =
      parser.parseOptionalAttribute(indexAttr, parser.getBuilder().getIntegerType(32), "index", result.attributes);
    if (parseResult.hasValue() && failed(*parseResult))
      return ::mlir::failure();
  }
  if (indexAttr) {
  }
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(valueRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  result.addTypes(valueTypes);
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetOperandsOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.get_operands";
  if ((*this)->getAttr("index")) {
  p << ' ';
  p.printAttributeWithoutType(indexAttr());
  }
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(value().getType());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"index"});
}

void GetOperandsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::GetResultOp definitions
//===----------------------------------------------------------------------===//

GetResultOpAdaptor::GetResultOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GetResultOpAdaptor::GetResultOpAdaptor(GetResultOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GetResultOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GetResultOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GetResultOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetResultOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GetResultOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr GetResultOpAdaptor::index() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("index").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult GetResultOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_index = odsAttrs.get("index");
  if (!tblgen_index) return emitError(loc, "'pdl_interp.get_result' op ""requires attribute 'index'");
    if (!((((tblgen_index.isa<::mlir::IntegerAttr>())) && ((tblgen_index.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!tblgen_index.cast<::mlir::IntegerAttr>().getValue().isNegative())))) return emitError(loc, "'pdl_interp.get_result' op ""attribute 'index' failed to satisfy constraint: 32-bit signless integer attribute whose value is non-negative");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> GetResultOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GetResultOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetResultOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GetResultOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GetResultOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GetResultOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetResultOp::value() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr GetResultOp::indexAttr() {
  return (*this)->getAttr(indexAttrName()).template cast<::mlir::IntegerAttr>();
}

uint32_t GetResultOp::index() {
  auto attr = indexAttr();
  return attr.getValue().getZExtValue();
}

void GetResultOp::indexAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(indexAttrName(), attr);
}

void GetResultOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value operation, ::mlir::IntegerAttr index) {
  odsState.addOperands(operation);
  odsState.addAttribute(indexAttrName(odsState.name), index);
  odsState.addTypes(value);
}

void GetResultOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::mlir::IntegerAttr index) {
  odsState.addOperands(operation);
  odsState.addAttribute(indexAttrName(odsState.name), index);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetResultOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value operation, uint32_t index) {
  odsState.addOperands(operation);
  odsState.addAttribute(indexAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), index));
  odsState.addTypes(value);
}

void GetResultOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, uint32_t index) {
  odsState.addOperands(operation);
  odsState.addAttribute(indexAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), index));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetResultOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GetResultOp::verify() {
  if (failed(GetResultOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps10(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult GetResultOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::IntegerAttr indexAttr;
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;

  if (parser.parseAttribute(indexAttr, parser.getBuilder().getIntegerType(32), "index", result.attributes))
    return ::mlir::failure();
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::ValueType>();
  ::mlir::Type odsBuildableType1 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(operationOperands, odsBuildableType1, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetResultOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.get_result";
  p << ' ';
  p.printAttributeWithoutType(indexAttr());
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"index"});
}

void GetResultOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::GetResultsOp definitions
//===----------------------------------------------------------------------===//

GetResultsOpAdaptor::GetResultsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GetResultsOpAdaptor::GetResultsOpAdaptor(GetResultsOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GetResultsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GetResultsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GetResultsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetResultsOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GetResultsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr GetResultsOpAdaptor::index() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("index").dyn_cast_or_null<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult GetResultsOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_index = odsAttrs.get("index");
  if (tblgen_index) {
    if (!((((tblgen_index.isa<::mlir::IntegerAttr>())) && ((tblgen_index.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((!tblgen_index.cast<::mlir::IntegerAttr>().getValue().isNegative())))) return emitError(loc, "'pdl_interp.get_results' op ""attribute 'index' failed to satisfy constraint: 32-bit signless integer attribute whose value is non-negative");
  }
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> GetResultsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GetResultsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetResultsOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GetResultsOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GetResultsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GetResultsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetResultsOp::value() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr GetResultsOp::indexAttr() {
  return (*this)->getAttr(indexAttrName()).template dyn_cast_or_null<::mlir::IntegerAttr>();
}

::llvm::Optional<uint32_t> GetResultsOp::index() {
  auto attr = indexAttr();
  return attr ? ::llvm::Optional<uint32_t>(attr.getValue().getZExtValue()) : (::llvm::None);
}

void GetResultsOp::indexAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(indexAttrName(), attr);
}

::mlir::Attribute GetResultsOp::removeIndexAttr() {
  return (*this)->removeAttr(indexAttrName());
}

void GetResultsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type resultType, Value operation, Optional<unsigned> index) {
      build(odsBuilder, odsState, resultType, operation,
            index ? odsBuilder.getI32IntegerAttr(*index) : IntegerAttr());
    
}

void GetResultsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value operation) {
      build(odsBuilder, odsState,
            pdl::RangeType::get(odsBuilder.getType<pdl::ValueType>()), operation,
            IntegerAttr());
    
}

void GetResultsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type value, ::mlir::Value operation, /*optional*/::mlir::IntegerAttr index) {
  odsState.addOperands(operation);
  if (index) {
  odsState.addAttribute(indexAttrName(odsState.name), index);
  }
  odsState.addTypes(value);
}

void GetResultsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, /*optional*/::mlir::IntegerAttr index) {
  odsState.addOperands(operation);
  if (index) {
  odsState.addAttribute(indexAttrName(odsState.name), index);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetResultsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GetResultsOp::verify() {
  if (failed(GetResultsOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult GetResultsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::IntegerAttr indexAttr;
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;
  ::mlir::Type valueRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valueTypes(valueRawTypes);

  {
    ::mlir::OptionalParseResult parseResult =
      parser.parseOptionalAttribute(indexAttr, parser.getBuilder().getIntegerType(32), "index", result.attributes);
    if (parseResult.hasValue() && failed(*parseResult))
      return ::mlir::failure();
  }
  if (indexAttr) {
  }
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(valueRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  result.addTypes(valueTypes);
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetResultsOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.get_results";
  if ((*this)->getAttr("index")) {
  p << ' ';
  p.printAttributeWithoutType(indexAttr());
  }
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(value().getType());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"index"});
}

void GetResultsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::GetValueTypeOp definitions
//===----------------------------------------------------------------------===//

GetValueTypeOpAdaptor::GetValueTypeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GetValueTypeOpAdaptor::GetValueTypeOpAdaptor(GetValueTypeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GetValueTypeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GetValueTypeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GetValueTypeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetValueTypeOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr GetValueTypeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GetValueTypeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> GetValueTypeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GetValueTypeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetValueTypeOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange GetValueTypeOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GetValueTypeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GetValueTypeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetValueTypeOp::result() {
  return *getODSResults(0).begin();
}

void GetValueTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value value) {
      Type valType = value.getType();
      Type typeType = odsBuilder.getType<pdl::TypeType>();
      build(odsBuilder, odsState,
            valType.isa<pdl::RangeType>() ? pdl::RangeType::get(typeType)
                                          : typeType,
            value);
    
}

void GetValueTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value value) {
  odsState.addOperands(value);
  odsState.addTypes(result);
}

void GetValueTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value) {
  odsState.addOperands(value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetValueTypeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GetValueTypeOp::verify() {
  if (failed(GetValueTypeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps11(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((std::equal_to<>()(getGetValueTypeOpValueType((*this->getODSResults(0).begin()).getType()), (*this->getODSOperands(0).begin()).getType()))))
    return emitOpError("failed to verify that `value` type matches arity of `result`");
  return ::mlir::success();
}

::mlir::ParseResult GetValueTypeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  for (::mlir::Type type : resultTypes) {
    (void)type;
    if (!(((type.isa<::mlir::pdl::TypeType>())) || (((type.isa<::mlir::pdl::RangeType>())) && ((type.cast<::mlir::pdl::RangeType>().getElementType().isa<::mlir::pdl::TypeType>()))))) {
      return parser.emitError(parser.getNameLoc()) << "'result' must be single element or range of PDL handle to an `mlir::Type`, but got " << type;
    }
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(valueOperands, getGetValueTypeOpValueType(resultTypes[0]), valueOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetValueTypeOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.get_value_type";
  p << ' ' << "of";
  p << ' ';
  p << value();
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void GetValueTypeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::InferredTypesOp definitions
//===----------------------------------------------------------------------===//

InferredTypesOpAdaptor::InferredTypesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

InferredTypesOpAdaptor::InferredTypesOpAdaptor(InferredTypesOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange InferredTypesOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> InferredTypesOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange InferredTypesOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr InferredTypesOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult InferredTypesOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> InferredTypesOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range InferredTypesOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> InferredTypesOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InferredTypesOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InferredTypesOp::type() {
  return *getODSResults(0).begin();
}

void InferredTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
      build(odsBuilder, odsState,
            pdl::RangeType::get(odsBuilder.getType<pdl::TypeType>()));
    
}

void InferredTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type type) {
  odsState.addTypes(type);
}

void InferredTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InferredTypesOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InferredTypesOp::verify() {
  if (failed(InferredTypesOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult InferredTypesOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = ::mlir::pdl::RangeType::get(parser.getBuilder().getType<::mlir::pdl::TypeType>());
  result.addTypes(odsBuildableType0);
  return ::mlir::success();
}

void InferredTypesOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.inferred_types";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::IsNotNullOp definitions
//===----------------------------------------------------------------------===//

IsNotNullOpAdaptor::IsNotNullOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

IsNotNullOpAdaptor::IsNotNullOpAdaptor(IsNotNullOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange IsNotNullOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IsNotNullOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IsNotNullOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsNotNullOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr IsNotNullOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IsNotNullOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> IsNotNullOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IsNotNullOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsNotNullOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IsNotNullOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IsNotNullOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IsNotNullOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *IsNotNullOp::trueDest() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *IsNotNullOp::falseDest() {
  return (*this)->getSuccessor(1);
}

void IsNotNullOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(value);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void IsNotNullOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(value);
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IsNotNullOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IsNotNullOp::verify() {
  if (failed(IsNotNullOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult IsNotNullOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::Type valueRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valueTypes(valueRawTypes);
  ::llvm::SmallVector<::mlir::Block *, 2> fullSuccessors;

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(valueRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      fullSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        fullSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  result.addSuccessors(fullSuccessors);
  return ::mlir::success();
}

void IsNotNullOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.is_not_null";
  p << ' ';
  p << value();
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(value().getType());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << "->";
  p << ' ';
  ::llvm::interleaveComma(getOperation()->getSuccessors(), p);
}

void IsNotNullOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::RecordMatchOp definitions
//===----------------------------------------------------------------------===//

RecordMatchOpAdaptor::RecordMatchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

RecordMatchOpAdaptor::RecordMatchOpAdaptor(RecordMatchOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange RecordMatchOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> RecordMatchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange RecordMatchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange RecordMatchOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange RecordMatchOpAdaptor::matchedOps() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr RecordMatchOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::SymbolRefAttr RecordMatchOpAdaptor::rewriter() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::SymbolRefAttr attr = odsAttrs.get("rewriter").cast<::mlir::SymbolRefAttr>();
  return attr;
}

::mlir::StringAttr RecordMatchOpAdaptor::rootKind() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("rootKind").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::mlir::ArrayAttr RecordMatchOpAdaptor::generatedOps() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("generatedOps").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::IntegerAttr RecordMatchOpAdaptor::benefit() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("benefit").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult RecordMatchOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_rewriter = odsAttrs.get("rewriter");
  if (!tblgen_rewriter) return emitError(loc, "'pdl_interp.record_match' op ""requires attribute 'rewriter'");
    if (!((tblgen_rewriter.isa<::mlir::SymbolRefAttr>()))) return emitError(loc, "'pdl_interp.record_match' op ""attribute 'rewriter' failed to satisfy constraint: symbol reference attribute");
  }
  {
  auto tblgen_rootKind = odsAttrs.get("rootKind");
  if (tblgen_rootKind) {
    if (!((tblgen_rootKind.isa<::mlir::StringAttr>()))) return emitError(loc, "'pdl_interp.record_match' op ""attribute 'rootKind' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_generatedOps = odsAttrs.get("generatedOps");
  if (tblgen_generatedOps) {
    if (!(((tblgen_generatedOps.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_generatedOps.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'pdl_interp.record_match' op ""attribute 'generatedOps' failed to satisfy constraint: string array attribute");
  }
  }
  {
  auto tblgen_benefit = odsAttrs.get("benefit");
  if (!tblgen_benefit) return emitError(loc, "'pdl_interp.record_match' op ""requires attribute 'benefit'");
    if (!((((tblgen_benefit.isa<::mlir::IntegerAttr>())) && ((tblgen_benefit.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(16)))) && ((!tblgen_benefit.cast<::mlir::IntegerAttr>().getValue().isNegative())))) return emitError(loc, "'pdl_interp.record_match' op ""attribute 'benefit' failed to satisfy constraint: 16-bit signless integer attribute whose value is non-negative");
  }
  return ::mlir::success();
}





























std::pair<unsigned, unsigned> RecordMatchOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range RecordMatchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range RecordMatchOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range RecordMatchOp::matchedOps() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange RecordMatchOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange RecordMatchOp::matchedOpsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> RecordMatchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RecordMatchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *RecordMatchOp::dest() {
  return (*this)->getSuccessor(0);
}

::mlir::SymbolRefAttr RecordMatchOp::rewriterAttr() {
  return (*this)->getAttr(rewriterAttrName()).template cast<::mlir::SymbolRefAttr>();
}

::mlir::SymbolRefAttr RecordMatchOp::rewriter() {
  auto attr = rewriterAttr();
  return attr;
}

::mlir::StringAttr RecordMatchOp::rootKindAttr() {
  return (*this)->getAttr(rootKindAttrName()).template dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > RecordMatchOp::rootKind() {
  auto attr = rootKindAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

::mlir::ArrayAttr RecordMatchOp::generatedOpsAttr() {
  return (*this)->getAttr(generatedOpsAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > RecordMatchOp::generatedOps() {
  auto attr = generatedOpsAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

::mlir::IntegerAttr RecordMatchOp::benefitAttr() {
  return (*this)->getAttr(benefitAttrName()).template cast<::mlir::IntegerAttr>();
}

uint16_t RecordMatchOp::benefit() {
  auto attr = benefitAttr();
  return attr.getValue().getZExtValue();
}

void RecordMatchOp::rewriterAttr(::mlir::SymbolRefAttr attr) {
  (*this)->setAttr(rewriterAttrName(), attr);
}

void RecordMatchOp::rootKindAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(rootKindAttrName(), attr);
}

void RecordMatchOp::generatedOpsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(generatedOpsAttrName(), attr);
}

void RecordMatchOp::benefitAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(benefitAttrName(), attr);
}

::mlir::Attribute RecordMatchOp::removeRootKindAttr() {
  return (*this)->removeAttr(rootKindAttrName());
}

::mlir::Attribute RecordMatchOp::removeGeneratedOpsAttr() {
  return (*this)->removeAttr(generatedOpsAttrName());
}

void RecordMatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs, ::mlir::ValueRange matchedOps, ::mlir::SymbolRefAttr rewriter, /*optional*/::mlir::StringAttr rootKind, /*optional*/::mlir::ArrayAttr generatedOps, ::mlir::IntegerAttr benefit, ::mlir::Block *dest) {
  odsState.addOperands(inputs);
  odsState.addOperands(matchedOps);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(matchedOps.size())}));
  odsState.addAttribute(rewriterAttrName(odsState.name), rewriter);
  if (rootKind) {
  odsState.addAttribute(rootKindAttrName(odsState.name), rootKind);
  }
  if (generatedOps) {
  odsState.addAttribute(generatedOpsAttrName(odsState.name), generatedOps);
  }
  odsState.addAttribute(benefitAttrName(odsState.name), benefit);
  odsState.addSuccessors(dest);
}

void RecordMatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::ValueRange matchedOps, ::mlir::SymbolRefAttr rewriter, /*optional*/::mlir::StringAttr rootKind, /*optional*/::mlir::ArrayAttr generatedOps, ::mlir::IntegerAttr benefit, ::mlir::Block *dest) {
  odsState.addOperands(inputs);
  odsState.addOperands(matchedOps);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(matchedOps.size())}));
  odsState.addAttribute(rewriterAttrName(odsState.name), rewriter);
  if (rootKind) {
  odsState.addAttribute(rootKindAttrName(odsState.name), rootKind);
  }
  if (generatedOps) {
  odsState.addAttribute(generatedOpsAttrName(odsState.name), generatedOps);
  }
  odsState.addAttribute(benefitAttrName(odsState.name), benefit);
  odsState.addSuccessors(dest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RecordMatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs, ::mlir::ValueRange matchedOps, ::mlir::SymbolRefAttr rewriter, /*optional*/::mlir::StringAttr rootKind, /*optional*/::mlir::ArrayAttr generatedOps, uint16_t benefit, ::mlir::Block *dest) {
  odsState.addOperands(inputs);
  odsState.addOperands(matchedOps);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(matchedOps.size())}));
  odsState.addAttribute(rewriterAttrName(odsState.name), rewriter);
  if (rootKind) {
  odsState.addAttribute(rootKindAttrName(odsState.name), rootKind);
  }
  if (generatedOps) {
  odsState.addAttribute(generatedOpsAttrName(odsState.name), generatedOps);
  }
  odsState.addAttribute(benefitAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(16), benefit));
  odsState.addSuccessors(dest);
}

void RecordMatchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange inputs, ::mlir::ValueRange matchedOps, ::mlir::SymbolRefAttr rewriter, /*optional*/::mlir::StringAttr rootKind, /*optional*/::mlir::ArrayAttr generatedOps, uint16_t benefit, ::mlir::Block *dest) {
  odsState.addOperands(inputs);
  odsState.addOperands(matchedOps);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(matchedOps.size())}));
  odsState.addAttribute(rewriterAttrName(odsState.name), rewriter);
  if (rootKind) {
  odsState.addAttribute(rootKindAttrName(odsState.name), rootKind);
  }
  if (generatedOps) {
  odsState.addAttribute(generatedOpsAttrName(odsState.name), generatedOps);
  }
  odsState.addAttribute(benefitAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(16), benefit));
  odsState.addSuccessors(dest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RecordMatchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RecordMatchOp::verify() {
  if (failed(RecordMatchOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps12(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult RecordMatchOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SymbolRefAttr rewriterAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> inputsOperands;
  ::llvm::SMLoc inputsOperandsLoc;
  (void)inputsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> inputsTypes;
  ::mlir::IntegerAttr benefitAttr;
  ::mlir::ArrayAttr generatedOpsAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> matchedOpsOperands;
  ::llvm::SMLoc matchedOpsOperandsLoc;
  (void)matchedOpsOperandsLoc;
  ::mlir::StringAttr rootKindAttr;
  ::mlir::Block *destSuccessor = nullptr;

  if (parser.parseAttribute(rewriterAttr, parser.getBuilder().getType<::mlir::NoneType>(), "rewriter", result.attributes))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalLParen())) {

  inputsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(inputsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(inputsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseColon())
    return ::mlir::failure();
  if (parser.parseKeyword("benefit"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseAttribute(benefitAttr, parser.getBuilder().getIntegerType(16), "benefit", result.attributes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalKeyword("generatedOps"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ::mlir::OptionalParseResult parseResult =
      parser.parseOptionalAttribute(generatedOpsAttr, parser.getBuilder().getType<::mlir::NoneType>(), "generatedOps", result.attributes);
    if (parseResult.hasValue() && failed(*parseResult))
      return ::mlir::failure();
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();
  }
  if (parser.parseKeyword("loc"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  matchedOpsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(matchedOpsOperands))
    return ::mlir::failure();
  if (parser.parseRSquare())
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalComma())) {
  if (parser.parseKeyword("root"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ::mlir::OptionalParseResult parseResult =
      parser.parseOptionalAttribute(rootKindAttr, parser.getBuilder().getType<::mlir::NoneType>(), "rootKind", result.attributes);
    if (parseResult.hasValue() && failed(*parseResult))
      return ::mlir::failure();
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseSuccessor(destSuccessor))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  if (parser.resolveOperands(inputsOperands, inputsTypes, inputsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(matchedOpsOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(destSuccessor);
  result.addAttribute("operand_segment_sizes", parser.getBuilder().getI32VectorAttr({static_cast<int32_t>(inputsOperands.size()), static_cast<int32_t>(matchedOpsOperands.size())}));
  return ::mlir::success();
}

void RecordMatchOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.record_match";
  p << ' ';
  p.printAttributeWithoutType(rewriterAttr());
  if (!inputs().empty()) {
  p << "(";
  p << inputs();
  p << ' ' << ":";
  p << ' ';
  p << inputs().getTypes();
  p << ")";
  }
  p << ' ' << ":";
  p << ' ' << "benefit";
  p << "(";
  p.printAttributeWithoutType(benefitAttr());
  p << ")";
  p << ",";
  if ((*this)->getAttr("generatedOps")) {
  p << ' ' << "generatedOps";
  p << "(";
  p.printAttributeWithoutType(generatedOpsAttr());
  p << ")";
  p << ",";
  }
  p << ' ' << "loc";
  p << "(";
  p << "[";
  p << matchedOps();
  p << "]";
  p << ")";
  if ((*this)->getAttr("rootKind")) {
  p << ",";
  p << ' ' << "root";
  p << "(";
  p.printAttributeWithoutType(rootKindAttr());
  p << ")";
  }
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"operand_segment_sizes", "rewriter", "benefit", "generatedOps", "rootKind"});
  p << ' ' << "->";
  p << ' ';
  p << dest();
}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::ReplaceOp definitions
//===----------------------------------------------------------------------===//

ReplaceOpAdaptor::ReplaceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReplaceOpAdaptor::ReplaceOpAdaptor(ReplaceOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReplaceOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReplaceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ReplaceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReplaceOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange ReplaceOpAdaptor::replValues() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ReplaceOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ReplaceOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ReplaceOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ReplaceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReplaceOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range ReplaceOp::replValues() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ReplaceOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ReplaceOp::replValuesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReplaceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReplaceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void ReplaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operation, ::mlir::ValueRange replValues) {
  odsState.addOperands(operation);
  odsState.addOperands(replValues);
}

void ReplaceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::mlir::ValueRange replValues) {
  odsState.addOperands(operation);
  odsState.addOperands(replValues);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReplaceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReplaceOp::verify() {
  if (failed(ReplaceOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps6(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult ReplaceOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> replValuesOperands;
  ::llvm::SMLoc replValuesOperandsLoc;
  (void)replValuesOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> replValuesTypes;

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("with"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  replValuesOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(replValuesOperands))
    return ::mlir::failure();
  if (!replValuesOperands.empty()) {
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(replValuesTypes))
    return ::mlir::failure();
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(replValuesOperands, replValuesTypes, replValuesOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReplaceOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.replace";
  p << ' ';
  p << operation();
  p << ' ' << "with";
  p << ' ';
  p << "(";
  if (!replValues().empty()) {
  p << replValues();
  p << ' ' << ":";
  p << ' ';
  p << replValues().getTypes();
  }
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::SwitchAttributeOp definitions
//===----------------------------------------------------------------------===//

SwitchAttributeOpAdaptor::SwitchAttributeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SwitchAttributeOpAdaptor::SwitchAttributeOpAdaptor(SwitchAttributeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SwitchAttributeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SwitchAttributeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SwitchAttributeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchAttributeOpAdaptor::attribute() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SwitchAttributeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr SwitchAttributeOpAdaptor::caseValues() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("caseValues").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult SwitchAttributeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_caseValues = odsAttrs.get("caseValues");
  if (!tblgen_caseValues) return emitError(loc, "'pdl_interp.switch_attribute' op ""requires attribute 'caseValues'");
    if (!((tblgen_caseValues.isa<::mlir::ArrayAttr>()))) return emitError(loc, "'pdl_interp.switch_attribute' op ""attribute 'caseValues' failed to satisfy constraint: array attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> SwitchAttributeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SwitchAttributeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchAttributeOp::attribute() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SwitchAttributeOp::attributeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SwitchAttributeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SwitchAttributeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *SwitchAttributeOp::defaultDest() {
  return (*this)->getSuccessor(0);
}

::mlir::SuccessorRange SwitchAttributeOp::cases() {
  return {std::next((*this)->successor_begin(), 1), (*this)->successor_end()};
}

::mlir::ArrayAttr SwitchAttributeOp::caseValuesAttr() {
  return (*this)->getAttr(caseValuesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr SwitchAttributeOp::caseValues() {
  auto attr = caseValuesAttr();
  return attr;
}

void SwitchAttributeOp::caseValuesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(caseValuesAttrName(), attr);
}

void SwitchAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value attribute, ArrayRef<Attribute> caseValues, Block * defaultDest, BlockRange dests) {
    build(odsBuilder, odsState, attribute, odsBuilder.getArrayAttr(caseValues),
          defaultDest, dests);
  
}

void SwitchAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value attribute, ::mlir::ArrayAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(attribute);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
}

void SwitchAttributeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value attribute, ::mlir::ArrayAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(attribute);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SwitchAttributeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SwitchAttributeOp::verify() {
  if (failed(SwitchAttributeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  // Verify that the number of case destinations matches the number of case
    // values.
    size_t numDests = cases().size();
    size_t numValues = caseValues().size();
    if (numDests != numValues) {
      return emitOpError("expected number of cases to match the number of case "
                         "values, got ")
          << numDests << " but expected " << numValues;
    }
    return success();
}

::mlir::ParseResult SwitchAttributeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType attributeRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> attributeOperands(attributeRawOperands);  ::llvm::SMLoc attributeOperandsLoc;
  (void)attributeOperandsLoc;
  ::mlir::ArrayAttr caseValuesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> casesSuccessors;
  ::mlir::Block *defaultDestSuccessor = nullptr;

  attributeOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(attributeRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  if (parser.parseAttribute(caseValuesAttr, parser.getBuilder().getType<::mlir::NoneType>(), "caseValues", result.attributes))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      casesSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        casesSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseSuccessor(defaultDestSuccessor))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::AttributeType>();
  if (parser.resolveOperands(attributeOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(defaultDestSuccessor);
  result.addSuccessors(casesSuccessors);
  return ::mlir::success();
}

void SwitchAttributeOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.switch_attribute";
  p << ' ';
  p << attribute();
  p << ' ' << "to";
  p << ' ';
  p.printAttributeWithoutType(caseValuesAttr());
  p << "(";
  ::llvm::interleaveComma(cases(), p);
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"caseValues"});
  p << ' ' << "->";
  p << ' ';
  p << defaultDest();
}

void SwitchAttributeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::SwitchOperandCountOp definitions
//===----------------------------------------------------------------------===//

SwitchOperandCountOpAdaptor::SwitchOperandCountOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SwitchOperandCountOpAdaptor::SwitchOperandCountOpAdaptor(SwitchOperandCountOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SwitchOperandCountOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SwitchOperandCountOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SwitchOperandCountOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchOperandCountOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SwitchOperandCountOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr SwitchOperandCountOpAdaptor::caseValues() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("caseValues").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult SwitchOperandCountOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_caseValues = odsAttrs.get("caseValues");
  if (!tblgen_caseValues) return emitError(loc, "'pdl_interp.switch_operand_count' op ""requires attribute 'caseValues'");
    if (!(((tblgen_caseValues.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_caseValues.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32))))) return emitError(loc, "'pdl_interp.switch_operand_count' op ""attribute 'caseValues' failed to satisfy constraint: 32-bit signless integer elements attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> SwitchOperandCountOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SwitchOperandCountOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchOperandCountOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SwitchOperandCountOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SwitchOperandCountOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SwitchOperandCountOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *SwitchOperandCountOp::defaultDest() {
  return (*this)->getSuccessor(0);
}

::mlir::SuccessorRange SwitchOperandCountOp::cases() {
  return {std::next((*this)->successor_begin(), 1), (*this)->successor_end()};
}

::mlir::DenseIntElementsAttr SwitchOperandCountOp::caseValuesAttr() {
  return (*this)->getAttr(caseValuesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr SwitchOperandCountOp::caseValues() {
  auto attr = caseValuesAttr();
  return attr;
}

void SwitchOperandCountOp::caseValuesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(caseValuesAttrName(), attr);
}

void SwitchOperandCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value operation, ArrayRef<int32_t> counts, Block * defaultDest, BlockRange dests) {
    build(odsBuilder, odsState, operation, odsBuilder.getI32VectorAttr(counts),
          defaultDest, dests);
  
}

void SwitchOperandCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operation, ::mlir::DenseIntElementsAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(operation);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
}

void SwitchOperandCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::mlir::DenseIntElementsAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(operation);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SwitchOperandCountOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SwitchOperandCountOp::verify() {
  if (failed(SwitchOperandCountOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  // Verify that the number of case destinations matches the number of case
    // values.
    size_t numDests = cases().size();
    size_t numValues = caseValues().size();
    if (numDests != numValues) {
      return emitOpError("expected number of cases to match the number of case "
                         "values, got ")
          << numDests << " but expected " << numValues;
    }
    return success();
}

::mlir::ParseResult SwitchOperandCountOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;
  ::mlir::DenseIntElementsAttr caseValuesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> casesSuccessors;
  ::mlir::Block *defaultDestSuccessor = nullptr;
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  if (parser.parseAttribute(caseValuesAttr, "caseValues", result.attributes))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      casesSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        casesSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseSuccessor(defaultDestSuccessor))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(defaultDestSuccessor);
  result.addSuccessors(casesSuccessors);
  return ::mlir::success();
}

void SwitchOperandCountOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.switch_operand_count";
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p << ' ' << "to";
  p << ' ';
  p.printAttribute(caseValuesAttr());
  p << "(";
  ::llvm::interleaveComma(cases(), p);
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"caseValues"});
  p << ' ' << "->";
  p << ' ';
  p << defaultDest();
}

void SwitchOperandCountOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::SwitchOperationNameOp definitions
//===----------------------------------------------------------------------===//

SwitchOperationNameOpAdaptor::SwitchOperationNameOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SwitchOperationNameOpAdaptor::SwitchOperationNameOpAdaptor(SwitchOperationNameOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SwitchOperationNameOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SwitchOperationNameOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SwitchOperationNameOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchOperationNameOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SwitchOperationNameOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr SwitchOperationNameOpAdaptor::caseValues() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("caseValues").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult SwitchOperationNameOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_caseValues = odsAttrs.get("caseValues");
  if (!tblgen_caseValues) return emitError(loc, "'pdl_interp.switch_operation_name' op ""requires attribute 'caseValues'");
    if (!(((tblgen_caseValues.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_caseValues.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::StringAttr>()); })))) return emitError(loc, "'pdl_interp.switch_operation_name' op ""attribute 'caseValues' failed to satisfy constraint: string array attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> SwitchOperationNameOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SwitchOperationNameOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchOperationNameOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SwitchOperationNameOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SwitchOperationNameOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SwitchOperationNameOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *SwitchOperationNameOp::defaultDest() {
  return (*this)->getSuccessor(0);
}

::mlir::SuccessorRange SwitchOperationNameOp::cases() {
  return {std::next((*this)->successor_begin(), 1), (*this)->successor_end()};
}

::mlir::ArrayAttr SwitchOperationNameOp::caseValuesAttr() {
  return (*this)->getAttr(caseValuesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr SwitchOperationNameOp::caseValues() {
  auto attr = caseValuesAttr();
  return attr;
}

void SwitchOperationNameOp::caseValuesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(caseValuesAttrName(), attr);
}

void SwitchOperationNameOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value operation, ArrayRef<OperationName> names, Block * defaultDest, BlockRange dests) {
      auto stringNames = llvm::to_vector<8>(llvm::map_range(names,
          [](OperationName name) { return name.getStringRef(); }));
      build(odsBuilder, odsState, operation, odsBuilder.getStrArrayAttr(stringNames),
            defaultDest, dests);
    
}

void SwitchOperationNameOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operation, ::mlir::ArrayAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(operation);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
}

void SwitchOperationNameOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::mlir::ArrayAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(operation);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SwitchOperationNameOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SwitchOperationNameOp::verify() {
  if (failed(SwitchOperationNameOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  // Verify that the number of case destinations matches the number of case
    // values.
    size_t numDests = cases().size();
    size_t numValues = caseValues().size();
    if (numDests != numValues) {
      return emitOpError("expected number of cases to match the number of case "
                         "values, got ")
          << numDests << " but expected " << numValues;
    }
    return success();
}

::mlir::ParseResult SwitchOperationNameOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;
  ::mlir::ArrayAttr caseValuesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> casesSuccessors;
  ::mlir::Block *defaultDestSuccessor = nullptr;
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  if (parser.parseAttribute(caseValuesAttr, parser.getBuilder().getType<::mlir::NoneType>(), "caseValues", result.attributes))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      casesSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        casesSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseSuccessor(defaultDestSuccessor))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(defaultDestSuccessor);
  result.addSuccessors(casesSuccessors);
  return ::mlir::success();
}

void SwitchOperationNameOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.switch_operation_name";
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p << ' ' << "to";
  p << ' ';
  p.printAttributeWithoutType(caseValuesAttr());
  p << "(";
  ::llvm::interleaveComma(cases(), p);
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"caseValues"});
  p << ' ' << "->";
  p << ' ';
  p << defaultDest();
}

void SwitchOperationNameOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::SwitchResultCountOp definitions
//===----------------------------------------------------------------------===//

SwitchResultCountOpAdaptor::SwitchResultCountOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SwitchResultCountOpAdaptor::SwitchResultCountOpAdaptor(SwitchResultCountOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SwitchResultCountOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SwitchResultCountOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SwitchResultCountOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchResultCountOpAdaptor::operation() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SwitchResultCountOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr SwitchResultCountOpAdaptor::caseValues() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("caseValues").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult SwitchResultCountOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_caseValues = odsAttrs.get("caseValues");
  if (!tblgen_caseValues) return emitError(loc, "'pdl_interp.switch_result_count' op ""requires attribute 'caseValues'");
    if (!(((tblgen_caseValues.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_caseValues.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32))))) return emitError(loc, "'pdl_interp.switch_result_count' op ""attribute 'caseValues' failed to satisfy constraint: 32-bit signless integer elements attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> SwitchResultCountOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SwitchResultCountOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchResultCountOp::operation() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SwitchResultCountOp::operationMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SwitchResultCountOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SwitchResultCountOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *SwitchResultCountOp::defaultDest() {
  return (*this)->getSuccessor(0);
}

::mlir::SuccessorRange SwitchResultCountOp::cases() {
  return {std::next((*this)->successor_begin(), 1), (*this)->successor_end()};
}

::mlir::DenseIntElementsAttr SwitchResultCountOp::caseValuesAttr() {
  return (*this)->getAttr(caseValuesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr SwitchResultCountOp::caseValues() {
  auto attr = caseValuesAttr();
  return attr;
}

void SwitchResultCountOp::caseValuesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(caseValuesAttrName(), attr);
}

void SwitchResultCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value operation, ArrayRef<int32_t> counts, Block * defaultDest, BlockRange dests) {
    build(odsBuilder, odsState, operation, odsBuilder.getI32VectorAttr(counts),
          defaultDest, dests);
  
}

void SwitchResultCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operation, ::mlir::DenseIntElementsAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(operation);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
}

void SwitchResultCountOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operation, ::mlir::DenseIntElementsAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(operation);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SwitchResultCountOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SwitchResultCountOp::verify() {
  if (failed(SwitchResultCountOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  // Verify that the number of case destinations matches the number of case
    // values.
    size_t numDests = cases().size();
    size_t numValues = caseValues().size();
    if (numDests != numValues) {
      return emitOpError("expected number of cases to match the number of case "
                         "values, got ")
          << numDests << " but expected " << numValues;
    }
    return success();
}

::mlir::ParseResult SwitchResultCountOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType operationRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> operationOperands(operationRawOperands);  ::llvm::SMLoc operationOperandsLoc;
  (void)operationOperandsLoc;
  ::mlir::DenseIntElementsAttr caseValuesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> casesSuccessors;
  ::mlir::Block *defaultDestSuccessor = nullptr;
  if (parser.parseKeyword("of"))
    return ::mlir::failure();

  operationOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(operationRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  if (parser.parseAttribute(caseValuesAttr, "caseValues", result.attributes))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      casesSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        casesSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseSuccessor(defaultDestSuccessor))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::OperationType>();
  if (parser.resolveOperands(operationOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(defaultDestSuccessor);
  result.addSuccessors(casesSuccessors);
  return ::mlir::success();
}

void SwitchResultCountOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.switch_result_count";
  p << ' ' << "of";
  p << ' ';
  p << operation();
  p << ' ' << "to";
  p << ' ';
  p.printAttribute(caseValuesAttr());
  p << "(";
  ::llvm::interleaveComma(cases(), p);
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"caseValues"});
  p << ' ' << "->";
  p << ' ';
  p << defaultDest();
}

void SwitchResultCountOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::SwitchTypeOp definitions
//===----------------------------------------------------------------------===//

SwitchTypeOpAdaptor::SwitchTypeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SwitchTypeOpAdaptor::SwitchTypeOpAdaptor(SwitchTypeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SwitchTypeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SwitchTypeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SwitchTypeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchTypeOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SwitchTypeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr SwitchTypeOpAdaptor::caseValues() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("caseValues").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult SwitchTypeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_caseValues = odsAttrs.get("caseValues");
  if (!tblgen_caseValues) return emitError(loc, "'pdl_interp.switch_type' op ""requires attribute 'caseValues'");
    if (!(((tblgen_caseValues.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_caseValues.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); })))) return emitError(loc, "'pdl_interp.switch_type' op ""attribute 'caseValues' failed to satisfy constraint: type array attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> SwitchTypeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SwitchTypeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchTypeOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SwitchTypeOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SwitchTypeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SwitchTypeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *SwitchTypeOp::defaultDest() {
  return (*this)->getSuccessor(0);
}

::mlir::SuccessorRange SwitchTypeOp::cases() {
  return {std::next((*this)->successor_begin(), 1), (*this)->successor_end()};
}

::mlir::ArrayAttr SwitchTypeOp::caseValuesAttr() {
  return (*this)->getAttr(caseValuesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr SwitchTypeOp::caseValues() {
  auto attr = caseValuesAttr();
  return attr;
}

void SwitchTypeOp::caseValuesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(caseValuesAttrName(), attr);
}

void SwitchTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value edge, ArrayRef<Attribute> types, Block * defaultDest, BlockRange dests) {
      build(odsBuilder, odsState, edge, odsBuilder.getArrayAttr(types),
            defaultDest, dests);
    
}

void SwitchTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::ArrayAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(value);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
}

void SwitchTypeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::ArrayAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(value);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SwitchTypeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SwitchTypeOp::verify() {
  if (failed(SwitchTypeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps4(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  // Verify that the number of case destinations matches the number of case
    // values.
    size_t numDests = cases().size();
    size_t numValues = caseValues().size();
    if (numDests != numValues) {
      return emitOpError("expected number of cases to match the number of case "
                         "values, got ")
          << numDests << " but expected " << numValues;
    }
    return success();
}

::mlir::ParseResult SwitchTypeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::ArrayAttr caseValuesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> casesSuccessors;
  ::mlir::Block *defaultDestSuccessor = nullptr;

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  if (parser.parseAttribute(caseValuesAttr, parser.getBuilder().getType<::mlir::NoneType>(), "caseValues", result.attributes))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      casesSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        casesSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseSuccessor(defaultDestSuccessor))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::pdl::TypeType>();
  if (parser.resolveOperands(valueOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(defaultDestSuccessor);
  result.addSuccessors(casesSuccessors);
  return ::mlir::success();
}

void SwitchTypeOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.switch_type";
  p << ' ';
  p << value();
  p << ' ' << "to";
  p << ' ';
  p.printAttributeWithoutType(caseValuesAttr());
  p << "(";
  ::llvm::interleaveComma(cases(), p);
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"caseValues"});
  p << ' ' << "->";
  p << ' ';
  p << defaultDest();
}

void SwitchTypeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir
namespace mlir {
namespace pdl_interp {

//===----------------------------------------------------------------------===//
// ::mlir::pdl_interp::SwitchTypesOp definitions
//===----------------------------------------------------------------------===//

SwitchTypesOpAdaptor::SwitchTypesOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SwitchTypesOpAdaptor::SwitchTypesOpAdaptor(SwitchTypesOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SwitchTypesOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SwitchTypesOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SwitchTypesOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchTypesOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SwitchTypesOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr SwitchTypesOpAdaptor::caseValues() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("caseValues").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult SwitchTypesOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_caseValues = odsAttrs.get("caseValues");
  if (!tblgen_caseValues) return emitError(loc, "'pdl_interp.switch_types' op ""requires attribute 'caseValues'");
    if (!(((tblgen_caseValues.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_caseValues.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(attr.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::TypeAttr>())) && ((attr.cast<::mlir::TypeAttr>().getValue().isa<::mlir::Type>())); })); })))) return emitError(loc, "'pdl_interp.switch_types' op ""attribute 'caseValues' failed to satisfy constraint: type-array array attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> SwitchTypesOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SwitchTypesOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchTypesOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SwitchTypesOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SwitchTypesOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SwitchTypesOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *SwitchTypesOp::defaultDest() {
  return (*this)->getSuccessor(0);
}

::mlir::SuccessorRange SwitchTypesOp::cases() {
  return {std::next((*this)->successor_begin(), 1), (*this)->successor_end()};
}

::mlir::ArrayAttr SwitchTypesOp::caseValuesAttr() {
  return (*this)->getAttr(caseValuesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr SwitchTypesOp::caseValues() {
  auto attr = caseValuesAttr();
  return attr;
}

void SwitchTypesOp::caseValuesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(caseValuesAttrName(), attr);
}

void SwitchTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value edge, ArrayRef<Attribute> types, Block * defaultDest, BlockRange dests) {
      build(odsBuilder, odsState, edge, odsBuilder.getArrayAttr(types),
            defaultDest, dests);
    
}

void SwitchTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value, ::mlir::ArrayAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(value);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
}

void SwitchTypesOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::ArrayAttr caseValues, ::mlir::Block *defaultDest, ::mlir::BlockRange cases) {
  odsState.addOperands(value);
  odsState.addAttribute(caseValuesAttrName(odsState.name), caseValues);
  odsState.addSuccessors(defaultDest);
  odsState.addSuccessors(cases);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SwitchTypesOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SwitchTypesOp::verify() {
  if (failed(SwitchTypesOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_PDLInterpOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  // Verify that the number of case destinations matches the number of case
    // values.
    size_t numDests = cases().size();
    size_t numValues = caseValues().size();
    if (numDests != numValues) {
      return emitOpError("expected number of cases to match the number of case "
                         "values, got ")
          << numDests << " but expected " << numValues;
    }
    return success();
}

::mlir::ParseResult SwitchTypesOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::ArrayAttr caseValuesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> casesSuccessors;
  ::mlir::Block *defaultDestSuccessor = nullptr;

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  if (parser.parseAttribute(caseValuesAttr, parser.getBuilder().getType<::mlir::NoneType>(), "caseValues", result.attributes))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ::mlir::Block *succ;
    auto firstSucc = parser.parseOptionalSuccessor(succ);
    if (firstSucc.hasValue()) {
      if (failed(*firstSucc))
        return ::mlir::failure();
      casesSuccessors.emplace_back(succ);

      // Parse any trailing successors.
      while (succeeded(parser.parseOptionalComma())) {
        if (parser.parseSuccessor(succ))
          return ::mlir::failure();
        casesSuccessors.emplace_back(succ);
      }
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseSuccessor(defaultDestSuccessor))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = ::mlir::pdl::RangeType::get(parser.getBuilder().getType<::mlir::pdl::TypeType>());
  if (parser.resolveOperands(valueOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addSuccessors(defaultDestSuccessor);
  result.addSuccessors(casesSuccessors);
  return ::mlir::success();
}

void SwitchTypesOp::print(::mlir::OpAsmPrinter &p) {
  p << "pdl_interp.switch_types";
  p << ' ';
  p << value();
  p << ' ' << "to";
  p << ' ';
  p.printAttributeWithoutType(caseValuesAttr());
  p << "(";
  ::llvm::interleaveComma(cases(), p);
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"caseValues"});
  p << ' ' << "->";
  p << ' ';
  p << defaultDest();
}

void SwitchTypesOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace pdl_interp
} // namespace mlir

#endif  // GET_OP_CLASSES

