/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

AffineApplyOp,
AffineForOp,
AffineIfOp,
AffineLoadOp,
AffineMaxOp,
AffineMinOp,
AffineParallelOp,
AffinePrefetchOp,
AffineStoreOp,
AffineVectorLoadOp,
AffineVectorStoreOp,
AffineYieldOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AffineOps0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IndexType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AffineOps1(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IndexType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AffineOps2(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AffineOps3(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::MemRefType>())) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be memref of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AffineOps4(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AffineOps5(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::VectorType>())) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be vector of any type values, but got " << type;
  }
  return ::mlir::success();
}


//===----------------------------------------------------------------------===//
// AffineApplyOp definitions
//===----------------------------------------------------------------------===//

AffineApplyOpAdaptor::AffineApplyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineApplyOpAdaptor::AffineApplyOpAdaptor(AffineApplyOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineApplyOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineApplyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineApplyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange AffineApplyOpAdaptor::mapOperands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr AffineApplyOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::AffineMapAttr AffineApplyOpAdaptor::map() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::AffineMapAttr attr = odsAttrs.get("map").cast<::mlir::AffineMapAttr>();
  return attr;
}

::mlir::LogicalResult AffineApplyOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_map = odsAttrs.get("map");
  if (!tblgen_map) return emitError(loc, "'affine.apply' op ""requires attribute 'map'");
    if (!((tblgen_map.isa<::mlir::AffineMapAttr>()))) return emitError(loc, "'affine.apply' op ""attribute 'map' failed to satisfy constraint: AffineMap attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> AffineApplyOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineApplyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range AffineApplyOp::mapOperands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange AffineApplyOp::mapOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffineApplyOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffineApplyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::AffineMapAttr AffineApplyOp::mapAttr() {
  return (*this)->getAttr(mapAttrName()).template cast<::mlir::AffineMapAttr>();
}

::mlir::AffineMap AffineApplyOp::map() {
  auto attr = mapAttr();
  return attr.getValue();
}

void AffineApplyOp::mapAttr(::mlir::AffineMapAttr attr) {
  (*this)->setAttr(mapAttrName(), attr);
}

void AffineApplyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, AffineMap map, ValueRange mapOperands) {
      build(odsBuilder, odsState, odsBuilder.getIndexType(), map, mapOperands);
    
}

void AffineApplyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ArrayRef<AffineExpr>  exprList, ValueRange mapOperands) {
      build(odsBuilder, odsState, odsBuilder.getIndexType(),
            AffineMap::inferFromExprList(exprList).front(), mapOperands);
    
}

void AffineApplyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::AffineMapAttr map, ::mlir::ValueRange mapOperands) {
  odsState.addOperands(mapOperands);
  odsState.addAttribute(mapAttrName(odsState.name), map);
  odsState.addTypes(resultType0);
}

void AffineApplyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::AffineMapAttr map, ::mlir::ValueRange mapOperands) {
  odsState.addOperands(mapOperands);
  odsState.addAttribute(mapAttrName(odsState.name), map);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffineApplyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::AffineMap map, ::mlir::ValueRange mapOperands) {
  odsState.addOperands(mapOperands);
  odsState.addAttribute(mapAttrName(odsState.name), ::mlir::AffineMapAttr::get(map));
  odsState.addTypes(resultType0);
}

void AffineApplyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::AffineMap map, ::mlir::ValueRange mapOperands) {
  odsState.addOperands(mapOperands);
  odsState.addAttribute(mapAttrName(odsState.name), ::mlir::AffineMapAttr::get(map));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffineApplyOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult AffineApplyOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineApplyOp(parser, result);
}

void AffineApplyOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AffineApplyOp::verify() {
  if (failed(AffineApplyOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}





void AffineApplyOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}


//===----------------------------------------------------------------------===//
// AffineForOp definitions
//===----------------------------------------------------------------------===//

AffineForOpAdaptor::AffineForOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineForOpAdaptor::AffineForOpAdaptor(AffineForOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineForOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineForOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineForOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr AffineForOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange AffineForOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &AffineForOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult AffineForOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AffineForOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineForOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> AffineForOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range AffineForOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range AffineForOp::results() {
  return getODSResults(0);
}

::mlir::Region &AffineForOp::region() {
  return (*this)->getRegion(0);
}





::mlir::ParseResult AffineForOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineForOp(parser, result);
}

void AffineForOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AffineForOp::verify() {
  if (failed(AffineForOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return ::verify(*this);
}












//===----------------------------------------------------------------------===//
// AffineIfOp definitions
//===----------------------------------------------------------------------===//

AffineIfOpAdaptor::AffineIfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineIfOpAdaptor::AffineIfOpAdaptor(AffineIfOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineIfOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineIfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineIfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr AffineIfOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange AffineIfOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &AffineIfOpAdaptor::thenRegion() {
  return *odsRegions[0];
}

::mlir::Region &AffineIfOpAdaptor::elseRegion() {
  return *odsRegions[1];
}

::mlir::LogicalResult AffineIfOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AffineIfOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineIfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> AffineIfOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range AffineIfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range AffineIfOp::results() {
  return getODSResults(0);
}

::mlir::Region &AffineIfOp::thenRegion() {
  return (*this)->getRegion(0);
}

::mlir::Region &AffineIfOp::elseRegion() {
  return (*this)->getRegion(1);
}





::mlir::ParseResult AffineIfOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineIfOp(parser, result);
}

void AffineIfOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AffineIfOp::verify() {
  if (failed(AffineIfOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('thenRegion') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(1))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('elseRegion') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::verify(*this);
}






//===----------------------------------------------------------------------===//
// AffineLoadOp definitions
//===----------------------------------------------------------------------===//

AffineLoadOpAdaptor::AffineLoadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineLoadOpAdaptor::AffineLoadOpAdaptor(AffineLoadOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineLoadOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineLoadOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineLoadOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineLoadOpAdaptor::memref() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange AffineLoadOpAdaptor::indices() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr AffineLoadOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AffineLoadOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AffineLoadOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineLoadOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineLoadOp::memref() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range AffineLoadOp::indices() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange AffineLoadOp::memrefMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AffineLoadOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffineLoadOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffineLoadOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineLoadOp::result() {
  return *getODSResults(0).begin();
}







void AffineLoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value memref, ::mlir::ValueRange indices) {
  odsState.addOperands(memref);
  odsState.addOperands(indices);
  odsState.addTypes(result);
}

void AffineLoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value memref, ::mlir::ValueRange indices) {
  odsState.addOperands(memref);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffineLoadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult AffineLoadOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineLoadOp(parser, result);
}

void AffineLoadOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AffineLoadOp::verify() {
  if (failed(AffineLoadOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps4(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}





void AffineLoadOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::SideEffects::DefaultResource::get());
}


//===----------------------------------------------------------------------===//
// AffineMaxOp definitions
//===----------------------------------------------------------------------===//

AffineMaxOpAdaptor::AffineMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineMaxOpAdaptor::AffineMaxOpAdaptor(AffineMaxOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange AffineMaxOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr AffineMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::AffineMapAttr AffineMaxOpAdaptor::map() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::AffineMapAttr attr = odsAttrs.get("map").cast<::mlir::AffineMapAttr>();
  return attr;
}

::mlir::LogicalResult AffineMaxOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_map = odsAttrs.get("map");
  if (!tblgen_map) return emitError(loc, "'affine.max' op ""requires attribute 'map'");
    if (!((tblgen_map.isa<::mlir::AffineMapAttr>()))) return emitError(loc, "'affine.max' op ""attribute 'map' failed to satisfy constraint: AffineMap attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> AffineMaxOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range AffineMaxOp::operands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange AffineMaxOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffineMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffineMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::AffineMapAttr AffineMaxOp::mapAttr() {
  return (*this)->getAttr(mapAttrName()).template cast<::mlir::AffineMapAttr>();
}

::mlir::AffineMap AffineMaxOp::map() {
  auto attr = mapAttr();
  return attr.getValue();
}

void AffineMaxOp::mapAttr(::mlir::AffineMapAttr attr) {
  (*this)->setAttr(mapAttrName(), attr);
}

void AffineMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, AffineMap affineMap, ValueRange mapOperands) {
      build(odsBuilder, odsState, odsBuilder.getIndexType(), affineMap, mapOperands);
    
}

void AffineMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::AffineMapAttr map, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(mapAttrName(odsState.name), map);
  odsState.addTypes(resultType0);
}

void AffineMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::AffineMapAttr map, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(mapAttrName(odsState.name), map);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffineMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::AffineMap map, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(mapAttrName(odsState.name), ::mlir::AffineMapAttr::get(map));
  odsState.addTypes(resultType0);
}

void AffineMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::AffineMap map, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(mapAttrName(odsState.name), ::mlir::AffineMapAttr::get(map));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffineMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult AffineMaxOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineMinMaxOp<AffineMaxOp>(parser, result);
}

void AffineMaxOp::print(::mlir::OpAsmPrinter &p) {
  return ::printAffineMinMaxOp(p, *this);
}

::mlir::LogicalResult AffineMaxOp::verify() {
  if (failed(AffineMaxOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verifyAffineMinMaxOp(*this);
}





void AffineMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}


//===----------------------------------------------------------------------===//
// AffineMinOp definitions
//===----------------------------------------------------------------------===//

AffineMinOpAdaptor::AffineMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineMinOpAdaptor::AffineMinOpAdaptor(AffineMinOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange AffineMinOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr AffineMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::AffineMapAttr AffineMinOpAdaptor::map() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::AffineMapAttr attr = odsAttrs.get("map").cast<::mlir::AffineMapAttr>();
  return attr;
}

::mlir::LogicalResult AffineMinOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_map = odsAttrs.get("map");
  if (!tblgen_map) return emitError(loc, "'affine.min' op ""requires attribute 'map'");
    if (!((tblgen_map.isa<::mlir::AffineMapAttr>()))) return emitError(loc, "'affine.min' op ""attribute 'map' failed to satisfy constraint: AffineMap attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> AffineMinOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range AffineMinOp::operands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange AffineMinOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffineMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffineMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::AffineMapAttr AffineMinOp::mapAttr() {
  return (*this)->getAttr(mapAttrName()).template cast<::mlir::AffineMapAttr>();
}

::mlir::AffineMap AffineMinOp::map() {
  auto attr = mapAttr();
  return attr.getValue();
}

void AffineMinOp::mapAttr(::mlir::AffineMapAttr attr) {
  (*this)->setAttr(mapAttrName(), attr);
}

void AffineMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, AffineMap affineMap, ValueRange mapOperands) {
      build(odsBuilder, odsState, odsBuilder.getIndexType(), affineMap, mapOperands);
    
}

void AffineMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::AffineMapAttr map, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(mapAttrName(odsState.name), map);
  odsState.addTypes(resultType0);
}

void AffineMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::AffineMapAttr map, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(mapAttrName(odsState.name), map);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffineMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::AffineMap map, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(mapAttrName(odsState.name), ::mlir::AffineMapAttr::get(map));
  odsState.addTypes(resultType0);
}

void AffineMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::AffineMap map, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(mapAttrName(odsState.name), ::mlir::AffineMapAttr::get(map));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffineMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult AffineMinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineMinMaxOp<AffineMinOp>(parser, result);
}

void AffineMinOp::print(::mlir::OpAsmPrinter &p) {
  return ::printAffineMinMaxOp(p, *this);
}

::mlir::LogicalResult AffineMinOp::verify() {
  if (failed(AffineMinOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verifyAffineMinMaxOp(*this);
}





void AffineMinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}


//===----------------------------------------------------------------------===//
// AffineParallelOp definitions
//===----------------------------------------------------------------------===//

AffineParallelOpAdaptor::AffineParallelOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineParallelOpAdaptor::AffineParallelOpAdaptor(AffineParallelOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineParallelOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineParallelOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineParallelOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange AffineParallelOpAdaptor::mapOperands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr AffineParallelOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr AffineParallelOpAdaptor::reductions() {
  @pvùj¬ @ÏBcàÑ[+
…
¦_&Õ÷ç·?Xmt«ÆÔD&k-a(ôÍIôño÷+.(<xoÑa-K0ê®2À::°‚ù «÷Ýa	ÛrTJ‹½˜ÙÍrù´tdé¾^%p"¦r÷ÚUÔtj'íBœ! +dy0Á]	ÍDm^àXek0ËyÁmÞî&	i;€+]<àð5ófJ%ñVï£Üh;hm\(°ÛGw>8OƒÐAixÿF Â¢mÝo]{?ZBL&[ù¸ÓÚFS l.JæFva±eÈî`oê!>MŽRHñ •ëâ> àôXu.Ö;ÂÜ¤%`5bèù|9’ÃP·wÅ¨«ðãê(éF BÛxwêUclnnhq^¶ð<‘M†
2à ÕNÞEæ¸>ÒÁ%Äùaíz“ÏþÒ†qTEqý2ÏL=ÓhBh®å}dŠ ìkvÆ¸^Kç¹mh(jˆ½qd»«\^`úv‚FÔæÒ+ÌA@Åg%xtnÊ€Ãm’»’S¬ývÞxÿ\©
õ”ÈÈ±.Dg"{Ã"æ“Ì¼37E°\AQfVÁ`nô‡aþEìbJó¬Xeû&òËâbU=#›,ÕÑ)vN*J†“L5\gFR1ú"JaEeôÍHåh{÷õâs°d:¢ß²ËÜ÷»ásÂmmš´Ò.A½i§üÒ÷ºRbng`sFö3x~~¼‰ÐÀ¯¨0KNp­rŠ³gÞ_iÂ¨ã‡ÉÝ{Qc_[03cþmÍª¡a{ÔLf4û,g )D'ðÜšŽÔg¸oHCÚn¨x#c*`£ZDC.øfÏö@ÙLS_•ÐNåüe‹qî4±…ôó¹ež‰|2ÐÇÌ_½'ù^.õ3‹1›Õ×Å.øoî òæEï4K[Ó„°$&ÅÕùÑ:h¡êaf­åcó†›îu7h8(Ä¢5iqgWZã(óãÄó,ŽIpó&#Cû}A'U¦z°(dRM$Á’PÚ¨:CsãS!¼@›+®€l]*¼•| Q=É"èÌÒögv†ñi+(Râ)[oÞÈ&QH“\Ûø0æåb(kS×¶eDÎÂ>Æ`fŽD]ú§Nd¶is‚f"Þòw‘™ÈŠ©Æj¶Ü{¿èífäbgfEal¹Ç-PxPŠGNæZ.øú$Ýeó.$ÃÐ+ä–´ƒÎ«[I…Ë7²LjcälE4ÈÏ|yNÑtgpëRj^fPÏb¥íÝiT¼l-¿AhpMQ<{F`WC;BmâªipLãRÑsh*(û&ç×2Yuzß~¥X¤õt0V%0<‡¦jì+ñ5¾Ås_õ#ãÛ¾E+ç ÃŸ?tÎ4pf`k°0eie0’£æ‹ 
ù,IqíÚ&½.7fã¤ñ8m|„:gÍÖ}cY<þ° n8êÚÜe#ÎLõÔÂî@îƒq±pÝrÏãôGxó€u¢ëÊ’|,%…?¢M8a.cfYš`5ÏÃyb]©lD¶;4y3[ÜúcvWcS 8|1\þ¤aöñâàY?dŽ²Q©_qK~pJñð	h#VüJ¹£v~ÌGB?B¸Gæš¡f%Z<?h¼úUuÏCÊN!KÊntkÂÑýØù(ßvn?ôé'š"j&7?øyíO~XgïgLã*QXEf"*æÎ¿u0%ñÝÃ§$ï†ÀÑæË1Ç!@‰¡•Nezc>ì`–ZŠzÑÌ2.+húöò¤7s ÷Ã
yS#øƒ{pxãPG &¤euès’£ÿ{ëyrztg;ù8z^|¢9ob-ßÚs±‰Ìe`~g7]I†€<¡Á¤sädáâ×šigß4 ÉM.BxDe@2íd»iÎW¬I)™2ÿ:FòÅí‘é,sAc))š!¦¦vóï>UÛÄGËèó‹‚ÔÆ’gGu-ø>Á0®¿Í| 4ÀæaLò|t$qdÐt#öçX‚CÒIHY-‚tháß?B¼:äªw4=–ûâdª=L;þb`íIHH°
õ˜†r,hI»Ø„™Î‘JøYÎk×¡vv,BØÏC@`ÒkÝtíÊÎRUãˆ ÀËk8¬ÝAQA.i Ú8t¸XýÏê9ek„V<^l¬ª3â`‹[C¢*iÑ0ux=f‘£CvõpÞ(ÕuÚmIn´+›(¸¬dn|z3UV2‚ÅéL	v}“ Au õ$¸ £m‡rï‘ªÓwðÁD¤!èB(ˆrd¢
dm}¤Åø˜ÎZú<¢á¹ã5òL¦o’‰õÎhmçîC–iã$ +xá“—Rÿòo×t¿é-¥E#$­$ôãTJ\Ö76"Jónâc´nÐkkGí~KÞdå£¤	koã¢Ž£k¬¢{oÿ.{"9R´V9åŒVPò €/M.O2ÓxÄl67°¹â'=íF&ýËÌ¥ãÖÅm§ó ™}‹~¦7¹ÃÐXxp{ØÙi€·srðC[t^%g©b÷dY²Ó«%¬MSÑQµzn!ÝÄi2’>|Øm1] ‹çÝgS€$f˜¸­;oWdr´ýúä\9Ìn¦H$[­L/l$r}Ur“`¢ÓìÉAdähÏJEI@:d~«-?7ßÃ †3nŽR€÷„$Ìu±FìBLe/	"Ï+Ûðö$~ßÏ'g,Ygi½¬š[ý®]kœà­Œ%¢±y6fkÆñÂê…ö3ÀAii‘^¸©gl6iµŠMØ^ëˆ]ä¿n8[‹ å¡ÚN²BjÇ‰ÁGä}<u°\o¤ _,Q‚Ód-t{WAêŠW\îT‘éµ7³ËwXêîâ9"pf!9  ži—á/y64D	_,C|ZÇÉDªw§þäó.<,;`iiaW‡;‹Œ+{`¨›-œÕfŠáï¶©n.Qa`h"îfîº ËRâÐ}51mX0G´ÇU<qÃóõ®ej>Dþw×îhi3IòPc;&à€x®+`$ ià!Z¹hïhmÃŒð¬{Íjú÷æJ}3Èµr)`±¶Ç\íñú¾¾kÒdAkÕzZÒpr(jÿQuÍgþoˆJ^--FcÀwÒÞo~zÍP,5ZÉa5‰_ùyqx—=Î{Å¸ˆ+BsqiÕ`ó×i¨nõmbÃi4ØWÜÆ158—™ìkÈ]Ž$ ¡Í‰Þ6Þ±xß{êzCOö™Ñ¶ýa'Oö É™áÊfa5AØÿÌà€k.Ô^#4@ðqiz?Š‚CRÃl¯`Ï3¬pœ¢îçðÓþyñ:Lë.ûÌ&XzifÃ_iÀ&Þwìü y¸/§3oAç¿ñÇ }4V*
™Ìn‚Jî¬ßíG?GÉ¡ðâF+Z¹aoë4a}X%4 ôÇvà˜9zBler®­îfÉkrŸ·Ï`ñäŽŒ½õBHH-¤/:$þp£€~G˜…]‡Í¦B4øòP+9EË‚Fîdÿª—rMãnSÔ2~uÔ3¬&†  "‹ yY¼
æ!:}ûahÅBîOwÌìrƒRà|wëO§äÒIÁ´#…¸3{¼vªòâ¨ñö ylrDl¬(`òo’tç6ˆ‰K)à(§¤¨m ~×RÅÎ?wFa5ÑØ5ORïE°çGà&rñÊDv”¬:´LOÊï¸ZJDÄÍS÷œé†ÿdÑ4 K´Öæ¨~e£„5&Y][-ntÎÝV dáª+a5R'êeC-‚ìÓuVOÒlî~ð+¥ÐÚÁa vYs§àðë8ä×ÀM3žnžà‘‘tÆ{Æè¯¶Û6AoˆÙ$=›Z¨&ñœ“²èVsÑoð$8_bûKesz¿ï’÷­I1Ú<îlëöe‚µ´ý0dçoZ·=MÐ1cíút|œ¿ˆž¯xZ:uÄpÆƒF¸à~î'i €®ùãl=&"  àkô)ÉTÍ`©1ceÒsª‚»Í„´áíÄgª­†d5ì³qâ`£Hèjy[ìPh;yRsCnì¨˜¾è%fªµV·²gò"m$Ûµ œ¹=D‚íÉpJíÄlgß$£µÇ^"oó}æg™¡`³1G´UCáÑw#…ŽRþ …î§u-¢c9Š»Òc%lœvlÛ0¨|M:D”­pmÐ)gÒåA(©]g¯É`aF)øMà8šÓéÃtjé™·ˆ]61úwzÄ$%&Ó}¤å|JoL-T$N1°Ïeï",†l#zƒ8NN”,GHt5 dl—Ò¬ÂÃwF‚™êqm/IMmÆnÕ&QVò!çT!cwo$›¥ÁI(KÇà¾Ißâá¦b„ª·Oð6rÂIÔô¼i }³ ³ psgêB3Q®—U¬\Ü°vFf]|^P émÖW+f¯"v_ Å0Sis+`ºêöT$ãu(`•?tLâ¹Æ~tGÀ9¸àõÛ¿À}ueqâw ¹ä÷ìÖNn0¤sAêWë,2„pf_´Z+ê«×6·6[|-þð sÌõOr¨Nëfø#Dv_RSóJcxz¤5ÒÖ0/ñ£MÃwÆÜãñwfäN3dEúâ(›ZWUý¾3]qoL(»A¹ÝÏcº—1U'1iv¸q_@ÎMl¸k
 ¢“lí¹ 7‡cŸ¾ÜöÁ¬Äá„+õzèFŠÉí…Nms×guméã=ÎÎÓ¸x¨–|ž¶I– œMâ~ÜÍÙ_Tqóa9nvÔn ?IggœPS*>òC<U3-þ>0zê\-üRët_peõß¬‹pï÷|1RÏÆ!Š}®‹Ù­HÊÕ’K•d:UÒ…õõ•G[dŒ¦	ä½>”(Ü‚8ûl?íy¡íDI_çåuÜESÃ¨uÕ|Î°JKã|V~{á"Mj.î0íô/«çàOf1 EYKØs)×‡dw³2b¯g¶qaº¶É…c¿8~ü¸z%ZsG\:Mëq]6ZŒÔ£¶vfÕíd)ehN¨uóô­}°@mÉ§04L6@D}5¢*:=5,uZÀÌÈîzbdÙÈOqÞÿ`w¥DâtlõUlš*³àçà)_R1}†gû›Þšt¢h{eIÍƒXµñ\)µ[ %#mša.Ìkwhê]D·âp0¦J@+,û®Ë(ã"àwr{ {"ÍxîeJG4Á\½ `µtÅ€N¶£5?ü7€&HWfh±:s0ýn„º ^f€×Oúíj|J^º´o­öÿr5×ámÞUR°‡lÿK’ÕP»§anï {_xh‹ð†Æ$Ûo€(¬²a|ÐËâOq8wz!äáÐEB`DDG´ð³,ªŸ
A"Š*xfL‘|ˆãæx=ÅÜuà©lÛæ}Í÷$6ÃÙZëTr:+Ùboyúû“qLÁ,;(«"èU>Âª#ë
!£ïŽ^Tb°Pâ*CdE³[äx’'!òlt¦°M¥aÔ€ø]š&ùQAã[[8¦– öþ²'ÄnÜ)„dD ¥–=ž¸Úõß¥Xû–ûýUsÇ\6 Œ\ æ¿„,
jç0J.­È¨$Ùó6xf¹4%J‹µ"lb5˜r3Bòfijh}ì²-m{Ÿ"Ù?ðá!…Êª|¨¤{I¶–¿ÚB±¶M>eªà;_˜~…â¹JI>ÁKaÓRõÜaówMImIÌz'|­ÎXàaKŒ…n×‹*IÜÆ÷¸w÷ûsk³oÐIxAÃî§†9ìGT
°/]Pvp&»:©ã­ä9Þñ'žlyQ…ùÏ‚¹Dâqai¢ÍfA3~äòV3m"*H`ë§Í*qáõy Fs;M · Õ„óVfmn:OÎ$?BSYâ{`tSôÅ{RÈvc’Ü@råûDö§¥!ã}
nä€Ð‹o£k«-ú‹+»(
÷>ÜêL.:Æpñ’+Sô~*¿&bµ±ÎhÿuObhE´*ÆÕcç;Ïfº"óÒ‰|¬W #LÁ}AqM,+EÕoõ›Xt¥!ÀlÆ
DÏ8i°ÑSÄÿAL‰åÿOQÉÆòd<i¥`Aaî¢Ù²øáàÚ²cé_bà‚»ª.ÚWÌ.,;6¹stçíB	d(Hùwl°F%hpKfÉbhMºZ>F=_Ã¥`78'I»ˆioeáj4B ÛkO!^DCgà¥ «¶B±êlü÷B:2UxbÍhÊ$d»ÿhÎê u²ö`ÖÔÄIßÁmiÄC™Å~X ¼Z*Ö ^€!),{u©¥ÇC¬Ti‚×9ûè:DyŸL^®¢RÃFµødböÂë-}ÆátB²ÞáØÃó"o”¤æ&¿ {ö.[Æ34^\×[r_Ç(8ÖëŠÞJ9øãQks;ýÕdqG:tvÆ':3KrÉ4â:oá{ë úßðzO!¾â•!ÑÁÔüxû¢³EÑ0@Q–)waœi}¸-‹’DPlýB-n-Àd¿…I¿uu”-A1œNvôºWu…)"{Õç¿îâMþb?V‘îižC$lU0ë'Œ`': «„natQf7ô±aCDBü°è'°ýÝçõ±)Ìøb3n¯øêˆªhR`õ9ôMl¬ó}(_{àÕš½eÿ ‚4¿ÐcC>u¤àbña;$šhÃ†saÎ8ÎQšÕá¸jVû	ŽrÐ` E{ª œ*.}O¢éo$+,]WÈ†Qè¢Ó%ƒi“,2Ðùøj@ùê÷¡mD¨ê¿¥’†u",Óg2™ÏþRžƒ—&Ì›n\Èg¶$Ÿ%…Ó–¤ âo“Šñ0yÓ–oÖsõ©ù ¦eþ"¼hõPíH0slHI¤6f ÈÆQxígMl’ÆïAA€üŽ÷-;frsd€cEJšæ˜±K}™oî!Ô´®v6ï#¡ÎÎV@ŸTý÷ÍL–©lHô¥ @›~˜¼áE+
d`‹E2e)öizsf9æ)(%å«2-á²ËCƒma÷¸Jì©iW ÇwÞµ"$aã‹Îc6·³¦dÈ?	§½ZRO
7ÞòIgHkñ«·.™I6£>qPN7µ(¡ûsùpýr®+Z) ÍAûž«­*zTW@OVq0?’Å=™Ä£~Ä-åIOP, ÕëVKMÿeŽeV\KÄpQÀmec¤UÝ2As€~%DQS°g"×è'üin“Åë|D@UhûpÍ^jî–‚«ËDùkïÂKlpL$æ. 	€vÕV]~AøÉ¦ãf2éú‹£ÈïJ-Ž_˜SÃªIÏfWØã»)S Òüoc#ùd9»ndY±D¼Íve1¨/Žï	­~'hhŒÂä…øF 	&X¾¤NßçpåÒV>m˜öÜ¼–îšd 2n‚(s>eÜ7Á%Õ€fCP–¢rTÚ\‰,Ý]/n\ Ì>wÜ|«fä1=m^¹§”Ú4hCâØqDofòüqû˜*ômzýk0òWYR¥ÈDÐ6ÿXá­JÜ*Þ¯	>Ë€óRigeF"¢`2‚VoñjOëŠ#†©YÂ½ej+@	7@¥íç‚0ºÑ–CìÆÑOKáidûÆë€döÌÀ}ÛÌiöÆ\EDMðæƒAVÜ÷¢[+þ¢Bnš&üë`xbÍÇVf»-×Vd±:/œ×k"Ç/ÀEÝ{m>duù[iihýè9j}­g`…nS=\©#{ûsïnÔ/*…» ºekýÚmxwîo¤u/u°h‘Ý¯í §ÆDnñð€ØáúEo ÿcRàâS â5eQ¤Þxž¿GìAt¹ré_ðeàmn®Ê4BapGÑG4hÏ$Y-å[ALî,(rÞTFo8ZµiZQ\Š™Úkàíkq-ôþdXÿ*·ƒ…afÌ¶qâ!‹S0]fèáDizc&‘¸;dçà,Ï!N¶Ë¿1¤ƒú{sì}´rˆ­Åsú×Ža•n—Ëe€PJ¬Nex¼ªèÿÑx“àˆøh‹„ÜHäA	bÌg•m©ùwZ""f“âÞ$…jÊôià©z}Jnæ%êÖûápÄw{rCM30o16OéšÀ’[êê™Íö8ý…Ž°âFNÓÝê£xIªe„-# zèo®~Âx±;‹@¨JÉ®™ $xš-W•K&Åx"Ùø„½Kéé²›gö Nvl!uib#bqK"c·º§3)cÎ3dÌÚeóR¾¶K#waUý2å#èLn~“o]îóI`°èh{× D×lT²¾+Æ!jd×¼2Il4€nÀ{cö1ß=)iC `Ï·†%`ljBºð{cK8®ÛaµxnïXÙ4Ù# VŒ:Š¹TÅÛëÞ×xnVã|ÏÖ‡d³Âò:ÿêOý®rîN¦}¹ó«|Ðøªë]}Ü÷$ÌÞìÚ%*JãF#À¯þþ4+OH#6DÔyOv¯/êqxÄSBÝ¶uŽÄA”á©«`%E~0“u# ùLšÐB\ìUèä5èÈËs3ä yLˆ!P¯Ì9œ%èÄGu´5ßâ‡rÞ‹>[W#eíe +LæåNÈidÊp`€ó.nÒ„zP¯ô)¤ª}g>ký?Èò"éÐF»Ûì$¬AVéxùRII¯Ê .ÎÇ£.ý„¦ä2’…'³Há÷ÄUX]mõÇ"[tpµškDç('lÙ5iéEg³©”)Ô¯ß§ìnU$oµfCç/|?Ý=ï$&ô,jôÂ‰¨Jje¸¸žn×w‹^Zä/,41æä'€ï¡tBÑ"‹>&Êuìá ¯Sî¡-áˆ˜d˜…|Š­ÌtY:YkI.Wf—(Ôö9›!ødtbáîÌdPìnn#9-3`wre¹¨61Ãyè|Fc¾p>a«´y8X/ú8~„AâëqþÓç=”ÜE¿qžO£ÑBdýçxGãL‚iŽÎ¢JL#«°õct°×?	¸mRa¡3ˆEñ,ÿXÿ º¾t¸¼wðù)Óžã!eÁ8*×!ò¶ê}„o#y“íûy`6;) å&¬Šã"¬"`öï¿ðeøª¢í˜ÏŠîyç[­æÄ¿Sý¬£s*Q'fC\åSéÃåFô…‹xzæ!çDñÛ©sƒA,&Ù"fSíCgK».jM×ãr[((ÜT©"ÌÅ]‹àU¯É™*7Já›dŠ~H;ÿÅ„XÝ}DuýT]ôZiKx!í¨ãow5WxW	²éd\ãÌšn¨êY^
:âà#Þ,ÉyÍT»Jù¨ÉÔ~«"“¹Â Z4dJÜcîšÌ0eó€Ô-"Ïgä¯biðá}3nÒyˆ!	!"lP#æ}LPñx)¿D¢áAi•\Ì¿TÙŸ6z5›uT4ØâècÇnPÉôA´o6tóÄùÝÖfOcIæ¡ô(‘Â&ìÐÉ‡å|gîå¯¢ejxËdüY)ž{2h¯á{§_Éñ8©N_È‹DÝ}NÔþäËcm†WÚîk(we‚^aÔµ>¤GM>	eÏ@Ilýê7ˆì¿`(T…iÖ|Æ…Eimäzà5±iHÔBœ-ñ ‹nˆ%õ&ë0|ÜIOMÊÃhëÿ¡©ÃÛnÙx+Ï+æ"$øÅ}¹kOp;Oðò£"7Þ&-*vŠjY…ó6÷e®vMåÊo{æ)“ë:R{ËTG²ê!b-j¥ÔRz`…/Ü¹a„Hl³ØNRnÌMu*‘)mþêò-_Í'lõœã¡À’ É óEvGÿ¾Ü)1sàÈt1~3ÚGqEˆ´0‚'Á|+wnsôÖ:33ÇíŽ(m-Ú9Íøìä³á°{0vn3ÄÌp”º*íWU©ACœ„«/¨±§£Š`òk‹›Q\RR}AÞI*›‡¤Ý
2ðpõqljŸn‡@›0úáHŒ"×íõ=¡
/&èÔÒŒÿj§¼Ž‚4HÈµ":›*Y#@R¢ÃP3fäµªIÓ_-SGÜGñÒoeþµÛZØ<è(VÎ]!¹MðºiâÀÅ%þB±;‚µ£g$ú,=sR@ÃšEßü(ï<¦ïC’£‡$|öAPCþj"0IƒQ+,ñ:ÁtZš"`ÌA‘r©=eMu/vöJ¾O%È×¶>ïï5í‡qSªt=’L2/…‘a ±CÔìíTfH­}Û–mz²d6ÀxWecCíEói•Tú™^“¦,År;¼Ôp@ƒëÅlMpÖg¡*BæŒdÔ'ÒEa±ìÅ Qp/:ÏÑÕúÖ¦Uºls4û¨Œ&.»à‘¥¹àµ0zeN“^ý³Œï¾Ðöjl{*jò#Ö~êi£iœ@+b}^®~ÐîÜ¾a°\=D³Etä-p ÿ´hjÙåXc7îF]ñí”	NÂÍÂl?nÊ‡YlÐ‰Ñçå$FßÑÃhÈGÍ&T bš6j~×oýÿQ3!´Ouâ_ 6©ò÷:Ú’L :vFï7è¤-Êmj9÷dœ¢.×v©•ÔŒhdG9‹eê~³ívÏUEö¤ß|}€­;'ÈL·òÆm`iyë	#k‹±ôU†9,TBú™ªú%~VÐ‹nUG_¹©æîcAñ©€É+qAÖ¬øhŒS5ª$ôísÏhdiÈÄUe£¬µõ~ugp.I~ä@Uï!Òíù,aÏï6üTlVùªì"ðodkaS/	5¹( &$ßqg·kPu|
¨WÜV7"-Cª¼Mˆõroð).	<y_8aoCrbt6à(±Ærù
.ª2Ë-	ÚR4*O—òÙvù¦tÄô¶Zaffðÿ’UÔvj$­AœP?t]ðU@If'^dSeg±Ûøqo,ï IJ+we<ñX4û"[uùzï£C<jo@MmT( ýp#ÿ"˜O»DAi¸òDqâòm}o]{8j>ÊDfQ	u°ãËS(l: .L6)±E„Æak¾&UI|Ò"•«2*”?ƒºìXi*×»Büà¥f5bm¹µyæ¶ïÅ cà9ãê¨©P2êuawúPCmÞnL%q_¶ê<]Î9"à`EoÚeÎý,Àé äùÑ­z“NtžÖ—eQqiu92Ì¨<Sà (ÜuwmŠ!æ{ÔJ¸4PWC÷¹iè	ê¹x&;íëXâþvBFtjÎ+qdÅg§x|~D+Ã}’ùÒa¬ýz^i|á
u¤ÐÂbn…@v2c/ä³Ì¼“v”(aSn_á`-µ·e®Dìfp½©Peû.2o<b&U!5t.$’R)4NlJ†¦h5pãCÂpJú"lkAeôí}@eR}`…aS&¸Ä}(o“ËU¿e}åOm›¤u*E})±=|²>"â+õónö}y:~º‰Ô@¿*tONq­Öc‚3N|ƒI)R°Ã†À™ûD£_c06£nmL:‰a/–î4ÿ9——k)p¦ðØˆ¿Ìe gmAOlhp$g`(h¡pda®Pú&Î	VAÈ$SÅb÷üIƒSgvVçù%–|ý:ó€ÇŽ~¿%½_ž.õq>Z‹u‹UQV†v~N(öR¥ÿ$K‘…«L$cÔñûQºh¡òab©õC²–“†t·r8ì"%has7XÍëe]çÔó<çPö"#Cù=%|@…¦s¸pÌ#RQdñrœ¨:CxòR­¾ “;àˆl*¾‘} 
=ÈêøîFyg.ÎIÓy•)VRâ¡[çöÈ"Qi²k¨0äoâ82E×šad{Â* fŒFmø§d5A3 [²u‘Qˆ«Ænäå{+ˆm&äf"gEmn8g?Pp[ªÃ~æN.ý|<E!·-6ÃÑ+d–ðƒÌîSI…â'âxo!´?(Arzh8y^ Õ56tðëQ
"mÎaíy[ˆe<}-?ÁpirY8yFàGk“nâ¨¡dfÆRá3h*,ˆa'gß:KW
ßvY¤=TvV-20Ç'Da#ù5¿Ëq>õ/ó}ßâE/£SMðÎ$t¤:+±p=ie §dKEJxŒMðoÉ$´*'fã”0)ü8e½?<þ±~8ªØÝf!F7uÌÂîDýÐqðq oE«¼dxÀó’52êšŠt,¥D?¢I6á?'QfH˜`‡G{²[­^w´r+zø:gr™Vg3Óq<R|*îîô`Þ»çäY{ä…w½_0Kîejôä	`'^øJñ§7Î
@ D8W¦š-3cX0?h:è}sÏƒzFe[îwvs¢Q¹ò)tßvN}Äå%š h&4°Ù9/gí'èDc"W@2P(b…l90%‘Ýu´fÞÀU¤jUæP	!TÆ)Z"~l`6ºpñN2,%úöè†u„’3 ·o!$¸,‘mzpãGb$ôeMgøCÖ¡ö{òAc‘~eg/a([X|9oâ-÷Ò1ðMi n'\YC€|ÿ¦'Á¿¤uñ`åâm²éGß2ùt:R8FmD"dõ+9¢Sl|)™²¿;sE Ž©‚i)rQf0	ž9e5&÷j]fs0…ŒÄéøû‹—ÔDme'º>Å  ˜DÌ<!P4E¦bŒ³|t$S$Õp¡öãxRC×iMHx-viÁp=8Z.uöU4= yâ]¸=e7fbû íIHh"²"ôØ”RA(pU;Ø ¦ìÏ
øQjs©Sd<NtOC¬pþKÑ ï
àtuã®$ëi8åÍQSÁ&jEÜr4tÈA½Çz)A+„V<x;¤ª‡zE‹[
r+¹Áuxdf#Wp|n(ÕuJein"K: ‰¾;l¼j|s3Wä"ÀNÄéL	n2*“¦Aõ(ds, à:£Lm¾2ë!"stòÃF#!`K)(vf¦
4i} „8Š:w9z<²Åy¸ä1ón7(#šÍµfø}g=A–yi$ac>ñ“5÷}z|Wt7Í$,G`+$ˆ%ô{\Þ6vRJönîg0QvÀ:wéR®6kÏ.sÇ£¤Á*gúŒ)kºi}Oo.?~2E^5eŒwS d7%OnOVÃx5 3T³g0=lv2{ÏŒ¥â›Å—c)˜%Ÿðç3U¹Sœápaò›iÌw7z!ð^-k«‘röal’Ó©.MÛeeY='1Lä`2²*m¸j3]1«çÕ&>“ 4oš9é›mV r„Xûç|	ÐÎ(Dó¨eYuD.j,j}Qp›Äs-wBìì4µAe0Ä`ÇrEMI!	"l:‹)?3ŸS€t^3l)ÕÞ4$Èu¹TlRmÕ3™rß+ÒÛñò$;
‹#v,u/ ø$ÊZýŽ}cUè>¯6áýcinÒâÆè4ö`!m¸±lp[g\#ì9í›Š]wá¨}Äx‰Tÿ!s³Byç:ˆ@GåX<U1°]/¤›N,w£sdx~WÉé	WT´PáM3¼«m[1aêêB92Po!) hÁ—åbÝ¶<D]rZÇ‰/5óÞôú><¤tàH#AUEº‡Žnow [GÕ#f²ƒ`îuö©Ä$q`ˆ("ìz¨; BVâZ51d=GD¼Ç~yÃñu®eÂ~F}Ð×Ohk 3iˆPÃ>DàÀ,äda% }ê%_uylõX}ÃVŽà0{Íjºe¦Jy7Âmq)â±¶Çåñðî.jz$AkµpXÀtRh.P÷PôÝÄro
*U/5S vòželÑùÅT*!Ryq1_ø¡qw<•=Ì®›>…8MBqr©…dóÏháZµ6-b#)d˜vØv9p8ŸïocOÊ&%¡ç«š:”:óxÛIz;OöÁ¹°ýa&_§¤hÙŸ,aÊe!¥C—XýÌèKnÕ^C4@lë!ú?Î
cSâ@¾B2(]˜?¦îg½Ó~1ñ4-Lë5ÎH&hNFÂ_9k &îSz” ñp/¦/AÖ«q…sõ4VzÊ¸Ý{¢’Jï¤Ëëw¿C©àòâL:zùacj-eˆHg46\(áºjÈ-Å2ž½Jviër¿³WItô^¨¹ŸbHR¤+:¬~z³ˆ~gˆWq‡M÷C´éÃ+=C×BradrM"?V2:µÕ:->¨"""dñy¼OezYùÑiå#Ç×6è©rµRá}sâo§fÂIÁ$…²}¼r*òêóf¤"yLQ4ll8 àóoÆ@ç9©j,`:§¤	¨o*~DÕreŽ^tFa5ñ˜4?@íe¢æDà&tùJt"4¬?õMJÎ:KÐR÷Ád®{„U5pK°Ýæoek”3*Ye.%gxnZ7 äc¨dA/µV§«#E/ÄìuvoÂddöõ¯ ØßWe"gc'äÚ).÷¤H#Ÿ|“|Õqgv×ào6ó>AŠY%<r›zyE>tŒR"zWbÑ-õ`ˆzf‹¤÷‘ø¯ï ö¸AE}¾k¨e¢£u•ì½0üåox—x-Rfïòt9œ½çž7{pz0q„pf+D½ðVê6ie40/`ã(=)&$ƒá+t"LÜ9› cgò3èò®õe´qìÀfá­Wb5øŸ2Jiº!È©úx9ôxºyPZPn,¨µÞ`$l¢ÿF·¶~ú/D- M·.ôø-\9 ¥(rOmÌ%e8]#¥æ}:éúÕânš´&òsMôUCAÕs#§Æs¾¤Åï¡1çíxª[©èy?Lœ&µr0¨|E*F´$qit fXõE!©]G¯Ãab')j‹ãúÃ¹qrzè˜ò©Yv1îuzD,5,/{u¤u|H'lO)R$Ï1måsî",†2ji?£:OL„†W4õ$ tlSÒÕ*B•se ùsæptoI}íÆO5gQQWƒFÒ-÷d'cwg!‘%‰I(KÇ þißîÂ¤ãª7ÁOÒ=zCÙäæ´ap[3$±pøw `R3AM¢Wõ5\ü> |Cbe|OPðÔW.pç6vuaå(SmòkácnFòtãU~,a•7|m ñÄftGFà}aÈõë?ÃQuTefaˆöe,äð”–7No1d±ÁjgK5$p*µJ"k¢«W4u-¶X|¤~òhcM•Kb"N!ƒy T7zZQÑOÃyú'URÖ /q£OÇÿÆXKãe¾s­¡n2nõ
ëæl—VCýž3ýqc`,»I¹yÉ+Ú?—q/4†(r°Q\YlÊh2ó{|„Ó-ÿœm‡g
Ö§]´äŒ„¡4z/:èÆŠÏåºGi*{gdm;­}ÞÎWú}àV|›öd>fqœ¢úÞmø÷òJ4~rTg±?XGdÁ@c">PC.U3(ú1> zzZ}luV»5zpeöÙ¤+ô ó)1VÍægYÝ«-f~­ikUKdlU’ãký5{b±¶3ä$>¢:û™d?Zzdø@‰_ny5xIRBiqDxFkHbtþ`#Mj.k²ýð'£ëàKë1 MqK„Ìs)×$~G4`/'ž1aBþYUbýs|z¸¸o%szEt?yïqe´Cš”£à~}æ…ù`/d<B)põÌð)=dmÍžcµ(46„|5æ,{¤p^$Èˆæ=h3%yÈOñ+4÷`u¡^ëllýOT>š(·=,áä)KJ5uÏÇP;ÉêNcLe((x´ñ;|9[h;!bdVA,ÌkwHÿ@¿¢t´†J!ess®Ë)w"¬u yk¢Í îa*6Ó\="Ðí½1EFw.§5|5Â$(W6i=Pzÿeýj&82^æ Önòíhíh^:¾/©vÿr5oÛì?üUV°Ì²=s¶ÔÐ;§iZ+V{udðm!0†G¦ÓÁ<¬¶a<ÐBÆý|};!åñÀHbÀL7@Gµð÷lª?Xe~Úª}vLØÁTÉãny}%v‹ph-nŸd<Àß ¾uû:{Epo*¹kOOóÿ—sLF&v(ê*2í>Â !ã	!a§Î^b°Pé
dlõe·Kt8±!zjvæÚ0É5a}ó€¼]ºf¹qA«S&,Q8v–Aön²Pnøadde¨¾-–¸;bqo¥9›!ïuS¢\7$,\ˆfK¶ŒnÏie° .Úmè‹ Yã20G¹<7%J›÷@Âe˜rRãea(úmî1²(ísN#ü5Éá +îTµ¤{Oº–¿Úb¹'M<mcñ+ušüƒâ»JH.C(WBÕÜãáu-MÈe?a}Z&h-ÌXÍiãiŒÅne;Q·49wôû	sa±IÇyxABî¢Œ!þ@‘ð¯u[cp$»š(ã½ì9ï±W'Ø;€s0øÂÂž»€0=ac"Áä¥3{¡¤ÒFsm"jHh£_­²!à0y"fk;½	µ(Ñ°£v¥mndOÚ&òb5ZbùstNüÅ{nB\vf“›^jaøFÔ'ce¤AeJlä¤_s¢ë%åþŸgûmSu>)]<*æqñoq%¤~	¢¿`5±îÑ{Tbja´û	Fíbg@¨bóòˆw4w€2,ì}A{Ladíïs‰Xf­© lÆˆ0EŠ2i˜ASÀ¿	eªEQðBòe4¹„°!ì¨ù²y÷ p0s=ë/âà¤½
.Úìzl;4¹?t£íz"	,5¥!Èüwp¹f|tS'Ébh!	š0e5GS§ew?/a;ªio c!*f2FàÏojO~LBÕæ…åÔêöPÔ5huýuW:0updÀÎŒ`¹=Æòát«r¨^„¤	žÁ1kÌwñÅZå¼Y"ß)|q*-<E<Û¥Ç¬)ŠF3}j2Äy N¼«À§N6ø `÷ò¶/4}Vág82¾#èÃó>kÜ$l2·±;ô.CöqsX|×žYpšÇ¬xŒé‹Û 78ã`p;5„Gpc´{4¾F;:±Q2æ(o—í{ã0 ú?·~!o5|¢“3à@”ý:ò‚šÃ0$q–#céœ!k|;»-É¦mX1=1r-$4T&½¤	¼uqU%°f´²Õu½h=b{QãkvbOþ"7V!î)g4L22o%Œe:> ë¡Tœo`w<pGWÔ±ãLnü9x??ÿýçùù¹Ì¸|Æ2L­x©¬>b`õ!õmî¬û}(_{"õšuaa 6C½pjS$eìb³	1$hâ‡sáH	9,4Q7šåÁ-JôYÔhXB`¢E{è"~.>}Í°xi "(0‰–UQì¡ƒ-Q£-2Ñ}ð* eýªï¥oÅ*j½å¶uc,Ñg)ÏxP¡)~ÇnùÈc·t6-œ¦$om[Šñ!zCßžoöw4¥Åù,09# eþ&< míJ0sdxkK¬6fS xBQ8­.{!hòæ®ÉA˜ì¬å-;Fb0$€cE’ü0±J}Uv®Ä¶&tk!9¡
ÈnÈ\ù×ML–ªn
€€@‹~žŒíÍ/uhom&m)µù>Ùoö	,!á62-á²Ë ))÷<B¬=mG©'wï5,,-B+Îa¤§»¦|­>¥1½z=h5¼]ojkó«Vn³IdÇþqÐ^7¡	±û~aíZj#J8ŒIk¾«½.mT=!%9?>-L³>”š-Ý)Ü<(U/&I¿Nnn
MUå|¤meA¡tR1¡\%°Q9¼o,Ô¤'=aìƒÅipDàu‹yÅ^nîF¶â¿GDyþB"xxD6<{æ>Â	¤fÕnÙ˜Mcl{éÙ‹£è~"'ƒ[©YIâZÍ7Ulõ+)q*Çt'mc3Ù
.1ç{Le3Di¥6{)ª¿JiM5R)o$§`hŒÂ¼ÌÐF!&E>¥
ïÇqçòù)ön¨þ’eof"!ß4·87Á%UÑö¬oq—!sTÞUX¬ÝUnx2é<%?høâ.÷0=m~¸c”
4hBóÙPmJf^óü5n?IœzUipãb0òuYRä$ð2m¿XcEoLVÞ«6Ï€Ô³GhAdF2Vª`4ÂÖ±¸‹"oçš\#¦ÍMÐ>m+	$
?Tg¯sP¾ÕÞSíÖÑM	îcfûÔ9á€dwL€yÛÈo²Ö+a°f ÈRÔ÷¦K#ü£Ffrgë0xb™&d±'Òd±>/•k#Ã/åUÕÛ}quù[(i)(è=nm9+GÅlÑw=Ý_&{„ySéNÖw">ûogãšm¿hvgx
åUP?8j‘ŒÕ®ýºd‚Dìv±b°YázK}~cPðâRÐ„G5åA ÀX¦7Î	V™`¢½øìpmn¢Ü4bg0‡"ÙE0jÞ$Y5NáV!G~(h'sN4Vìtrq	JL‹‘°þëpokidôfa¯ý*#gÁfÄ6aà `}f”øa{B'™8»%
õ(ý1n°€¿"$‹Ø:sMY°:‰­Ñ{ø59—*d•~—gQPI¼ú%0(¼ªq£˜QÈZ“àèpÊ©RLåD&¼e•ï@+qA~*"gÑæÎdäyët)à(zyH~æ!«^ûåtö}r=O"e8fO¨øšLðÚ{ëñ.ëåxý‚0ãDqÝf‚xJ¢e¥'#RZlg*>àXuû‹B©Xãî (%`lW¥KE&Ùù6øø„ýGaö²nñ ?d«uHf+b#VK&kg2k:"óü¡Î7dtx'ÓRö°K¥sKq}2ý+JTn>mÿéi`°ái5	Dßlä’<Ž)nd8'p
d0¢,Êrk²5ï5)iB `ï°%®) hlkBêÕ~bK8"ûat9wÿYqt" vœ9 §Ô©ûëþ¿rrQç |ß@dñB*:íêkø&Rî&¤}ö¹©]P¦;xª®uÜóQ%Ž%ÀølÊ¥x(
áC7SÄ©”*r4lI#3ÒqMsd//js`dF
ôtÄÔa©¦ArT}~1·dc¡ýLœÕèèŽ5èÌ© 3ôHyì©tš®È9ðh”"ß5•ïov‡òÞ‹~^[3eÍeK"õFÒiFÊqD±£,lÒË°T­'ô3à9ðG4¢%?è’Ò"œ$Ðf9[-trAFïxur2	V¿Î T/®F£õ…x ¢2ž%±\aµÄSXhü&rJô(µzzç-%h[mmqEF3©D%)Y®Í¦lf<j6FG÷nvkÕ9ü$ôn~‰ìÂ3¥ù¸ŸnW^«~p¤/md1÷õ$`¯±vq"™.¦êwüa2ÏSº°-ŒÁà4\J¤htyºykIw`”HÕz9!ðôd#öþD´tŒ/>#9%»`6z%¸	v=t=éydg¯v/!ãöy9”	ò/Ø.T,adïsî×u;”À-ƒ½zžNûJ;	hædcLBy
î£A	'é µc\ðß™˜zZh3ŠC±,-t["*†e¸ügñy“mce'lE4kþqb62¶ê}„''qSÍys@&)) õª¶ˆã&ìâ`Öï¿Ð %øŠ¦ç	~’Ìy\`væÄ®Se¤£0ou'\ÅCåÁåG´˜Ž1`h	?â+äMõý¨3«A$.Yª6C¤An_»<1H×cvøtÇ+[#4UŠä|¡“šj2J©®Á
¸H­ùEMyFGuýt}tr`kx(é°bç&?\Ti2Ad\cŽŽl¨¨<NK
àc#~­QyéD;iø¨‹Ô|ã"êù" Y$gH\iš>:ŠNÈaò¡T=$O™gtïaplm+lú]¬M	)*lT{3Æ>_@§Ð™Á`+ûNC²¡cyµTì¹TÝ¾rt1‹n´XhmjGïXI´A6o6ród±ßZÂJcMÆ¡Äsâ%zñÈ‡å~0î6çàE{úëL;ÜYiþ:erx¿âKã[ñó*­TVMA‹DìÞ^ç&äÁC©‡w“îc(tg&^a‘½iÅO>¥FHKÅùj7õ·/c!U„žlÜlÖ$·i}àj`5(iJžJ>,`¬«nØEõ"ay~ÝE~mHÑ|Ë÷±	éÓúlDp?ÊiãB$˜u}{bP;ÅpÐ†ò»"&_"=-/7š>yEr&p$ªg)…èoSÔ;±0
8XsÂYd1ëd/låÔb~4.lyAT`±l-q.Ìˆ5FÁ)Pmúê²-UÇ®lõMë¥à^É)£Ðvgû¼K5#ƒXtqvÍ3OsM€´¯bü.3jØS|:3Ïíš(h5b=Mé `óA |0fn5‰‹Åät¶?,MWÝ(BC2|…¯/(á6%£Šø°V £ÁT|RRýEßt*¿²ÃÔÑ
2ðpuvéj»|¶BÏ!ÊáH
¢Çî{ (t6êÔRƒ½·¼†Â¶lèõ&4š*£@¢ƒ\6lô¥>ÉÂ]]%GÌMñ“oEþ%ï
[Ú?ldöî]Ð’aAm z`çÐ€osƒµ5mlûn=PbK[ü ïvïfB£!¤qö Ecþj!1L’òk,ñ}åbJÊ<& IÃpTaumx÷/z¦¼kpÈ:oû1í‡ô38i¹²}075ñeððBUªaTfK4?–e~¢ä4€qWgã=CíFWâí•^êv·¤l†c`s=Ðï¡Iäkmty/& ~J–­æÕ'cD @ ì QP/9ÌÐ×{Þ ªLc²~¨œ6.éô…ü¡5ùz!F‰~ù€ûôÕöil=*bv#ÒÞ;y3iqkNtB.~Ñ|ªúše°y&£§4n-Bd ·´kCqåVC'äc\ñGg€e¢|/mÎ§cn™ÔÙ¥'dî_ÑÃäHSi<e€b;—&j~ÿm]»1aOå|T>©û÷2Ò€M :u7Îï7(†,Ne"(µdTàjôW‰·tB81»	5j:‡ývÃBuö-ßx]D¤z.h\¿óGlrlu4£	!iÖ±rMF%Ö2{i¦û$~FÀ«*&_›é3lbñ©*N)qÀÄC¤hh„CaÎ1ôµtJâ:iÍ&Dfk¬¡´/g!;h~ïaqvœcÚíÙ.yIó:7ô {
  auto tblgen_isWrite = odsAttrs.get("isWrite");
  if (!tblgen_isWrite) return emitError(loc, "'affine.prefetch' op ""requires attribute 'isWrite'");
    if (!((tblgen_isWrite.isa<::mlir::BoolAttr>()))) return emitError(loc, "'affine.prefetch' op ""attribute 'isWrite' failed to satisfy constraint: bool attribute");
  }
  {
  auto tblgen_localityHint = odsAttrs.get("localityHint");
  if (!tblgen_localityHint) return emitError(loc, "'affine.prefetch' op ""requires attribute 'localityHint'");
    if (!((((tblgen_localityHint.isa<::mlir::IntegerAttr>())) && ((tblgen_localityHint.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32)))) && ((tblgen_localityHint.cast<::mlir::IntegerAttr>().getInt() >= 0)) && ((tblgen_localityHint.cast<::mlir::IntegerAttr>().getInt() <= 3)))) return emitError(loc, "'affine.prefetch' op ""attribute 'localityHint' failed to satisfy constraint: 32-bit signless integer attribute whose minimum value is 0 whose maximum value is 3");
  }
  {
  auto tblgen_isDataCache = odsAttrs.get("isDataCache");
  if (!tblgen_isDataCache) return emitError(loc, "'affine.prefetch' op ""requires attribute 'isDataCache'");
    if (!((tblgen_isDataCache.isa<::mlir::BoolAttr>()))) return emitError(loc, "'affine.prefetch' op ""attribute 'isDataCache' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> AffinePrefetchOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffinePrefetchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffinePrefetchOp::memref() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range AffinePrefetchOp::indices() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange AffinePrefetchOp::memrefMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AffinePrefetchOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffinePrefetchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffinePrefetchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::BoolAttr AffinePrefetchOp::isWriteAttr() {
  return (*this)->getAttr(isWriteAttrName()).template cast<::mlir::BoolAttr>();
}

bool AffinePrefetchOp::isWrite() {
  auto attr = isWriteAttr();
  return attr.getValue();
}

::mlir::IntegerAttr AffinePrefetchOp::localityHintAttr() {
  return (*this)->getAttr(localityHintAttrName()).template cast<::mlir::IntegerAttr>();
}

uint32_t AffinePrefetchOp::localityHint() {
  auto attr = localityHintAttr();
  return attr.getValue().getZExtValue();
}

::mlir::BoolAttr AffinePrefetchOp::isDataCacheAttr() {
  return (*this)->getAttr(isDataCacheAttrName()).template cast<::mlir::BoolAttr>();
}

bool AffinePrefetchOp::isDataCache() {
  auto attr = isDataCacheAttr();
  return attr.getValue();
}

void AffinePrefetchOp::isWriteAttr(::mlir::BoolAttr attr) {
  (*this)->setAttr(isWriteAttrName(), attr);
}

void AffinePrefetchOp::localityHintAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(localityHintAttrName(), attr);
}

void AffinePrefetchOp::isDataCacheAttr(::mlir::BoolAttr attr) {
  (*this)->setAttr(isDataCacheAttrName(), attr);
}

void AffinePrefetchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value memref, AffineMap map, ArrayRef<Value> mapOperands, bool isWrite, unsigned localityHint, bool isDataCache) {
      assert(map.getNumInputs() == mapOperands.size()
             && "inconsistent index info");
      auto localityHintAttr = odsBuilder.getI32IntegerAttr(localityHint);
      auto isWriteAttr = odsBuilder.getBoolAttr(isWrite);
      auto isDataCacheAttr = odsBuilder.getBoolAttr(isDataCache);
      odsState.addOperands(memref);
      odsState.addAttribute(getMapAttrName(), AffineMapAttr::get(map));
      odsState.addOperands(mapOperands);
      odsState.addAttribute(getLocalityHintAttrName(), localityHintAttr);
      odsState.addAttribute(getIsWriteAttrName(), isWriteAttr);
      odsState.addAttribute(getIsDataCacheAttrName(), isDataCacheAttr);
    
}

void AffinePrefetchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value memref, ::mlir::ValueRange indices, ::mlir::BoolAttr isWrite, ::mlir::IntegerAttr localityHint, ::mlir::BoolAttr isDataCache) {
  odsState.addOperands(memref);
  odsState.addOperands(indices);
  odsState.addAttribute(isWriteAttrName(odsState.name), isWrite);
  odsState.addAttribute(localityHintAttrName(odsState.name), localityHint);
  odsState.addAttribute(isDataCacheAttrName(odsState.name), isDataCache);
}

void AffinePrefetchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value memref, ::mlir::ValueRange indices, ::mlir::BoolAttr isWrite, ::mlir::IntegerAttr localityHint, ::mlir::BoolAttr isDataCache) {
  odsState.addOperands(memref);
  odsState.addOperands(indices);
  odsState.addAttribute(isWriteAttrName(odsState.name), isWrite);
  odsState.addAttribute(localityHintAttrName(odsState.name), localityHint);
  odsState.addAttribute(isDataCacheAttrName(odsState.name), isDataCache);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffinePrefetchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value memref, ::mlir::ValueRange indices, bool isWrite, uint32_t localityHint, bool isDataCache) {
  odsState.addOperands(memref);
  odsState.addOperands(indices);
  odsState.addAttribute(isWriteAttrName(odsState.name), odsBuilder.getBoolAttr(isWrite));
  odsState.addAttribute(localityHintAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), localityHint));
  odsState.addAttribute(isDataCacheAttrName(odsState.name), odsBuilder.getBoolAttr(isDataCache));
}

void AffinePrefetchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value memref, ::mlir::ValueRange indices, bool isWrite, uint32_t localityHint, bool isDataCache) {
  odsState.addOperands(memref);
  odsState.addOperands(indices);
  odsState.addAttribute(isWriteAttrName(odsState.name), odsBuilder.getBoolAttr(isWrite));
  odsState.addAttribute(localityHintAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), localityHint));
  odsState.addAttribute(isDataCacheAttrName(odsState.name), odsBuilder.getBoolAttr(isDataCache));
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffinePrefetchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult AffinePrefetchOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffinePrefetchOp(parser, result);
}

void AffinePrefetchOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AffinePrefetchOp::verify() {
  if (failed(AffinePrefetchOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}






//===----------------------------------------------------------------------===//
// AffineStoreOp definitions
//===----------------------------------------------------------------------===//

AffineStoreOpAdaptor::AffineStoreOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineStoreOpAdaptor::AffineStoreOpAdaptor(AffineStoreOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineStoreOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineStoreOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineStoreOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineStoreOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value AffineStoreOpAdaptor::memref() {
  return *getODSOperands(1).begin();
}

::mlir::ValueRange AffineStoreOpAdaptor::indices() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr AffineStoreOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AffineStoreOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AffineStoreOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineStoreOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineStoreOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value AffineStoreOp::memref() {
  return *getODSOperands(1).begin();
}

::mlir::Operation::operand_range AffineStoreOp::indices() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange AffineStoreOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AffineStoreOp::memrefMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AffineStoreOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffineStoreOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffineStoreOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}





::mlir::ParseResult AffineStoreOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineStoreOp(parser, result);
}

void AffineStoreOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AffineStoreOp::verify() {
  if (failed(AffineStoreOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps4(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}





void AffineStoreOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::SideEffects::DefaultResource::get());
}


//===----------------------------------------------------------------------===//
// AffineVectorLoadOp definitions
//===----------------------------------------------------------------------===//

AffineVectorLoadOpAdaptor::AffineVectorLoadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineVectorLoadOpAdaptor::AffineVectorLoadOpAdaptor(AffineVectorLoadOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineVectorLoadOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineVectorLoadOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineVectorLoadOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineVectorLoadOpAdaptor::memref() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange AffineVectorLoadOpAdaptor::indices() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr AffineVectorLoadOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AffineVectorLoadOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AffineVectorLoadOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineVectorLoadOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineVectorLoadOp::memref() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range AffineVectorLoadOp::indices() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange AffineVectorLoadOp::memrefMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AffineVectorLoadOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffineVectorLoadOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffineVectorLoadOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineVectorLoadOp::result() {
  return *getODSResults(0).begin();
}







void AffineVectorLoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value memref, ::mlir::ValueRange indices) {
  odsState.addOperands(memref);
  odsState.addOperands(indices);
  odsState.addTypes(result);
}

void AffineVectorLoadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value memref, ::mlir::ValueRange indices) {
  odsState.addOperands(memref);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AffineVectorLoadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult AffineVectorLoadOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineVectorLoadOp(parser, result);
}

void AffineVectorLoadOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AffineVectorLoadOp::verify() {
  if (failed(AffineVectorLoadOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}



void AffineVectorLoadOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Read::get(), value, ::mlir::SideEffects::DefaultResource::get());
}


//===----------------------------------------------------------------------===//
// AffineVectorStoreOp definitions
//===----------------------------------------------------------------------===//

AffineVectorStoreOpAdaptor::AffineVectorStoreOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineVectorStoreOpAdaptor::AffineVectorStoreOpAdaptor(AffineVectorStoreOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineVectorStoreOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineVectorStoreOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineVectorStoreOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineVectorStoreOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value AffineVectorStoreOpAdaptor::memref() {
  return *getODSOperands(1).begin();
}

::mlir::ValueRange AffineVectorStoreOpAdaptor::indices() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr AffineVectorStoreOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AffineVectorStoreOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AffineVectorStoreOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineVectorStoreOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AffineVectorStoreOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value AffineVectorStoreOp::memref() {
  return *getODSOperands(1).begin();
}

::mlir::Operation::operand_range AffineVectorStoreOp::indices() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange AffineVectorStoreOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AffineVectorStoreOp::memrefMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AffineVectorStoreOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffineVectorStoreOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffineVectorStoreOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}





::mlir::ParseResult AffineVectorStoreOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAffineVectorStoreOp(parser, result);
}

void AffineVectorStoreOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AffineVectorStoreOp::verify() {
  if (failed(AffineVectorStoreOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}



void AffineVectorStoreOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(1))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::SideEffects::DefaultResource::get());
}


//===----------------------------------------------------------------------===//
// AffineYieldOp definitions
//===----------------------------------------------------------------------===//

AffineYieldOpAdaptor::AffineYieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AffineYieldOpAdaptor::AffineYieldOpAdaptor(AffineYieldOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AffineYieldOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AffineYieldOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AffineYieldOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange AffineYieldOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr AffineYieldOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AffineYieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AffineYieldOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AffineYieldOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range AffineYieldOp::operands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange AffineYieldOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AffineYieldOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AffineYieldOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void AffineYieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
 build(odsBuilder, odsState, llvm::None); 
}

void AffineYieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
}

void AffineYieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AffineYieldOp::verify() {
  if (failed(AffineYieldOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AffineOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}

::mlir::ParseResult AffineYieldOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> operandsOperands;
  ::llvm::SMLoc operandsOperandsLoc;
  (void)operandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> operandsTypes;
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  operandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operandsOperands))
    return ::mlir::failure();
  if (!operandsOperands.empty()) {
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(operandsTypes))
    return ::mlir::failure();
  }
  if (parser.resolveOperands(operandsOperands, operandsTypes, operandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AffineYieldOp::print(::mlir::OpAsmPrinter &p) {
  p << "affine.yield";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  if (!operands().empty()) {
  p << ' ';
  p << operands();
  p << ' ' << ":";
  p << ' ';
  p << operands().getTypes();
  }
}

void AffineYieldOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}


#endif  // GET_OP_CLASSES

