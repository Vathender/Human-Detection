/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

mlir::tosa::AbsOp,
mlir::tosa::AddOp,
mlir::tosa::ApplyScaleOp,
mlir::tosa::ArgMaxOp,
mlir::tosa::ArithmeticRightShiftOp,
mlir::tosa::AvgPool2dOp,
mlir::tosa::BitwiseAndOp,
mlir::tosa::BitwiseNotOp,
mlir::tosa::BitwiseOrOp,
mlir::tosa::BitwiseXorOp,
mlir::tosa::CastOp,
mlir::tosa::CeilOp,
mlir::tosa::ClampOp,
mlir::tosa::ClzOp,
mlir::tosa::ConcatOp,
mlir::tosa::ConstOp,
mlir::tosa::Conv2DOp,
mlir::tosa::Conv3DOp,
mlir::tosa::CustomOp,
mlir::tosa::DepthwiseConv2DOp,
mlir::tosa::DivOp,
mlir::tosa::EqualOp,
mlir::tosa::ExpOp,
mlir::tosa::FloorOp,
mlir::tosa::FullyConnectedOp,
mlir::tosa::GatherOp,
mlir::tosa::GreaterEqualOp,
mlir::tosa::GreaterOp,
mlir::tosa::IdentityOp,
mlir::tosa::IfOp,
mlir::tosa::LogOp,
mlir::tosa::LogicalAndOp,
mlir::tosa::LogicalLeftShiftOp,
mlir::tosa::LogicalNotOp,
mlir::tosa::LogicalOrOp,
mlir::tosa::LogicalRightShiftOp,
mlir::tosa::LogicalXorOp,
mlir::tosa::MatMulOp,
mlir::tosa::MaxPool2dOp,
mlir::tosa::MaximumOp,
mlir::tosa::MinimumOp,
mlir::tosa::MulOp,
mlir::tosa::NegateOp,
mlir::tosa::PadOp,
mlir::tosa::PowOp,
mlir::tosa::ReciprocalOp,
mlir::tosa::ReduceAllOp,
mlir::tosa::ReduceAnyOp,
mlir::tosa::ReduceMaxOp,
mlir::tosa::ReduceMinOp,
mlir::tosa::ReduceProdOp,
mlir::tosa::ReduceSumOp,
mlir::tosa::ReluNOp,
mlir::tosa::RescaleOp,
mlir::tosa::ReshapeOp,
mlir::tosa::ResizeOp,
mlir::tosa::ReverseOp,
mlir::tosa::RsqrtOp,
mlir::tosa::ScatterOp,
mlir::tosa::SelectOp,
mlir::tosa::SigmoidOp,
mlir::tosa::SliceOp,
mlir::tosa::SubOp,
mlir::tosa::TableOp,
mlir::tosa::TanhOp,
mlir::tosa::TileOp,
mlir::tosa::TransposeConv2DOp,
mlir::tosa::TransposeOp,
mlir::tosa::WhileOp,
mlir::tosa::YieldOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace tosa {
static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16())))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps1(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isSignlessInteger(1))) || (((type.isSignlessInteger(8))) || ((type.isSignlessInteger(16))) || ((type.isSignlessInteger(32))) || ((type.isSignlessInteger(48))) || ((type.isSignlessInteger(64)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1-bit signless integer or 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 48-bit signless integer or 64-bit signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps2(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isSignlessInteger(8))) || (((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))) || (((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be signless-integer-32-like, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps3(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && (((type.cast<::mlir::ShapedType>().getRank()
                         == 1)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 2)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 3)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 4)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1D/2D/3D/4D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps4(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && (((type.cast<::mlir::ShapedType>().getRank()
                         == 0)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 1)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 2)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 3)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 4)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 0D/1D/2D/3D/4D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps5(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 4))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 4D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps6(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().hasRank()))) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16())))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be ranked tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps7(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().hasRank()))) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16())))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be ranked tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps8(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 1))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps9(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 5))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 5D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps10(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16())))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps11(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be tensor of 32-bit signless integer values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps12(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be tensor of 1-bit signless integer values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps13(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 2))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 2D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps14(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 3))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 3D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps15(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32)))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 2))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 2D tensor of 32-bit signless integer values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps16(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && (((type.cast<::mlir::ShapedType>().getRank()
                         == 2)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 3)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 2D/3D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps17(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::TensorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be tensor of 32-bit signless integer or 64-bit signless integer values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TosaOps18(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1))) || (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(16))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(48))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(64))))) || ((((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 4))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 8))) || (((type.cast<::mlir::ShapedType>().getElementType().isa<mlir::quant::QuantizedType>())) && ((type.cast<::mlir::ShapedType>().getElementType().cast<mlir::quant::QuantizedType>().getStorageTypeIntegralWidth() == 16)))) || (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16()))))) && (((type.cast<::mlir::ShapedType>().hasRank())) && (((type.cast<::mlir::ShapedType>().getRank()
                         == 1)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 2)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 3)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 4)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 5)) || ((type.cast<::mlir::ShapedType>().getRank()
                         == 6)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1D/2D/3D/4D/5D/6D tensor of number values, but got " << type;
  }
  return ::mlir::success();
}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::AbsOp definitions
//===----------------------------------------------------------------------===//

AbsOpAdaptor::AbsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AbsOpAdaptor::AbsOpAdaptor(AbsOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AbsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AbsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AbsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AbsOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr AbsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AbsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AbsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AbsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AbsOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AbsOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AbsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AbsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AbsOp::output() {
  return *getODSResults(0).begin();
}

void AbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void AbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AbsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes({input1.getType()});

}

void AbsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult AbsOp::verify() {
  if (failed(AbsOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void AbsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::AddOp definitions
//===----------------------------------------------------------------------===//

AddOpAdaptor::AddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AddOpAdaptor::AddOpAdaptor(AddOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AddOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AddOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AddOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AddOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AddOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOp::output() {
  return *getODSResults(0).begin();
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AddOp::verify() {
  if (failed(AddOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void AddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ApplyScaleOp definitions
//===----------------------------------------------------------------------===//

ApplyScaleOpAdaptor::ApplyScaleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ApplyScaleOpAdaptor::ApplyScaleOpAdaptor(ApplyScaleOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ApplyScaleOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ApplyScaleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ApplyScaleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ApplyScaleOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value ApplyScaleOpAdaptor::multiplier() {
  return *getODSOperands(1).begin();
}

::mlir::Value ApplyScaleOpAdaptor::shift() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr ApplyScaleOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::BoolAttr ApplyScaleOpAdaptor::double_round() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("double_round").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult ApplyScaleOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_double_round = odsAttrs.get("double_round");
  if (!tblgen_double_round) return emitError(loc, "'tosa.apply_scale' op ""requires attribute 'double_round'");
    if (!((tblgen_double_round.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tosa.apply_scale' op ""attribute 'double_round' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ApplyScaleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ApplyScaleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ApplyScaleOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value ApplyScaleOp::multiplier() {
  return *getODSOperands(1).begin();
}

::mlir::Value ApplyScaleOp::shift() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ApplyScaleOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ApplyScaleOp::multiplierMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ApplyScaleOp::shiftMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ApplyScaleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ApplyScaleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ApplyScaleOp::output() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ApplyScaleOp::double_roundAttr() {
  return (*this)->getAttr(double_roundAttrName()).template cast<::mlir::BoolAttr>();
}

bool ApplyScaleOp::double_round() {
  auto attr = double_roundAttr();
  return attr.getValue();
}

void ApplyScaleOp::double_roundAttr(::mlir::BoolAttr attr) {
  (*this)->setAttr(double_roundAttrName(), attr);
}

void ApplyScaleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::Value multiplier, ::mlir::Value shift, ::mlir::BoolAttr double_round) {
  odsState.addOperands(value);
  odsState.addOperands(multiplier);
  odsState.addOperands(shift);
  odsState.addAttribute(double_roundAttrName(odsState.name), double_round);
  odsState.addTypes(output);
}

void ApplyScaleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Value multiplier, ::mlir::Value shift, ::mlir::BoolAttr double_round) {
  odsState.addOperands(value);
  odsState.addOperands(multiplier);
  odsState.addOperands(shift);
  odsState.addAttribute(double_roundAttrName(odsState.name), double_round);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ApplyScaleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value value, ::mlir::Value multiplier, ::mlir::Value shift, bool double_round) {
  odsState.addOperands(value);
  odsState.addOperands(multiplier);
  odsState.addOperands(shift);
  odsState.addAttribute(double_roundAttrName(odsState.name), odsBuilder.getBoolAttr(double_round));
  odsState.addTypes(output);
}

void ApplyScaleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Value multiplier, ::mlir::Value shift, bool double_round) {
  odsState.addOperands(value);
  odsState.addOperands(multiplier);
  odsState.addOperands(shift);
  odsState.addAttribute(double_roundAttrName(odsState.name), odsBuilder.getBoolAttr(double_round));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.aÑ-Q˙x%Û(+ˇ/I˜œÛ≈ 'z»ÄœvÇö&°§⁄#ˇïYêÄhÁLr6˚iOA.l ™"m8x2ä≠Eπ^|˜JÎH¥=·∫'œ„X™Ñ«Y˝â›Ùﬂ›NX Óe8ÆmV·‰%]ÏÄCáÌÏjsöçIktg»´fÒ€ ’zPÊwYêu¢!î=ÆÊ¿8í}.Í1ÙaeR$∑»D◊Pg‹‰•ä2ÓTe3
Mz®Í·«S≠ö∫v>öÏÅÖ@‚ûWP.ÃOÿÅiˆ6…xU—B$µ ˘éâ+*PEÊ4:•»m/}^s°w#+- äm™3ÛåNgòÈ[–3w&Ï§≤*sËŒZ"ÏŒç∞‚™Àd¢ˇNb”˝ÂëÅ/nq˜@tÖ~{EÑ’j‚9Ê}bDqñëMt®®≤g¸wUﬁÂ∆rÛ¬eQp$∏ıÙÖF˛¢@dzR†:Pµªï>≥q⁄hõ√È2ì)[≈¬ıBRt@·@j‹Ü∫˝ú"Ω%ÿÚD6˘G√≈ƒˆƒ˝·Î¥åe$î·Ç∆ÈÆ@;ÛT‡⁄2‘Õ zµ;⁄1‰ñ/L÷˚¥ÃkN^6h¯r˚©p†«qÑmok7÷≈£Ÿ)dz(ﬂ‡2∏˙zt£{¿mG•såîvçëœúûb˚	È¨ÓGs£åˆ
'ﬂ0„»Ÿ∫∞°Ëíx∏8y@`gf¨aTV`e‚hUN˜/ÙQœÑ$~.,º˛˚∏áz3ÿLÂè$!eYWçdß<•ıåH—%‰<©>éRªM<wŸÅ≠Û_Î	û´v†ÁNÒE-—ä;{o¿âØ6ˆ˛—ΩBrà∂n Œ|ØP†ip˚¥@.U}e=C¡Îg 0ö‚¶·B≤6`;áCybaLS∞1Á$ÔG_-*’d∆ß˝t~ﬁÍy*Óa¨®$P){£jL˛∆º´ïgr˙ˆ
ù!NUë‰jî˚πAg°•ê	Ûù˝1p2:Ìøﬁ#©5Á1èe≈…—{«_∞v[ØtpƒI,™µhÖxÁ¢¡Î÷Odc∏@#£Ï±&‘oY @s+˙OTF≤DºKU&$ô0°%ßN≤˛Œ©≠b`IxÖÒrt‰Xf$iΩX?m•¿*R,¶$E †#Bb]U‡Ô7„ÌÊ˘“gqˆ˘zEl! L§H"…#≥›∆@"Y9N Nxâß4ïp6XFqF⁄8™BﬂuIp@61iò‡@m;“ñÁO“V¢G‰˘Râiˆ¡°* µIál‡~lÕƒ"ı:niH\Bºµu#'¯ŸU_œ√Ä4X#âbÔØI0Æ“s˚w5¨X&⁄ys“Ê2∂ÇòS°ep^√m¨kÙ7ácFéØ$ÃÃ¬T_A1d¬RXeOÂûToqÂI∫_„EI¯ıI˝v±|À:Êy6/ PˆC]¸ês⁄E-÷lÃ7U«Dü‡·†∫…ÀÓ’ù0à§π‚Ú∫$p˘Q\uÍŒ¨ã86˚	;Ûiai’7 àh≥´‰Òeöd)U 0⁄	s4∂u@:(o§2b)π[0}ﬁh<kIÚ‡Âÿ–e]Bi”€P¨íÍ"®êˆ‡ O ®Kl!#∆¢o·∫4ok"º‚u·Œ•r‘ƒÒπü«bô9·ÛBXu“ò<4e©⁄vØ^€iMˆUﬁM≠;˛o≠{»åOíÕ!UñWÜyLvdÁM7…ª34¿fÁ|ùC.æ£ÿ˛FaAbthÃ.Xm$]Do·x)˛Y≈Î˝ûX(ï≈¢)bG©aI›”äoIJ◊¢8Ãb *COº(b“0Rt#3€+öÄ,`R|√¨-O_CÄM9Ç"ê&&Ëm)<WÅ*ÁÒõuF[*ÇØ@Ó¢§.Û[’hùè,GR∏/88rÇ "`iDKó4N∫}—° 	pÒ⁄¬iLdT‰dÁïú/ŸE\5x_Ã∑Z˘˝qD∆7ú2˚0ù	c˙.>ºµZ(ìI®ør&`i,ö, ö¸!ˆŒ1NÌxv+%‰Ò@B
ÃA`'∂ZË.ópM|CP˛tõ~·Ô5Ÿ˝ÖT‘–|kƒ≥*iœfs‚p9íÒb¸NŸuò·¿'\{ıN  Ûô™Â]pwÙECAº#/ÆBï`ÄáL™tV˘˜h©î**>[ÍI|+ë®rÎN[~´=ÄEÇ;,∑(î>NVtV
;à:èË€B¨≥#$ö@≤G=J&ÈÖÇÂ∏µ1/QË¬◊Ëë
∏Í¿0ubuN∞
•ßån£fSqo#˙æGËˇ≥$“%DÚö[Ínks*⁄”0%ÕUpöÿÉe[îd`ıÁx˘É⁄tIU+‘˙º◊%ˆﬂ˛á«˝eŒ9Y·poí“@oPy‘∫€≥(M„e`Õ—\nûÓ„rœÂcb@‡≈l–J∫˜.˜§êÈ›u¸zÒÖÖQg[òq&F√w∑vAÀ‰‚h|√¿1+§Q?ŒÄ;$]j'≠L52±’˚>¡.òp»…˝ò~>◊∫deE`~Å¡ÉÕxY¨røÍÒKm;d¢"oß-‚kr^8´»F√òMrπ∆f"îxá∂iy$}Dı|Øˇ+’’$	ûØ„,,Ìã/ME \¿uà]é+£Â≈)¶è‘%7´$}œ%±]ó4=´ÊÂåQ§â}=ç®'h+õ•≠G √’C™)¨BâfºZVú cÑ¡Cxo-8‘’wqH’f%FBlÉOæÁ≥Z7ëi≠≠-•ì¥b0'%)ÖaÕ,ççxó≠M(&>ªÆK◊+iK≠m…7ç%-k}ÁØ/ow|}ÜçNm©N∏¨≠òÕ¨H&?ÓâÈXud˝gÛ|yIÍ„ACl3≤É†ÏP¸oÃ|>‚·43"÷´añucP€~[ı´b.z,à*ÈL(å>RF£T*t‡¬w;e{.≤!ˇ‰ÏÚÄ(9O&lXC!™∏yÁÊIÁΩ∫	jµ¢˜ô¨I≥\r©([±DFU˙Çb4∂^%@<GÏ⁄uR!Ï•?p◊œ·ı“ qntXwÈÇ∑=œÁK)V‹«/åÌÁ»;è˘ó:SÅ «E·#•Œ{oAùüa»3IT)l7nïÈ1È}hkbX®M!ÖP4JπH¸†4S^‡√aFk»©g]æÌÆ1œ–˜údbÓ;¥!Îuq‘c⁄K#–⁄•∑Õ∑J$&≤}!Ω"`â∞Äl)´Ã∫íjl>YÁekáO°Ó@F[áÂÌ8˚g]Ëì†7a7c√…±˛(R…yîQÏ;;RékˆFSj£CëµO¿hI÷-'ràJÑ”?»Å|£b≤‚hìbµ
3Q∞'µß“döh√ác∆	0∆Û3ıZÇC^ÓúJiQp&Ã$"ai»1•,>;«äbŒ/h q`“JPAW7¿F◊4‹s¡&Lÿœ FgË≤Ô·mÙÉÏˇœBÖ}NQo	øÍÿ$ıØΩt≈ﬂf¿Ëxá"≈Cî	⁄«Å∑qˇ‚€_
b€E2w? ΩÉà=5Õ a0À=çıœS„d$}I8e•Cd5}DÆzÍ~i¥+r£e√ÊÄÖR¡Ú«`*yb0L¢Cch˜¨v‚Ï>E˘gƒ≠ ÄimLâ(°Nïù#\‰Ç
≠+;ˆã∆W›%è„≈`@Ft$V (`GTÌÀ‚~L´exâ{≤ skëÚröMˇVÖqŸ;l/uTÙoó—)Üa˚‹≈t±æEüf´>q*∫a_$Z·§tc”∏Ö7Äb8(ú‘skR¢î”•hŒ'ﬂ8R%Fœ@÷ûE u/xe	)0%<ƒN»˝›fÿg
’˛œI*˚ˆfKﬂmÆU+8H>¶1[Áop‘4jKe@◊ê˛aê*MbÌwk¢äyÖI<(˚=Â\l©x⁄Ÿ·¢u–]à∑	k'xrw≤‡pê){…∂]OOè—•Ú(O«ø„˘y™s4ÇA/∆ëÑz\bªÇÃ™M5˝ÄPœ'ma!Æ"bU…{	 ]xLE™â_s1{*Wi¿{w°\Ë|&ÏËç‡‰ÜTñ`° ‚JûÜSLUÒ„íÙiª.ˇ˙Ö≠T*+rj ~9MÀ7Ï7a‡ì÷˜baqá&ÁPﬁ
<ÍÈ˝:Õ„ˇ>˜9˙6âh∂üi^c4»ß{?WnE‘™§<5X)8
˛æ†º˝⁄:4Ú‡Lsö&RD
væﬁ€ÁCz	A⁄ëáS=CS≈M≥™¶ˆñ´?2V:y\)U)zT˛÷+	∆t4∞ÉyÉ$MÌq‘v^$u-]ë‹ÇôöR©5ÛÈ“sñ;©ﬁ∞ÚháO\t–Û:P)vO√zÑ2I”¥'È¡ÛƒBÇê-#≤`i≠“*˙gT‚s…l^≈Gu=uKÎ»MO›_‡g∂Ï™x\˚ÀLmXj:`:ãDYr©ÀmƒlnΩ%q%9û&2äQõ™sª…' p`eıˆ˙ˆZË›FüîAARÂ“√ß≈v)ûqÚ3§+,‡´ÎÍN‚zπ‹ f`Ê˚eJ‚En®5[mq˘EMÔÖ*[ÙrŸx•-≠–∂ûg˙	∏v\Õ¿9ò£ôG8V˙
ìuprƒ&0ı /¡Ωótÿµ˜x9C.¢ı?¯yê∏¥5N†‡*ÆPD•Ãn5,Â€PzI˜yú9h,eRæ±[ê$–ÇÑK®“d0º¢Ò£êŸ6xà ñCx£≈ﬁL¯Meòk¥˝e∫ƒ}	Z:W	ıˇ‰ÌD¶Q¿vA˚≤5-N:§›ñƒÆ.∆mS:'`m02).Ì≠·(êÚÆ8¡/˛·0‘Ál˜∆hf˘UÔ∆eBänµ8mwC†Ãvàsô´§‡ƒÿØ†L„.aÙe)I§Û—oË«µ◊t7ßòø9£|‹7+[|9i{ewzª!aˆÚ”•úT\8∏{¢`ø0b!C3Ù%ÛI∞Ÿv
oÌG”«.ñ£qÚáR-π.≥!U∞©0)ÿu‡…{g¨nDnˆqß#E!];€ô}û\<J$C"C1
h ”QØ
Ω|BÌc?ÿØ˙_sf–SÄ/ÆÉ·Ëx‘˝paÎiÊ“»≥7…Gƒ€W©Øß>±ç©≤AÂÃ@–ËÖQ]NûËj)Ë9©Á´ñw)L•Gz!∂`°è‘h¯O~>I&sÄ@1&F9êüÍw";X=≈B≤pÍÊ%ÂúÀÎ-AQ%<RÆ>4V„˙∆V”aŸıuŒ(Mg’Vƒ—á+√Ú8¢öa¿4àÀ:êzéfæ•°(|LK¡i
$üÊQ˛6N»Loö2ÊbCxâñO~C_Ïµ)ÂÔnL´ËÜ¯Tv†Íöt√(˛'∆E:°™aH$G∑Œ®Œ∆+>|–ÏÑ -|è9E·c‘Y–oM5á˛I÷UÊ ÷‹o‡w–QÔÖ	/"0fgbK¶¨jﬂ]js‡iaÀïß‰r$‰êbv“¬à¯‰fÁ^\{vceÔç•%g£ÁQ†òf[*˚»kä©ò≥M›DÛ®MÅ^c Ô›K2”£O6Wˇ≈?ZwoK5˙ù`ÊVçısâµÃù;ÔoeÆ˙ªTb??{ﬂP‹MÀ˙(…Í:y*x=Iºîc⁄d†¯ ÙyÚ.ezÓl0	&sO—IÊÛB®É‡ôÓƒ∑äÌ‘Lxgî~wS~ÿºÿïF¯AŒ6AS;N0bUåõv˛cﬁÃŒ;;é·‰¯5tM>Í n0)Ä†Aqç`2¬v6tî{I∑tïÊF`∆RÂ€«'A @ ¿WUEËk¬#ñ¬îöñ9πjt2¡jÙr!#ZZxEìÇ˙Â1Yi~YOgjds®a|ªÇEaf™cO¡(´ﬁÂf·ÌIn:ÏÀ´xQ((îù\F¡è#“c\Îw!±'É,
Ø<JcWû®≥Jk·~‚Jfƒ›ÃI´6û4‰sØfXceÇŒﬂÚ∞•ko%,ﬁbÚ˝9¸‹jæWy≤vœíÉ7,‹NfA>Í´C|lÏ*`4Ø<•)±ãH:Ùˇm¯Â{≥ÓB˝KM)@[≈õF?IOˆﬂQ|‡…pBnc≈;s9˜}û}zì)oÛ'{~≠h√™„M∞˙SâPAB}n”`mc]K!Ï)fGœQà@dMvÓ0çÛ>V[™ìmd√~<ÒP)è¥Ë3∏ç1‰kék2Põ’JtÕZÂ3CÌƒæi47¸njitÙ•|≤&†
;pﬂek–Zlê∫nwRr≠mv¯∂ÛÁ Î§Óóá∞aÍ˚Ôdÿé¬DOiÎ@Ä£¡ì|ªz®Èä7ü<&zìt8§== J … ¡F{ˆ≠ô>ŒêyIÈtvÙÊ ≈tKv»ÌÔb©ª¡EQU ™~nÏiÎ¿¸ ∞≤˚Qƒ[B‘eîo[!ì ıxdºŸRocmlÇYy÷~M›%˚/ªzwå^´
^d—ÇÆ%Úk-cÛgÚò?MeSg¢L0}:˙£êZ;-§]wêíÁî‹™q™f”yñƒº!pK,l1º9Ô∏(¢w†@òj˝¿Y®¢Ÿ!∂ÖM/íQﬂ–a˙ˆ.nÀ8q‘r-w7¿π˝–∫ppÎÄ=æÛ9Ê$c\xDÛ◊±!™èL&„‰Ü8"Í4HSQ5˙Ã“Ï6%Yó À$πÌpt+,Ò6xÏîÊbU††3.Ç≈ŸÓFM˘˛W“HZ±ä´M˛µü
^ 5Ù$^œ8‘ê‡]Ò∫mÍöàù˜h˝	«˘€O,a5UóI.ó÷bcı`„9öÛ#{∑˝À≠1∫ R-7îB)a◊e;ŸwŸTHía4≠ldX–!ÙH”.>„j≥ø(»ñRvÔœ`ÄÛ˜N®xÕ÷R7Èï8!ºA†5≈*Ìvk?ù6ÁæD:∆l˙—XNXÇa7e*´ˆ≠^˚`˝IÔŸ©rnı¡<PÚﬁaÄI9uº?oHmû•Ï¸Có$)hıâ¥N u',à¥∞Ü¥£\∫¿{ás≈…SZì⁄ƒl…®—ò]nºcY÷Â˚ÚìäaC hVb≤>Œ+Û&Ê•ºVVX&¶kÙ^¬è≥ ƒm™ˇAÛ%J  ∂µpr>Ë¯t6D_YÌ∞‡<2x’añÅ{|ñJPxR3Ù·4=ÇÍ|—EÙB¿2(ÏF≥ª6]~gãd‹R=u)QaÚ´y-°ˇÀ&é˝|(#!Iv´7‰Â5GaÓL…˜¢ﬂ:‘ï¸â¯00KõMaswârûte–s=s˝¥*ÂmÈbªvlˇTwO≈qÿ	¢¢JÎ‰¥ó8N3»¿G=soπ§Ïír<…gE ©‰tA≠3TW¨…$»c“xπ©mì IÈ§˜çÕ·jKb$vÌ,eÇ*gÓ–yx$äØB¥O‡d˘™≠"\mK‚Ë—i"Ó¶æóßÖ˜{"’øê•~…kﬁ^\7≥m? vO^w¬Êb&§3“ΩO„+UX|$,’Nv9ÚMê{—ü+snMúÿ¿O« Åv˘Í2°gz–∆p *rˆ ‘b;¿∞∞ä‹fDeu—Z—:≈<)zH†úeÏô!pgV·b¡¨eÑdÃv{{q„å‰h¬Â∂tﬂ{ÚøÇ)êb‰r[ƒH"˚1áQdˆ˝idÈ¶mUi›yyÑú§XüOl_Nv,ÕõR@ (N®N¶|<°N—`∞0ÉAàP”ıÚÌaﬁ{_´7@UÌ![9D·oe.hÎº1h%UÀRn$ãfi˚i>˜`áLA⁄aßsG+Œ‚ a[5gíB;Ø"Û›óOÏbkR4j0∂PpØì">A3ÛHÃTÏÊ-A7xÖä3œ=‡iœÁgæG Q÷îù&ÚÌjµÇÒmÚy˙— M:òãi vN;N"WÏ◊é)hlze¸ƒêÜ«zø≥ÙE1≤tÀ/Ë]\Úg Ÿ»°r≈sΩ„Æ ,lŒl„^:î~√E*]√7§µL.2ì‰qÅh{::¯¨™-"hÃê|-§VOE<,“ãh»i◊(Ç_»—:¢Dìã¯ÉÙu≈Ÿ‡_}$CbÒÂékpÚ©çI´*ß sPeõ§“+≈}©1Ü[àí˜q£jÈw`ÛBv∑?NÌ˘MÑÍûªÂÓ q}Üˇ@sÁªŒ?Ør/8r7,»„Rc;°¬eŒMm˙nò aΩ¥9ŒÓQ‘®UÒpI˚óUgò{,YzÆx!¶"xRK1∑kK‚eÕRC\h-AÂŸ§Õ-∆WÖÖ<
vg<):Ã(
’o≥’ª"»
«?O`j¨2$Ï$Û >eªÄ#3MR0~(BaıÄA∑#TQB’_çeŒAÇ`º'˜·kû¥ì)l˘2¬aËÈg¬¬%Ë/InG}WÜƒNt$“ìR„Ø‡∞¯c—∫LU˚p‡E±EáZ}∫%‚Ó∫iò5 ©Í<8»≠5l10¯Ωz,(˜1Úv[7(‡…c˙)2“#˙äÏ+≠cM§úcO˝0c!‚]q)∆S¬z‘dÍs∏ÑU
?4›ûõÚ{eÚl£bFﬂfb“©“*RfÙ1˘„≠Ÿ¨◊®s f‚≤Ùcm¸cÍÓß≠Iè«ÜN(s>qÌ!7MP
dY±ÚÅ÷ŒfŒÛÌa_ñ«\3⁄r·KÃEÒH?Ì¨^ÊuuBÁp4uXQãÓ":_T`˘9•≠ú´: 9˘Ãd…˘∑RgsölÃDˇiÒH«“pv--á˛'V3˜=Fäx`…D †2ÓÛ9	%5±€F≤Í∏ØqˇæA+”üs6é v•6k∞pGyie1¸Á‰ü}B˘π[˝Ÿp˝
1d„˙Ò
/|«	u»ñy#:ªÒ&(*¯ZŒ"„æ7˜¸”¸D˝ó&‡4EúQ:Ω≥¸F:Ä5¿a¶°äãœp|uá&¥n%F≥`I˛"…;ˆ[˘÷“{4¨QYh¨cd}c”Úl|$˙º02*°Ê‚Y*≤ÃcCÓ0ÍaZ¥ßHusYºLÍ¶%;LH]R?D8UrJ|Á5&»\8};©ÚW5ç¡à%éRi)≈íÏõækX6li‡ªcÕW)1a;ÎÆÒKagÎ#À}±(dQG6y‚Ô≠}#5˜¶”t•¥©◊ûÕÉ˜Ÿu◊3G’!¿ÖgJcq™7Ñ,ôu£j#-;MËÙΩo3”Ac`„S[ycçq§o6o†@GÊw•f[%˚S¿Áª(ªL!¢?vqCxiPç£•-oD_ím¨»∞†Yâybg`IY∆∆/©·R—™‰1≤e˜qÅÚÌ€26ù	}D©`Ô§Ì,”˛`Unõ§„,9¡WYΩ⁄≈nhXSczò&£sµÁ,$˝RDﬁæWtﬂ∏∑"òóá@î7qe3pØ>√ Èùx7p≈˜qúÊxc0w"ë!∑p•Ç◊^
Y:Õy;≥ô=NT≠C{•˙Ñ¸vÈ‚}≤=E3˛n˚jÔij	∏
∏–ûR`sa˛¿.ì◊≤»Yó ’-Pj7-®ua›QçcV=ÛË¶nÇ"àÈÎ#8&Œ{mÎ6ÔMî0huUÚ<ﬂ‚f	k¶D^r6í†arm√Sgh†h,{u ì°#Uüsºg›,ÀdKn‰i¿9ò8ó9ÿTv;`"ÕÊ≠˘F!µ$!•kë3?ËÙ∆"„Zgå;¡√X¢lYÇ√¨û"ËAÇX±"q\+,C•ö±≈§v}ÿMõñT6‚y˛úB#»∫ˆ¢∏~’í	µ7–4Ä2±ÓZì∑∫Ït©µ>ÑU2l¡aÂ—f0wo|gQKùm˙_,v◊Qt.”…w.6T∂;Eﬁõ˛>Î4◊ø˜òıÓwt¸u)RtfÏó5-ÿ¥ÔbÛUuoClæ@µ?Xm¢±A,˘m^„«›¥Ä—÷&Ò@6ŒaÜ=
P⁄˜Z*yH√°`j¥û!ÙO"!1>®ë ∏(+∫ëJœ.Û „hòv$ ˜≈Z∞3aFY}ö}ﬂ'_ÒŒ")-∫!â™$4Y{ŒÍÿóvËÔyf¯»< ñ)b!\5m(Úl7£÷†«Ä4‡*dm[›a{$i!s^B(}pË≤ û‰_§;ì6ÓDŒ$°ºhÀ’/	"’*¬Va‚$æ.{Íπ‹â'¸à%Ê 9"*Z˘ˇÈ4y(oŒr[íDÏr&sÀFSK<⁄dèccÔ%h≈ößägÏª‘ªz)›D\/^]@¿µ.p≥MZe>*uaEn(14ò~æ%Lú‘Wn<Æ"ÒÌÿ-ˆ‡æd©ÂM|ã£y™jL"¨%bﬁìiUˆòf4ªLU.>·LÁ%ø'≥(–m∫
0à-kÀ,%≈Ë;á(8.àiD ›†¿1b¨4PZlíèíºVA,8£ıƒ.-µÈ `ß‰_#J|A#U7Ë„uq™¬√ÃDZ‰EMHt’ ŸU^`RzjÀ|FVﬂy§ZœH|pn™ﬂ˛n,t“xÏj)`•\b‡ÁßDsπeÜÙP®=BŒsä{FÛ≈>ö…AƒS∏:{ueF[ˇ}LÈYeè%7FÂkﬂﬁË%zeDeZcë!ÍÌv+Ü≠®l™ªô,uu·EÂ7<ï£ısihJÎ	ÚBØ‚è‡/U%Ai‡+D,8»œmOöw® ≤y:x∫Œ^‰[Ôˇ˛ßmúVß[Å¶]
ê?È0Ñ=,è{ùuÅÖ√.◊zóÃ,uÿ'≈˜Ÿ<)h-ÖÆ≠æI;øó)´å&≠ («â	c(ãÏMΩLI®.jÓÁœ¿ =S∫ú!q(/ .IgœªßoŒp^z¬Ò’t
&u,s£kóIêÇ¯jlpñÛaM¿nmn®`m%:xÇ/≠M∏^){)Ø\¥-ÛÆg-Àx5*ÑIm	‹Ïøù?9 Æ#8å,>≠‰%1mèÌÏhÎØ≠	)}e»ª&¯-€ãQ(g_å%’6#<»Ê‡,€yeË!>PaETFª»d«WÂIƒ?µ∆p˛v:u2ÄU˙≠‚]e«È‘N_SæuÆ^hÄd‚ûW
f.*K.»P)~ApE	B$µEÅÓfŸ"RÊ0%»i2:{_1ÛÂyn´/®iÍS”åMHgq:’&*¶k∫ﬁZ†~ÜÌ§bÆC@'Kfkí˝ˇë_ëßR}sgB45\{e§Ej‡ô°ª`@Òái<b®6,g|ww«≈W˙˛õhS`º˝Ú≠VÆÇFË“a>i≠ın˚{^:œ»y2yKF«µPRa‰ÒdrûÑ{9<bΩeŸ#ÚD∑ûyaÀ≈D˜‘‰·xtåhê!ÊÌÆD∫ÛÃiôn‘≈!xµZˆ5-ÌÑ/$˙íà˚¥ﬂW~2l‰ry'q¢~r‰iokuñ¡≤ı©h9lh€·2»tÚ0£{†-œÖqå"R∑Îú˛¬ˇ*a≠ËFq•åˆo%”2£»)LzÒ≥|∞|¯ayP‡cÏÌ"V($.h
F˜>ÙpõLÖ2À>d=ü}~Sj'@•À$ÂÌ¡UÌ‰¢=•˜Ch=Êt=6éR!M<ö}ôÕ·€˚ç/„>d«®· g%pä91˛„o∂øﬁµRrn∂™éºé°itÚµ`+r]uc¡kge°0õÚ¶S·3;U“+`;ßIydyLGpwvˇLN[,.d§¬•˝Uu÷FÓ˘*ÔaÓmÑP6°`w‚jÓ∆¥∫ÇNïfrJˆX( JW@ôÏjT;ÈAfh)Hè¿-˜ü˝15q&ª∑ﬁeùÆ51%Ÿ]Xã_∏vhøphñA ∏ıiË¶"¡È◊N-„∏	'±h≥bXwPby¶˙M DT∆∂V<J?¶%ïHë!á@r˛'åﬁOπÖbigxÅqrtÊXd$iΩX E%D]*Rl‰$W¢#bbU =ÒAo2≥mÆ€î&1æyzD|%$DK§a"Õc≤ú@pf’YO xqÁtïs∂NsDˆ:∫CgÒup`aiÿ`b≠>¬3ìÁIg¶W$!Sq·i˜—.•i∆|`ÌtÂ,.q-i(í˝µqcu%∏õeüØ√(¥d#	sßßI0Ó⁄s˝_uƒ(,⁄{w¬n gÇê˚†az~km†s0#ácñ%V4ÃåÖFî#2`ÀIe$OÂUotÂx'∫^e]Y¯‡M‹ˆ≤|o:dy6áHQgcSˇêwŸD8÷m~Ã7W.f+Ë·†~Ÿà.¥ó^0∞e{ÊÚ:lvÌ1LT‚ﬁu$´∞~˚	ªioil‘' àjˇ/‰¡s:Õ(d`q*09¯Yw0∑uthºpnCøb*q$π{pìdÏx]kÀ{`˘ºPÂUN)—°\Ï≥‡f·êu˜_`äOŒ OC~5ß∆bn¡≤ m_k¢Ìbe!~	™RMò !ΩüÁscô˘”D¯o“—¯Te°Rt«^ı’i]tU∫^s¸pkΩˇËåOíA£UVÜy*eÁE?c4‘!Ü8ù%4æ#ÿ¸T¡Ab&BÓ¶UlD} [_Éz+Óx«ˇ˝æXjï Uk`GãaIÃ”ÂÁEﬁZkW/4Ãc@jAΩA#“1U:v23KÌ⁄Ç,hm¨LœYgƒ≥e=◊&◊t¿l	,Wñ*fq.5uD[jÔ/@/&*=ÛRïNiTóÉFﬁ?/(;vó "ewo9=:-˚Ì"ôR„n⁄¬~Lbt$tÒµç/›Uz7s^L∑
˘m3 L¶?2¯ıπ	„˙:<<ˇzhEI†ø:ah(‡4Rò(m;UÏ1R}xw3)`Òp@¬HŒQjO:Z7Ì&óZMˆS‰pˆTÂÂÎu—Ω$y‘th+ƒ≥*Rf˜"p=FÛH~]n˘a<·'Y{ıNhÑ "ôxÂip~‰KC<t-‚∆î`6!L™ WÂÛ 8ørú[∫bIn5ØrÛv_~:u§G3∑ßé6dvpV#ªÃÍ„è¨Ò#,ˆA2∞5 ¶ÂFı+∑l	™6“Ë10Kd:$`
oV *•Úß&Ó3fWp*!rÆ-h˜Ò$„$S˜∫HrA>gì‡{p9öì:ue#ª@£ey$`wÔp¸Ä{wHu´Ù˙πÔ+∂ﬂ˙Å≈}/b9y·xgÊD/h}“¯€3$OA„!iåMnæ‰„:Bik"T!l Hb⁄,˜ow5$È°p}ÒEá±QR^£aørûw7cvQÎ!≤xx«¿!¨Ì÷h2%~)ÏD'6!›∏&∆+tÿp»ƒ}¯~ 6“˚unEbbÉ¿≥Õ}u®rΩzÒSmªf™ sg	skrw8´X& ∫N{π∆gbµ¯¶yq$&.VNı8é[+‘Â0\	∫>Ì,mÏÀ/cDeR\'“Ò∏w
{2«ÄXäü‘< 
y-q\vú9¢`≈jq†à}õdx'h&+‹¨3ŒOÄ√US√(“»vºUÿ 'å’yo%Mƒ˘osxfEGFl‚BsÁ<≥j·SAJDå˘G4°!Úuz'‰me0 ·Ll	5xzí5]h,@"8õÆzTyjZº}I›mv(+jm√æ*OW}ıÖ≠NıÏ¬∏•aòÌ¥Z¯&7Èı·†P}4{mÎ|˘K∆´aCl22Ç°|xjﬁw?∆Ì7"÷+d.S3Pü{Òf´v'j^¶E™!£O,å6Pg£0*ahFÔ:ek.ß5?§Á‚î˙5ODxB!™dy&¯A‚Ωæ ∞j8„?ô¨Yπ]2¯>Y5`F"U¯∆$5zÖe<'§“˘V+˛Âzpﬁ∞ùó8q*e)˜ŸGÇe?èWY9Vòf/≠Ì„ !u∑sÒ„/B∆°3$.z‡!Aùô ó V+œoÓi>p!·mqyb9∞I)Ä5
;X4~·4WV·2ÎBri‘®Ì|øÌ.ç—’‰ Í?¥b0k5"3’√*e“˚°7∑l˜J$"¥}
ø6∞¢l9ßƒ≤Ùj(XÜujM·bEF[ÉÂ˝∏®W\Ë†˛J·5Á…°¸I)Hy%kd∫?RTåd˛OWj°ò%S¿iJ“%'[»(å⁄=HÅ{Çf≤¢Jöb¥
'Qı7ÖÇD$haóa·¬	%Œ<∑q∫ı“áB~˛	ºÃhUy*  ™eyà1•$>yÄ;G∞RO7( sD~¯Q1H«°|S.Å"\}åÀ"glªj•-êó¶wOÕó]ZÛk©£Ÿ6q´!vwﬂf—iPÂ#CPèZ É+iiÙ_*
J~E∞3ø»î¿==ç +´=‡Ne‚`mi8aÂCd<ürÊ?iºkSc5EÊ ØT∞A¬«a*yr8|™`)zˆ¨u≤d _}Ne-S"6˘mH©)D)OïÜΩ#tÇA
Ìã+ˆPƒ≈!Á‚·3BD0,w¢(jGTo€(“rl+d8KR" skÄRvàäVq›ó},a\Ùwìù &b˚t’p•¸uÓvª>"?c}4Je•8ˆc—º…wÇHLlòﬁyÎróÊ’‰)K€RF¨A∂›Ô°uO%e	- $4◊@H}ÒÚ‹ÁU	ˇnC**˙NJNltU+8H?™0w
&p^v™Ce@«∞>¸dP"≈re'z£jÌ–i=§}k‰\`±y˙ı§guÄ_§∑0ig;pp'7hp≥)ì°óO/2c$+hoC;Á}˙´tíx?ƒM¶x|bªäàÍM4˝ 0^')%jé`&U©{MxM(\D¢ç6s0Sü+i≈[u)©<'…Ë¿‰éñ`°O¢Eû∆|Ee˜Ö∏y!.ˇ∞{•4O*É3sjA~8dÚ1Ùa»ê¬©.cs«2ÚT|
*Ë˚ﬂ:{Ì´Î>Ú?æ>Ìj7∂ﬂmn¸{6Äáy/V?p‘™$t5H∑)πJz∑†|ÌR.6p†Fxj&ST?w¸‹ÀÁY{	ja˙ëG3W=GWUG≥†fvµE;52^$mÿm#c<u÷*∆(u∞3aßdOÂ”–f~Ùu!Iì\ÇŸVËujÈ–;b>®ﬂ0ªlán8ttÚ"d),fe:&pEA¸'È≈ÂÑbÅù.!≤ )áÿhrgd“ÓËOEAwm›aª»}D_M}pg¥Ó
*}dÎ€§ Wj>T:ÀEXz©œÃƒm39eu-πû&9å|õ¢∫âf`Èdı2)˛Z¯MTﬂ‘RÉE@Bè¨’rß≈q)T>q`;dÉl‡´S˛Œ‡^9å‡b8%≤©e
j+mn®1ztÌ≈Ø∏(Yl"]pe$ÃXCúüC˙â:ˆ]…¿å+ùG5vz{¥ ∞•v0‰ +>ïΩótWtÁ =c&Çı?(xÙΩ∂5N†;ÚzŒRD(Î,±(é•˚PZ/’yW¬>luúΩ2∞,ÛÇ§K®÷e8]¥¶ÒßêY>i¬í√pÖÖ®HmIe$D'ıme2^;W	µæÏ˝ £SˆA{≥4=J	&M^@~= }9t,xg02~).OÈ≠`®íz.∫—?æe`◊oÓCÑlnzïÈŒ0b
~¥zo˜CCrk|r)zë+§hh_´‰Hwgln¥a/h,”io`√5◊p¥3ø#w(ﬁ&r_|<!Bewr∫z3Á&”SáΩuò†kbi>0cÖV#ô4ÛI–ﬂ>NoÏgô¬«.î°hªwT=ªa…tàÌ9J@·yK*{gÆNtgˆy≥Mo)˜;ÕÿvœtHF45C$ƒFs(aÉëØ(Ω|DÃcs¨ØÛ_sV‘” ΩPæ«“HtychaÔ!)ß“h±∑·e+€W´Æ¶.ıuA™£ëÂÃD)óQ]~‰BhËYπKÒ*öcÅFJrcod•éﬁhÃmf0	&QA`4vF9–OÍ?&;H=¿6∞ÍÊaÂúKz-cP!<N™g<U·Œ¢∆46RYŸıUå†öm$UW»9É+Cp8‚va–ñ®:9‰vœg∫'B6lMkIir&Ω‰PﬁvhhMjö6Ó"ax…∂^ﬁt_¨"∞+%ÔKc8ªËÆÌE∂4°*íeπÔU©!‚A8a
†RG$eµŒ†vŒ∆au-‰à2d-=ß9t£ø‰ŸU__t˜ˇI÷¶@R^ÁÒwPSæGhn9f3∫;F
$Ìj˚Tx/‡Ëe’°ÊEv&Âî·|≤˙Çd§Ùe^#\zÊ#mÅhπW/f)-£mM¢ös;> ªiéØù6ÛM$ŸDs¨mÅ|s0¸Õ[2◊v6wı%?
OK6âÍù rV}ÊtΩ¥Mc„Wt.∫´(Pf?;ﬁB›ç®<(ªÍ~Y:~<Y0ïGÍe°˙¬¸{ï3Á{Óh7aG“ôÂ±s –°∞$ôºƒñ}kıı@ygîrWv˛–ºxgyKœ&i_uLp`åæfz+ZÃo :;’Ò'¸$l=8,˛ j2+¡Öuî F9q.|6xï{h≥tü‚|p` ıˇÖ'8T»  îV=›‡˙z+ñÇö∂zjt>—6h,!5CCyd”˙‡aôi2Pgb∂mq)q<ªÄ◊u*cãcÂ∫[‘;1Gf©Â…r8Ò”Óhs`)Ò\V√´¬g\„e1 0'£dòmgW®ok„~‚z[Á@’\K˙<,aÓnc`Ç∆Ÿ¢‡%ik-8èüc‚Ì9¸\"9¥W˝bíÕª7 ˘lfË´S:|‹h>h'=°t£l:Ùcmpem≤Íh’AL)iÂ˚F}`ë?ˆﬂAyoàdf#¡{Us 8Êüt2ì9nr':ftj—©Ú≈1!-PY`MŒ˜bicGc‰yÊ ‡Q÷Bmmjn4Ì®c6÷:™õ|ym≈|<x);0˙*π,±ı{i%“Tj3‘R7Á3#ÌÚ.)23|n}p¥•¸∂Sú¢⁄n/je›g*t{ı—ruP`¨π-˛x¥3á¬€ÙÓóû5abûØdòÇ:ŒO{„T
Ç·¡êp≤{ÍkZ;|~:ùl<±9=HH}
≈ôîEGaˆΩ‘_Óò~I`rw‰¢‰»Zw¥∫Ôb^{È¡Eu¬&vl‰∏j¬˝(©∏¯pƒY¬“†ÄÎ[•C±]@e|e:…^a"Li§y∫?I›%Û$_w{sàH®Jd4—ÙÆe±k-s•)ñûßN`d†M=W?¯°îj;m&h0‚¢¥ﬂ®sÆo÷∞R<‰ºapS™o1Ù3o¯Ä7gÅPVcùô®£õ14¨\/QKa˙∂fv{0aVj1/p4D©˝ÿ˛XbÍÑ=∂°9Ál#<yd”«ñp)Ê `ÎlÜ8J"™Ω4Jyù¥ÿÏrÌvi€ œ&†Ïa’,(5?xl^Êf—$≤w¨¬∆9nN]O{R(bÒÇmeˇµ_
H“5$$NÏ9‘ê!U∏∏)jX®wb˚O˘…O`c5I>•2aÛÙD'=æg2{˜Ì…º8∫5“%7≤A	P@◊·/$⁄7˘p	B2cV©Ã,m“qÂH◊,<bj.Ø5@ñÚzoÀ -êÒ∞N™;‘V7Ë5l!¨A 7·* v+=¨&Áe:÷l≤ıHFu√Ga7e.(lˆÌ^ÛrÈG¨yÑÌr'5rºpöû·ÑA0UÆøoËfjñ•Ó˝CÖ(%hı94Fu&w, ∂†∫!|ƒsÁár‘ÈSZ”…ƒ$l©Òô_l∏l—◊˜Í ‚iCahVB™vÓâ˜&Â5ªdVX&Úmqv¬è3(ƒ∫∑ma¢/hd75Pa4Ë‘u~∆Y]Èê‚<pﬁGaDÅb|îxP8r±|µ¥dˆºsƒ‡JÒ(ÏS3”6}~gãÙTÉ5}aÒÚ+3,h∑‹oJuw3)i˛´7Â˘eeÓMIpavÇ›D‰â¸
0xœm3S
…2Z4vO—˜<˚<^`ËmkËµ Rf.ˇtwImô‘™L#b€d¥7yG3a“G5so8ªê®êf$…$Ä ™•TA,;‘]≠Ë$…c-≤p°Ωm≥»TQ¯Æ5å}·hak$vM,yî‡e⁄3˘xfò'z"vV`^·™©¢XONÎÍx5"“ÜÆïæèÕ◊{#øoΩÙÈﬁ\T72Ë >mDu⁄Ár#µ7“)G5≠#Q˙y$&îv2lîy”õ+rnM¨ÿÂÕÚ)['v∞b! gzáh"(¯Áƒ;$‡¶Œêfpt—^¡;az\†ºeπtÛCpgV°nCdr‰‹6kbQ‚å‡hÚÂnZ{≤ü¢mÏ"‚V"¿  ˛EìáSpˆyÄÙÈ‡m}Â]5xáJÑXüGh_^28≈áBo"(nÊJ7||#^4§.ßAM¿ò4∑ıRËâañ~~´Ø!y 10am%.bˇ∏"huWÀRblÀd}˚iv˜0¢hQ»„Ç{P+^¬ !sEucÇNXgˇb≤˝∑}Ã"·Pl∞HHØÉ*mÛHÓ'lOwdN%Kx•»1M=πaﬂÁu|GJ1Ù_3˝w∑0È6}Ûy∫—Œç2c∞zDO"Ô÷ú*c-l∞A|ƒëÄe(-ø≥‘5∂aö/hMVÀ—Iµ(”=£>chT˜Nhï~Ω„ü:]„7≠Ωfr≥‰3,y€*¯$∫ç7,Ã∂|§KGG<L{–Hå=Î,Ç∏Ò>¢dÖÈ¬ÙqeŸ†}ÙCxÛûop™…A+˙®(
mO™§“(¡˝)#É[à˜+„bow`ÛFv≥5~¸˘M”`w7„ÔŒq:áΩ*3Ê‡Õ6!r/zR1.˘˚vU#;!‡g÷m)Í(ò!aeºuÂø=bË”	â=€pIªó@g*,:™	x#™™xk1ˆB$KnFhÕih3øl≈[†Ì◊Sb«ù4
vs=36Ì(B¡gÛŸª='»
/%Ujk,2$˛)Û .m3
#˜Ö4~0 kîïa‘pŸı^≠e‚I.¸‰-Øa*é•Û(m˘ Ç·b·w¬b>©jOO}V∂$Bv\%“≥È?h†Ù$Cpªl1¸rÈ$$#Z}™%†√æiën	z}](»5=e±0ËΩh,Ù÷_3(‡¡s¯,8ÚctéO)=#M¶º&
˝0;!‚_RFs«xÙDÆsæÜuÇoııûΩr{˝†z£bfég"—Ø⁄**‘tôc∏S‡›h7 nbd)ltvÓn•ˇYÉƒN)ÔÌ!6iPRe:ırá÷Œ. Û‰aøî¶:‹0·{L¡ÁH:Ì¨^Ê’eR¶–9tx˘+l"2_4‡·π•çÃ≠{⁄t…ÃhiŸ∑@#t∫wÃ¿˝aıÄ«“`F,Áy&V3˜≤)F?_çpËE 02|Ô+9#5=˚6™®ø“˝ˇE+#”Æ5∂,v50+5p9ie1Ù&d
›Z 9∑_¯ÏipÂ*}ljr·ò%¸E)g…ıb\?:Ò,z Rü¢Áç˜ŒS~F˝€&Û=0æQ:ú≥fzµ¿sÆ®Óàf0|Öƒ,ın•d7&`!ﬁ"Àá{vTP=–“;6(yx…(ct]6o—#-~2ò®Ïb´†÷˙Yj≤L#Cf0-Í"Z¥&L5p\ˇLÍ¶!9\àYR}F∏Q‡€T≥&bLxY;‰ja5â‘∏% n!aƒh:ˇzŸ'm(¿/cÂ\l1!9Èé…O;
g´!À;±(4AQG4y•_Æ1c7ÁüÀ•>eWü7∑iu=2ß]!Å¨gZ+e:1Ö,ô?¢N#%yO ÙΩ^7”kÂq1Ú“9#ç˚5Ä/vw†@Ew7≠f[/{Sòg˚(æT!Ç?u o¯u+XôØß+|Fìt¨H±†˝Ösj&"I9ˆ∆+©iZa=Ù3≤`ÁsÅ˙«€27õIm@©/`Ïn|?“ˇlmn°c$4µA?YçøCCoHVS {+Òn:36Ô,≠˘iXÌûWRÕ‹v qóGìïqvpØ|Û sΩ:åx'dPupùÊzg?*†aw¶HS\
i/Tz;ïô=~T,@~°j¸=“yg}n=M7ﬁj˚bÂIjY!∏&(Ì–∂R@jEˇ–wéÉ◊¢ ¸Q∑ U©PN/$¨∏Âieúc—=o©¢n¢¶à)È!8÷M{=À7Îƒ<muE‚<¡0I)¶\':m¶†•ˆßm'ÈË·x,y-≥Î!E~=jÕ,⁄Vk,4i»ô∫∂qGﬁ\vA"6›‚≠`F"µd ß"’3?ËÛÓ™™YgçV+¡ÂË"lmíA¨/"lKäi$by\k,´Ñ∫9ç§7YÈmçT0"9∏ç3i≠Ù/∏~’∞	¥#ŸE 59ΩÓ^ùu:º|ΩµdyrmëuuPVtuqÙ~gsbUÍ],tdSv.]P8…wÆ<p&9E÷;˛:I%gwWHk›Íc4~U874#º∑9=‹¥\˚jÙFUaWdvpµ6y ¢ıA^&}}>sœ›ºÄôvU$yJ>⁄√5!˙∑z©y"õ`l˝û Y¯Wbl>q)ìº(b21⁄ û&sTÙh–˛$qtgs¯¥;7¡GSy⁄˝˛?_Û•i%™πâÍ{4Yq É–rhg|'ËÃ| }u	\m+r‹?-hW†«ÄvËHd}[’)©;&P!3WX$}qÏ≤(ûÙKµ{–VˆDn,°¨HÈU'ô"ﬂ)RSqÊ§˛,π©,c§c†Ÿw(9*Z"gËqy,å4r]LdrN*Í V1S…01WtèmcÌ.h≠õ≥=JfÏ˛·ªz∏çd	à)^)H9+í≥hJ„.daX(Y%∏xúVH
Õívf>ªwaÌË≠Û…>g%eMc/¢qÍÓLjú'`ﬁë)U÷úa-PªLt<Q.I<ÒãNı7ßÂxˆo∫<0å,c˙-7≈‡+á≤=.9iE.A≈8`!B¨îQL}í€ºUE(¥/{ƒ,|%IDÖ‰~#ëJ<Y.'E;n·uq™¬ËÿÊ~maMMtD$AEw]`=RzjÀp2 ˘˝‚⁄Hl∫lhxÙ8¨tûxÌn	iπXh∞Á*ûVq=uß∂p®}fÊYé{Tª¡ÿœADcx*7zcV;˜oÃÈ[o÷ô%>Ck◊ˇ¯5XE, mzcı†	ÍÈ6iU≠#®|*õπ$u<X„Gee<µèıwihN„Oë#¿è‡/$+aÈ‡?d,5åèmH∫{d ≤y8ºrí§€g¸¶9sÂR"õ·5|cëÎ2Ùwy(/{üu¬Cn˜}zÉ`!WXî&∆‚—l{jBaÑØN›8” ê∫oÉ:3à6ÏpàwX?‚(°Ëk$L[∞.j‡de¬<¿gin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool2dOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr AvgPool2dOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr AvgPool2dOpAdaptor::kernel() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("kernel").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AvgPool2dOpAdaptor::stride() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("stride").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr AvgPool2dOpAdaptor::pad() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("pad").cast<::mlir::ArrayAttr>();
  return attr;
}

mlir::tosa::UnaryOpQuantizationAttr AvgPool2dOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::UnaryOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::UnaryOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult AvgPool2dOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_kernel = odsAttrs.get("kernel");
  if (!tblgen_kernel) return emitError(loc, "'tosa.avg_pool2d' op ""requires attribute 'kernel'");
    if (!((((tblgen_kernel.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_kernel.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_kernel.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.avg_pool2d' op ""attribute 'kernel' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_stride = odsAttrs.get("stride");
  if (!tblgen_stride) return emitError(loc, "'tosa.avg_pool2d' op ""requires attribute 'stride'");
    if (!((((tblgen_stride.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_stride.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_stride.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.avg_pool2d' op ""attribute 'stride' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_pad = odsAttrs.get("pad");
  if (!tblgen_pad) return emitError(loc, "'tosa.avg_pool2d' op ""requires attribute 'pad'");
    if (!((((tblgen_pad.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_pad.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_pad.cast<::mlir::ArrayAttr>().size() == 4)))) return emitError(loc, "'tosa.avg_pool2d' op ""attribute 'pad' failed to satisfy constraint: 64-bit integer array attribute with exactly 4 elements");
  }
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::UnaryOpQuantizationAttr>()))) return emitError(loc, "'tosa.avg_pool2d' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for UnaryOp quantization information.");
  }
  }
  return ::mlir::success();
}

























std::pair<unsigned, unsigned> AvgPool2dOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AvgPool2dOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool2dOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AvgPool2dOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AvgPool2dOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AvgPool2dOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AvgPool2dOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr AvgPool2dOp::kernelAttr() {
  return (*this)->getAttr(kernelAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPool2dOp::kernel() {
  auto attr = kernelAttr();
  return attr;
}

::mlir::ArrayAttr AvgPool2dOp::strideAttr() {
  return (*this)->getAttr(strideAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPool2dOp::stride() {
  auto attr = strideAttr();
  return attr;
}

::mlir::ArrayAttr AvgPool2dOp::padAttr() {
  return (*this)->getAttr(padAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr AvgPool2dOp::pad() {
  auto attr = padAttr();
  return attr;
}

mlir::tosa::UnaryOpQuantizationAttr AvgPool2dOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::UnaryOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::UnaryOpQuantizationAttr> AvgPool2dOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::UnaryOpQuantizationAttr>(attr) : (::llvm::None);
}

void AvgPool2dOp::kernelAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(kernelAttrName(), attr);
}

void AvgPool2dOp::strideAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(strideAttrName(), attr);
}

void AvgPool2dOp::padAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(padAttrName(), attr);
}

void AvgPool2dOp::quantization_infoAttr(mlir::tosa::UnaryOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute AvgPool2dOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void AvgPool2dOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value input, ArrayAttr kernel, ArrayAttr stride, ArrayAttr pad) {
    buildAvgPool2dOpWithQuantInfo(odsBuilder, odsState, outputType,
                                  input, kernel, stride, pad);
  
}

void AvgPool2dOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr kernel, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr pad, /*optional*/mlir::tosa::UnaryOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addAttribute(kernelAttrName(odsState.name), kernel);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(output);
}

void AvgPool2dOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr kernel, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr pad, /*optional*/mlir::tosa::UnaryOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addAttribute(kernelAttrName(odsState.name), kernel);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AvgPool2dOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AvgPool2dOp::verify() {
  if (failed(AvgPool2dOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void AvgPool2dOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::BitwiseAndOp definitions
//===----------------------------------------------------------------------===//

BitwiseAndOpAdaptor::BitwiseAndOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BitwiseAndOpAdaptor::BitwiseAndOpAdaptor(BitwiseAndOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BitwiseAndOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitwiseAndOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseAndOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseAndOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr BitwiseAndOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitwiseAndOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> BitwiseAndOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseAndOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseAndOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseAndOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BitwiseAndOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BitwiseAndOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseAndOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseAndOp::output() {
  return *getODSResults(0).begin();
}

void BitwiseAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void BitwiseAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseAndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitwiseAndOp::verify() {
  if (failed(BitwiseAndOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void BitwiseAndOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::BitwiseNotOp definitions
//===----------------------------------------------------------------------===//

BitwiseNotOpAdaptor::BitwiseNotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BitwiseNotOpAdaptor::BitwiseNotOpAdaptor(BitwiseNotOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BitwiseNotOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitwiseNotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseNotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseNotOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr BitwiseNotOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitwiseNotOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> BitwiseNotOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseNotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseNotOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange BitwiseNotOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BitwiseNotOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseNotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseNotOp::output() {
  return *getODSResults(0).begin();
}

void BitwiseNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void BitwiseNotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseNotOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitwiseNotOp::verify() {
  if (failed(BitwiseNotOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void BitwiseNotOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::BitwiseOrOp definitions
//===----------------------------------------------------------------------===//

BitwiseOrOpAdaptor::BitwiseOrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BitwiseOrOpAdaptor::BitwiseOrOpAdaptor(BitwiseOrOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BitwiseOrOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitwiseOrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseOrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseOrOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr BitwiseOrOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitwiseOrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> BitwiseOrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseOrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseOrOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseOrOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BitwiseOrOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BitwiseOrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseOrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseOrOp::output() {
  return *getODSResults(0).begin();
}

void BitwiseOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void BitwiseOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseOrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitwiseOrOp::verify() {
  if (failed(BitwiseOrOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void BitwiseOrOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::BitwiseXorOp definitions
//===----------------------------------------------------------------------===//

BitwiseXorOpAdaptor::BitwiseXorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BitwiseXorOpAdaptor::BitwiseXorOpAdaptor(BitwiseXorOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BitwiseXorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BitwiseXorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange BitwiseXorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseXorOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr BitwiseXorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BitwiseXorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> BitwiseXorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range BitwiseXorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value BitwiseXorOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange BitwiseXorOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange BitwiseXorOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BitwiseXorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BitwiseXorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BitwiseXorOp::output() {
  return *getODSResults(0).begin();
}

void BitwiseXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void BitwiseXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BitwiseXorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BitwiseXorOp::verify() {
  if (failed(BitwiseXorOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void BitwiseXorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::CastOp definitions
//===----------------------------------------------------------------------===//

CastOpAdaptor::CastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CastOpAdaptor::CastOpAdaptor(CastOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CastOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CastOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CastOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> CastOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CastOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOp::output() {
  return *getODSResults(0).begin();
}

void CastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void CastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CastOp::verify() {
  if (failed(CastOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void CastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::CeilOp definitions
//===----------------------------------------------------------------------===//

CeilOpAdaptor::CeilOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CeilOpAdaptor::CeilOpAdaptor(CeilOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CeilOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CeilOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CeilOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CeilOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CeilOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CeilOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> CeilOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CeilOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CeilOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CeilOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CeilOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CeilOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CeilOp::output() {
  return *getODSResults(0).begin();
}

void CeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void CeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CeilOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes({input1.getType()});

}

void CeilOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult CeilOp::verify() {
  if (failed(CeilOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void CeilOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ClampOp definitions
//===----------------------------------------------------------------------===//

ClampOpAdaptor::ClampOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ClampOpAdaptor::ClampOpAdaptor(ClampOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ClampOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ClampOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ClampOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ClampOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ClampOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr ClampOpAdaptor::min_int() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("min_int").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr ClampOpAdaptor::max_int() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("max_int").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::FloatAttr ClampOpAdaptor::min_fp() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("min_fp").cast<::mlir::FloatAttr>();
  return attr;
}

::mlir::FloatAttr ClampOpAdaptor::max_fp() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("max_fp").cast<::mlir::FloatAttr>();
  return attr;
}

::mlir::LogicalResult ClampOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_min_int = odsAttrs.get("min_int");
  if (!tblgen_min_int) return emitError(loc, "'tosa.clamp' op ""requires attribute 'min_int'");
    if (!(((tblgen_min_int.isa<::mlir::IntegerAttr>())) && ((tblgen_min_int.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tosa.clamp' op ""attribute 'min_int' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_max_int = odsAttrs.get("max_int");
  if (!tblgen_max_int) return emitError(loc, "'tosa.clamp' op ""requires attribute 'max_int'");
    if (!(((tblgen_max_int.isa<::mlir::IntegerAttr>())) && ((tblgen_max_int.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tosa.clamp' op ""attribute 'max_int' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_min_fp = odsAttrs.get("min_fp");
  if (!tblgen_min_fp) return emitError(loc, "'tosa.clamp' op ""requires attribute 'min_fp'");
    if (!(((tblgen_min_fp.isa<::mlir::FloatAttr>())) && ((tblgen_min_fp.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tosa.clamp' op ""attribute 'min_fp' failed to satisfy constraint: 32-bit float attribute");
  }
  {
  auto tblgen_max_fp = odsAttrs.get("max_fp");
  if (!tblgen_max_fp) return emitError(loc, "'tosa.clamp' op ""requires attribute 'max_fp'");
    if (!(((tblgen_max_fp.isa<::mlir::FloatAttr>())) && ((tblgen_max_fp.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tosa.clamp' op ""attribute 'max_fp' failed to satisfy constraint: 32-bit float attribute");
  }
  return ::mlir::success();
}

























std::pair<unsigned, unsigned> ClampOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ClampOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ClampOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ClampOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ClampOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ClampOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ClampOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ClampOp::min_intAttr() {
  return (*this)->getAttr(min_intAttrName()).template cast<::mlir::IntegerAttr>();
}

uint64_t ClampOp::min_int() {
  auto attr = min_intAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr ClampOp::max_intAttr() {
  return (*this)->getAttr(max_intAttrName()).template cast<::mlir::IntegerAttr>();
}

uint64_t ClampOp::max_int() {
  auto attr = max_intAttr();
  return attr.getValue().getZExtValue();
}

::mlir::FloatAttr ClampOp::min_fpAttr() {
  return (*this)->getAttr(min_fpAttrName()).template cast<::mlir::FloatAttr>();
}

::llvm::APFloat ClampOp::min_fp() {
  auto attr = min_fpAttr();
  return attr.getValue();
}

::mlir::FloatAttr ClampOp::max_fpAttr() {
  return (*this)->getAttr(max_fpAttrName()).template cast<::mlir::FloatAttr>();
}

::llvm::APFloat ClampOp::max_fp() {
  auto attr = max_fpAttr();
  return attr.getValue();
}

void ClampOp::min_intAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(min_intAttrName(), attr);
}

void ClampOp::max_intAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(max_intAttrName(), attr);
}

void ClampOp::min_fpAttr(::mlir::FloatAttr attr) {
  (*this)->setAttr(min_fpAttrName(), attr);
}

void ClampOp::max_fpAttr(::mlir::FloatAttr attr) {
  (*this)->setAttr(max_fpAttrName(), attr);
}

void ClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr min_int, ::mlir::IntegerAttr max_int, ::mlir::FloatAttr min_fp, ::mlir::FloatAttr max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(min_intAttrName(odsState.name), min_int);
  odsState.addAttribute(max_intAttrName(odsState.name), max_int);
  odsState.addAttribute(min_fpAttrName(odsState.name), min_fp);
  odsState.addAttribute(max_fpAttrName(odsState.name), max_fp);
  odsState.addTypes(output);
}

void ClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr min_int, ::mlir::IntegerAttr max_int, ::mlir::FloatAttr min_fp, ::mlir::FloatAttr max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(min_intAttrName(odsState.name), min_int);
  odsState.addAttribute(max_intAttrName(odsState.name), max_int);
  odsState.addAttribute(min_fpAttrName(odsState.name), min_fp);
  odsState.addAttribute(max_fpAttrName(odsState.name), max_fp);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t min_int, uint64_t max_int, ::llvm::APFloat min_fp, ::llvm::APFloat max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(min_intAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), min_int));
  odsState.addAttribute(max_intAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_int));
  odsState.addAttribute(min_fpAttrName(odsState.name), odsBuilder.getFloatAttr(odsBuilder.getF32Type(), min_fp));
  odsState.addAttribute(max_fpAttrName(odsState.name), odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max_fp));
  odsState.addTypes(output);
}

void ClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t min_int, uint64_t max_int, ::llvm::APFloat min_fp, ::llvm::APFloat max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(min_intAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), min_int));
  odsState.addAttribute(max_intAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_int));
  odsState.addAttribute(min_fpAttrName(odsState.name), odsBuilder.getFloatAttr(odsBuilder.getF32Type(), min_fp));
  odsState.addAttribute(max_fpAttrName(odsState.name), odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max_fp));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ClampOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::IntegerAttr min_int, ::mlir::IntegerAttr max_int, ::mlir::FloatAttr min_fp, ::mlir::FloatAttr max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(min_intAttrName(odsState.name), min_int);
  odsState.addAttribute(max_intAttrName(odsState.name), max_int);
  odsState.addAttribute(min_fpAttrName(odsState.name), min_fp);
  odsState.addAttribute(max_fpAttrName(odsState.name), max_fp);
  odsState.addTypes({input.getType()});

}

void ClampOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ClampOp::verify() {
  if (failed(ClampOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mli3[2£MbI˙Òª˝í(¸(yT‰cÊ¨bDDd$ÆhQFÁ6ÙQäEt˚/dΩﬂˇC¯Ú*Éc»L•ﬁdÂÌŸWç‰‡=•ÛúA’-Ú4πäX´MlŒ›π¿ı≥öÔ/éÎv·Á[aQMe—™/7–ÀØN≠ﬁê¸Scå¶o£éºØÂNhtr¥D. eB¡Îe° [‚¶ã2√#`>áibq»g%Ên˚J_=.’$∆≠˝U~Y⁄FÔ˘/Ôa~®ÑA°‰w£jn∆∏ªÇRÉf{ﬁD˜Z≈`JP©ÏbÄªâA&]•_çî˜ù}!a6≠7ﬂ-©ù¶-è1≈MÅhÉM∞>O/}hÑI,´≠mÖËß.¡©ñn$Á®-#ßÏΩ#¯u amØÿoEÏ∑TºJE¶$4uU!◊¶Ôçﬁã≈bÔIhÖqrl‰xv%mÏX: oµƒ],S,¶$G$†/FÊ]uÂ/2ΩÌ,Ì	ì&1¨Ωh-%$M§+*çc¶ù∆P#’]ìN O=ç'uïqæN!ﬁ(™œuMq@%kò¿A,;J—ÊI“¶w†ÈW◊Ÿis¡¡z ±IÉ∏∞ml√–.ÒV-iAH≤˝ıu#W!‹[E;éA ∞#âsø/I1˛O“c˙mr¿Ht⁄s˜√Ê ÚÉòÚ†8t\√c¨sÙwÉcﬁÔT&Ãà≈Ü¥K'q`Œ	eN·éUgpÂID˙XÁ]KyıE›æ≤lœzß}6èÀ˜a]WP7€D}TY^Õˇodä‡· ÆœŒs¡Wû05§˚„‚∫mVmaXTÍ^®ãpzÎ˘ÛiıÈO‘'bâj˜ˇ§AıÕò`-póÚYq$E∑yEæ)oTø2j,π{0ì,*NlN[jaÚ·‰æ–Ì]NmÒ€|Ïí‚c‡ÛÂ‡öoJ ©K~5Á∆‚o·∫$j_o¢¨ÚuÂﬂÂrô»£πã≈bŸ±õXu“˘ÿd! vÔZói]ˆ@UöDk˛j˝Ô¿8[“Ã≥UñWy,íeg;å34Ñ&Çlå$~:ßX¸FDAb$Z»¶YlD }·|9ÓYAÔ}ép(—†Ui@Ge …” ÁÃJI˜'=Ã#bzENø(#“WZÙ&C Âõm`Rmì¨M}HC¿ M=á&ƒv"…l,Y±(˜
ûuF[jÇÔBÔ¶∂,‚R› yìãGVπ78:v—ffduNá1ZCí~Ò·`ôpAZ¬gMfTÑdqïQôoÿU\5{~ÍıJy˝7l∆6ú2ªıô„˙.<º˝R`áI®Ωrf`&y ä<îmu—ŒqK˘xg:aÂ·XX¬NÃIdGÊ^(ÈnÜPMˆRƒˆHTõ~·jqŸøÖT–Ùj-–≥*ifW¢\peñÙ>ºOIaÿ·—$ıNÑ`Áè™•]qsÁkGæ#-¢¶ƒ`Ä«,™ÚW≈∑h∏î?:<FÍhl¡ØfÛNHWÍÔÄgí∂≠‰>KVuU7âjè‡œGËˆ#ÏûEì∞-À¶˘Ö¬˜˘%%QäZí(ëX∏ ‡:<fAeU±
ÂÚßÃÊ£tVvk#ˇ(Æ˘≥$¬ Q‚íZe˙O N*õ{⁄:%U#⁄@eÑ§`˜Ôx¯õ€eMPÉê˙ΩÓ%Úﬂz√«˝%À+Y·pgíÊDk@]‘zœ≥8EEcuiÃ–XOé|√8üÀci\rE£≈lêKÿ˜.ˆ∂êÈŸ`˘Ÿ·ÖÅQ^ô:q≠Fû◊>£NSG·£xl√¿1I‰øﬂÄret{!¨L56±∫>≈KnJp»º}Ÿ~B6”{enA`n°E∑Õ|I®r©]*ÒSlΩds"Î£Úoa…8*ò¬õHqπvbbëÿái`".RTıx˙—+ı’∞NAô&„Æ,˝ +ADEP\Ä—òUŒx≤§¿y¶ü‘w6B`yÀ%±Y÷î-¢‚ÁÃQ•hmõå¯'j)À¶©FÄFƒOqÎ®¬âd¥<VÃ #Ó¡qn≠8E’/a)ÿj6RFlÇj∂„Ûz—SAHFò∏M<!”‚btw¿eqÖ√ÃÏôç@x÷ıM¯@ kèÆZ÷	xZKÙ~È7e)mF h=ÀØ(jc|˝ÜÑNa®`8$©ÕºΩ&'Óú˝A·Xu4Ûgh|nIl£aCl:2¬a¸X¯iÃt>V·#"÷+dñSc`€^Û´~'záÆ»Æ‡M,ç6Bo£T(tj∆ozel˜%Ô$ÏzÄ˙8a6EHF!˙≠lßÙH‚ΩrÙk®£ßô$I± ∏<ıDGU˙Ç‚4∏OÕU=G•⁄·Vc¸Â;*◊æÌó8}.wH˜YGÄ≥=´WIxR±÷ÕÔÁ +m˘≥:”….BYPvE1c‰Œ~ÈAüﬁ»3t(ø7nëx85imqj`∞Mi‘¢0HI\<·4SÜ‡0¬¿Ro‹®n]∑ÌÓ@Ö’ﬂ›`"Í?ÒT0MÎ5#’Bã´'–⁄Ä7Õ6J$*0mµpøfpâ§êl(•Ã¶ñbho]qjó^‡™mFZáÌ˝ù˚U\!Ëô†™Ba'%√…ÒˆW@R	Hy0îQÏË;R›o˛O_k‡Gô•R¿ij÷L&{»
Ñ”9…ã} bÚ¢i“bµ*7AÙ/:î%öx√Gv·∆	p÷'wö·^ÉB^f\è`Az&Í%Ôl9»1•0_._!;Ê R€>(!JqFG¯QAW6¿eÉÿS
#TÃãBGcË≥ˇ$mpÉÓøÓ¬ï}N€oª™ÿ2Ò.πW≈^f—ÏP«'≈Cîâ€ÍÇCey‚ÿOé√^M¥cØ€ó¿m:uÌ )!6ÀXâ"ŒNÁ`$}A8`µcdw}˚∫™9iæ+{£5√.ÄlSÚ¡‚«`*|c0M¶C;hv•W≤‰>_¸g≈• ê˘mL»(©ŒUƒ›b‹°ÉJ≠É:Ùò∆‹eé‚¡íTFt)†( GuÌrb~`´}dZ…R≤a3˚ê‚gÄˇV≈s›ß|.u¸Ù{¡ç$∆q˚›’p≠ºﬂﬂv∫>–*øUa_]4JÂÂˆc¡∏|Ñ1«B<LúvskRÖ‚	¢ÉÙi ⁄8RCFÓA∂èÀÀ
uG=e	10.e¥‘Dâu›˙úÁ±ˆœC*™‚N,€tÆ+z]?‚0J∂~p–v™Ken◊˛p
ê≈ürÕ'kbäÌî(\•o˚_Â^l9y÷Ÿ„u¿OÄ∑Ijg+x`7ìË1Û)õàó}O_√$≤(O¡æÔÙ∫™töQg¬ Ö¶k¸r∫√òÍE5]Ä Œ3)% æ#6Ui	`]$LD™E6s1*n
yÕb!L)l"Ë˘å–†éü`°I"_ﬁÜ\?‡uì∞x∫>Ø0ÍG<®ajqSTcc t=lÀ3ËWae“B≥$#sì#ˆDﬁ
>À¯Ì:i›£ˇ>˜u∫˛çh¶üg^¸cTà%j6?DPÍ∏>XÒ)π
Úæpºl⁄&00†lbV€¢R‘UMvæ¸€uÊ9:)A⁄ëáW5CS’G¶bÊˆóF˚62Nm˘)AUy{™“+∆(5“≥iß$EÌ·‘g^’q(M1‹ÇôSôh]Ûk“;¬L:°ﬁ2≥d∂jt¿Ú*T:fO”zÑrE”¨gË≈≥èBCƒl|3r()üö)˚gP“_ÿÎ_EGm=Ãk∫…MoÃ_u¶Ó™∏\Q˚KX∂X^hzRzVèGHzK!ŒÃƒe:9%q$πö22åQ€∫æ°g5`®dÙt∫ÛK®ŸJü–ÜQAR¡»‘”#≈c)\è‚;§Û(È™€˛^ÚπåäÚ 'Úg`
‚cEnh=[q!Ì«?∫*Y"˝=§-≠HBºõC˚©˘Ù\…¿®›©ôf9VKËzì¥0∞Ñcv0ıÇ	9ïód¸Ùˆ9CnÇµ;¯}‘9¥uF®f{‹DtµK>±iàµZP JÁy‹‚,dS∫±:ëh–¬ÄZ¨‹d`º≤y∑ ’æx≤¿“É|á°ﬁ*LÏIu…mµÌer¿OR:EME´ÏÏ`ÊS¿÷AÛ208J;&ˇí¬æ>÷uY1:-t"20~5.G˘-·ÏêÆ∫–˛Âp—ßF¬.hn¯—Ó∆pb ~µzyfBC†ÃRàzŸ´∞‡,ƒœÎH'„.mÙiiX§W¡mË¡ı’tV„òø£}ﬁ7kKu9%oevz´r!ÂÛS”Cù]∏πk‚hæ2cS[#0˘IPç4N-¨	«Z«.ñ•`«t=ûn˚a≈∞ÄÌ(Jp‡…K{'>Jø@wˆyßEca›;≈ŸtèT|F$%Ce¬F1(mA◊ÒÁ
Ω|F⁄s»ÔÍ_sV–sÑ.ÏÉ¬Ã¸‘ypaÌ)¶VL≥¶…fÑ{G©Æ-¶#∑ç‡≤ë‡mTqÏµPy^>Ï")Ëπ®˘™îw F
Sc¶d•ü‘i¯G~4&sB!vV}ÙéÍ#1H}ˆ∞Ór!aúã™)A@1vVÍ.4Vcé5∫a“IÿÂQï®MsïW·—ã{ãÚ<¢û!¿ñ	äπîfèoÆ•·∫8mLK¿8Z&ügE∆vH»kDõ6Ê"RxçR⁄C_Ì.Ò;∏ØA\∫ËÇmT∑ !Í¬dù«}˛c∆A~· b$Cø ∏VŒÂ/>qMêdÑ1 )=é9Â¥‘”–_Luá˘HƒP†DÚŸÁw–sˇ«›Wc9∞'D€¨iﬂÕk)‡haıïEßÃ|$Âî‚Óß⁄ LÌ(ÙÁZ{fn¡ÍôÂfX'¢ˇQ‚‹q~|;»/éØò≥MVT˘¨DÖZs4Ôƒ[◊ÉOfˇÑ+ZOiqâ˙Ω%ÚV›‰rÌÙM›QˆWuÆ∫¨Pb;?yﬁ‹- .)êÍ>y.}=XI¨îgöe†¯ Ùy;ÁzÓhhveCÒôÁ≥ZQ@‘4ë≤xŸ˙D6ÀÌuLqgî~cS˛Pº»’f¯CŒ"A/J0 éöv ˙´ﬁÏoÎ?sè·•¸u|Mz~Ó0)†E‘¯åef¬vvhî{IÛtù„ÙppRıﬂÜ'RQ»D ƒ@Q›¸Í¬+ñäññMπkt!ƒ6jasesKZ˘EÉÉzÙ%qQi8]Wjñ˚©q8qÇÁE*bãa
¡∫Ô÷_LEf≠Ìijjm”ÎhQbh%è|v«*“f\„wM1∞0cã,ÎdWéÈOf„ÊZQqƒ\åH∫ö8$a˛ni ¶Œÿ£`•ik-|/ﬂcÚm9¸≈&>WΩ≤°À£É7,¸Nb™´CxxÌ:`Ø\Â°pãH:ÙÆ,‡• ≥lZ’LCMmD[’ˇõE)Úﬂ|ÔŸdog¡ys9¶=[tzª9nÚe{flj«´ÚD∞ΩTQ`}Œ“dmaLD!l(Æ Q»ÇdorÓ4Õ¢cn˛™ì|Il◊l<+è~‰n3˘çqÂıﬁi2Çõ‘
3»öÁ##®¬æ94'¸f:ΩTt·¸∂Q≤–J+:eœd+‹Z›–®z_VÍÏØ-˛˘¥ÛÖ ^§ÓŒ±iÍæø`ÿÇíÊOz´T¢£…í8´h®Îé5õ|T~XE|<§$9/\BJÃ¸ê¨FkÊ¸›^œ±KÈprd≤$≈Ñ[wúÒˇb˚˚EU¬™fnÏpÎ¬Ï†∞ ˙	 ¿[‡ï†ëÔ%ì``•\eÆŸZc#Kl X0í?M◊!c-nL˚zsâZ´,-	¬/%∞kmcßc6òØM`f‚}pg8∫£Z+-≤MwÇ'î˜™wÆMS0óƒº1z[†-3∏9ÔË"£v∞aòvb›¿X®£ÿ!∂ú$≤PﬂKq˙7.vÀzqTr%w0Ã)Ω0∫ypÍÑ=æÈ9Á$3|D√∆°)Æ M„l∆x:Í’uKSùµ“ÃrÏ7aÈ ŒrπÏqu.N·7/x»õÊfWq‡≥7,‚gÿÍF|˘m¢.±ÄªE˛0ﬂ
ZÏ5§t˛Œ1‘∞tM8˛iÍÿâßb˝√äa(‚eıJ~Öí }‰IÛ=ûf#k≥}⁄¨1ª1R!7êB	 "«aŸ7Ÿpbía&®à(–%‰L◊n:‚jˆØ-–ñzrÔÀAMÛ8J™(π÷V/È’,#ºH†pƒ*πd?çfÁ∆D:¬,˙MhLYcqgel(Æf≠V˚r˘GØh¶∏v.-–8P“Àa¿IxeÓß^È~v•Ô˝C«,yp·/ÙD477,¥†Ü¥¢\æ`{Áá~ƒARZì»≈§Ã°—]n¨fÎ◊eÎÚëä
!CdHVr¢wéÉ„'ÊÂ¸WB\&¶o·S¬≥*ƒ´5A≤-J 7ıPc6È≈ub[‚_]È†Ï(r¸≈añAkuí⁄P!R!Ùmˇµ8ÇÓúœŒÒbƒ(ÏS∑Ÿ6-?'ãd›ç==)—}Ê´9•∑ﬂmè-|#-Hı´5‰˘5eNM…)Æ'ﬂƒü¸≠π,%$ã-)∑â3öeœÄ˜=Ì¸Zb®-ÎÍª f.ÔtwHœπ‹„ÓK€‰ÓñyN?â≥G=cm†≠ñb,…gÅ Æ•DA¨3<W≠»%»o8°Ωmì…ym¨?∑å≠Èoe'$vÌ-yñ·' ë©8$ä/+¥V‡Wπ.≠™XOJcÌïI)⁄√ÆS¶›ƒ÷{;’/oêÌ˛…9ﬁnL2±h(>OlcZ„:6•7RΩŒ¶S#A˙|$,4G.v≤O–{ë2õd#<lM‹ﬁaF√\Ñr˘‚"†c™¿á`'.˙˜:‹;«‡¶Œ–f‹evë^≈≈z\ òa ˛Ÿs`bW°b«¨rÄdŸv{{ÊàÂh”Â∂⁄s≤ãÇnêb§
DHc˙ÅáSÚv˝)ÙÈ£mUÌ‹5häúÑXèOjKbv,ÕçB$o$-÷Æ
¶l|#Oë4$tÖATÃùòı“Ô©a^´ ¨ 9!k.`˙04laeÎPjnãfi˝Xa.Á5†L¡∫k¶2€N{÷¢ s_/4kífMwÔ`Ú€ó/HÃ"oFjY¶@`/«"@EÛHÕ%Ë?@7OmÖ»'G-˘i◊£?æf  ÷¸ù≤˙o≠“b=˜y˛’ ç:ùãg†vN/_cVœ÷öj-¯≤Q˛≈ïÇœKOˇ≥ÙU5≥ €®%\bw vŸÕ°a…SÌ#æ,éXÛNz”|tì*]√v§ΩLnrsÂ1¡,q˘>®˙Ì!<Ãñ|L•RG«<H~–œHå9«eÇÃ—?≤E“èÎ∆taƒŸ†>|ÒK`Û≈™OpÍS9ç`´¯°n~aõ†–*ÅÔÌlÉ[∏íÛ+£cÍua{W0∑<Z˛¯]ƒdõ´ÂÔŒy< ˚7Ê˛M{©s/9C3,›{R713¬GŒNm˙j8a‚Ω]o¥>)BÓ—ÑëcpI∫Pgòc<z*y*¶"xKa∂
A{ˆG`Id\ËøQ%Í°…«SJ◊’z
rg]!vÕ=@ë≥—ª='»
œ.wbh©∫$¸ Á .GaÍ
Ä#∑Ö4~zs‘hQµ#ƒQ’Tâe aÇ¸Ù˜„.’¿(IÈ"ÇlÏ·g¬¬:ÈZYOG}∆NJ*%÷ÁˇÈ∞`$C—Ô“L1˚`·µTCZ∫'£SÎiúëäªÎ|M(…≠7l9 ËΩÍl(ˆ%ÚÊ_7(‰…oÍm2“stéÏk=#m§µfS˝0#a‚iq…∆c∆zƒAÔa˙ÜU¨?Â›Êõ√{Â‚p„vcﬂob≈∏⁄*"fê1ëÁ¨™¯∏? f‚2‰!m¯bÍÓ•ÔYÇ`+∆N(æÙ˝a3`@R m·r¡÷ŒjZ#≠AüÜ‘:Œr‡YÃ¡Âx*˝Ë_ÊU1Bß—9v[Òè„cz^¶Ω0ÂçÃΩ?p,âåv…zÁa'ouÕ‚˚)ı(É¢`b,wáˇ#W2Ûì9Fz_öu,‰ﬂe ∞2|ßÛ8	s5•€0¶:°ÆkI∑æA*£@Wü6:¥é%w• 2¥p<mm ÷Á‰é]B ¯Ω[Ì»q˝l5d„‚Ò∂o¸á)uÈáµ#^~∫ı(xËﬁﬁ¢„ç3˜Ï√~D<ì(·4DøU9LÌÛ¸FjÅ•¿v¶¨è´À0m%Ü.∞n§VØ'`ﬁfQ…{`r˝–Úz2≠yIŸ®ct\c”¢£-v0íº`wã°˛ÚAh∞Õ!C˛	0IË`Zµ¶qgΩHÍ¨%;,Ät>DpQ·⁄N£&VLx9;¨ÍgeåÙò	e{éo))Tì¯õ{j˘'mi»Øe»]h3!;ÎÊA…O;wÎ(À±(Q"yßﬂ≠rg2Ûø«2Ù¥®õÖÉ7›÷7 Ü›0¡¨cZ"d∫3ÑMù2£Œ#-+CÏˆΩ w”O≈f!‚Ú+y#ü˘Uo6o†@`‚6•v[e˚s–Áª(ªD!Ü?g1o¯y+@ç„°{od·|å…Û†ﬂç*' IY«∆©ÒP—§uÚbÊ·ëQk À6ü	l È/`Ø™©;í7lUv⁄ „t%¿MΩ”¡ohrS2kcÅn†SÂÁ,n˝Iû.WÚœ‹˜PŸ¶«ëßqstØlÉ ˚ùx%dƒ%q‘Ê:c2gb‘aÁ`µM¬”_Y/ƒa?â9^|ºV{·˙§¯}ñ˘‚\≤-E3˛b´`ÓIjyxJı‘ûRarEÔ!/éì◊¢ ÿSá ’iPN$V|ÒEa¥QùcQ=nÎ£NÇÊà)˚"8ˆﬁ{}Î7·]‘0lQ‡∫œ‡2Ak¶^Bjfó°§ÚE√kf·‡Xl}UìÎ'Dèr∏j›-€VI.¥i¿π:á1NNLv;#v›¿Ì…fctt E•@‘s?Ëƒ“„[™[&Õ+ √M¢l]÷√Lﬁb¯KX$h1\k.√‰ôπ¿ºgY–MãÖT∞‚x˙#àO"…™ÙgXo‘í9¥s–N U≥±Æ^ßÛ™¨xΩı˝îT'rmtı—T5gwÊ,gQ@Ω}˙]<tó{r(n”¡gÓvTÚ?Eˆõ˛>i$˜ª÷àk’js4¨Q84mÏ[0=‹=\4Ôb„ud~GlæPµ2y±¬±A&˝}˜|† ¡˙≤∏K¥#ŒÛÜ<
PŒ5K 92ìRdnıñ!¸^"+4>°–º)j∂ëpTûn≥TGÚ*ÿ∂%}˜„_7·GsyûYﬁ>_∞äN8eªπâb%tYqŒKÿörËÁi'˘®<"◊}wG~}yIÚÕ?.°˜†GÄfËJD|‹a®;$y!
XsF¿l]qË≥(é¥Mµ{ì÷˛D€.°¨ãı+â"o+R[q‚‡æ$´8©¿•g¨›	Á);"*z˝ˇc49(/ér_ñ®fObÏfS—<€dã!c˛$hÖ˚≥?ärÏ<’πz≠›dm^])@Â0.“≥h[!.™1c(14j,®ƒ¬WG<ˇ2CÒi»¨”CÆt®∂Ië=ü"i{ÍÏÕbΩevﬁì.Qˆ®a5PªUf]<Òã\Â;)ªÆ£x’dæ0L,¡⁄?1¡‡+áÛ=>à`Tjƒ∞Äqc¨îPL}≤èÇ¨WA(Ù¶Î≈,,î≠@`•ÙZ#ëk9!&W1[Ó‚}1´¬K‹«ZtAIHtîg»DaSQ~cœpA€Ì§N€h<2lb›Ù:¨tñyen	q±Xf†Á£çDsΩ5ótp∫yVŒyä{Ò¡¯…AƒKº*:paOÁƒÈYlèmV%¿eﬂœÌ5:ÿD^mJsï°Í˝jv≠®8™qôdu.ÎÂgëõÙw)kKÎI≥ã√	ı/+A®‡;*(àèmN”~}® ≥y:x<˛§kÓÂ˛£eåRß#ïÁMCëÈ.Ñymã{ùe¡Ö√n«zlóH<w»¥ff˙Ÿ,jkcëÊf›˛”'˛OÉ2≥à6Ïp√¯¬(cÌI˝LKp>hÓDÁB\–¿ΩS˙\ Û˘'ø/IÁM3ıÑŒ6Vz“¡vg‚ö&•§üÁˇïh∞Ä0¢
"∂ˇmO¿/m&©cm<<ÀΩD∏2ÛJ¨°-fÆvÀ‡I£™”A˝	‹ÏﬂπHX ™c:!ÏZ·`®Å3CÜÌÏjcÀâI/ug»Ô6˙€äQ:Áwè[Ä%uˆ!î-™bAh¬y.Í1ºEaÖ	R@≥ P≈RÁ›Ê≥ŒqˇUu#M¯ÏkÂ«!®’^OBÓv,öËÅî@ÂûRK.Ãj
Œ»!ˆ7Õ0eâB$±QÀﬂv›K
pDÊ4s•‡m/h_s±·3´)Èöm™sWàmLaòu[v‘63¨§≥kQºzKj¸Ãe‚ÊŸ`‚oNoí‹Á0"≈e
qf@4ïI{EÑ≈jÁ ¢πgx^”¡XM.ä®∂g¸w˜GûEí“ˆeSr +∏µÖfÆ/@qZJ§2(¥©’n˜iﬁrè–È≤ìG_&ÅˇBPt`¯Ep‹Ç™πÃuv≠%ŸDÛ¥.yG√Ö¿ÛÙ˝¢Íıúd$ë!Ç¿ÈoD:Ûœ·ë~FÕ)z5{é}mñ-L¯íÄ˙¥ÿ}L6i(r˛°qÜ÷pÑIoh7û≈`≈πd1l(Ë·2˘˙˛0 #Äi∆us≈î#ç∑œöÊ©È•ÍVw∞Ãˆ
%c0£»)˙p≥|z¯(ys‡!Ê¨ tVp$&hEFs>tPÖ$Ôod±ói˘szá!ÿl•/$dÌÿWÕd†5h˜àaÅ=‰t(6¨z#MmíJ¡Õ≥”{ÏÎ6‡«fÈ EÌÄh93w…•∂´˛ ørpö∂oä™∂ÊÛi|:±@+U]%7q¡˚g$%0€n§a0;Rw`3á#ycsYOpu¢Ól)[<,—§«•U~√Fn˘GÔaÓ,p*©‰w!jIne¥øÇFzRsP Jw—Ìzêª9VfI©}çŸ+sù˝1{4ª∂‹%!ΩÊ51≈Y¡pA[¥|Jø|hdi.∫µkÖË2®lÈˆN,„8	2#`±#¯O`sc⁄=VLd∆≤tßjN¶$ï2ë+F¶˛åN…a•`Èex!ÒjtdHf$eΩi>@M<ƒqjdÊ$E·)F‚]EÛqÔw≥-Æπ B$[6Òz|c$li$`"ÕajFPb’]⁄h Op	Áx∂NqD◊zncœwEp@6*i∏‡D≠w¬ìÁI“†Wb§Èsµ—y˜r≠.ëI•taÌh«å&w8l/ah≤wµ7cC'Ùüiü
√ ¥#°q ßI0˛/t{{_uƒ\,O{Ù¬Ê Ú p”¢ip^mÔsÙ7ádB/4N$©•$+q`“ HedoeéropeI'∂^Ï]MÿeM}ˆ>tI:&y6è‹YÛCﬂòwÎD=÷X~Oe÷cdÍ·®>€KÆuóNﬁS¥¥˚„Ú¢FO~ÎTVh>>¨ã∞5˘!ª9iÌÀ
‘& eb˜Ø§√ÂÕòD)Q0∞zZQs47uuæ8nL4>ø"*q9{xìoNx_a√Ûbı<@ÂmNi¡€\‰ì˙f‡∞ıı9¿WOK ËKv$ß∆‚g¡∑ n_k¢,‚u°?)§r_ê¿N9ˇ«QcÙf—f¯u“ÿte©»v¶\;ﬂa]vu≤/1˛*k<˝P¨öƒ°Aû|Üy,íeÁdÖõ#4 a~ùE	4π£Ã¸B…Ab!JM¶;nm]pucriÓm«ˇ}éX,5)Ä)@C	eKú”™Á‹qKW≠=Ãa@*AΩ(#”e2t#3KÌ˘.`m,\OUGBo?~&‘6&»hlW’*Êıé/uF[jŒÔL@ÔÜ§=zZ°"ió…<d÷º.:;~ó%"`uO71í}[e :90A⁄“|djT§$Û}/ŸU^7y~Ì∑:˘˝3#Lt<2˚ı	Á˙&<ºızH‰C®øz&am(Ç< ∫$m<u¬1
˝ w?!ÌqZ@‚HÃQ`GßZË&óPOvRdTˆ-T~^ÂÎuQ≠áD‘≈h+‰2™iüfı 0 Û
~ºNXa®·—'y{æneÑ gô¯et`vdKO<+-(Ê‘`ì4gD∫ÍuE∑(∏ø6ú}:ËA}ÅØjsL[˛™˝e≤? ¥≠:"Vtv'ª*ÍE·‘dÏıs¨–aì0B=À¶ÈÅB˜9∑3/|Í“óÍ±®J¿:v`HeVq*ÂÚßinÛdEzk#a¶Íˇ£$«$usöN'8/.{õ¯{6;ﬁô:#ãecì¿£Gúe`ıox˛€e@T£Ùz=Â∂ﬂ˛£«u-r9Paqg∆D/Su‘x_39Mc&ad–hNæÏ„:è…k*@©Álò Bz,wg˜P§∞È0pÓŸ·•¡Q^Ÿ.qøVú÷7©vQÀ§≤rpt‡1$o¸Ë3!=,)§lt60›˙.Ek⁄!»]˝ﬁvD>˚˘%nT`lÉ¿ìÕ|®c=]jz[l)m¢2˚«	rkg›8£–R:{π∆fjx#∂iq$.TGıxÍ{’˚∏F	äü$<!Æ,l…/aDol–Òò]`{˚Â@XˆüR=5 @qC%ÒT◊î?¢‚≈DS§®mÑ¯lh+)Ñ„∆YÄ«UUSi8}Ràvæ} c·yn≠9ƒ’osÿdmWBlJ®Ê≥jSrhHbåπE<°Ar`p'‰-ur0·Ïπ1)`xµh@ ~õfZ·yjS¥tin’am bi√Ø™{w:}
NıË∆8ÑmòoΩ|¯"?:çÒa`P(u:{ekv˘ÏqAgl2≤ƒ£hËhÃr>FË7 )÷™nÔS!pOÛEÎg'kÉ<&`+%´L.4rg#T(t‡~Ô:e{.27V$Ë¯ ˙ympDTB ™.yo¯H‚9≤0e∏„∑¨i±m2∏4q5DGU˙
∆>7Lçq4g§˙Òtc¸·9pw^)ù≥ q/eP◊4ŸEÇ¶=§’]9Tò«/DÌÁÍ?Öu73—K/ VFs#'§lz w$aù≥i∑tT#iÕ'Ê¡iÈ}q*b∞K!· u
πHÏÌ'5Sﬁ‡ÉH k‘´Á\/ı¨ Ö–_úd0‚¥F`]$˜53—√ã'–Y!∑Ô∑c$$>|ô ø5x©∞ l*•L≤∂j(qÜujÖMa¶GnYGÌÂ8∫Vl'Ëõ†vC·ig…πˆ5AcI»y‰y|∏:rd§c˛NW`° ô9[L¿hB⁄-d[h8
ÑSø`|Çc≤‰`jÒ
7Q07πäL,⁄h√áqÈ÷)2∆L75öızrAv˛îÆhuy  $™ayÏ1%$?~0 r«⁄PÀ;-(3
pdÛ¯st@G*DsOÅ&TY ,gn±ˇ•e∞õéæœÔ}R”}#ª´H6·+Ωva˜eÒ·X√#©cTç˙¬À√eÒ‡[4CVE:zøhîË0:5M !!Ki¢ﬂe‚`eI1a5Cy5%ØÚ+?e¥ks∑5ÅÊE•v∞¡¬≈ab}`0h†E(ˆ8W¢‰2W}F¿ı¢î˘l@â)´ïéU#‹† ≠avî∆Pﬂ!˛‚◊íXft,W†*`TÌ€¬~L£axÀPb!OÎ∏“b®fV∑q›ól&>˛Âw”ù`Ü`˚¸ıtß¥’Cw˚<0"?a_=$Je%ˆsr—ºEwPh=l<‘'ÎR¬íG§+™/ﬂ8RF¶Q4ègkuO=e-:
$¥TJ®ˇﬁ˙‹e◊	ˇGC(®‚NJ-≥l.U+8\?28}ß~r%6™Ca@w#¸`)*Â«rœ'i¢ÀÌDi$o˘=q\|9yÚ…§≥w–[§7cg;ppuìÍ5ìiª	W}OC∞C‰∂(O„∏ÁıÛª0öU?«≠§j¸`ªÇàÇE9} S'-%$n&U©oIpu(HL*èFw!*ù2ioYu©\°<'·Í‡‰Æñt°-¢[æ¬LM1EìÖºy£.4∞ÚÖ•4OÉSsj|0Lk3}A·¬∑&cs2wT^*>Íq:{˝£˝>3=∫æÃhv∂mt¸cháy7T?D‘"§<=le9
˙:(-ÌY.0‚Na[¶X‘
tv˛¸R/gY{	 Ax±'>=Cw—Gª*ÊˆQGõ7b^=mÿk)u™V;f*;∞iÉ,Maspf^Te)më˝Ç∏∫TôlU˜ÈÚ9Ê,®æ±{lGl4tà≤*t+dk«zÑtMQº5'mÂ3ÑCÉ <92 )çÿ ”gE“wIhOEGu<›kpª(]_ÕUÙg∂Ó§}O1{€L§P/j:P;åe^z©˛lÃet±%u%±ü&4éAôz∫âwhËDıvËˆX¯›V‘Ka`CÖhT˘ß≈s+\Ò";$#e‡+€.Œ ^˘éLÚdÚ°e
ÊEnË1[q!~≈	Øò-Yu qp$$-ÿkúøC	hÙ|iNê‹´•g(VK˙j{3¥`∞Ñf0]")>ÂµìtyÙd")C&Çı?uyTº¥5v®6ÚyÃPF%k.±(éÂ€Q.	w{ò}U‚tf[û±:’¢K¨⁄e0øÒ'ê›æx íCx™Ö\
lÌOeT/†Ìm∫‰_^tW;lˇ $S¿÷a˚∫4=J:&œñÍ≤4÷}]1,rgp2~)&Oi≠Ò®êÆ∫i?˙Ìr◊£nÛÖ@n˘ıÏ∆*`Ä~µjt˜/C®KÃRzëÎ$‡Lﬂ%‰HÎ,lva,H%”·o…√µw|î„òÔ9†5u‹2y]|1!.m^x;z!ÂWQQá›]0`Kpi>0g•Scë$˚IR’6
oÃoô◊C.‘!`ïtdô,ªqÕ≤àÏ1 p·iKh{g§Nülg∆yßAo%◊9çŸtﬂTlB5@$√∆3(yŸ≠
=|6Ã!s™≠‚_sV‡”7æÉÚ»T˚!paÔ!"Rp≥∑	G˝sE©™	Æ.µuM®≤ë‰ÃT(5QUVûÏbcË0π°Ò´ñvDÅFjs"?l•ØThËOz0	.S°CavV9ê«j ;L?≈∂:‡Ê#ÂÀ©-p!4V*$4n„å™ƒQ¬QYıU¨"T&D¿+√Ú8¢ô=q	ñöπîvägÆ%aæ4m-o¡ek&ÊQ∆rHRMr6Ê"S¯Müg˛K_Â 4/!Ô(IYõ`¢Ì4≤ !}övâ«_t#dI~·® o $cø §_/NŒ+ud2--á5TÔ∑ƒy|_mvS˛iV&‹Á0W‘Sﬂg…'c9cg2%N€¶®b‘|o/!ËiîµÈŒ-~&ec˛∂⁄2Äm§Vt˜^S\2Ê"oÉÍ8‡f'gÌq™s;>r;:+-/1M	›ls≠ONc2NMk—£O69ˇ?ZOc4	¯ù(⁄VoÊcΩ±Õî9gWu.˙#rPr??{˘X<Ö≤æmz>Yw|-A¥ú—g‡z¬ˆyó)ÁjÓh	7E—Á≥SÄ– .9ºƒ∂Î¸udye¥~wU~)˙¨ÿêe©kË*A_/L5` ˛÷Ï} ;;ÎÛ†¸5d:	¸EÍu) çbTp+ú5&"t6xµyiªdù‚˛`‡ı Ö7U D T›hjÊ+êÇövtnD6Aj§25skz˘Oã¢¯d1y0gnñM{©Qi;Ü’A*d´c~_¡3O÷≈l©o…h8≠”£hyb)ïùZ^¡…´˙g\a}g1∞0G£lggWé,cj‚~Êx0g◊›Iªö4≠a˝nk`ÄNŸ#‚•ag-◊ccÌ)~˛"ºW˝æ≤O∑√7 —.f-*£C∫t\Ù>d-%htâHÙÔm•m±ÓR˝CN)0_’ˇkf>}`ôKˆ]AdÓòd
n#!y{9ˆwgt:ì9f '}n,h”´≤M≤ÚRâ0PA`zÓﬂ`hcxGaÊ)§»Q eM*n4Õ‡c÷*≥tOm‚~,p	è;4Í!π,±ÂÛûirÚ∫–J3Ï˙ÂsÎ“n)01<n:˝t|Ù¸∏∂yû¢–*/#eg+‘Q]fòzwSj≠ª%i˛x¥˙çÃ€¶nöú±ioû≠ƒ¯ÇÇFD{ªTÇß¡Ûx;z®Î*|~ól>$=J,
Õôí≈Gkv=≈W«êI„pZ‰≤Õ$Ou=8˜b6˚Ò¡mE¬äˆnm8k¬¸†∞∞Ërƒ[ l†%Î;%ìO]t@∑\%%Koc#M,¶Y8µ=I›%a	-˚ys®_©d<ŸäÆ-±o-cßcñØMhg†M-W,∫£0o;-¶}ê™+{Æo≥85<ƒº!x+®H3æ1Ôx{†2gtA∞Tjù“π®£’9Úå}-YÔKez∂?^À01÷y-w4¨©-∫phhÖ=>´9Â$£yd€î±)) )£Ï8*Æï5
QùΩÚÌ6!˘ À&πÏeı.*Ò?=xÏæ§n6Q¢≤'Bœ\n6]qGE“HjΩ¢™Dr5ˇ
^⁄4¿$÷Œ1U(r{∏8ibX®ïebı¬yœOm„5ëc>1ÛÙd+=o"{ÛÂI,"∏!˙%62`	0 w·=$€7ŸpYb2!r„Œ.T,eH˜'>bjßØ1»¶“rÌo ]ês0Z™zô˜V7iï-!,A†7≈"v;?õ&g∂u:FÏ˙Uln]√'a7Á.®ˆÌ^˘pÏg-ÒI©p.”æ\3‘· Ixu¶øoËnûmÓ˝C«( `Ò±¸F<w. Ω†¶2r\:ƒ:gÁpu…SVÛ»D$k)Ÿô]o0tŸ◊ıÎ rëS aC(HoF3vÊâÛ&¶5ºVyf#o`V¬Ø3(≈.FÍ5,A±-h  ∑uPg4Ì‘w{‚_eêp>0ﬂ·c˛Ék¸⁄Q*±˛p;∂,ÇËº”ƒ‰bÏweÏs≥˚&_~gãÙœ5|)—‚´;a∑ﬂgØ˝|(a)hˆ°7ƒÒ0ÇeÓ}¡~ÅnÄﬂ¿ïxâx,0pQma”"ñâ2ÿ<fÔ’˜8}<
`¨m„Í; f%5TCIoª‹	Ú£J—Ï∂yF3ËíG=so[‡®0B,Ie†`™Â\AÏ3‘V≠‡$˚cGí|°±mä %YË¨9∑åzajag!$dÌ,y~hg–›yX$äè:*tv·Vy™?¢\mkshïi(_Üo◊ÖWk#’øv¥ø~e;O^Y7ÒËv >OL7˙„rcøw÷Ωœ•#QÚx(îFNv¢fë{±ì+#>gMºP√œvKSva‚"¢e˙˙`""zˆt;Ñ`§)da~õ^Å’zx m∞Ù‡cpow°rCÏp@Ït6{{Qb,bh”Âæ»{‡?m‘"dv/‡(*˙ì∑s‰÷˝à‡·¢mTÌù5h4ÑXN`_|:8ÃBo"!ÓfNÆ~t£K±4§4ÑCMl∏4óÂ“Ôâfñ{^ª $ 9D°k%.bÎ≤0hgwŒRjlãn}˚i.˜1"DQZ„¢sw>+^  ;s6aÉN\gæjq›¥hƒbÎ6f∂@`-°"AÛHå%¸«=D
'~x»3œ%±i]ww˛gJ1¬Vπ6£˝i=∫„E}ÒyyPç	™c∞vow"^ÔGjzn-˙∏It‰âï«*/∑ÉT%5≥a…/hMop ÛI°*Ö”<£æ%llLVÛnzdù√j]C7ßΩHnpÂ1$n{”2¯,∏3ç!(‡ñ?§RG]O8D>“çHç=g$†Ÿ—6¢ ëùÈt5≈i‚urk"SÂûmr¢5ôç©zc"kgmª¨÷*A©ÄYi~+£bÍup˚v≥=ºÚMÙ‡øª§Ì∆q:áˇ2Ê~œm©b'8R?,E{rU/3°GMƒMgÍní%√
<T¥7m¬Ó[Ùâ0ÒfI©ü6g‹+.'z*(z #$™hK97j K™@`MaËW?uE”†ÕÂSf±<v"!6d(
B¡gÛŸ„'»Ø/Utk,∫4ﬁ Òh&@e≥
Ä!∑Ö_4~:baUàaóa‘q”W^-eIAÇ¸ˆ˜„j◊Ÿ M˘ Éa‡Ác¬B<˘IOq}VÜçhv|%ıì„æË0¸AT∞ìl˘p·°áj}∞%£√øiàë
ô‚} Ï∑um±5ËΩjl(˙5iˆ[38`Es˙,sÚsÙIœ#∑#M†º`&Ò03eb<W1à‰QGrrdÓq∫ÜeÇ7˜›ûüÚkˇcxc7dfg ’!“(fT1ôÁ≠€£]x7 f‚≤‰!i¸sËÍ%≠˘É[Fv8uøÚ˝!2I@R.:∞ÚC~N&÷Û¨Aë%¶<:^2`[Œ„gH;ÌÙ^Ê˝1P7P(v:—Ê*4`4π±èdØ?–-ÈÃ`˘Ÿı@#wRwl@{+uà«RXN.áæ'F3ÔíxFöp,‡]E±2^Ás9	#'€6™™ØÛMªe+!”~∂å$fµp+0pO=hep‹«Êé›Eq5[Â5Èpˇ*%d‡¯2o¸)sÀ∂Ω#^4:Ò(zË˙˛¢aç}Ãö~›ì&Â7Iﬁy;ú≥Ù@r•¬s&®äO0l•á&°n•d/`sﬁ"ŸoÙtR=∆Rc6`yQ¡(al˝ g˙Ç°%~`ûºÙpã¢v‡Yb≤m#CÓL0‚`zu$ 52^ºLÍ#9LSRD∫u`˙VØ¬Lrq9¨Ío5Ù∏$	$o!-Ê”Ï;ˇv—'mi`kc…Tl1#1c¡m;:g+!´;(5a@GyßﬂÌwh7ˆøGe4i÷”ÖÉ∑iUy!ß›!Aådz e∫3§$ë?„Œ!-;M‡t˝^'”}≈b1c“+9#ù˚%o6o¢aEÊ?°f-nSËÔπ(´\e u,oÈ}gXª´u++D^ì}åÏ3‡ﬂO{b' i9∆N?©!RÇ"1≤bgÛÅ˙¯˚22ªK-a)/`ˇÂÌ?”wøloÀ°Ò.ΩCqçΩ”≈odPS"~d†9Ag,¨˝Ic»ûw“œ‹w
Uóá1ïq	+pØ|¿ ˚’Ñp'.dƒˇuù`zc2}*a«≤Ã-MV
I'epaó	=^|æbs°z§¸“˘‚]≤5E7ÓjÒbmIj[8ˇ“ûR#`rEz–/Üs˜ˆ ‹Q# ≈)XN6$¨`ÂeµCúsÒleÌ"nÜ¶ )™#<÷Œ{uÀ5kE‘plue‚ºO¡6mc¶^:f§¯≠;√ygad·‡xl{ud†Î#Uù~¥j«-sVJ.tadô9ö/1N^nt;"6›‚ØÈn+µd ëÂ"U3=h÷r¢	™ZgâV¡Ä»†lPí¬åñ"˙iÇX&•`u\k,EÑ∫©·$uY‹M™Öu∫r9˚‹Ba/Ù/ò~’43¯E@5≥ßÊ^óˇ∫¯|≠±>Ñupoue”t#ufˆ=eJ}}˙^8td{v._S8WÈg.>p&9Mvõ˛;at◊yUK¿jS4¯u 5+ºó0=ƒ¥\˚b„V]t_lºZu4dyÄ±K
.]˚ß›§ÄÒˆ∂ÈHÒ>÷„5¬∑Z©y ì≥xnıæ!iXV"0>â±º(h≤P˙ æ.Û\Ûhi~$yw≈Pr7·n[Qö›⁄/Yq(9%∫πÂÍt4YpÊ¬ÿ∑r∏Á9%¯»p>}w\U}	L?;˜ ∆Å~hJP}8›a©:y!+sWÿ$]pÏ≤™ÆtZ±{í÷ÓD^$!$Hã’#'ˇoPSq‚§æ,†©ú3ÖG¨’Ì(;"Z¯vÈ0{(ºr_ñLrFb VS3…<⁄|Í%`Ô$JÖ1≥=
fmºQπz∏≈D'im~])¿t(íhJÈ*ÆJaX(Qp(û®‰uF<ª2OumI-”¡æg©Âiëù¢xS‚Ó›b˝Jﬁ+Q÷Qa4P0Lw.Y<pÉhÁ;-øØ¢xPo≤4Æ,¡Í-5Ái+∫u.(ad&9≈∞¿iB¨N}ØÛ(WAhî‡˚‘l<7Ø@qÖ‰^a.,Qb'u3Ó„yq*¬ ›∆ZeAMh|<&…uW`\P|hÎp6 r›¥⁄_hl≤fÍåÙ:¨pñ|ÌF	a±Xj0ÁeTsquG¥T®-flYé{D1¡\¯…AÑK∏"SpaV_ˇ‰i,Ymèô-wÅk_ˇ‡5fÿDEmZcQa‚˘6c◊,#®|*õ–$9<Î]Âw=TátwihRo`ãƒ-h/<*IÈË?f,:óeGöla ≤}pî|ö‰ÛÌ|˛1∫mÏR•ªô¶OC±Èrày yºuÅ•√&n◊}rñH<Wò∂,∆yy>{kaë§n›˛”Sêø}¯µàvlaáÿ (i¸I:LZ∞}bÓDw»}ÇøSÍú!Ò∏/ø;+IÂœÛÂ|g~{¬ë’vÇz&•§°.îIêÖp·l ∂{iO`+mf†Bm08<íN>-E∏:Û@≠q¥=Û.gÎ¡{ó*Ñ”i{…YÏÕùWP ø":¨º·d0MÅBßoÏ*À+M+tgHª&€ÍÒjfwYeUv!‘<ÆÊ@ Úy,Í3ºaÖb≥»peVÁ¨ƒ'∑d`uTxuuÇmzjÁG3©T\_Bæv¶ﬁË0ï@‚œW $.ÃI»Ÿ+7œpIE©b 5A…VYlP@Ê<°¿b'yo;ëeq´-¢éiös8”çMguKw÷+?&<§≤k.™Ó ™|Æı¨`y@‰ÀNcíˇÂ8ãß
u|Á@6^sE!åÒjÚ¶πrÒèïM<
®≤TeX}f«û≈4–ÔõiS\ºÂ“’V∫F`\“§>q¥ØŸn1yÌ:Ø¿)≤≤IqG–µRRdd8Òdr¸Ü+ª2r5%Ÿ$z5∑0æ˚g√ ƒı‘}£nˆhd%°‚Êe¶D∫sÃπr‘M!~µz.=Ì¥/n≤Ä{¥ÿ_]4lÏrı°q*DpIgkvñE2Ÿ©)dh€c24G˛z$£{ÄMÁ>Öc¥"∑Íº6¬˚È≠Ùfs≠hv  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ConstOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  auto attrName = valueAttrName(odsState.name);
  for (auto attr : attributes) {
    if (attr.first != attrName) continue;
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
    odsState.addTypes({attr.second.getType()});
  }
}

::mlir::LogicalResult ConstOp::verify() {
  if (failed(ConstOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void ConstOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::Conv2DOp definitions
//===----------------------------------------------------------------------===//

Conv2DOpAdaptor::Conv2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

Conv2DOpAdaptor::Conv2DOpAdaptor(Conv2DOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange Conv2DOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> Conv2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Conv2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv2DOpAdaptor::weight() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv2DOpAdaptor::bias() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr Conv2DOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr Conv2DOpAdaptor::pad() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("pad").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr Conv2DOpAdaptor::stride() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("stride").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr Conv2DOpAdaptor::dilation() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilation").cast<::mlir::ArrayAttr>();
  return attr;
}

mlir::tosa::ConvOpQuantizationAttr Conv2DOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::ConvOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult Conv2DOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_pad = odsAttrs.get("pad");
  if (!tblgen_pad) return emitError(loc, "'tosa.conv2d' op ""requires attribute 'pad'");
    if (!((((tblgen_pad.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_pad.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_pad.cast<::mlir::ArrayAttr>().size() == 4)))) return emitError(loc, "'tosa.conv2d' op ""attribute 'pad' failed to satisfy constraint: 64-bit integer array attribute with exactly 4 elements");
  }
  {
  auto tblgen_stride = odsAttrs.get("stride");
  if (!tblgen_stride) return emitError(loc, "'tosa.conv2d' op ""requires attribute 'stride'");
    if (!((((tblgen_stride.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_stride.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_stride.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.conv2d' op ""attribute 'stride' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_dilation = odsAttrs.get("dilation");
  if (!tblgen_dilation) return emitError(loc, "'tosa.conv2d' op ""requires attribute 'dilation'");
    if (!((((tblgen_dilation.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilation.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_dilation.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.conv2d' op ""attribute 'dilation' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::ConvOpQuantizationAttr>()))) return emitError(loc, "'tosa.conv2d' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for Conv type op quantization information.");
  }
  }
  return ::mlir::success();
}

























std::pair<unsigned, unsigned> Conv2DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Conv2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv2DOp::weight() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv2DOp::bias() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange Conv2DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv2DOp::weightMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv2DOp::biasMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Conv2DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Conv2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv2DOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr Conv2DOp::padAttr() {
  return (*this)->getAttr(padAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DOp::pad() {
  auto attr = padAttr();
  return attr;
}

::mlir::ArrayAttr Conv2DOp::strideAttr() {
  return (*this)->getAttr(strideAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DOp::stride() {
  auto attr = strideAttr();
  return attr;
}

::mlir::ArrayAttr Conv2DOp::dilationAttr() {
  return (*this)->getAttr(dilationAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv2DOp::dilation() {
  auto attr = dilationAttr();
  return attr;
}

mlir::tosa::ConvOpQuantizationAttr Conv2DOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr> Conv2DOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr>(attr) : (::llvm::None);
}

void Conv2DOp::padAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(padAttrName(), attr);
}

void Conv2DOp::strideAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(strideAttrName(), attr);
}

void Conv2DOp::dilationAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(dilationAttrName(), attr);
}

void Conv2DOp::quantization_infoAttr(mlir::tosa::ConvOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute Conv2DOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void Conv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value input, Value weight, Value bias, ArrayAttr pad, ArrayAttr stride, ArrayAttr dilation) {
    buildConvOpWithQuantInfo(odsBuilder, odsState, outputType,
                             input, weight, bias,
                             pad, stride, dilation);
  
}

void Conv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value weight, ::mlir::Value bias, ::mlir::ArrayAttr pad, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr dilation, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(weight);
  odsState.addOperands(bias);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(dilationAttrName(odsState.name), dilation);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(output);
}

void Conv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value weight, ::mlir::Value bias, ::mlir::ArrayAttr pad, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr dilation, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(weight);
  odsState.addOperands(bias);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(dilationAttrName(odsState.name), dilation);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv2DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Conv2DOp::verify() {
  if (failed(Conv2DOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return verifyConvOp(*this);
}

void Conv2DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::Conv3DOp definitions
//===----------------------------------------------------------------------===//

Conv3DOpAdaptor::Conv3DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

Conv3DOpAdaptor::Conv3DOpAdaptor(Conv3DOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange Conv3DOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> Conv3DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange Conv3DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv3DOpAdaptor::weight() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv3DOpAdaptor::bias() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr Conv3DOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr Conv3DOpAdaptor::pad() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("pad").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr Conv3DOpAdaptor::stride() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("stride").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr Conv3DOpAdaptor::dilation() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilation").cast<::mlir::ArrayAttr>();
  return attr;
}

mlir::tosa::ConvOpQuantizationAttr Conv3DOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::ConvOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult Conv3DOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_pad = odsAttrs.get("pad");
  if (!tblgen_pad) return emitError(loc, "'tosa.conv3d' op ""requires attribute 'pad'");
    if (!((((tblgen_pad.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_pad.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_pad.cast<::mlir::ArrayAttr>().size() == 6)))) return emitError(loc, "'tosa.conv3d' op ""attribute 'pad' failed to satisfy constraint: 64-bit integer array attribute with exactly 6 elements");
  }
  {
  auto tblgen_stride = odsAttrs.get("stride");
  if (!tblgen_stride) return emitError(loc, "'tosa.conv3d' op ""requires attribute 'stride'");
    if (!((((tblgen_stride.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_stride.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_stride.cast<::mlir::ArrayAttr>().size() == 3)))) return emitError(loc, "'tosa.conv3d' op ""attribute 'stride' failed to satisfy constraint: 64-bit integer array attribute with exactly 3 elements");
  }
  {
  auto tblgen_dilation = odsAttrs.get("dilation");
  if (!tblgen_dilation) return emitError(loc, "'tosa.conv3d' op ""requires attribute 'dilation'");
    if (!((((tblgen_dilation.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilation.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_dilation.cast<::mlir::ArrayAttr>().size() == 3)))) return emitError(loc, "'tosa.conv3d' op ""attribute 'dilation' failed to satisfy constraint: 64-bit integer array attribute with exactly 3 elements");
  }
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::ConvOpQuantizationAttr>()))) return emitError(loc, "'tosa.conv3d' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for Conv type op quantization information.");
  }
  }
  return ::mlir::success();
}

























std::pair<unsigned, unsigned> Conv3DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range Conv3DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value Conv3DOp::weight() {
  return *getODSOperands(1).begin();
}

::mlir::Value Conv3DOp::bias() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange Conv3DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv3DOp::weightMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange Conv3DOp::biasMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> Conv3DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range Conv3DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value Conv3DOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr Conv3DOp::padAttr() {
  return (*this)->getAttr(padAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DOp::pad() {
  auto attr = padAttr();
  return attr;
}

::mlir::ArrayAttr Conv3DOp::strideAttr() {
  return (*this)->getAttr(strideAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DOp::stride() {
  auto attr = strideAttr();
  return attr;
}

::mlir::ArrayAttr Conv3DOp::dilationAttr() {
  return (*this)->getAttr(dilationAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr Conv3DOp::dilation() {
  auto attr = dilationAttr();
  return attr;
}

mlir::tosa::ConvOpQuantizationAttr Conv3DOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr> Conv3DOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr>(attr) : (::llvm::None);
}

void Conv3DOp::padAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(padAttrName(), attr);
}

void Conv3DOp::strideAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(strideAttrName(), attr);
}

void Conv3DOp::dilationAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(dilationAttrName(), attr);
}

void Conv3DOp::quantization_infoAttr(mlir::tosa::ConvOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute Conv3DOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void Conv3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value input, Value weight, Value bias, ArrayAttr pad, ArrayAttr stride, ArrayAttr dilation) {
    buildConvOpWithQuantInfo(odsBuilder, odsState, outputType,
                             input, weight, bias,
                             pad, stride, dilation);
  
}

void Conv3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value weight, ::mlir::Value bias, ::mlir::ArrayAttr pad, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr dilation, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(weight);
  odsState.addOperands(bias);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(dilationAttrName(odsState.name), dilation);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(output);
}

void Conv3DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value weight, ::mlir::Value bias, ::mlir::ArrayAttr pad, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr dilation, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(weight);
  odsState.addOperands(bias);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(dilationAttrName(odsState.name), dilation);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void Conv3DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult Conv3DOp::verify() {
  if (failed(Conv3DOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return verifyConvOp(*this);
}

void Conv3DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::CustomOp definitions
//===----------------------------------------------------------------------===//

CustomOpAdaptor::CustomOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CustomOpAdaptor::CustomOpAdaptor(CustomOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CustomOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CustomOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange CustomOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange CustomOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr CustomOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr CustomOpAdaptor::identifier() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("identifier").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult CustomOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_identifier = odsAttrs.get("identifier");
  if (!tblgen_identifier) return emitError(loc, "'tosa.custom' op ""requires attribute 'identifier'");
    if (!((tblgen_identifier.isa<::mlir::StringAttr>()))) return emitError(loc, "'tosa.custom' op ""attribute 'identifier' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CustomOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range CustomOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range CustomOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange CustomOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CustomOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range CustomOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range CustomOp::outputs() {
  return getODSResults(0);
}

::mlir::StringAttr CustomOp::identifierAttr() {
  return (*this)->getAttr(identifierAttrName()).template cast<::mlir::StringAttr>();
}

::llvm::StringRef CustomOp::identifier() {
  auto attr = identifierAttr();
  return attr.getValue();
}

void CustomOp::identifierAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(identifierAttrName(), attr);
}

void CustomOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::mlir::StringAttr identifier, ::mlir::ValueRange inputs) {
  odsState.addOperands(inputs);
  odsState.addAttribute(identifierAttrName(odsState.name), identifier);
  odsState.addTypes(outputs);
}

void CustomOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange outputs, ::llvm::StringRef identifier, ::mlir::ValueRange inputs) {
  odsState.addOperands(inputs);
  odsState.addAttribute(identifierAttrName(odsState.name), odsBuilder.getStringAttr(identifier));
  odsState.addTypes(outputs);
}

void CustomOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CustomOp::verify() {
  if (failed(CustomOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps10(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps10(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::DepthwiseConv2DOp definitions
//===----------------------------------------------------------------------===//

DepthwiseConv2DOpAdaptor::DepthwiseConv2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DepthwiseConv2DOpAdaptor::DepthwiseConv2DOpAdaptor(DepthwiseConv2DOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DepthwiseConv2DOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DepthwiseConv2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DepthwiseConv2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value DepthwiseConv2DOpAdaptor::weight() {
  return *getODSOperands(1).begin();
}

::mlir::Value DepthwiseConv2DOpAdaptor::bias() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr DepthwiseConv2DOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr DepthwiseConv2DOpAdaptor::pad() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("pad").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2DOpAdaptor::stride() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("stride").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2DOpAdaptor::dilation() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilation").cast<::mlir::ArrayAttr>();
  return attr;
}

mlir::tosa::ConvOpQuantizationAttr DepthwiseConv2DOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::ConvOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult DepthwiseConv2DOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_pad = odsAttrs.get("pad");
  if (!tblgen_pad) return emitError(loc, "'tosa.depthwise_conv2d' op ""requires attribute 'pad'");
    if (!((((tblgen_pad.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_pad.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_pad.cast<::mlir::ArrayAttr>().size() == 4)))) return emitError(loc, "'tosa.depthwise_conv2d' op ""attribute 'pad' failed to satisfy constraint: 64-bit integer array attribute with exactly 4 elements");
  }
  {
  auto tblgen_stride = odsAttrs.get("stride");
  if (!tblgen_stride) return emitError(loc, "'tosa.depthwise_conv2d' op ""requires attribute 'stride'");
    if (!((((tblgen_stride.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_stride.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_stride.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.depthwise_conv2d' op ""attribute 'stride' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_dilation = odsAttrs.get("dilation");
  if (!tblgen_dilation) return emitError(loc, "'tosa.depthwise_conv2d' op ""requires attribute 'dilation'");
    if (!((((tblgen_dilation.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilation.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_dilation.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.depthwise_conv2d' op ""attribute 'dilation' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::ConvOpQuantizationAttr>()))) return emitError(loc, "'tosa.depthwise_conv2d' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for Conv type op quantization information.");
  }
  }
  return ::mlir::success();
}

























std::pair<unsigned, unsigned> DepthwiseConv2DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DepthwiseConv2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value DepthwiseConv2DOp::weight() {
  return *getODSOperands(1).begin();
}

::mlir::Value DepthwiseConv2DOp::bias() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange DepthwiseConv2DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DepthwiseConv2DOp::weightMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DepthwiseConv2DOp::biasMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DepthwiseConv2DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DepthwiseConv2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DepthwiseConv2DOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr DepthwiseConv2DOp::padAttr() {
  return (*this)->getAttr(padAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2DOp::pad() {
  auto attr = padAttr();
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2DOp::strideAttr() {
  return (*this)->getAttr(strideAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2DOp::stride() {
  auto attr = strideAttr();
  return attr;
}

::mlir::ArrayAttr DepthwiseConv2DOp::dilationAttr() {
  return (*this)->getAttr(dilationAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr DepthwiseConv2DOp::dilation() {
  auto attr = dilationAttr();
  return attr;
}

mlir::tosa::ConvOpQuantizationAttr DepthwiseConv2DOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr> DepthwiseConv2DOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr>(attr) : (::llvm::None);
}

void DepthwiseConv2DOp::padAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(padAttrName(), attr);
}

void DepthwiseConv2DOp::strideAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(strideAttrName(), attr);
}

void DepthwiseConv2DOp::dilationAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(dilationAttrName(), attr);
}

void DepthwiseConv2DOp::quantization_infoAttr(mlir::tosa::ConvOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute DepthwiseConv2DOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void DepthwiseConv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value input, Value weight, Value bias, ArrayAttr pad, ArrayAttr stride, ArrayAttr dilation) {
    buildConvOpWithQuantInfo(odsBuilder, odsState, outputType,
                             input, weight, bias,
                             pad, stride, dilation);
  
}

void DepthwiseConv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value weight, ::mlir::Value bias, ::mlir::ArrayAttr pad, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr dilation, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(weight);
  odsState.addOperands(bias);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(dilationAttrName(odsState.name), dilation);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(output);
}

void DepthwiseConv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value weight, ::mlir::Value bias, ::mlir::ArrayAttr pad, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr dilation, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(weight);
  odsState.addOperands(bias);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(dilationAttrName(odsState.name), dilation);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DepthwiseConv2DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DepthwiseConv2DOp::verify() {
  if (failed(DepthwiseConv2DOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return verifyConvOp(*this);
}

void DepthwiseConv2DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::DivOp definitions
//===----------------------------------------------------------------------===//

DivOpAdaptor::DivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DivOpAdaptor::DivOpAdaptor(DivOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DivOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value DivOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr DivOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult DivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> DivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value DivOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DivOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DivOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOp::output() {
  return *getODSResults(0).begin();
}

void DivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void DivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DivOp::verify() {
  if (failed(DivOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps11(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps11(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps11(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void DivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::EqualOp definitions
//===----------------------------------------------------------------------===//

EqualOpAdaptor::EqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

EqualOpAdaptor::EqualOpAdaptor(EqualOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange EqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> EqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange EqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EqualOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value EqualOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr EqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult EqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> EqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range EqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EqualOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value EqualOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange EqualOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange EqualOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> EqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range EqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value EqualOp::output() {
  return *getODSResults(0).begin();
}

void EqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void EqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult EqualOp::verify() {
  if (failed(EqualOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void EqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ExpOp definitions
//===----------------------------------------------------------------------===//

ExpOpAdaptor::ExpOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ExpOpAdaptor::ExpOpAdaptor(ExpOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ExpOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ExpOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ExpOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ExpOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ExpOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ExpOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ExpOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ExpOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ExpOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ExpOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExpOp::output() {
  return *getODSResults(0).begin();
}

void ExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void ExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExpOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes({input1.getType()});

}

void ExpOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ExpOp::verify() {
  if (failed(ExpOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ExpOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::FloorOp definitions
//===----------------------------------------------------------------------===//

FloorOpAdaptor::FloorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FloorOpAdaptor::FloorOpAdaptor(FloorOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FloorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FloorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FloorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr FloorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FloorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> FloorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FloorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FloorOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FloorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FloorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorOp::output() {
  return *getODSResults(0).begin();
}

void FloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void FloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FloorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes({input1.getType()});

}

void FloorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult FloorOp::verify() {
  if (failed(FloorOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void FloorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::FullyConnectedOp definitions
//===----------------------------------------------------------------------===//

FullyConnectedOpAdaptor::FullyConnectedOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FullyConnectedOpAdaptor::FullyConnectedOpAdaptor(FullyConnectedOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FullyConnectedOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FullyConnectedOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FullyConnectedOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FullyConnectedOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value FullyConnectedOpAdaptor::weight() {
  return *getODSOperands(1).begin();
}

::mlir::Value FullyConnectedOpAdaptor::bias() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr FullyConnectedOpAdaptor::getAttributes() {
  return odsAttrs;
}

mlir::tosa::ConvOpQuantizationAttr FullyConnectedOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::ConvOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult FullyConnectedOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::ConvOpQuantizationAttr>()))) return emitError(loc, "'tosa.fully_connected' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for Conv type op quantization information.");
  }
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> FullyConnectedOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FullyConnectedOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FullyConnectedOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value FullyConnectedOp::weight() {
  return *getODSOperands(1).begin();
}

::mlir::Value FullyConnectedOp::bias() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange FullyConnectedOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FullyConnectedOp::weightMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FullyConnectedOp::biasMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FullyConnectedOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FullyConnectedOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FullyConnectedOp::output() {
  return *getODSResults(0).begin();
}

mlir::tosa::ConvOpQuantizationAttr FullyConnectedOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr> FullyConnectedOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr>(attr) : (::llvm::None);
}

void FullyConnectedOp::quantization_infoAttr(mlir::tosa::ConvOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute FullyConnectedOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void FullyConnectedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value input, Value weight, Value bias) {
    buildFCOpWithQuantInfo(odsBuilder, odsState, outputType,
                           input, weight, bias);
  
}

void FullyConnectedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value weight, ::mlir::Value bias, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(weight);
  odsState.addOperands(bias);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(output);
}

void FullyConnectedOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value weight, ::mlir::Value bias, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(weight);
  odsState.addOperands(bias);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FullyConnectedOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FullyConnectedOp::verify() {
  if (failed(FullyConnectedOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps13(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps13(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps13(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return verifyConvOp(*this);
}

void FullyConnectedOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::GatherOp definitions
//===----------------------------------------------------------------------===//

GatherOpAdaptor::GatherOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GatherOpAdaptor::GatherOpAdaptor(GatherOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GatherOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GatherOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GatherOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherOpAdaptor::values() {
  return *getODSOperands(0).begin();
}

::mlir::Value GatherOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GatherOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GatherOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> GatherOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GatherOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherOp::values() {
  return *getODSOperands(0).begin();
}

::mlir::Value GatherOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GatherOp::valuesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GatherOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GatherOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GatherOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GatherOp::output() {
  return *getODSResults(0).begin();
}

void GatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value values, ::mlir::Value indices) {
  odsState.addOperands(values);
  odsState.addOperands(indices);
  odsState.addTypes(output);
}

void GatherOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value values, ::mlir::Value indices) {
  odsState.addOperands(values);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GatherOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GatherOp::verify() {
  if (failed(GatherOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps14(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps15(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps14(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void GatherOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::GreaterEqualOp definitions
//===----------------------------------------------------------------------===//

GreaterEqualOpAdaptor::GreaterEqualOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GreaterEqualOpAdaptor::GreaterEqualOpAdaptor(GreaterEqualOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GreaterEqualOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GreaterEqualOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GreaterEqualOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterEqualOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value GreaterEqualOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GreaterEqualOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GreaterEqualOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> GreaterEqualOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GreaterEqualOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterEqualOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value GreaterEqualOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GreaterEqualOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GreaterEqualOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GreaterEqualOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GreaterEqualOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterEqualOp::output() {
  return *getODSResults(0).begin();
}

void GreaterEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void GreaterEqualOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GreaterEqualOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GreaterEqualOp::verify() {
  if (failed(GreaterEqualOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void GreaterEqualOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::GreaterOp definitions
//===----------------------------------------------------------------------===//

GreaterOpAdaptor::GreaterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GreaterOpAdaptor::GreaterOpAdaptor(GreaterOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GreaterOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GreaterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GreaterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value GreaterOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GreaterOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GreaterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> GreaterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GreaterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value GreaterOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GreaterOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GreaterOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GreaterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GreaterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GreaterOp::output() {
  return *getODSResults(0).begin();
}

void GreaterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void GreaterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GreaterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GreaterOp::verify() {
  if (failed(GreaterOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void GreaterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::IdentityOp definitions
//===----------------------------------------------------------------------===//

IdentityOpAdaptor::IdentityOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

IdentityOpAdaptor::IdentityOpAdaptor(IdentityOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange IdentityOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IdentityOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IdentityOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IdentityOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr IdentityOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IdentityOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> IdentityOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IdentityOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IdentityOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IdentityOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IdentityOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IdentityOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IdentityOp::output() {
  return *getODSResults(0).begin();
}

void IdentityOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void IdentityOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IdentityOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IdentityOp::verify() {
  if (failed(IdentityOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void IdentityOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::IfOp definitions
//===----------------------------------------------------------------------===//

IfOpAdaptor::IfOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

IfOpAdaptor::IfOpAdaptor(IfOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange IfOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IfOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange IfOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IfOpAdaptor::cond() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange IfOpAdaptor::inputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr IfOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange IfOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &IfOpAdaptor::then_branch() {
  return *odsRegions[0];
}

::mlir::Region &IfOpAdaptor::else_branch() {
  return *odsRegions[1];
}

::mlir::LogicalResult IfOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> IfOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range IfOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IfOp::cond() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range IfOp::inputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange IfOp::condMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange IfOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IfOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range IfOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range IfOp::output() {
  return getODSResults(0);
}

::mlir::Region &IfOp::then_branch() {
  return (*this)->getRegion(0);
}

::mlir::Region &IfOp::else_branch() {
  return (*this)->getRegion(1);
}

void IfOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange output, ::mlir::Value cond, ::mlir::ValueRange inputs) {
  odsState.addOperands(cond);
  odsState.addOperands(inputs);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  odsState.addTypes(output);
}

void IfOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult IfOp::verify() {
  if (failed(IfOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps10(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps10(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('then_branch') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(1))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('else_branch') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::LogOp definitions
//===----------------------------------------------------------------------===//

LogOpAdaptor::LogOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

LogOpAdaptor::LogOpAdaptor(LogOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange LogOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr LogOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> LogOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange LogOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogOp::output() {
  return *getODSResults(0).begin();
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes({input1.getType()});

}

void LogOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult LogOp::verify() {
  if (failed(LogOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void LogOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::LogicalAndOp definitions
//===----------------------------------------------------------------------===//

LogicalAndOpAdaptor::LogicalAndOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

LogicalAndOpAdaptor::LogicalAndOpAdaptor(LogicalAndOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange LogicalAndOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogicalAndOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalAndOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalAndOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr LogicalAndOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogicalAndOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> LogicalAndOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalAndOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalAndOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalAndOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LogicalAndOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogicalAndOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalAndOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalAndOp::z() {
  return *getODSResults(0).begin();
}

void LogicalAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(z);
}

void LogicalAndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalAndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalAndOp::verify() {
  if (failed(LogicalAndOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void LogicalAndOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::LogicalLeftShiftOp definitions
//===----------------------------------------------------------------------===//

LogicalLeftShiftOpAdaptor::LogicalLeftShiftOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

LogicalLeftShiftOpAdaptor::LogicalLeftShiftOpAdaptor(LogicalLeftShiftOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange LogicalLeftShiftOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> LogicalLeftShiftOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange LogicalLeftShiftOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalLeftShiftOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalLeftShiftOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr LogicalLeftShiftOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult LogicalLeftShiftOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> LogicalLeftShiftOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalLeftShiftOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalLeftShiftOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalLeftShiftOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalLeftShiftOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LogicalLeftShiftOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogicalLeftShiftOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalLeftShiftOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalLeftShiftOp::output() {
  return *getODSResults(0).begin();
}

void LogicalLeftShiftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void LogicalLeftShiftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalLeftShiftOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalLeftShiftOp::verify() {
  if (failed(LogicalLeftShiftOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void LogicalLeftShiftOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::LogicalNotOp definitions
//===----------------------------------------------------------------------===//

LogicalNotOpAdaptor::LogicalNotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOpera∆GvvÅaRûÁ4ƒD¨—Ù&q`ƒQiGÕÇWnpÕa≥nnYkÒ]M’÷Œq·0£.ø√ _KQ◊PW€FˆUVÂ6-“ND∑¿k©øÂ√Ê¸ñ˛xÌº˚À˙pl/r	T|\i∆qÏºvœ ìjX≠‡‹%°{ﬂá‰·ÒWAœπD8U$Èg˛PZ5=˜TlS	û!F%=v{+0∞S`–L>ÔPu{mˆÛ·˘ºpÌpF—˚}-ªå&Ë∏ÚıKÃÇgÍ »6ce4«F¬JÕì@n~käå¢-˘Â∏ƒ&±∑÷2WÒ9Òˆb¯\{È,`o°Z_ovø◊HtﬁA“<á2ˇ
O%÷‡¸göÌãLÚDèp≤i˙e7|õ'(Ô."ÜTµ4d.Vøã‡ı»bFcƒæpllE[fav∆tœv˜ﬁyGU©¨hoÍgaÃ«Ø˜SJÒètƒb@:a/î*˙PRs‘/>A‰∞√,hkeâ‰dÓugIìls.O‹nËlH_ÿ
á™TfZVJ£Œ7@ÔØ‰fjΩA<óÉo÷h/Z:^ø#`U`A∑[S5]t√O	1¨dŸ“ÀFdKtÖêº8§O˘uT~r~Dø~–s;NLè+tQ’¥AÍÚ≠†zH¢i†∑ZhnQh•pòÌ5’d1K˝|w?qÂx‰R@LƒQbE-ZdÓÿM~ÿlXˆÄŒP¢zÈ¸—~÷‘tj!HyroÓÙy^x+^{¿|<NBc2kS%·yÊJzâ°cmDpU‚¬Õ¨∏°j∆ˆ`™Öƒ(b3ƒ7£`™5a∆sÍ¡|≠byN_r!ı∑W≤%óΩ≠-†
‹tQ7ŸËj›ﬂfÂÎ2…
:lËd¸MY˜;o5˚ â÷Nd9ªô—∞"b ùdRÛê-x°Nd1fFpk!Ïí$Ë›†é¿%ŸkR[≠yçmhj9ô1h'çŒ©õ¬es\¨Í”eru QÔHV+"$˛-‰œm)¡7•€;»kq˛
ƒW-X‰Zq@≥(≈·)aVZkLMwˆ3P~ïÖ B:M‰ ’⁄{∑n<
r¯mA·ñQ∏É«Ñ{¨ST_w¥vËA;√rÚKH"ÂÓEª≠ìr!7NÌØyD1n‘√yS∏PeÓW|À>YbÌ‰ÕÔˆ¡¿ìAÙ∫xºÈ‡Yn´d†9˘m	z2Ã8ÈÎﬁk ∆;1«yb¯Ä>°˚l,V^izÌP±◊˙8Áñåñs&≠wÀÙÀâ[ÚW.z*·JdDPΩ/ yÒD6≥^~,§*‰N˝Q ânôpÌ¬Æ∞Ñ)LÑRƒ_SL¨“âv¸Gñ !Ãc_CO‘≠»UÊ{ÅXÓØŒBmJ‡kë€— Îh…≠Õ6i1XjV‹ÊÛÌ∏√»l"3%æ)ZµnË¶ÍËü)f“lXhÚ%ˆ…å\·mf )jKçbsW|uÜØS{3e5=´ ÔÌ≤Œbïnßs)1^?u$kErXÎ–F# AN:*ÉeªZ˜$T∂l}òé™"«âFï˘˙r≈ZÚŒ´T"cOÙÆÆ¯jlçUg7YÿÄ_‡dE8ej≥Ú,V›@ÿ
ıD‘R©&˝”MRJ≈ﬂ¢°x⁄)âπü{ìÊò8x•Y-ÃGÍTQ,N˘å Ùt,C‡“A|^ëwG:ø£Ë∂C9ƒ¥@e
§=_O:ò|•¯ﬂu*7SNn[HT(†ZN?°ö‰ﬂˆxÊ»ºf ç˘g®£g&w$C†∆!C¸uib^ƒ0*n¨ÇEÌj\ŒZeºq}Òx‚⁄ÚLÔ7^fâezÓ2∆;Í5lÿN≈¨pS"#_K©ê)ÉïÌÊÇSò®2÷◊≤‰∞	g∂>G+≈ÇqÚ)ÓG√H7y” GÁ:#umõ!
≈xi7oIc≥E˝{È+b¬º6>{Í©‚påKE≈◊·ö`~‚∆RO•&ÒŸhî‡üj	’(ÍH,Hàó
¶ †7CÜƒ$!hÁ«a)JM¯∆(µWªM⁄Cﬁfê·¯Ò.ŒåÕÒTq-$ßµà£ˆ&⁄e”OÄ(:ÕdXpõçÕvƒ«+0uÎ%ÂÍLÈåc™ÔÏ+g-Q±˜èsQ{óoﬁìOÎ¸∫e&§v√SvÒ 9	€¸ o£e„˚<ñüéÒN)≤p#i¥/h=≤aÂ(Ì`7µÓz`EoÃÂ‰:aQcd›âg˚VÆ/„¥√s?≠{‚•ùaLe√O…#xròƒeD^SÂƒ>kMŒeçÉÆEI\)€ ™)”'˘p#çÔÁ÷<Ê±3qçã¬8ñ‹aÑ†¯¸E€Ji¡+¨XÕËRÒw Ú˙%äew’QQO‘¶A¸t˚≤Ωaá»GÃıBb}?˛´æ}–K%Èc]®Jı!âjçÀ( úaˇ¥~ld~gwz{j/*?á-ÔCY⁄ÌŒ7|÷ÎKÎß]«¡Õ-à(¨,— ¸—r®+ö• gc∂™~∆µWƒ&p+9pÚ*î]0nTqb™oe,kÅãTa*î(rI€e#Ô≤3Ïm-,◊°V{l|Y5_ci9UdÇ<°Ká<Ï™;&Pêßó?e/a{Ô≤√∞«[ã_ewr¨|Ái),ÚTfSñàŒI)¸ òuâ≈ùÃã" q©ÁCUq2(ID∫çdsaì¢_Çi[gÈU©§'x`MÃZ`‰¡"õ‰EÂ(^≈}ic£e8˛‘ÌÁ[“ÿ{j h0C∫tÂ‘R¬ÆÎ˙ßæk‹SlÍu"∞{*?.Û=ÔæÌ†3:ûmtc	L"wõ∂Dn§D5P[(∏NbwÏΩÌò.<-$N˚ûzn6‘íÒ<fgP:§+YÚÅdISá6="üGÛn≤˜S37÷})LŸhâu)∂è+∆+É^†q¥-†OaÈ∂∞Æ÷‘u-yt∆ö˛®ù;a÷:Ç¿∑©”Ùum√oZp]⁄∂*ôk»Ó
OzÕIé5≈sË,Ø‰	z≈jÉ“èÊ´zwu°A€©&'Ej˛Db:≈g™)›Lk¯vÕY÷Ñ◊xÔ7&ÏÍ ‘Ÿf€Ä§Xáå„vÿ¢üjŒ_O¸g›l‰;0Æπ≠®Æ˛˙öPﬂg˜1àm]¯`wdµ≤ÍZtöíî(……é`êñoÄØ„’r~ky∑§pg&Gk˚å&~lE≤ˆ∏JÎCE*®1yH=!LØAò)ï5™4yi$ú™à⁄€rAuˆZ…T‹fäiV\6«≤;±4~@¿ª∏ı‡{X˘{¸†`9„∆mÛºΩ|p=u«hª≤2äúÕ.rxmŒ·üûîê{µP÷„„,∏ö|;’D ê‰K$⁄e -x"ı#ê€Íq—s¬Gx^MlÜ·WÌvmˆ∏:MœyWùóyi>Ä&ÒD‘‘˘pı˝ä≤•EÕ%Ä∏Ty)(Ò°0∑ÈÓœ>≠„ÎB!,∫Fø~Â:—‰Ó†FnÍª’ÆFa@;¸GxπfA¬ÊI2 Æ∏ôì´%iMRﬂzƒzƒ2·ˆÓÙ„m^dRQmxA‰GR÷#nô3í{E/‹"πà~y‚ot˜z9z†etì±îƒ÷òy¯¶iæ2·i7∞s÷Îñ≈pÓoM`ﬂ0úÄn§Ò∆÷{,gzô~CÒ˘0‚À	€πgÆmﬂÑßÆ˚%’áÎr_πçËıŒîÆa6˜aÑs®pøõlzW cÊjo)_qñ“—ÄÆì|ê–˚i{ÅÒtoA{†ó`ß	Sµ;Dxlœdπ&ˇ¸hs¬2Ã∆R9Bœ‹ç¸‡˚Ë
©xs0áı—ÈWK#ºÁÂN™ÌÈbVò§¬ q‚e·K)·πœ|uÉv"zd2ßúœIÌ`cx∏~Tr)ÑsÀ{˜3é3ZH†soˆ—B“˙É0¯ [|c¬‘fI»*Â§%Ω}2-øJƒ πÅRııb‘•ÍıÇg7 ◊8ÀAMÚWn¬wyÒ≠˘…M{™êëÌˆS‚i˜AN<#¬Él· ±f—$Vø»‡FÆﬁ+l∂‰≠P>m5œq\ÈˇÃŸ˛WH8è‘cﬁHÑ“⁄ˇMsXqïœ‰OADeP!N◊™$H˘»Po“k∑∏ÖŒc^>ÌòÊˆ,ÿr¢Â≠l¸Ô^%\vÚ%a£„ùV´n,ª≈/ÄTk92%ªfÜ—0£E5Ÿf≤≠M£BQvÁKxG°G:%›çUhc)i<£vî88sBÎƒfáˇî7„G=™4ØDYP;Iœr˙àƒÙ)ôo,tv~2eº 1Z–∞ ﬁm!MÕ\ÍdcemˇÛ˚—8}&ê‚b]Ç(+ˇö˙ê{©”ÒBqcæ~Yq∂-˙ñ‹Ö_ÈG÷2X}8vF?ÄJ=~‰≥RÓ}Ë7&C¯ì¸u`'lˇ[ƒ¶Øuæ0¯æB\ä|xB{IØlÑÊˆG⁄i¸«è#*n⁄hn¥O+ÛBÿ‚öÇ§ﬁé2£zLA>§qqqhÒ~Ï⁄˛\%9ë%#uop˛DÛC ôMbj93Y#}¡∫⁄.q¡Xã˝Ôy*ÌÒ}Nf%Ô≠zJ‚=ÁnMs˜{%%‡4%ã∞c?)E`ÇÜ©IDs\–Ro›gÎ)æÇF§[U\'EN¨ÒˆE∆%yw4É|Yˇ·!¸ƒn7êQ€îö‘ˇ98òhb7;à£m¥Ê
?`kÈ8•p H:Ùˆ}Ò‰‰;Ó⁄›jCEOÔ_\€S öıea~]±D2ÏâÈ&Å∞˙s‡_TÊ!¸Z;qLY6Ê4¶hâ¶Õ‘)#Ær‹`MÔy ÁÎ_œ©y∆¶`b@ùR¬Æ≈˛ÊVÃGc9",Â«]µZ∏c˜Ù&UπcìÂKvJ\Äk"Ä ;*  (∂áqd¢~Œ…^áu$–€4oXÖ*dªAn;uˇ‘gzv⁄Æ ª@Éß∫æñÚ-l€hEñó0¬b$I‰wmt∆JYo2 
„TZ»–ŒØ$2‡Q‰ˆ}1⁄SM/<(¿˙Ù#)Å≤´2X;„ÌﬁòlUÆxÄRˇŸ4b'¢…πjoc¸J™‘nÎË1&‰˝¬x)@ì7ƒkNrÇÎ§K±-ÚRÓ’hçaÎ|Ã´≈sñˆ∏˜ÛƒTks/§Ñ”˚Ú-ÔıØßÊMÌ∑(ç-Øi „Æ<Æ‘”ªÁ*UÅ¥’,‚„~*gõÆÎ…£08: éÏx”$eª6&û‰]Î|≥:©Øyˇ⁄fŸïj3.e¯æÈ#$Yzd‘%uπ÷ŸU¶Eºd1¢8R&`í2E∞¡Aoo“n¥°ZıÂa IºQãiÓ¿ˆ(Wÿ`¸d>äŸ)~ŸFÓUÀU≥ıÊl˚Y÷∞û 'p∑zFYl%Ó≥›œò“h
Ç¢ÚÙœJZ7Ï¨ﬁ™9≤∞uÒ›∏mÈ~7‚}_gY+œ˝√ô5SØ>¢Å30≈¢ô«í[omkh∞ûe”ÏI2˛)T Ì‡ü‰Y∑ﬂp9√fa$)ÿD=nP°Âh÷koÆ.◊?mÿ¡FpœW†˘∞gxN~]ôb<P”Èµ(†hê7≈™ô≤;OÜÁ6!Fi‚ÙX™}s„C&E˙à;C©¨P°ÁZπ(bÂvÆ‡dºà2§‰y*’NøÀXwjJ2%^BaÃÂ( ›="%•á2)®` ‡Ú+\*?!˙–˘væ2HÙ“âÙ©r8ö\a˘#±/à†1ö‚¬\ËÁ‚ˆ»Ocpbë|•ˆr¯¶6Oc‚p_gÙ-=ü6xA®Èj 0≥%¥S‘d#ÊˇVOÕ4¥\à≤^=abÅz8N$∏ˆDEpÓ4xÚ^ºceÒ÷lÛ	‹Q¨wù9j«‰pgº˝m—o{◊éES÷#>›|Ãf˘‚≤ˇ∑ 55 ˛©˘BÅ4C∫D?lÌ`ﬂ∞Oq©i◊ÛKÚÈfñ4U´.˜¯°}å^B©3JUDDfL@o…gyyiÇ%jg&k‰RgYzÁ<"ÁEªz[tê¬˝·¿
5±å1Ñã…i†≠ó¨WË•-©wæd=-.©´ì,ù·/%14Ø§F))…f†g>}©¨%ÆÎ∏"∏fmy™≠¢n„Æïi^Ü¨ó§èó-#EˇÜ-ÓÈ9ûZ|w˜Ë"]/H1»fqp∑w¬˝ãÁV#v‹~&~Übu∞L∞~ùª/$(Oúçèƒ;]Ö'?„d§eÍ…á-&.Ï??Ö‡‡Èî ü) ë\çX{†å ≤Óåe eß"á-0ÅÊ~7)JWßåakŒ‰rDSy$›†<‘#|M¿mbq\E—ÊQ∂„∏ãÙËj Øu>¿Rê:ŸI&\^p;è/f,Œmˇn:©ír‚zÇBÜûQøî˙œ‹|Zˇâd!fM9cÇmc+p™¥0-gUèPpjâf`˚/oˆvÄO”ÿ‚"zî+ö`s\I7`‘I}uΩcp›‚M€ ÍmsîaÆWÉ oEÛHåbÔœ?W/&H>áÀvÕy˝zöÇ}BÃwˆ‘€ÙΩhæê·P;|m” å^úã'ˆr_Z&ÏÅúro,º∫I˛·◊"∆MZ{T!àr'3'òj®OS‰Kä ÀÂ*¬óË†ÚAhoŸ Ú
>’|üÉó,[Ôf„˛P(rë(uÊ-yå}º`˛Fã/√—;Km¶≈8:îÆ¬~G`É˚ï{‰!TœÈ¬wÁúÊZ:B‡KbîÉù(p‰e˘»@;æÄ*
om{§¬*Å˝-uÂ[∏∞≈+Ôrcw`ÛFv◊=^™¸ˆ‡-ôÂÔŒsZá≥b‚∞ﬂèrX
pc,€øPwg+-«ÚeLoÍPòÉ/º)røo¬¬Ò∆}U˜BIΩûrc˛*BF¢xM#‚àh95ZOPFNÍ2ŒVøÅÀ†	I·G(ÂÖ'T#/%fı
Zd‚w’˚{;gÃ≠?EIÙÿB‹!ï.R%J‘"¡mldc0∫Iï+ˆC¯≥^Ô¨AˆöVam˜¨ëÒnoôdä·È·#‡-≠,/i!mpı¬Æ
E:CÑÙV≈Ÿ¨t¸B`Q`Xñ:3y6Òa@'◊hlÜ•ïi©˜¬˝Íme
‹} %N±F®ΩÆ*ˆ5@ëI6“-AP=&“'÷¨©,ÏUM÷úvCNÌt3—;!àí%t|rfncπ‡w∞;«Ò⁄†≤o◊shPqrFãgS§ãËKRH¢!‹—:¨ÀÊÕZcDf§∂d!:œ…(§©Ÿ‰°‰Xy ;ˆπG1&ut|≥¶·ÙLHdÚÈsá¥‰/nâàë◊+©ƒ^eÁqtÖÚmr8Áçà0)Pt–üÀÀÕËÌkÚ-˚Ó;ø≥"uòQJóËOÒÃ°§q5oì]àAiUë∆)Rm|Œpa‡+#"∞'D.–U91{ÑÔÒÓ˙¨ˆÛ3ﬂæG+ßt◊∆V_∂ç uµ0;∞p,ceU–Á†ã˝"®ù[Ìip˝
UeEˆ¡∫›ß	!…Ècop∫dbZÀ˙ö¢`Õ|7ˆçC˙D˝v&ÖWEﬁQ;-ú2ÙdzÕ•ß7®  ä`dÑá•>oÂbÁ
`9Í%1…∑>ˆx#‹ê“[súYNÈ®Sp˝T"r¢ M5oP∫ºÙ2è‡√X|ñÃÉ&ŒoTIÎd^ëÊm5Szm©y9((9V<dò1Â¥2√b¶PX?äl‰¸\(é:AK‰÷ŸÔ€\‹T	m‡ÁC©0Ua[⁄ eÈI[Rè!Ó;”lA7|•ˇÈPG◊ü¿6Â¡™Çﬁ•óYU[dáÕ‰Ò¨gü©l∫√œb-mÎë=ﬁ”
¡"e‚“[y5∫˚UÄzSo†aeÁvÑ=˚rı£´l‰t(É^ao•}O∞é±+!V◊\¨Y≤‡›'/InBdA‡ÁkâÑP@óp!≤@ÊìÅ˚ÏEOvœlpç2j@ÇA?‘6ÓL[KzÂÁtÒÖ:à¸ì†ÔJtMZ+˝+Ê6√mç 2&˙3ñãò21”ÁÊeu·D-B]‚e∂˝:à8B&0œÁp›ÇR""ë ó‘·mÁC≤n#{k·Q[áŸY*T·C>Á†ÑalÚ˘‚]¢mE6|jøbÓIAY	∏
˝‘FBG@a }¿%éÜ◊∑» √ ’ÈPs$ ¨≈pïåcï}Á¨¢j§¢å©Ø#9◊jk| 7ÎM‘i,tuÛ¸Â¡2Ik¶d^N~bÜ†•1cYvÈl·•d-q◊´,~hj®(¿P..∞=¿çôö1*÷h3("GŸÛA≠ÈGvµd:∆‡"F3jÏ‘JÑÛKÓXg<Fs≈ÜŸ°lYÚáùæ"xKsÜ‡&5\6`√¿ã˘≈§sYØMŒ¡4˚)ØHBrÿ~‡‚ânë∆ÙeîóVA£‰Óóì∫Æ8y‡æ4¡ :|ƒ%ıµG50wÚ)gaMlø],t6Kv.[oR^7»wÔ'≥;√^˙:¯%«Ï√™—Í&4©U(R%:Ëóq,œÙM?3‚bUtnD(6A2H=°∆tQ7Ì)Û◊›Ûƒ¿ÁUˆΩÛ:œ√Ü*D≈˙Û©,FQí>±Œ@!¯Waej<)E\xhkˆD“U⁄.¶PBÓlÿˆ`l˜«_([j¡T8ôœ{;Ò m%z®|¨a5Y5?√ç”Ggh≤=c¨åmDólsR~XFTM‡Ã9XÊ“`Ü∆#¯%=	ô ¸p}e\g+ÿhM%∏≤∏ûÒtqkµí™D“yÁCòHK’/ô'ﬂ3“[qÚ·x-ˇö™òÖg‰›Mg,vBz|˝È!k(é5îÏ<p»"QV…xUuˇ%`©nhô˜?ÈfÏæı®zË›DX…iX]|¿œ*í·h·pÍKaXlAdöoòQHô‡ˆQFzπc	uÔà≠≈≠dÕÂKƒ >†iÏL',Ev‹ë.w‘tc Q™^ 	1lH>¶ôL°*4ˇ‚°x´{}Zvù8√‹-q÷‡+∏=,Ni"hW≈ÂÜpøëRO9àà¡™AhîÁÌÜ/jñÍ&î˜gÉ/ASUa1,™ø0/®FåûÜhÁC	\tAbHOeEQ;Ehz¯rf Ã±ÿﬁJ|´iÓKÙ>¯~îiÌ}Ov≥JyÁÂ%üUsÏw•„`¨jFYÿ?MsÀZAÂC|m(taUˆNäÎU~Î‹U`Rz›ŸÏ5;‹
J~Z"÷ÁÆ˛4z∆y*)fÀÓ`4<N¯Á"ïﬂ∞u%jY≠k¡Aœßœ¶cCyPØckD/i ⁄mâ|}ÌUˆl7¯~è#ü˛ºy≠nŸP•ôF„cPëXp0’?n;Ø,} •Å∂Enƒ})RérUœ“eƒ‡Ãi=.@6•„v‹Æó^«}IU¢åp˛%ÃÅúNÑ*ã˛G>_<∞><(E5⁄L;À¬ıW˚ú Ò(/øoI#œ1ß·Œ&[zÇë’vÜÓfıÂüÉ_ïY∞ Ë‚\D∂˝I+¿Bi à`M$
`íLZπe¸_óhèx‘yÛnckˆxÖÆÑìI/…πÃﬂ…]jeÓ#:å†!M≈OßuÃ.Î˚›]ocÊõ.úD˚√–nDfw…C¥F%Âd\Í∆¿lAM. ÆUa=cÈ@◊g√¨‰{á‘:@Ë1É˙åÆi’◊1Àî:oæ~é€»eëdé˙W"1NK*ÈµÉ™4≈ÈF`î%Èüf˝ko@uÇp: ∏ht[Â¢Q_À(“ÔiNs8ñúMX"Ñ°IWÄ?YFÂ‚+ b∏ŒäÍÆ∂BÆˆ@¢èoK›QÙ$6µá^YSˆQ4·l1;ƒ`jvò2¸{XPq:ø°],Ã›4WËo«ßÆıÚuﬂU$$+¨≈—ï∫Ç`§k„:{tµ˚gO3k
*©Ñd≤Á_m«‰Ñ3b ƒÒRæÊª›Ω˝eπ,≤(ó˙'ÌC˚µ‡‘·ìÌ‘»/Ta`ÄfÇ©ætˇˆàÖôZ‰bë{>∫1â£8ºÎ∞”¿([ZbL™Bˇ’Ê"@ÒmkC7¬¡÷›Ïx(h€·vz2üép£*ƒKr[Ö7»‰Ge∂Ô¸zÛﬂi…éF"µà≤øeœ0s»QëÁqÛ|ê:xZzS‡g¶§e$W@$ÏhU≥<ˆqπfÖ2œm`Ω›˘√hÑc€Lß$•ΩIQ§°~•ıãS9Ùuº=¨Z+M<öüôÉœÛö˚O+6Ü«L·WÏä|;1yÒ…`∞ÓŒ˝0rˆ§/»éÆo0·Lid∞±@kR[eSÉ;d$¿2ô‚¥p·wF–e`îydwÏU2wÊ^øN.?*µ§AÌªWròVÓÛÓqÏ®ñOPn„Îv·(,¨%º®ÅVó$|NwK! URä¨lí˝ÈB$`£èîOµﬂı']1rÌ±ñCoùÂ3qeŸÜ80t˝{*FIb¯‰/Èg†CÎNn„⁄]'ÛÊ≤"ÿw["byqÎÿ?$L≈ºZßl’0–#áVS‰ÏWåLŒ·á$©z©ıp6vZn&-˝Z|Aoıƒ\hsl $D2)d‚wCE±©a≥iÊ˚“&sˆP{NNe&*M°`Õa∞ŒÁ`µ–la6z9µc’q¥ZH3Dü:ªQ˜K m)†FÌ:Ç[ìeK“dU≥‰ÆP0ìiı£à:@≥Âº·≠,Qƒ$˜XT})–˛≥u#UgﬁÀ#ŸãÉ†¥cK1ÌÈ+0æ[—qk[.ï+f…{qÄ¨0Âí∞ë"i ^É-VotO7∆c"æn5F$¨•¶f"a9`∆jAtWÕ]+xa∂~Ôukq˝M’DöuceÜQ>Æ„1Ô`Q“êWSw<?YRÂb˜Nt∑‡È-æ@¡|ó7ˇ8}¥ÒÀ˙≤d-vÈB|\ ◊;ã∞6˚ì˙zÂ(Ù0°J˜π‰·u'O9E)I Ω;:pq4/∑uh_Is!E-}6O* x$∞b0rLo«p'wkÛÛn˝º¯ÒPC!{|Ì≤¬fË”ˆuM
cbd¿vcttàFeF˝í n}jDéj!ˇ•Z/πiÄ&π?D8GŸ;Ò˛Be^˙ŸtÒ\oÁ€^Á~ü◊HqﬁTñA6}KΩﬁË %8ÕÉ]∂R)x%≤moe'¨#†?"ÜUq$48Sø´pdGyHB$a‰iplm]5h·r	VpmÏ]æ{©π($ hkemïz´ÁmSjøÁ4‰bARA.*¯!V3ê+:”‰≥B.j7dõ$ddurÈE6û‹V/hd	_—%«ÿ.ûqfiJ#Ô7AÂ}&s~º%@<≥Éoﬂ∞s3^∑*&@w%g78Z%õ$<÷Ã)1∏Xh.VÀVLK^emqΩ8§Ò1\"pvƒr}ı:Lá{∂ ”—µ!ÍyΩ∑zIÆiÄ∫ZnHiyaä l5ÚD=H˝x|;aey–@hhÓ[be/Zπpe/ÙM^ÿsTˆ ﬁ1ˆx„Ì’ΩtﬁtTl©N9"k=Êı9¯˝{ÄeºOBbkXe–sÊNrê	„2m∆(uéç–≈º∏•  ÷eêÁF jW≈µ•j∫-v°üq‚¡~)≠rqD"_v3ıìGí'?5°¥J|t ã2ôËhˇ|fÒ´fI*{|»$¯	Se±=u_YRÖr.`Z:Ÿ—π&"†êev±P-x•>d9vfpk!Ï∑$Ë˝®.¬%›uz[≠pï5iqz*0)'ÅÃ™ªde”§‚ıi˙dÄAoHl,er$˛≠7ﬂl	«w≠€u—`aˇ+∆U-Ÿv~p»∑Uc%kW[I\çwÚˆPrïÖ$@+M,)ËŸrµd}:dËmA·∂:eòÜ«Ñy¨R_7¥t»J5#rKh ¶‰e˙¨ªo!7NΩ?9f0(≈5P8gÓSt<["Ì‰ÕÍ˜E‡G®p˝Ü ‡]n®dÈ1®} xcu8ÂÎØ[∆z!u˝b¯Ö>„h¨,VWmzd¨Q≤èF8≈†0Õ„vµlC4ÀWﬁ÷<KÒW∆l
∆H–§$\-Ør˘qA>ªH\§"`K‹1¢™lòp≠jÑ`Ñ©l# z‰{SD|¨∆âvºU´à„`T≠∞¿]Î˘•XÓOBnJa<oÖRQŒÈXÀÆ3iñm±X‡Pv≠qÌ∫	√Ly"s'ø*xÙny¶Í®[<&Ûm[`◊ttÂÃ©-d)z_Cç`sw|uÜØ◊Pb0°Ô¨≤¬&óÓ-Òi9i4$qEp|Z–b£Àcz∫(ìe¸¯Ûf∂`xú.Ó!Ã©bÉyòrõ¿z´æ)‹'·+6ä"â4l. P+7	‹ÑTelLwj3)Ó,F€ÄËÂuPk´*ΩrX…üÇ„Y⁄+ëôü{Êò∏$Â}5DG‡Up"¸å`ˆV,Ci‹A¸^ëP}o∞?Úl≤VY˝ù@m
iáG{Rt|5æÓﬁQ*'s*[X ‡ÿBæ!8§_zxÊÎÏ' À—?g®u&3.C¥«!Cı>i"É[Ù2'#º¢(jœ%∏˘(˘x‚“cïMoUwﬁ6âzÍ>Äª™µ|‹Iırr3M2©a!ïˇ4J¶WY( 4Râö±d0Of≤{”,`s‚=∫G«Œ5uS≠m?!moçQ$
Âpi7oZa±e9hÈ+bëº6,}Ï´¢p¨IÔ’Û°∫	!>Á¬¿O•9Ÿ<(`øb˜)»)(öó..0cD%öh√:{qJI8ˆ8=?7M{B÷dí\åaÌÒ&N¨pÃÙP!-&?&Ω)≥Á2ﬁg=Ä©*Èd\-Ÿﬂ5‰Á+$tª'!™ic™.?Ë9g-›π∑é?k≈íóõmø-¸∫Ò+π4A-fqp∏;)/î!ˇn/+e-‚˚ä˚LI2S#‚Ïh=21M®È34SıÌz`EoÀé,··8qôctÅ,ªjÆs·°√r?5c`%9Bg@K;*lrò∆
g!ƒZW§@>gMÓm-¿¢,I
-Ω!˙9”f©s/~ùÔøUúvµ a¨‚q4\nrWÑ˙svEÔoj¿3.Ï…Í%Yk¬Û˙ 
cnµqU	‘ˆaŒÙ˚±ø ∆ÌEÏıh™t7‚©4å“
A}c9àhıi cÀi |∑;ÜfÑlvnc)j;J_Lï/6+clrÈŒ&Uñ´Î˜w]«ë¡in¨<X–*ÎibËjí]%ÓcSæÎz‘F•U‰&q+<;,ú_
pnV¸g™eWd{£O`*¥82!Za#Ás·a-.◊¢o≈|Zu]bY(;ut”</!#¨|m´3têvWª%5·/Ág√1,lÁDõ[t}3z®r˝„() ÚTF∂®éIq(πw/Öﬂ§4"Œq©gC-(8(@Q™ç6s9ì™Çi[w´ulµ'``kd"ÿ>`Â¡jÛ#‘ul]F8y!&s(˙4>¨Ω.ÁmO˚kDe∞c´t-¬?•Î|á™z_RZÍq22jT+ˇ˛…‰:üi:vc[∂'∫vD8Ó‰3x_)πNzslΩe'4}†LÛ™˚>‘—r7T”¥"]ÚòŒ¡SáMB≈Cªn‡Ô3#‘üeI˝ àYi∑W™∆+ÁL†ytO%Oma9Õ2—‚∆‘5#*8ò∆‹Y¨Y?ió:ÜJ˜©_Ïh√:XrË∂hëeÏÔ#OxOJÕ7·Y⁄o¨2¿JÉ–O§Aª#0£P€86eUZ~Lp8‘Gπ=Ÿy∏wÈUƒÄ!yÓµdÃ"{‘ë6kdYÄ¨„|Ÿ∞õOYbMÌGÓLu0.Ÿ%πñk˛»X˛g˜;Ô‹Ëdsd1`ª}ZtQ⁄º8£…Iå, ≤ó# ∑°TZ:>9i±§hesvVk:9å?lCÁ®*·'+®1Zl=1N/a≤+—9‡54y,$ÀX[Kru`\ŸT¸bππ±N6CˆÒ4t¿D≥¨ˆÅ{xy|4d(y„G}˜ººTa=1∆h◊£>£úÃ$j8e§È≥5Ü1P–CÏ,®:||Ur,ÑK¨qe <"È' ôzxë[Cx~Àliè·u8-6)Ù®@]-Ø˘ø9`>Ä§–@vBqr‰=¸∫$Oœ`<=D˘0),Ú·0'~.Æ:©´
*.∫BΩ~!r◊ÂÓêfjl˝gÆF0h¸fxπbA‚mpdíÎe1\˜]j‡J‘`øjºkmJ&q–myLµB6∑#lswt?‹&˘àp9Ô.d˜:98ctìíå‹x¯"x∂"„t1ÒSˆ˚t]tœnMWÎÄºáo6``∆“˜; Dp˘˛k˘
2sQﬂg™=oÑg∂˚§≈Ökr]πµ»tÓ≠§5'@D3∏xæ∫loWŒ£"Jo)_só–ÿ eÉtêP”k/oÉ·pl¿+% h`5Eï1∆<ÓÆ$ø&ªú"ÚÚvƒÃπ ¬û‹ån‚ÈÈ
ixs:GıYÆ7H1µuß:ÎOm23ŸÓb*yˆ˚M(q·9<D
v*j.∞ÁúEi©A!|ÖÌ?rTÛé©ÑÁ5⁄Ÿw-πZúWOøaBÓ∫´∞∏ [\ab^HË:∂eeÌC24º~jŒ8azuÂÇú¥j}h,nw`S>ÀEŒRgujsxÁ/…Hmy™ë”ÌÛychÙ_%<;Fãx„À±ZO·rCøŒ†VÕÙ#?}	∂fA>-5¶1VÈˇƒ—˛UMvè¬cﬁH†
⁄\”üZq‹Á.CD%ì+fQ™$LŸıy5À”K˜òï¿/|~ÂùÍv¨ 4†$QÌ§$ËÔ]!P\Êa£¢πg·tª«wÖîc;2$ˇf	ÆôtESvx®M#BQ|'K8W2G8˛Ω%xgah=≤Êµ8xF˘ƒbã„ùwko*ê©,kH9IœrZE§G)k)&3o6g¸ +ÚGí‡⁄uı\†`2e$ˇ±Û!4|-êb:ùÄ(+?t˙ÿsÌ”q@ac˛~Yyv/x÷‹ÖOÌW÷2K};pD?Ç=t<fc¬ÊÍ3aßÒ¯7 '(u;‘"K≤770?&l;G:ä|8´:YÏlÄbæB“h}Ôá#/o j#4F+s¬ÿ¬hò&§ûä3°z^P…~§ YqxakÌí}ﬁ%9âg&0Og^ísBYºóM"b%£Iy¡∫X*;¡X	}˜h.Ì·ôO}"-/ù~ra=6ŒMzts|-6®4™1„v)DqÇ.©KH˚LTV'UÓÓ™`øV$S’X&AJj0˜	R•}w6K∏}¯Î!¸∆
1q¯ú˜?•=8˘hj7ê·yµZd√-jwâ/§yh:ÎCmpÂ·;Ó⁄Oj2MÎﬂUıÕñıh1ao]	Ùg2¨D©#…p˙s†w|¥q¯i±NYüÊ4≤cä6ITπ+ˇrïl^ÓqÍej]o©J∆$a!@T∆NΩzÓi‰zZ\9 —bÂ«Xµz˜NC≤¥feic3eûIvRVti3äZ)*c`xæÅp|2~W›^áq>[6oAÉÌ*dπ.~µ˙p:>~ZÓ:»Sá2ûµÚM§·hA0„bu…‰ltŒ
©r )·÷H‹‡ŒØ3qS‘v59«_”/,P(â:ˆ°©Â∞û2 ;gÈê`˜¶o≈X˚Ÿpf3ñ…øk/e}J©∆ÊÎm9&˝Ç89Rä7ƒSˆíÓ∞
%!-eR*’d=qÍ|,´≈£¶4>∑Ú¿TakØ‰§T˙Ú7Ôıß•/OÈ∑?(†%^ßi@cÆrÙÁõÎÁmW=1ÅºÂ,zc]	Vk<ÓÛ…„[0pn*öÊ|” °õ4Ûfﬂd]Ì<'∫
Ø}—˝àÊŸïd”/_˙›i%:Ÿr·T/tµW˘Ua1¸fc1ÚòB7bÓæT∞·ans¡Ó4°zuÂo`IΩY
i^Ï wú8SÏxæD~™I©,°bÎWªÍ2|˚YÚâæÄ0qw:Ωn,:7Í3Mò_L&°E¸µﬂJZpµ‰§ﬂ™4‘‡1ÙıH:™jpà\`˝WGY+NºC=uC->∑AbŒÉ)≤{w,Ii±˛m‡µAó6‚3‘ÁÂõ•yßŸõ¬Fc7)HD,Ï@!ÂhﬂKÜÆ6/=(“vpœ]®˚≤5(Nl\q29V€·ıh®h3°®ªbOFÁ3kFlÍuxæuC„a∑U˙™>g-Nü0Ì‰[afÌB.·p$Ñv5‰p(î Ω	Puf
0%lπbc‹Ej°˝4"©óqh*¿a‚v&H:D?Ec˙≤y7¸7ÿı‚ °ï´k9∫\"È+µ/»6?öÁÖ√T‡v†Vazf’˙Â˛"¯Æ∑OagRg‘,çé
?yA∫ib2 %$QGŸL!¶˚Fol?!¿H≤^1ab‰{8Z6∏ppdp≠5x˜^ stpˆtÛàdSºwÍFÙtgΩˇ}Q*÷[9+G*œ+?›¸Áyh2Áøêu=#°¸°ÈƒÈ6πDwOÈ¯÷4O}))’˚;Í©rö0UÈ6uxÌ}ú^º©?K_T÷lEg3πgm8)Ç?zg.o‰RY:<$ÁX™^_trí“ú5ìÏƒQ1È3àLH‡¨áæTË!-©}Æp=,à3ì(ô·%4Ø&v)¿	r‡g>}m¨vÓÎú#∞V`4y.≠≥|rJ„.I >$˙Æ&ßåe=#◊˙}“øÓ¿9ﬁ\^vu`">)D1Xgp ˜w–=â5ß^ Púv..6b.}y∞tê9ëπ+d"Gúï¡«‰ Iá|øbd‡eˆ–˜$4(9~Sìw‡`»î(Üi2ëlÖ x.r8(æ í¯¯9pu+bè-p·Êﬁ7={Sßı·j”‰ s{µŸ!‘)d5+ÃM:˘\Gp∆Y¶∆πÉÙi¢kUÔu>`ÚÄ˘O'^|p8é&)f(oÆsT80ír‚rF@jíPî3(‹%î<:ˇd^≠f]8C°ma/ ¨‰1meuèj*…nhr.wtëE‡⁄Ê$yî)∏†3\L6qïEeΩcp|“õ#Ó%u-∑anQ! BÚLàrÓ«?F/"`dák3ÌymhS¢yøt@tˆ‘òÙ∞h∫êapzr=˝”ÍÏ~úâ%Ùv)S_b0Ïô4Kh-º≤C>≈W¢CMK˚T±R6±/ôh†m∞KoÜwY[Âj¬◊!¯IhdÌ r[<q|üØ„ MÑs·∂B(s—"u∆}yút}`™Fé#N”;KA¶[m<	8î/oÍp«`Éÿçy◊…ÈÄ7r7ÊX:zÚKbïÅ})pU5H`Ô∫â,*jmõ4“*a¸)3Â[ê!≈e°"ÎwbÛFfU=^2¯/tl/ÂÍLqX•_ ÊêB=Ôr]pwlŸßRgg;-ÁËaÏ/)‚\å#≈§g¥=o‚àÒDﬂs@	ª~l˛+j{X¢ xh#&Ñh8=˙J$:FÔ2ÃS∑È§	Â ÙÖ:u#/!:˝J
 „wUs;7s(Â?DO<ªrX —d>b!π*Ù"ï¡w&n8dcêÆAÙ#ÙQ˘≥Nk-¨AVÙa‰cÆÒ^~∑b¢ Ë˘3‡§Ω,/(!m .‚ÆD8E†Ò^¡À¨|¸@`—hÿ”:3€&Ò$·@–zT˛%Ñ•ïaås*˝˙mMBX8≠5GqfË=4zv5¿i!“ïp–8"Ò'‘¨˘+}uM“åvE>Ìt)+u!– %ˆ:ˆf~s`w∞?Gë +v/«ÚhÅmb"´gDïÓ(P !yu)¨JfÏqDGîdt!*FlZa≠ŸŒ)‰V},|P¸±e-&p4.&£Â|I∏ÛÈ_ˆU‰/~äß_àQ’+©JbƒÔsxÖrG<kè(20)xb“óÔ√i®ÈkÚ„ÓmøøëfUQ8uƒ©oÒÕ°%p<ótöH8Gëñ)@imŒpj∞©*"'u:◊ïq	aSë{|öißsˇ∂E+g”ΩY'$wµ0+≤h>ieTTÁ∫˛`(¯›[Ì≠p}
Fá†—™'‹ß	#Ly#jz∞r X»∞ö†»%>3uâS˛Dmˆ&ç'E˙Q)-¸≥$fseµ$7®àrã0lÖáN’?ÄFÛE`mn s…ß?rXîêÚ[r$xxÈ(N0q+“"¢1/T¢<Ù7√†˜FNÃ”$Ô-xIÈ 6ï&m9SÿmÎfI9 ©r?lx1`øw√cÊL\X{»ËÙ‹L%Så:AOÙTÕ˜È>ÿ-‚ÔB)3	Ueæ a…[)èd.9ëlE7ßı·`C’ã¬2•–®÷Ú°Ö˘v˜dá]•I†g %b‹_Œ"-~:»Ω^r≥"¡jmÊSO89+º˚†)RF+`eÁ6Ñ2{ysî£ö,Ù4 =u!oΩvM¥,Å+!ì\≠»£d\≠7AjBdiA¢ÊK© [Ûä‡2 Êá#¯≠AõwÕlaÃ2hD‰Ü©:ñvlqo˙a¶p±≠ x…ºÅ°Á`p]Y*˝*∆j˝-å:	d,˛Ô9ãò≤(˘∂ÁeÙ˚-R]Aaº}»n «˜p⁄ÇNcëd3–`e¶A∫:#q@°q_óôI2T{C>‰®îÙm8©‚U2}E7˛jø`g	{Y%4Z˝¡G p ˇ–/&◊≤¯f”˝©Pis,>ÏApïºc±=k,¢(†¶´©Øg)FN{}∞7™m‘ehV}∑0ªﬁ·2Ic&@^E~f†%>·y|‡T†§kl91n◊k+l¯xàh»d&4t¿ôÅR•,*LL2* '’9ΩAßÈDvÙv @·&d3j0‘Jû#+&Xf˙v9ÖáŸ9l“áüû`¯s!¢&‡&5q>x·¿©≈Ù3Y≠mœÄ@0‚)Ø;¯fz˛,Íâo±~Ep"îµT[d™∑;;¨yy|‡˚ÏEVL2|ƒuÂóc50wp-wSDç`ØM-thv.hq^·w≠'∑+|ÖŒæ:p%◊~◊Uj&"©u)W%:pï1lÕ‰Mø'`tjF(∂ µ6D=!∆‰*w˝9>≤“≈‡ƒwˆΩ	Èzœ„$D€s>),f;õ,k±Bqp"er¸’|¯hj∂ÃË5⁄.¢TR‚hú˜`(ı”Ò°Ob¡+YHãôœ{˝äN} ∫9‹¨b4[5ﬂ√çqBeË≤=cºh)ñl}rD_Q)mrÃ7XÊï™Çƒ#Ë}9
-¸j=l7÷`C$∏2∏0EÒyìö"d;<ÂS®Xj›-È"ﬂ+ﬁYaÊ¶¯,Û28î!gæ’Á!r*˘ıi'}"Ü!4[_lv`j&"AWIttXsM%pØ&aŸ˜?ôfn∂’,z›DXÄil}|@Ê6.r±`ÂxÍii0lA4ÿmıC.lªd¶qozπ2ÒÓØÖ-≠gÌ%k% û(y.¨Ï%,%s|±8Ï®+`™N--H<.	L!k<ø·!=m∏vΩ=œú-qû‡)%9=,Ïi l]ee1%ØæRn;êÿ˙2k:(Ö˜ÒÇ:M'Î&ıXo&@Uc.LÆßy5¯¬åû∆-ÂC)Y|¡lHmEU=eUxkÿ2.JÃqlﬁ)|)lj™t8¨vy≠}mpªkyÂÂ%/]1l=ÖÁP(jdπIõ/W§ÖÀ⁄a’<m((kDnÊläa_YoK›a@ –z_öË5/ËjpXP◊Ê¢ﬁ$a¬·
¢8Ó∫Ã`54N¯g*|1÷∞u)n[≠i˝Pœ&»¢:+mp/‚jD+kAm©|wÌAv& >x∞ã∑ùn:89•mZP•–Êc+S∏P˘4Û'&zçlY3≈a$lD}/¿éztè“$‰Ûi=.@6ÅbUÙØ◊U√˘Au3¢lpÏ5ÅLé(ªnˇ]¥>,(D≤YX+ÇΩ[z ):/ø3/I£Ì3ß•Œ4_x¿ëıvÇ˛>•ÂóKﬂÅyêÇ˙b|F6˚hgÀKm»bM&+x R-d|_*∑jèzÑ{sûg„gXÖ™ƒ”i+X∏‹ﬂ…_Ch ¶aå“*Ö)1Må≈Swf˝\ÎÔΩIgf¨ò6XiN—nu÷w˚{¥LtÊ!TÍ«¡mcy>J¶u(Ö=„`H˜6«,dk†ÓªL¯2íÍå*kQ◊!…T8W.v∆¬HÏg$¶¯G^jJ|C(Ë8¢©6E©JpÖeÈ:døjn@tÇp:sÒ	t[}≈£^ì-ƒÊi~s8áúe#à°[Wòr]DéÊ¢+kc®ÓÏ{Õ4¬ÌØ
¢nOíw◊t v±~]qÁpt¡|[9D°Jñôì˝rp˝:ø°XU<FﬁÜN4F‡oÔ)>ıñÚ≤Oug d,ıæ˙ä §jb~qt•˚ÂN≥a∫*Ø$ÌªG_«Êçvv!@yRú∂?–˝a}$79ìÍ'ÔGœ5†ìT±kt»+te¿…∆≠˛t˛„à•≥^Ùâzïje:%è∆8<Ê0[‡º~XbLÏ@ﬂ’b¢@Ú%Oi5cÙ›Ì m8`x€˘v‹s¨ıP°+ƒ	Á_≈7»ËGo¶Ôx˙Ûﬂa—d!µä¢Ω'_ £»0	ÚÒ˜Ù“:0{``b„¨ f`fÏhU˜eˆUôÜ$Eof=’q>H°#˙L'è • YQ¡d°Ø˛éB±<dd˚OÑZ´M>\ﬂÉÕÛõ{,Í6¢∆å·WaÔQéP+3{–âÌ¥~√ê˝0r ,gÕé˛ÔAÈLoi0±BkS_eCÀ´dË0©‚§0·SRËc`;≈#qDsÃe≤qÙn?N?,§`ÌΩU~DÆ˚/ÔaÏ®&NADÎ¶wC0¨ƒº©ÄT,jöLwzΩ(
UR[,h⁄∫ÎLc$)£ÅûgµkΩ3_yvÌµ˛GÎπD6çp≈K£80t+ı~*∆I.òµ)µ‰Ád·ÎÙN&e˙O#ÛÍ≤ ⁄u{bqÈ>eHÏ∏:ºnéfê0i)á†¯D˛OÈ√biI~Åpp6Ê~dg)˝Z@Oµ¿hSl'6'¢)`¬PUπSm0°≠Æ˚h“q∞yjF\g&,o§3	 Õa≤zŒQHá∞Ldr©´tÂq9Z3B∂{∞lè˜K tc!ÿËFg;“QdÂ[íu§72v£Qï≥i•ãÌl ≥≈º /,≈‰,˜\tl+
–ˇ¶u#g‹W‹ÜõÄ5iÀ0m˝+pæo∞qªmwÇ*n⁄Z◊Ñbı¢öõ‚a8z%nsigned, unsigned> LogicalXorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range LogicalXorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalXorOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value LogicalXorOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange LogicalXorOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange LogicalXorOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> LogicalXorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range LogicalXorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value LogicalXorOp::z() {
  return *getODSResults(0).begin();
}

void LogicalXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(z);
}

void LogicalXorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void LogicalXorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult LogicalXorOp::verify() {
  if (failed(LogicalXorOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void LogicalXorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::MatMulOp definitions
//===----------------------------------------------------------------------===//

MatMulOpAdaptor::MatMulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatMulOpAdaptor::MatMulOpAdaptor(MatMulOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatMulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatMulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MatMulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatMulOpAdaptor::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatMulOpAdaptor::b() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MatMulOpAdaptor::getAttributes() {
  return odsAttrs;
}

mlir::tosa::MatMulOpQuantizationAttr MatMulOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::MatMulOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::MatMulOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult MatMulOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::MatMulOpQuantizationAttr>()))) return emitError(loc, "'tosa.matmul' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for MatMulOp quantization information.");
  }
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> MatMulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MatMulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatMulOp::a() {
  return *getODSOperands(0).begin();
}

::mlir::Value MatMulOp::b() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MatMulOp::aMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MatMulOp::bMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MatMulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MatMulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MatMulOp::c() {
  return *getODSResults(0).begin();
}

mlir::tosa::MatMulOpQuantizationAttr MatMulOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::MatMulOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::MatMulOpQuantizationAttr> MatMulOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::MatMulOpQuantizationAttr>(attr) : (::llvm::None);
}

void MatMulOp::quantization_infoAttr(mlir::tosa::MatMulOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute MatMulOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void MatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value a, Value b) {
    buildMatMulOpWithQuantInfo(odsBuilder, odsState, outputType,
                               a, b);
  
}

void MatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type c, ::mlir::Value a, ::mlir::Value b, /*optional*/mlir::tosa::MatMulOpQuantizationAttr quantization_info) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(c);
}

void MatMulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, /*optional*/mlir::tosa::MatMulOpQuantizationAttr quantization_info) {
  odsState.addOperands(a);
  odsState.addOperands(b);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MatMulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MatMulOp::verify() {
  if (failed(MatMulOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps16(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps16(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps16(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void MatMulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::MaxPool2dOp definitions
//===----------------------------------------------------------------------===//

MaxPool2dOpAdaptor::MaxPool2dOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MaxPool2dOpAdaptor::MaxPool2dOpAdaptor(MaxPool2dOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MaxPool2dOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MaxPool2dOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaxPool2dOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool2dOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr MaxPool2dOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr MaxPool2dOpAdaptor::kernel() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("kernel").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MaxPool2dOpAdaptor::stride() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("stride").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr MaxPool2dOpAdaptor::pad() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("pad").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult MaxPool2dOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_kernel = odsAttrs.get("kernel");
  if (!tblgen_kernel) return emitError(loc, "'tosa.max_pool2d' op ""requires attribute 'kernel'");
    if (!((((tblgen_kernel.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_kernel.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_kernel.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.max_pool2d' op ""attribute 'kernel' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_stride = odsAttrs.get("stride");
  if (!tblgen_stride) return emitError(loc, "'tosa.max_pool2d' op ""requires attribute 'stride'");
    if (!((((tblgen_stride.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_stride.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_stride.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.max_pool2d' op ""attribute 'stride' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_pad = odsAttrs.get("pad");
  if (!tblgen_pad) return emitError(loc, "'tosa.max_pool2d' op ""requires attribute 'pad'");
    if (!((((tblgen_pad.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_pad.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_pad.cast<::mlir::ArrayAttr>().size() == 4)))) return emitError(loc, "'tosa.max_pool2d' op ""attribute 'pad' failed to satisfy constraint: 64-bit integer array attribute with exactly 4 elements");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> MaxPool2dOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaxPool2dOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool2dOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange MaxPool2dOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaxPool2dOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaxPool2dOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxPool2dOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr MaxPool2dOp::kernelAttr() {
  return (*this)->getAttr(kernelAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPool2dOp::kernel() {
  auto attr = kernelAttr();
  return attr;
}

::mlir::ArrayAttr MaxPool2dOp::strideAttr() {
  return (*this)->getAttr(strideAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPool2dOp::stride() {
  auto attr = strideAttr();
  return attr;
}

::mlir::ArrayAttr MaxPool2dOp::padAttr() {
  return (*this)->getAttr(padAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr MaxPool2dOp::pad() {
  auto attr = padAttr();
  return attr;
}

void MaxPool2dOp::kernelAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(kernelAttrName(), attr);
}

void MaxPool2dOp::strideAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(strideAttrName(), attr);
}

void MaxPool2dOp::padAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(padAttrName(), attr);
}

void MaxPool2dOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr kernel, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr pad) {
  odsState.addOperands(input);
  odsState.addAttribute(kernelAttrName(odsState.name), kernel);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  odsState.addTypes(output);
}

void MaxPool2dOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr kernel, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr pad) {
  odsState.addOperands(input);
  odsState.addAttribute(kernelAttrName(odsState.name), kernel);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(padAttrName(odsState.name), pad);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxPool2dOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaxPool2dOp::verify() {
  if (failed(MaxPool2dOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void MaxPool2dOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::MaximumOp definitions
//===----------------------------------------------------------------------===//

MaximumOpAdaptor::MaximumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MaximumOpAdaptor::MaximumOpAdaptor(MaximumOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MaximumOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MaximumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaximumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaximumOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaximumOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MaximumOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MaximumOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> MaximumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaximumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaximumOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaximumOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MaximumOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MaximumOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaximumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaximumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaximumOp::output() {
  return *getODSResults(0).begin();
}

void MaximumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void MaximumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaximumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaximumOp::verify() {
  if (failed(MaximumOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void MaximumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::MinimumOp definitions
//===----------------------------------------------------------------------===//

MinimumOpAdaptor::MinimumOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MinimumOpAdaptor::MinimumOpAdaptor(MinimumOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MinimumOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MinimumOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MinimumOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinimumOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value MinimumOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MinimumOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MinimumOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> MinimumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MinimumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinimumOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value MinimumOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MinimumOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MinimumOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MinimumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MinimumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinimumOp::output() {
  return *getODSResults(0).begin();
}

void MinimumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void MinimumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MinimumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MinimumOp::verify() {
  if (failed(MinimumOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void MinimumOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::MulOp definitions
//===----------------------------------------------------------------------===//

MulOpAdaptor::MulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MulOpAdaptor::MulOpAdaptor(MulOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MulOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr MulOpAdaptor::shift() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("shift").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult MulOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shift = odsAttrs.get("shift");
  if (!tblgen_shift) return emitError(loc, "'tosa.mul' op ""requires attribute 'shift'");
    if (!(((tblgen_shift.isa<::mlir::IntegerAttr>())) && ((tblgen_shift.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))))) return emitError(loc, "'tosa.mul' op ""attribute 'shift' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> MulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MulOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MulOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr MulOp::shiftAttr() {
  return (*this)->getAttr(shiftAttrName()).template cast<::mlir::IntegerAttr>();
}

uint32_t MulOp::shift() {
  auto attr = shiftAttr();
  return attr.getValue().getZExtValue();
}

void MulOp::shiftAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(shiftAttrName(), attr);
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2, ::mlir::IntegerAttr shift) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addAttribute(shiftAttrName(odsState.name), shift);
  odsState.addTypes(output);
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2, ::mlir::IntegerAttr shift) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addAttribute(shiftAttrName(odsState.name), shift);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2, uint32_t shift) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addAttribute(shiftAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), shift));
  odsState.addTypes(output);
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2, uint32_t shift) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addAttribute(shiftAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), shift));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MulOp::verify() {
  if (failed(MulOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void MulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::NegateOp definitions
//===----------------------------------------------------------------------===//

NegateOpAdaptor::NegateOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

NegateOpAdaptor::NegateOpAdaptor(NegateOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange NegateOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> NegateOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NegateOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NegateOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr NegateOpAdaptor::getAttributes() {
  return odsAttrs;
}

mlir::tosa::UnaryOpQuantizationAttr NegateOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::UnaryOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::UnaryOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult NegateOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::UnaryOpQuantizationAttr>()))) return emitError(loc, "'tosa.negate' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for UnaryOp quantization information.");
  }
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> NegateOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NegateOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NegateOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange NegateOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NegateOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NegateOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NegateOp::output() {
  return *getODSResults(0).begin();
}

mlir::tosa::UnaryOpQuantizationAttr NegateOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::UnaryOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::UnaryOpQuantizationAttr> NegateOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::UnaryOpQuantizationAttr>(attr) : (::llvm::None);
}

void NegateOp::quantization_infoAttr(mlir::tosa::UnaryOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute NegateOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void NegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value input) {
    buildUnaryOpWithQuantInfo(odsBuilder, odsState, outputType, input);
  
}

void NegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, /*optional*/mlir::tosa::UnaryOpQuantizationAttr quantization_info) {
  odsState.addOperands(input1);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(output);
}

void NegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, /*optional*/mlir::tosa::UnaryOpQuantizationAttr quantization_info) {
  odsState.addOperands(input1);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NegateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void NegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input1, /*optional*/mlir::tosa::UnaryOpQuantizationAttr quantization_info) {
  odsState.addOperands(input1);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes({input1.getType()});

}

void NegateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult NegateOp::verify() {
  if (failed(NegateOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void NegateOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::PadOp definitions
//===----------------------------------------------------------------------===//

PadOpAdaptor::PadOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PadOpAdaptor::PadOpAdaptor(PadOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PadOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PadOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PadOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value PadOpAdaptor::padding() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr PadOpAdaptor::getAttributes() {
  return odsAttrs;
}

mlir::tosa::PadOpQuantizationAttr PadOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::PadOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::PadOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult PadOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::PadOpQuantizationAttr>()))) return emitError(loc, "'tosa.pad' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for PadOp quantization information.");
  }
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> PadOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PadOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value PadOp::padding() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange PadOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PadOp::paddingMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PadOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PadOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PadOp::output() {
  return *getODSResults(0).begin();
}

mlir::tosa::PadOpQuantizationAttr PadOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::PadOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::PadOpQuantizationAttr> PadOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::PadOpQuantizationAttr>(attr) : (::llvm::None);
}

void PadOp::quantization_infoAttr(mlir::tosa::PadOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute PadOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void PadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value input, Value paddings) {
    buildPadOpWithQuantInfo(odsBuilder, odsState, outputType,
                            input, paddings);
  
}

void PadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value padding, /*optional*/mlir::tosa::PadOpQuantizationAttr quantization_info) {
  odsState.addOperands(input1);
  odsState.addOperands(padding);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(output);
}

void PadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value padding, /*optional*/mlir::tosa::PadOpQuantizationAttr quantization_info) {
  odsState.addOperands(input1);
  odsState.addOperands(padding);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PadOp::verify() {
  if (failed(PadOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps17(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps7(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void PadOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::PowOp definitions
//===----------------------------------------------------------------------===//

PowOpAdaptor::PowOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PowOpAdaptor::PowOpAdaptor(PowOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PowOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PowOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PowOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value PowOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr PowOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult PowOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> PowOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PowOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value PowOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange PowOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PowOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PowOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PowOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PowOp::z() {
  return *getODSResults(0).begin();
}

void PowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type z, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(z);
}

void PowOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PowOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PowOp::verify() {
  if (failed(PowOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void PowOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ReciprocalOp definitions
//===----------------------------------------------------------------------===//

ReciprocalOpAdaptor::ReciprocalOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReciprocalOpAdaptor::ReciprocalOpAdaptor(ReciprocalOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReciprocalOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReciprocalOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReciprocalOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ReciprocalOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ReciprocalOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ReciprocalOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReciprocalOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReciprocalOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReciprocalOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReciprocalOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReciprocalOp::output() {
  return *getODSResults(0).begin();
}

void ReciprocalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void ReciprocalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReciprocalOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ReciprocalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes({input1.getType()});

}

void ReciprocalOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ReciprocalOp::verify() {
  if (failed(ReciprocalOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ReciprocalOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ReduceAllOp definitions
//===----------------------------------------------------------------------===//

ReduceAllOpAdaptor::ReduceAllOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReduceAllOpAdaptor::ReduceAllOpAdaptor(ReduceAllOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReduceAllOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReduceAllOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReduceAllOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceAllOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ReduceAllOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr ReduceAllOpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult ReduceAllOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (!tblgen_axis) return emitError(loc, "'tosa.reduce_all' op ""requires attribute 'axis'");
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tosa.reduce_all' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ReduceAllOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReduceAllOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceAllOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReduceAllOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReduceAllOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReduceAllOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceAllOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ReduceAllOp::axisAttr() {
  return (*this)->getAttr(axisAttrName()).template cast<::mlir::IntegerAttr>();
}

uint64_t ReduceAllOp::axis() {
  auto attr = axisAttr();
  return attr.getValue().getZExtValue();
}

void ReduceAllOp::axisAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(axisAttrName(), attr);
}

void ReduceAllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  odsState.addTypes(output);
}

void ReduceAllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReduceAllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void ReduceAllOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReduceAllOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReduceAllOp::verify() {
  if (failed(ReduceAllOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ReduceAllOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ReduceAnyOp definitions
//===----------------------------------------------------------------------===//

ReduceAnyOpAdaptor::ReduceAnyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReduceAnyOpAdaptor::ReduceAnyOpAdaptor(ReduceAnyOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReduceAnyOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReduceAnyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReduceAnyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceAnyOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ReduceAnyOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr ReduceAnyOpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult ReduceAnyOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (!tblgen_axis) return emitError(loc, "'tosa.reduce_any' op ""requires attribute 'axis'");
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tosa.reduce_any' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ReduceAnyOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReduceAnyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceAnyOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReduceAnyOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReduceAnyOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReduceAnyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceAnyOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ReduceAnyOp::axisAttr() {
  return (*this)->getAttr(axisAttrName()).template cast<::mlir::IntegerAttr>();
}

uint64_t ReduceAnyOp::axis() {
  auto attr = axisAttr();
  return attr.getValue().getZExtValue();
}

void ReduceAnyOp::axisAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(axisAttrName(), attr);
}

void ReduceAnyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  odsState.addTypes(output);
}

void ReduceAnyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReduceAnyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void ReduceAnyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReduceAnyOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReduceAnyOp::verify() {
  if (failed(ReduceAnyOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ReduceAnyOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ReduceMaxOp definitions
//===----------------------------------------------------------------------===//

ReduceMaxOpAdaptor::ReduceMaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReduceMaxOpAdaptor::ReduceMaxOpAdaptor(ReduceMaxOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReduceMaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReduceMaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReduceMaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceMaxOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ReduceMaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr ReduceMaxOpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult ReduceMaxOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (!tblgen_axis) return emitError(loc, "'tosa.reduce_max' op ""requires attribute 'axis'");
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tosa.reduce_max' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ReduceMaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReduceMaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceMaxOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReduceMaxOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReduceMaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReduceMaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceMaxOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ReduceMaxOp::axisAttr() {
  return (*this)->getAttr(axisAttrName()).template cast<::mlir::IntegerAttr>();
}

uint64_t ReduceMaxOp::axis() {
  auto attr = axisAttr();
  return attr.getValue().getZExtValue();
}

void ReduceMaxOp::axisAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(axisAttrName(), attr);
}

void ReduceMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  odsState.addTypes(output);
}

void ReduceMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReduceMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void ReduceMaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReduceMaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReduceMaxOp::verify() {
  if (failed(ReduceMaxOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ReduceMaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ReduceMinOp definitions
//===----------------------------------------------------------------------===//

ReduceMinOpAdaptor::ReduceMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReduceMinOpAdaptor::ReduceMinOpAdaptor(ReduceMinOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReduceMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReduceMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReduceMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceMinOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ReduceMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr ReduceMinOpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult ReduceMinOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (!tblgen_axis) return emitError(loc, "'tosa.reduce_min' op ""requires attribute 'axis'");
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tosa.reduce_min' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ReduceMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReduceMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceMinOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReduceMinOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReduceMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReduceMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceMinOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ReduceMinOp::axisAttr() {
  return (*this)->getAttr(axisAttrName()).template cast<::mlir::IntegerAttr>();
}

uint64_t ReduceMinOp::axis() {
  auto attr = axisAttr();
  return attr.getValue().getZExtValue();
}

void ReduceMinOp::axisAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(axisAttrName(), attr);
}

void ReduceMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  odsState.addTypes(output);
}

void`1h˝}w)a·yÿ@JÍU`E-JõmÓÿM~ÿhV˜ﬁÁxÈ,≈≠\^‘\ndM:$i˛Â9kxæ{@}ºIFc6kZ%·~ÊJzô„ubm∆pe¶å«Ôº∏•:ƒÙpRR≈ƒ#b3‘7ÉhÓ5yòS™¿>Ï{yNWraıóGÅ ◊t¨¥J‹tU;2ËkıˇfÒ´&5»
;RhH†¯O≤π-5Ÿ “.dæŸQÙbc‡òaVaƒ9y¥d1dFp{!ÏÇ$MÆ˝†Æ¿d]Tz[‰`ÖAYi1jzE9âm+â∆)€“	e’$Î}eÚt QÔHS+5r ˛a∞we	’o°Î3Uoq˛‘EmÌ{pl≥(¡-Ò%iWZJ 2Ú@rîß`@:M‰K xﬂYÁn (s¯us°íQàÇBGƒ˝Ëpc¥fDQ9£ÚÚSH f1lQÇªÔµ{!?NªÆoA0.EÉeV¢DGÓSl>:su‰ÕÓ≤Å¿√GÙê™0ΩBËqYn™d‡1Ëm	r‡eŸ<¨Îé ∆{!÷}b¯«r·˚•,,VV{~≈¶Q2óŒlGíàw∆g"±2k¥…V˛÷çkÛWŒb:ÁH Z}ÔÀ˘Ò6q^]\§*`N˝T¶à~ô.pº‚Ùƒ®HYÄX≈[Sd¨”ôv∏XWñ °å·#KtÏ0ƒ]ÁÒÅÿ™èœBh‡[{Öë–"À„H√Ó…¬(5XÍR›ÊeÛe8M√LËe'%ø¢Zµf¸Ê™èl+∆mK{hRu»å]hmdqk_KM#V|uñøï_S‡}© Ìº≤⁄f≈nØl)X7tD˚`f~ﬂB£ÀCJ9:ìÉa∫öÛfDÚypòÆÓ"C©Fó˘ÿs3Ä_Ûºª‹'#ûÓäôk, àCgu	|B‡lAòejL£Ï,BÿÄ¸
ÂDƒR™wΩ”RZ¡ü†°X⁄+›Òﬂ{óÊ∏∫,ÜY=úO®qP OÏçR¥U|C‡^A‰RQT}V®ø≤Ë∂G[’@i
E9è_{R–m•æœTu*"S,[X §ŸN>°÷§ÌˆxÊ»∏6$ç8g(£wf7.R0√)ı1Hb°J“P/+¸¬&πl\œZ%º˘|‰Rx„ÍÚ’MØ7ö'àUZ¸2∆„Í5,‹J’¨rC3uo ©—aÉD‘Ô¶Jñ«ù∏v√√≥‰†d≤jW.–ÜW‚}ÓG√Ãgu◊%VÙ#usâp$
≈`i7oQcµEπz)+c◊lv.{nÎ"TÃIÁ◊s†`6‚†ÚO• ÒÒaî‡üb◊(ÏHí…ì&@∞7+Éƒ$öhÅóciB	2«(ÒwÍM⁄jFFb‡Ì&œÏMıQ,4¶±®3‡"⁄g”Ä).…dLt¸ç˚6≈W+pd˚%a˛\˘åc™Æ˚Í;'-P¥ué"SIó≈”˜√I_´º∫¡sπvAVfÒtÙ;€ó˛€/ÁeUrÛó%ä˚^M"S"Íƒi=≥4m,¨17Sµ-:"EgÿâåÂı) ësvù‡d;VÆ?Ò∞Crs˝k‚†¸GÂŒJŸ)}rÿÑ
nÃJ,R"¿~{ÌŒeòCÇ!AIL@)ï!⁄=”&â¯/≠Ø7¬ºˆ53aÕ+{ñÕŒp∆Ñ‡c¸D€t^j¿r‰M®D—r ÚÚ4ä#rq@4TÚa‹t˚3Ì`Ü…WÓÂP=®m7Ó+∂åù*Èb<ä
µ-ânù€i çµˇÑ~Ñh4~csÊ;xkz_5-ÎB˚©Ã&W∆+À˙ßT«8…)H(¨<P– ˘ôbxköm%Õc#6™xÇ∆ÂWƒ$q/8Ú„.î[^R0nTıbkc`}ê≤Db.e3I⁄`#g≥2Ì(l<8«Úw?U|X5]s€ ;UÙÅ=1_#ó}¸Æ;P‹'’ø%~·kÁ≤‡≤oL∆Oõw3S¨˝f(-<ÚPfñâI˘ òwã°\¨é" q,ˇS-t2(HE1å6r1”¢†iâ[®’©=&ip%XlGÕ:`Â·*◊_{‘m_≈(i/¶sx˙8˝ùOÈŸÿÈ*D|†CÎtÏ¡Ç∆?Æh˙Ö™z‹jÍ}0Ç{t#ww)z˛…§2+Æmrkq47∂LÏ§∂5D[(Ωf2;‰ΩÌ∫.%=5N{é[.F‹—vvPŸ‰mYbÅGYSÖ-Bü EÛj‚˜?"3˚∆ßihÿ)àQ)3è2◊+ÉL†{∞OÒO{ 	Ì£A˛V‘5( ô«öﬁ¯Ÿ3aß:C¿ﬂ§ﬂÙwlco^t_⁄≤*ô-¿.
OrÕhÜ:‘¸Ø™:– «‘è§X±:$°@◊©&bUZæ b¡G©<ï jôg©]ﬁh∆x˛∑nlBÈ0dŸ&€≈‰}ãúÁ~»≤ﬂFœk‚OÏG…tÂ0-˘uºÍÓ Pﬂg˜s…èŸÍq8eÒrãRpAû8ïéÉÈ…ÇL ïó/¿ˇ°’±>;iß‡ivCvFk©çnÏAÁ©
cF@+†1* ±A1]ØAò;ï9´04ymaôKÿ€Àzu≤t…ÑPÿ"πã±Vng¡Ú·4l –∫∏‰Oä{HyÏ1†v i„«lÁ¨∞Lq|uÀhW∑:ã<Ãdhymä‡èuöûÅ}µ‘„˜,Ëûl’E“Kº⁄%1,"q/ê˙i—WíSxãLmÂVM§6iˆ∫e\) xÃÉh},ÄÊ— îVirıÂä:•}Ÿ Ä<πDzÅ ),≤Â¥£~π>œz≠Û™0 .˙Jøv†v’ÂÓ∞BOÓ¯’.Fp@Ï~xπbCÉ‚KnP ¯ôìÍt5EﬂﬂËdR’·ˇÓ4ÁmK43mmE2<ñ'
n3?‹ πà>x„{t˝~0zpe~ìUî¨ì;òpË"`º2„1qWˆÎíYuxÔfM?üÄ¸mo°‡Çñ°
:®"2ô˚FÒ…0rãâ®g˛üŸÑÁ2ªß’gÔq[8åhÙÓîi&2C∑Cƒ£Ëp∫€l.WŒ£‚J/©_w«∆’¿ˇ√|í–”kÖ{É‡po‡+§Hó`∑Gî;∆xÓè4Ωf˛~z˙¬vÃfR9¿ü⁄ù¸ÈËk˘`r0áuQúJ#·ˆØ™·kgìò˙√k p∂…tO)aÈç-D¬vr:tßﬁÀiÏ#lÖË7~T≤Ü†ÑS I˜éªJú§_NW—`√˚Ç∞® [a¿îVHÃjıs`Ìe6-^j∆∞ÅS±tµÉï¥ `gv`¡9√D„‡t¬sy„Ω »Ôoøë”≠ˆQ„hÁ[,'ÊÉxÂ…±JÌ$#ø†VÔé'm¥•->-5è!MÈøÖ—ˇM`î#ﬂHÑ(¬Lˇw›a•œg3Dï+”™≠HZòq	˚¬ÛWŒ'\:Â‹Óˆ® u‚D·¨(¸o^+\Ê5eßÊôW·n9≈oÄîk=3-πÔ¨°ô4øE-…?˚(m#BmßÁ8ó•+›Ω-g%--£fï8)vGkÑfóãÔ7£G}™ë´H;1I≈sÍåÜÑ,âÎ,4st~S2fºê%¿WÒ‡⁄oÂ…YÍa/em≥Ûxx-êB2›±;ˇ ˆò:Èa·@qsæ|Yyˆ-˙ñ‹°NÌG‘sMl1v{FÑ‚-l~Ê≥“ÓwË;'§˘¸?`g	Ô+ƒ¶˝æ$¯˛#ä|l®{]øl≈dˆL⁄h˝Îœ#nk h*Nk„¬‹“à∆‰ﬁ™3©:zZÏz•1]`z∞s≠ñ˛ﬂdqÅ%b3	kíÊCôZ◊d'z)"IDx¡˙∞⁄*n≈Yã›ÔJnoÒN{r$Ø~R„5ßJmRˆ{-4®4ã$∞„?)Eq«å©zE˚\÷L/›Ô´*Et^¶§[÷Xfo®∞ˇ≠¿•}wO0É∏]x·!Ùƒ>!àu⁄åäWø•]~…hr';Å¢hÙFÁ√>d;ÌπÏp L/ÙÌJmÒÂÂ{˛JôjCm™ﬂX˚3Œ∑ıIQÒ~ﬁEÙU2ÏCLè!¡hwP\˜p¸9±LQE1ˆ4¶kâ¶Õî9#6rº`[™9»ÔÍA °lD§a"@úT”Œ≈ÍÓÕdsx9"ì}UÂ˜\µZˇÛ∂&EπcìeOvZwêiså⁄9J ey6√ptßxﬂÕ^’uN‘⁄0gYáÖ(pπE.~5Ô‘w>v⁄æø¿Ü∫óÚ,¨⁄ja◊ñ4√ 9Ã‰&h|∆
)2rJyÁRNò–ŒØ¨3‘ı=9_À€⁄/lP(®∫ˆ£©Ö0€3;„iéîm’Æg¿ZÔŸtf'ñ›ˇj.sˇNk‘∆„Ô1f‡È¢<90ì7ƒ[nÜdÍ‡K%µ9ÊR˙’dçsÎ}´≈Ç∆w∏G„¿Uak¢¢÷˙Û7Ôt´&„oÏì?(çeßm@„Æ=QÆÏÜÔgMWÅ•‘d‚g]üv.:õÓ˚ËÁ0x?ûdx√`°õ&ÉgﬁO†I´,£ÚÕø—ˇ´Êı6ÍÛ+W˙ØÌ(4Y:"‘$dº”—‚D5ºfqÚ‹R7&‚ñ<E0≈GoÛ÷b¥cZÙ§c HºIèy^ËÄDÛD,S¯xΩd:
ô¨ FÍEŒw≥»¢}˚M÷	üÅ"Q∑
*ôll}Ó≤ﬂœz”mÉ´EÁµﬁJ{^ï‡‰ﬁb9‘t±p‹∏zËeX®„~_ X)œº√˝0C≠>Gˆ¡gP≈√ù~«í[t-oh±ûe“°	2Ú)Ç ˛·õ§{¶€©„fad)»H,¸P°•x◊I«Óñ/}»÷RrŒG†¸‰7(
nLù9V“iµi±aò#Ä∫õ¢E÷Á2 f(ÍÂ‹Ó}S{ ∑E à>V≠OûPπ„[˘EgÂbÆ·tº 2•‰yi‘jÔXvn7!^C"‹≈h·Ÿ0"%•ü3h®– ‚ˆ$,{D;Gc⁄∞˘%æ7ò‰¿JàıÈl9JX"˘#±&»æ1Æ¢Ö√TÈÙF£˜“OorbÅ¸!v6˘¶∂y≤“gımMû7yA≤Èj!∑5¥r6Yde¢˚VC›m¿»∞^q`b¡{8K©rLtØ5rˆ\∏sd‰“t≥òÿ{ºwü9Ë«‰~"π˝ë%;V_éERO25›8òÂ∏®≤øßê5ı ˛kÈ‰Åv[ªg?lÌ¯X‘ÙOa+9Ò„3‚˘bötU+tˆz£¸¨ZB©8
_E÷wòQoT…e=i"%xg/k`RY8˜*"fI™^_tH”îΩì‰‡JQ0aå7Äs…h‡¨ó<VË)©u˛p=**òª(©·
 tß‰F-l…`‡c>µπ¶5ÏÔ0f∞WËW˝Í‡¢zFJ„Æë,
ﬁÜzó&ﬂ◊=#Uˇw÷ø˛â9ﬁ^P"ıË}rQzaM1ÿgp`wkB˝á£W#x›{&"ñBu∞êjê3*l Nç¡ŒVYá6/sdd ˙@«a2:¯˛±oÂp‡»îpû!0ë\ÖÄXz\†û ¢Óÿape2£b√ÂP¢ﬁ7=zSßÃdz◊‰· √y¥›∂),'‰S=¿I"ıXGêåQc˜˝äÏÈbkUÔ<5.¿ÚÑ<ŸO&|^h:Ëè5+f ŒØMÛ~z†Kí"ÊoFJ	àõtú≥ï™ﬂeú<ˇè`≠f_8kÉlc.aÙÙ1-cUMQh*âfh˚/gÚdÄm”j‚¶*ë1€†{rhK6a¥A9eøcrÕ“À`Î-∂Ña™wÉ LPÛHòbÔ«=ROfP~À9›9˝jõ=øFƒw◊‘Ëpªiæ·P;Û=e”Nÿ{ú©'‡v[_" ¨ëå*æ∫A˛≈◊◊EK{±–R'c'Ÿj¨K_¥SèYÀÂ*Rót°ÚAx}M “
8ïlﬂf◊$_Üs„æI*sëbeG=i‹|¨Ï˛Fœ!/N’{KMÓUD
≈>2î/À:Â`É’ïyÂ#’iÈ¢†7«òwBÚKrµcú)Sp‰_ÿÏ@Îæâ*
m§“*¡Ìç1Â[π∞@;'f˚w`ÚBfƒ=^∫˙odÙèôıÔËaZÖˇdSÊïœãcJp#-€øSve;9á‡eÏ)Í\‹«/¨ºøOÇàÒ∆ÕUÁBI€õtv{*JCx™xA'§åap-rZ$§F$Î SøÅj†	ÛhÒõJT'+agT
Xdcw’Î+~s»º/EI∞òb‹"ÖD>J!9
†w%¡}GFXlgë∫@ïcˆtπ3„$`ö`≈„≠^oødÄÂ(·7¶V5,gi)m ∞»ÆD2Cıf≈[ËÙ˛@aY Ãí>3h6ıP·@”
_˛T–ÂÖi≥ã˝mO
Z9≠$K±FË=Æ.r5Eêh÷}A¯<"“'ﬁ¥È)ºUMS‹wSÌdsê*O àÜ%Ùkwﬁcà‡g∞}”ö⁄©∑o◊Bl√qbFägfïÀË ≤!Õm:¨À´Õôcbûˆd!Œ»3µiÿŒ°‰x nÃÙ9GA"pt|ì¶ÅÙH∏ÛÈsûÙ\†o~äÖ_ä—«+©K
‰˜aqÖˆ 2<„«â2!Qc“üœCÕ ÈjÚ-ÎÈæøπbE¯Ul´OÃ°†x,µ]ôP2Pìíiy}Œpj‰/#"¥%U8’îi	ERıœDgÓì¨ØÛﬂzA3£”Z∂Ægµu*tp[}he‘e†èÌb¸ùk‡l-`˝
aß‚Q∫s…ß	1…ñ˘!z™‡rZh˚˚¢Nç<7∑›Á˛U˝ˆd«WE[P;-ú•Ùf~Â¥§3÷¨ää4dÖ≈Â>e§FÚJ e˛"y…ß7ˆXæ “[#ÆYHÈ†C0˝'≤bLqT∫º7ã¢÷ÚX^íÃ¬"ŒTI˚dÊM5Z⁄hÈñA9(ÈRS?dò1‡∂2√S¢nLL;ò ¯Ù¸I5À*e‰÷Õ€ÿGL(‡ÓB©p)Pmé A…
O%<?m|A478ßÔyDAS◊ü„wÌ–®÷•í”\T˛d«’Âa¨fZ#;â(Ï_Œ$)~-»ë<ŒR”n≈bu"◊O9#Ì˚ÄkWN†a%w2•{usÙ£ìh~t!É!o=}R)¨ŒA+C ~◊T¨Ë≤‰Ã).A*bd¢ÁOà6ıüË∏A‰óâ˙MGüvvﬂl!ç6ju@~Çu?ˆ6ÁLX.z•$pÒïVp…<óÂØ``[+ø*ˆrıÉmúòMf$˛˚#íÎúÙ Ÿ∂Áe060rØXCdˆ˘…BF ƒ˜pŸíGVr5á—‡•D2;+JK°PUóıY:@∏C,ÂÓÑı}$˘‚]29!2´*˚bÔI{i!πy¿æRGDr ˙ÿoé“◊¢ –@T@’®POad≠–¿cïòcïyÚ(¢A:í¶à©´#ñå{}⁄7ÎLÑelTuM≥ º^¡sMi¶p^D~nÜ·Â¥TCXwÈd‡°	,=qSÔ!Qün˘jh|éR.4|–ôöá1JﬁL2	6%›=ÛI≠…Fr±JabÄÚ&‘3hË‰JV£o˛Zg¯V;'ŸÒhQí'æ"ËKÇT‡&5\:h_ÄπA‰#YM]Õ¡≤‚9Ø_‹BbÃÍ‰ç~ïV	Ùb¥V≥§™&µÚ˙¨x˘\‡æD¿M
w|ÑwıïF%qwˆ-gQémÆ]=tKx*H”^7…7™'≥;Xá…Óz¯e◊n◊¨^UÍg4†Q)C%:Ëó1,¸‰M´7‚GTdnF(∏A=7u=∞∆ÚEEw}8„‚›ƒ¿Á5∂˝©~œ√F,J¡Ps6≠FãñG~±ûbaI¯`#"e~®∞hlbˆ@÷$ .¶DÊ8Dˆ`hÊ«r‰ _*¡[h;…ﬂÒ
o%ªπƒÆ`!uﬂ√ﬂ”@ce∂=cºç(“<rVmghMpÃ\Óì ÇÌ!Ë_}Ÿ%˝}`-!}7∏($È≤™æêOı{√íäD∑<%A∏ISÖ'ô"ﬁ*∆_qB§¯<˚ö‡åág¨ÿ	o,)yXıÈ!{(éD5]‘VÌ$Fd»T"QQ»4U€6œ!qÈ láôÊ?âgjÓÙ∏z∏]DTàjM}|Ä§R*ì±h9· Ígd%XlQ4ö/ù@LŸ‘«QBj˝tYqÔΩÜ≈´cÏÂKƒ õé†y/‰Ù'¨%sÿô:–¨f`P™NI2,J>ÙàL·itˇ„°xmopRwù-√‹l}÷‚*Gºm(Œi
h_≈e÷qDø’Royë¯—ÔSaL Ñ˜˘
.xÜoF$êvwì m@Va!dÓ£q5®¿à∆IÁ`t¿j»JUywuxj~r4F
»ÒÿﬂJ}™hÍâ‰:Ëv’xÌ|Or≥Iyi·°èU#‡cß„PËjFô]éw†≈S ŸAtC|y(pgTOÊlä#pkÀ›aB¿z≈âh5+ÿZF~c˜Áz´˛4{∆·Ó8ÓõÓ`u=niÁ ãº5izKΩi@œÀ#kCiPØ‚jAnoﬁÕm#M=ˇCˆ,.˝=ã7ü˛º8'Ô»PmÅd„HDëXz0√{o{),˚!”≈Snƒy-‡éj)¬$≈såitM.@6†‡u›Âó«˘U^¶‹p˛uà	òNî*ãÓOm_∞<,¨DÂ⁄Z+´Ü}˙‹%Ò(/ª?Mœ≥ØµŒr^r ’’vÇÙ&Â‡{É›ïL†Ä¯‡LF∂Io‡K-FàbD%yñnZte¸^*ójèzêxÛºgÈ„zÖ®ƒ”I	àp»›…Je Ê#ZåX°(LàÖa¶ıÃÎOùuo'¨õfúøŒ’fP“u˚[¥Ftf§Z∆@lC(y 1ÆuA`}f≥Ë@◊p«\‰káF˚D12¬uÓÆn’”1Õ‘ZkBævéZ»iûÚW^beM¸O"¯ï√È4≈…B(Ö Èﬁv‹o@tÇp*·¯ q_]Â£GTTã)ƒÏi⁄s(ó¨M#Â{GösEB•¥¿+kb®Œä¨ÆÌ∞a™/H*éfK¬›WÒ$6ó>YuÁP4¡|{1+Ñ°zô°˝"XzØ)i8NÃÜ
tF¯oÂ£æıö‚≤ﬂU$$*¨‘∆¢V:∆ †v‚Ñ~qp†ÎÂN≥k*-ÑeÚß«‰Ö>r ƒ R!ˆ9›ÆU˘`Ω ∂b«˙t≠FÎ•†í‘ΩíÈ‘»/Ta‡ÅBÇmæd˛‚å≈ô^t»Zïc>2â2∏&∞Û¿<:ZbLÏBü–5ÊÓT∞-OK$¿±÷]Ì i(x€vﬂsﬁT¢kƒ	ÁS≈»‰F-∑Î¯rÚ˛È»éB'¥ò≤˝eÙ4™»&	˙ı≥Ëê2¸8{Bi„¨dV` Ïi!Â=vPŸ/Ö,œmdπùπ∂”BÖ!⁄Fßñ$'≠›UÕ‰°%ıŒCëy`t:9é[´L|ö3ôÉœÛõ{ÌOÎ6Ä◊D·;Ì
p;)}Y…˝¥Íû–˝v¬¥j»FæÁe\yt·ıBks_e+É≠}¡pâ‚§„s)R–c`{Ñy$wÏE¢gˆJ?N?/’§–Ì/W~åÆÍ+ˇaÏ∏ÜnAL„&w‚h-®¿º©ÅvñtxÿNwZù TRõ≠h–˘ F$£ZœÁOı›>35zZÏµSÎùe6âp«Ÿ¿9À‡u:∏6.F,®|+µË{§·ÎRL&„Î#ÛÎÛ"ÿwKbqÎ‹oH4ƒp6∫
Êfîe—a«†¯UÃVœ·∆iÈKz°·x2ÊZor;ΩZ~@Ou¿OnCl§$QE¢)HÊKU±sÏ2≥-∫ªHr&qˆ⁄zfb6I®
 Œa≤ﬁ‰Ptî¡DdUzò•r’t¥zL3D≈:∏Aè˜J c)ÿ‡fÌ2ÇQ”lK5QÚd´Qµì}ıÉÕ ≥ ¸†˝-≈‘!·XTi++–∂t#Fg‹€≈Ô£êÙcj1ÌÌ#0øO“q{[wÖcp~Â¿$2ıÇh—‚i0^¬-ˆSÙ7Üaé§tD,¶•bq`÷ZildGÌáuotÕa/∑~f][Ò›I—ñötc#¶P.æÂq}NQ◊SME˜qVÂ"	√_E∞—˝©&—√¶Ïïw˛8¸Ù˚C˛0l%gIxH ÷$¨Ô∏5€ ìvIÒ‡‹/ àJµá‰Òq6ŒπD)E$πy˙U[ y'Uh	û!VmY2ü*2:R9íLzÔ$k„Û·|ºhÈpF—˚}dø√f¯ÒÊÙ»ÇvÍ‚6fw$áÊ¬N…Ä	f
éI„}°U £J%Ω·ƒ"ë∑∆qCQ9ÒÚ`¯X˙ô<Òi°⁄^Áry◊hqZt“	á:ˇKµ÷d¨göâÉ	≤répU≤nÓ-7¨œ#<∏>"Çy¥4`pΩãpµg…JBcƒædim] ybÈvE«pœ|Ùî9ë˝¨( hoÆea”´Â‡sJ¸è$ƒaL[A&îm+r9@3‘i:_‰≥¬,h3ej§fÓu'kì`6ò‹/®,0ŸJÊ
˙æ.EwZJ£ã7@ÁÆßczΩ$A8ßCo÷∞/3Lˇ"U%G˚Xz4ã]<÷ÃH9∏R…L“JVLJ|ÖM¡ª8$OuT6zf∆Ør‘ÒkiL_4€—ÍÚTÌıkX'iÅ∑ZL)I(¢(òÏ5’deJΩx&;!ee–AJhŒy`m-|õeÆ
Mfÿ,T2ÄvpÈ˝yΩ>˛‹\h°9fkÓı9~Ë9zÄ<4$b :kzg—yÊ;z$∏„Q:`Fx}¶çrŒ¥∏•*ƒ÷p∫G≈≈® Ufµ•h∫%°ªqÍi|ÌrlDZ_3tíóµm-lJÏtv/w—0y]ˇft+dG¡
;l»q¯/Yª9,5 ŸÍè“`;:ÿ—&2Ä·eu± %p-*d9dfwko‰≤$h  ¿ Ur[°8§=i)r:=9e%Œ©ô»gSo§Í›mÚtÄEÔHD+≈v Øµﬂeiw%€;”kaO!cW-Ÿe^a»'8e·%i_KDç/Ú∞Pr5Ö b(e"+ËŸÿu7,(dxÈ9·!ò"$˚mr_.¥v»I=´Ú∫Kh 	ÆQÏEÇªØm 3Ω/98nEa9[∏@g S}õ<[{Ì§Õzw!¿”G¥ô∫pΩéh‡yn˝d‡1˘w83K›8´Îè{ÊS1◊˝cpÖ.„˚¨*gwuZ•ÆA≤tÊ8Õ≤¨r„"µlÀ4mW˛"‘ÌKyqŒ~*ÔLl¨`\<Ø»ÒÂA&≥^\|§*ËO’S¢fIq≠„åÛ0<©N	$Z@[2D¨“âyºDWî ´®„Ak‘Ì∞º_f˘Âxnè„Bl
‡<oŸ¬’"Îi√nM)1p‚DîÊÖ˜Ì®‚ÃÌ"2'=®s±nl§Íà~&rmA[x”'Ù»¨M©rdc+n}Ie#{U~eÑÂˇw‡29´Ô<∫⁄.µÏØÒi9x?u$kE9^œP&£+C-∫;ìÉe9¯qdU∂,xÆ-#âFá},õ’£+‹/„ÆÆ*ô	n,$çRe7‹VÈlAê%j≥ƒ8nTÄÿ"tD–f©"=”JXQp†·I˛)ôØ{ìÊõ∫,áY=Ãg©]-(nt-h-v,CÏﬁi¸ë }^∏≠=È6EYıùiÌ
Ñ-≠_yP|•ºœ‹}*/S*[X- !ÿ,º©ò,ﬂÚxÓ		å âYC(-Éw&w.@4„!Jıqi`Å#T0%/º∞aj«z%º˙:˘xr⁄rïmÌ]6÷&	Ez‰6LπË≥,‹J’¨rA":O´–akëÔ§JFÄ◊®6jâ∫≥Â∞If≤>[”/¡¶S¬=>«√Ãguc%Ô#%gS'*’pi7vxn1AπzÈ)bcº4.yÏ≠¢AådIe«aÛu∫1h6fB“O•ÒŸx(®‚ób	◊(¿	Hí»Ω
@∞7cbƒtöl√áqhJy∏∆857íMÿC÷rê4}q&hÏgÌÒPQ-5ßóô≥Á2~gQ °*AdtrŸçﬂ6DF+pt˚'!*Wi<c¢Æ{Ëjge¡17å3KKÛ≈p∑“O ø{¸∫—a1VATfqpÛ;))Îî ˛ /´eU‚}ìï/˘i2S#Ë5d=≤m®m3nS∏≠*`Uoà¨äÂ°:y±apÉ$ªL.e¡1Àw=πk·$ùbÁ—IO(qrÿƒgbdG¶¿>eœÊoå¢®PI ó%˙uÛ.	K¸xù„µﬁúÚµ
aåã‚q6‹p‰WnÑxzrMﬂ ij1uÓÌËE€>†rzd
ewy]T&AXÙÔ3>(f…wÓ‘B(}7‡´ˆå“cç·„jua(lµÀa ŒùÁ§<Ñn4dc1Í;J;r_tµ}Æcz$Ó&U+{˚äU«ëõ9-(i§<X– i—wËkM• Ce∂¢z«∆µwN&q+8Ù.4_:1fVds™rUt{R#A`*ú!0K#Xa#ÁÚ2m,i=,◊†w3≈|x5Uby%9QÙÀ>°}!w|¸+9S%ïØ%|¡oÂ4√.≈GõOut33¨}hÎ)),ÚPDRî®Æ	Ò(TwäÖeå‰*Jq©gAv2nHU™á6g9k™üiâQ%’¥&``B‰Fÿ>`d¡ “#‘E`W$:x#¢snzî-ΩoÁOõP˚id|∞,C˚t≠ÅL?¶k~ápZ·#zÍqz2sT+w6w1¸}…§4>ømsc!O∂7ª;D8Ó 8Xo)πN2s‡Ωu,4%†TÛD€.TÇ—5a5T€‰+YrÍƒiW	èBY8E≥w‚n?"3'ˇ^7SIy(ãQ/5w™V+áN†s)O%OcIÔ
QÍÙt={::ò»ñ˛Æa?aóvÇ–uC›Ùwg√_Pa˙6"±mHnOzEHîU[¯¢,-2c É–ã¶x92E$°A€ 6guZ¸Ds: E∏?€kºiÈ}-RäVxÊµfÃ"rD[4ˇÅ'ySÔ^X∞´nq~G¸GÃLe3(,(≠öû*Ù{P›gt3Ì%—ËpQd±†∑'RpöñUÈIé Å7!Ç˛°‹RÒ>.a‚§xgS|nkπårÏAÚf(
Î$E;®5XIµ 1M-Øa	+R454ye$¥Àp€…ru∆\qáU‹"ã∞fl4√Û°4c@Sª∏˝*âjX˘{˛¸|e9„¬uÙº¥\y=√ ◊g>*îÃ,Aj=mÆ·†4P“Îz,Ïû~{uP$ÑN¨⁄e0|"e'‘æxësc@tG^*Lmè·w(6mÙ(@Œ{Cç◊9l> §gbıÚ˘R†={∫$ME<†D{YQ),rÂ∞a~©ÆD:Â£´4.{JøvuzıÂ|êWjË˘R¶D0@®ft∏nC„ÍKNP®ª≥Î$1E◊NbÂjta∑‚¥ÛmJ$‡iy'∑G∑ì#RfÅ3ì?u.„àn1b."˜:9~pgtSë∞ÑîXxp¢aæ6·CÒCˆ˚¢ı0ÈfIWÅ†8çn!‚SŒ◊ˇ[©'rô~yL0aÉ_…g¸ï_§Êñ˚•Vá¨r{π©¿4Œú≠d5gK_≥∏x7æl<WŒ£bJv´_sñ–’Ä-£L∞‘€kç)¢·pm¿+$AHù`'G/Êx‰ü&π&ú`¬vnƒ*π@øTÆ‰t·™
¯pw:ı“Ñ7Jcµ˝ß
ÍÎwm6ì‰‚#!qÚÈN*T·ªõ-D¬v{jt∞'Ài|IR#|Ö =nT≤é©$W1»€v5§ªNúÊwnó—bR∫É08 [|u¬îVHËj¥≤ Èe2m∂FjƒE∞ëY2ı¢4j‡öc7p”tÀeœ“[}DqxÁ®ÀÕÂc™ë”Ì˚Shˆ[J>+∆ÇxAÀíZ5¡$K>ÃiR<ŒŒ#;u/¥d§6-5≠3LÈ˝‰—˛gMtØTCﬁHå R|ˇówXQïOÁAd%>+NS…§@ŸÂQiÀbK˜π3ï∆'\2Ì>Ív¨⁄6jÂ¨,¸ÔZ!L\Áa£xù%·nªáO
îo9:$ªnOE5∑aHvz™I£BQˆgC0◊!E0˝Ωzeam=´‰68xrv˚ƒBóãÂs„Eu™∞kYH+Mœz˙ÖÑÄ)àÎ4`<|36e¥ lZcíp`Œ}•Ï^Î`C3eiı≥q/<i/„zùJ
? ˙{Ëqc@ucæIqp-xñÙïoÌC÷rI;fH?Ñ
=~?ÓÁ¬gË3f$)¸5`-)n;N	≤ˇ™0¯ægä|
z´{{9lÅÊ˜J⁄h±œÖ!.o¬` îj+ˆ ÿBö÷§O
3£x^È~Ê5)QqxÌk-í‚^%¬eb;o>o\òsßwﬁM"jb#By¡*µ÷*9AXÀ}gH.ÌÒõNo`%øù>Z¬ø6Œmrer=-T®<ÅR·|)Ca¬Æ≠KP{‘v/uÏ)™Eø6$yıx&mL*∞m)B%uw+4∏]˙·!4Õ.5âsYûw?Ö8ôhb=+†"k∞RÙ√eb;â9]§`0L:ÙÔ+mÊÂ;o⁄’jAMKÎ_]˚DóıH·|ﬂMÙI2§ãH	#AıÚ{ |Êq}9±lY∑F6¶KM∂Ì;§π*ævúa^‰yÍÂÍ}Œ©l∆≤c bˆTÚ∆—˙ÍÕDbY29"ì|ÂÁLµZ˜Cb¥&EÒcÂûOv[VPi1†ÿ;*)h(>£pt¢~Ì›~'=ˆ€doxÉE(dπF,xµ˚–wÿ.ªËa:û’Úo,CjEó0«bp…e>d|Ü£f *)„÷^ﬁPŒÆ"˝SWˆ=9?√‹”L-$–(©:~e©≈≤Î2389„È∏h›.o¿ZØŸrf'î“ølØrˇJ´TÓÈex&†˝à8Pä7¬[n˛É2j∞K%·%rpk˜d	so|4´’ÉF∂Í·¿Pec'‡W˙Î7Íıªß'om∑(ç%u•d@ÎÆ<ÎÁNôÔÁmVÅ∂Å$ „]üT/=lÓÛÀ£[ x,*Êx” !ì4ëf†M+<Á∏5YÁ™ÊŸ"ùkÛgWzﬂi4Yr„T%vΩ∂YWÜEºf!1ròS6¬í>P∞’Co˚JÓ≠°zıag`AyãiZÏà™<sÿxºFbäÒ©»bkwö¿"x{YÚâæ†"q3xùB.d7|˜ù«ödb¢´E˛ºˇZzµ‰§L*YT∞±‡›∏:¨j\(=„AO{+è4Kø5Ø2'Û·q0¿ÉÌ?≈2{wmKn1ôe;7Iñ:¢)‹LÁ·ª§Y'Yqô‡fa5#EDll@!µjÔk6ÑÏñ,=‡⁄Rr_†Òu7(N*|i2VSÈ5h!hu4Å*âbÊÁ4!N
Í}ÿn}S„X7E˙ê>f%züT‰„(fÂb&¡pmÜr-‰y(u¬µ´X}o
7%ôrcT≈`£‘º*¨Ω3h©¿ ‚Ù"T:`=EcÍê˘7~7ÿt@)ï)k=ö| Ë#t/à∂1ö‰˚~Ëˆ¢≤∫IovfÖ¯¢rtx&∂	!≤RG
‘içˆ
4yA2Ëj  ÛÒSŸt#.„Vo}=°¿h≤\1a` {(J∏ÚDa≠!xˆ^¥sh“tssÙw_9ÍDˆ|gΩ˝}qwˆ;éEgÌ;?]|òÂyËwÔ´ê55	~)ÈƒÅ6ªDlÂxM‘≤Ou´)˜Ò´fö<U,4w¯°È\Eú°?JUD÷&ºQor3âg)Ç%xc.s‰y8t4`ÁI´^_tíû<ì‰ƒ*Q4·å3¥ÉÈH®¨úvjÈ-®w>pu&nà˚ë∏.#tØ$Ù+HÌr‡g>uk¨rŒÈ∏$∞V‡v˘Í≠¬XOjÊ¶íI*˛fÆˆÆØÑR=s’Û÷øwËy~t\6l#Qg	D1XÔ:(lwR?ö„V!R›~&.îBu∞M∞{ëd(M]ÀOƒTyá>ø‰dÊc˙–o$%"Ëv±‡‡»u ûa8±•6ÄPz8†æ`≤Ïÿqp`Ób„≠p)ˆˆw=?{C•ÆasSdd€z5eÇ	‘bd)pMgπLGôñQ¶Ù;éÙÈ¢(WÌª<¿VÖÈO&|Zp0âw)f(JÆNÛ:∞)r¢rÜBú≤Pñ≥ï™M%‘4ˇèd≠f]yCÉOg-a.Â1%eOè9h*âjhÎ:/vtÄM“⁄Í§Sî+"†2r|I6`ëieΩsÚlR:
*Î5xµÑaæeÉ"Sb%I®bÔE?F"@6áa3…ymj∫¢>øV¿w÷ÙXÙ©`˛0uPr“yı¡ v)'¸v)?_0ÏëúKjj(º¥I¶n≥ÇGMk{|18R5≥'õb†~_∞I}sYÀÁ*‚¶¯†¯SheM˙
<Â~Yßó(Osczh(q¢?∆)qM|˝ÍtFu#.ŒA3AIˆ3E<:Qè jÂ`ÉŸµq·#e¡ÎÇ07ÁºÊ~8 ÚIb5ãY);pdU»CÔ≤≠*
gm$“;°Â°1g{·e)£hÎt`ÛFfı5^ˇxsˆ·á	ÂÌÃ Z Ê∏Or
q{dYÆrwO8%«`glg)ztæ!≈Ï}¥BÄÛƒ›Úbq;üvoﬁ;JBxÆh@3§```=rNdÑf˜hS?·i∞+)≈ı•N*d#7!z]*Z`„w’˚ª?q∫Ì?E<p› ïD<j.õT0ïA}fndsê≤A#:Q˘3^Î*¨UﬁÚÙ`ÁÂ¨^-4ä`ËÚ3≤¶/Ω<'(!m tBÆD:B ˆV……®Ù|@a—`ÿä: ›4ÒD·@ÛZm˛UÜ‰›`z
ı˙mM–0≠#O0FÎΩ™:ˆu¿i—ùq¯|"w'F,π*πwE–vGmd!–+S!àÇeÙzˆf˛k®†wp?◊πj©t/”˙kpAFÀgDµÀËr ≤!˝’:,ÈÓÌösDf¥ˆ¸e*Óh≤u≠ÿÏ©$^y({ÿ4˘-&p4|ìÊÅtÙL∏g·s4U‰/vä!á—˜,+ä ∆˜yh•`O24„á2P)Pb2üœ√IÂkz=ÎløøôJu¯}Ãñ©gqÆ·dr<{óDòp0Uì∫)Byzpj$´3"0'T:U1ESµ$Û¬íhØ˜_æW+$tÚ6[∂Ü%Wq2kp=iuT‘ÁiØ˝b,x[ımDØz}
dág—˚/‹•M5âñÈ#~z:ÿv I»˙Z™¬ô0˜Ì”ˆD}t&Ö'EŸQ-Ã≥un`Á-§/Ü†ä´8lÄ&’>"$feC`m˛ph„?ÊXú!Z[sÑpXÈ*c0Ìob¢u1T:<t7i†ûÚYDíLµ&NTij 4µÜmtS–qÀ¶a9≠s?eÿ1‡>>√c#LTy3å ‡e¸f%é#x	mÒˆMˇöÿ3-‡ÔR©r	Se[ú I–	3èbÆ;ôda7,'∂ÈdCS◊œ¿v%–®vzÌŸD˜"d¶]sagz´#•,‘:ãM"~i‡ÒΩ\pE Ÿbub”o!3BºÒÿ)cN `aok˚cî£|ˆd a+ΩlO	<§°:a>st>»d‹%}AjBvA¢'K)dV—ﬂ‡:pÊ≤Å˙-MèRmlAè2jSNÉâ?û2*QO˙d¶
PÒÖz…º∑!°H`B[kı(∆2˜!-¨-d'ˆ˚3©®≤ Ÿ¢ÁgÙ±!RP~√wº˘»<b.(≈ˆpÇAV&#ì`‡m&Y≤:+Hyj°QW˜ô[8TyS6e¢dÙ=Ò‚]≤=E3ﬁh?cgc{Q∏Rı“ûRG@2SÚ%Æ¢ñ∞¯A” U®Pn{h,≈pôDc55o§†'*ä¶à·Øs!~Ï~}“7ÎMelVeU≥ºﬁÒ0+kÊP_g~f¶¢e∂√Yv˘T‡$al93WÎ!Sü~xn h¬V44`π©≤u
ZLr*"'ﬂÛAµIFvµ*ebr·2ƒ#bÈˆvñıÔZgz^;¡á˘≥,èπú`¯c &·s5\>cK¿ãπG‰9SçMÁ¡t∞‚-≠_ZBdÿ˛‚ôgô◊∞"$óVQ≥‰*:ó±n¨8}`º‡GL4|Ùuıóo51u‚/{SLåmßy-l˜nv+HS|7ıwt#T7#TCŒ˛0˘˜Ó2à◊h&p©Q!{)8¯˚3 Õ¥M$Ω7b(UtnF(æa56L1°∆‰@w˝;>q“WL¬e6=·:œ∆Ü-N˙˚°,N3C$±∫J ;ÌW"nez©ıX¯ljÊDÿ5€.d\Í(ºÚ`(w„6‡°_bA^ulãôœm˘¢.5%:®‹Ê`mQ=ˇ¬-G`kË¢5cºå)∂lwbLG(Mrl=X‰†ÇD`W}
“%Ór= h,®≤®æ:uÒ{õí"@=ÂR™HÎÅ'©"◊)÷[yÙ¯,s⁄∫ú3g,Ÿ	g("*˘	}))w(Æ%4	_óÏ$fHËSU_È<u⁄tœ!põ&h¶˘˜{ôbn4›ƒz˘˝DXÍk]t%«Ê2" ±h„x(c`XdU4öm¥AL9dRtz92	qÍå†∆≠emÌK( ïñ y ÆhÃ&¨%s÷1 ﬁ∏a`R*^E,@6¶L°k$ø#!0°/∫Xvç5`ú/qî‡)çò=,n	`_JÂÜ1=ÑRl9¯ÒÚSG$(î˜}†.i$Î.îw(o_/@U` L®•q=(¬IÁ-ÁC)yt¡bHJUEY_UXl⁄vfÀàÒ»ﬁJt lÍ™ı:hvæyÌ}kr≥jsÂ‰•uwl?„P(jdôxõ7W†-}ã“ ’C¸,(pcNÚlÆÎzY√˘aBtPzﬂùËe/‹l~Xo◊a.˛0cƒÎB´8Ên`=,F|g"M∞u)j[§IP˛¶Œ¢kK(pØbnDn)ﬁ…mkÈ|iÏ ˆ,>|∏™∑û˛∏8u•/ÿq•ƒ·!`X0”9.sç,€1≈eú@nåw-»ÃrqçÚ$◊˚å!9"@&Å‚˝Ø}«˘!ı""ÃpË5ä°FÑ*õf/Û >- n2SX{´á?S¯≠ Ò8/øz/IÉM≥'%∆6wz–ù’t*~g%dù√◊usÙÇ¯ÍxF˛{qoHKm(bN$
xB‚K-`|^
ìjNx‘yÛûok„X'*ƒ”Aâò:Õˇ»_@h Æs2 ÿ•®;:Mh≈cß›ÂÎÔΩInqe¨õ&ûÛN¬mt÷w€∂gtÊ!îj§ÍnCY>J1$we•m&E£‡@˜6G‰kóŒªD3∆yåÎkı˜5…≈oûv⁄ÃÊî$ä¯w|d0jÏk
nïÇ7©57eâRp’%i:BΩon@tx>·˘	t[=-Õßw^è-ÑÓm~q8øúM-•KU</WCå≠†+i.(Œ.Ï-m<b.Ø@ ènKΩwu ?1ó^]Y'X4I>[ $°læâ≥¸rPÒ:ø©]|LÃéV4Fhg«£<u4˛2ﬂW.<,UïÖv˙¢ §jÏÑ-q}•ÔÂNπo∫.ØÑÌ∑ÂÔ‰ç6z($8© Vú¶;›º=˘aΩ$'8ù(o'≠GÈ=!‘πªÈÃ…/TaË≠Êè∫t¸s9Xt	 z˝k>:F1âá8∆‡€¿<Z:j,ÏB›”Ê¢q=O[7J±v›Ï m,z¯Ò6‹wºﬁp∫+D	Á[L‡F≠Öo¯Ú›ÈÈF!3à*=eﬂ8#@&D	˙ÒìÙê:‡8zR‡aÁÆ2v`&ÏhUcˇtˆP±'≥$ˇmlΩΩqæ√h≈#RL6è$••QtMg°ßı$Sì5‰aª|éZ´E,∫?J£œÛõ{åÎv¢∆Ñ≈W$Ì—äX3<–YÂ¥˛ﬁır ¥L,o·mkU∞5BaS^e4À´u01‡$·SyR—ccsydslE¢s‰jøN?;ï¥¿ÎøW~;úFÆc/aaÙ∞NbDÎ¶g„p¨DΩ©Ä^¶$xêNwZΩb
GRõ.o–t√CdÁ?åñoµ?;_1~m≠ﬁC„ùl7aÂqÅ(É?04u|,∆K,ò5cÖ¯Á0·:÷F&„˙I#qÍÙ"xuX"qÎX4LD∞RæZ5&fï0”)á.Ä¸ÃﬁÔa·`ÈK©ÒxvfZf&)}zz@O7dxSp¶lL"i@b_CU•S}:3≠Æ˚H“osfÒzFVg&,M¨`Õa6˜F@`ï=Plcvâ§v˜q•Z3Lû(:`á˜k0 k)ÿ‡fÏ;ÇqΩeí Ñ]≤m+qïì)˜Md )≈,§≠Eƒ4ˇITa+C(pÔ7u:e‹€›è„ÄÙkÀ1ÌÂ2æGq?w∆gxkıS§"ıÅëbi2^Å=÷Sd/7ác Á=tÃDÆœ‰2e8d 
AmEÕÜUozE`Hµ{o\ky›Uñ2pcr¶s>´cqˇGqZW€d~qwÂ2=VndıÛÎ)æ¡·fº5¨8µ<wK⁄≥l-wÀ3|z T¨†6Y ì⁄ie‡¸' °zˇ‰·ı'O˘O)u q;zP[45∑QH:	¨!F-6ü*":∞#0l:œ`-5{asa˝˙ÔPf+Ò˘oø@dËπˆı»¢rÍ »vcz∆¬L»í lwJäå‡}°˜%Z'8A&ı∑Ç0CÒ9ÒbÙ|~—<qm°⁄^ÕvøÛ`uﬁTR<2o*MΩ¸`,göœß_ÜvãpL≤onEi¨›3<®?"ÑU5$&8µnÔOAHbaƒÓp|m]!5v·r√pGÓuûiWª(< ho*g ï◊´√tsRˇè4¬bRzE.¥(+˙)V3V+:”‰≥",H1m‰l|uei∞E7æ.‹%hl	,UŸ*G;ÿ§æQfzB£Õ7DÁK§tÛrº%!>ão‘∞vbV?*c@w%eøZ7õ4ÛÃ)1∏PÀPÀVlAlëeIΩ8§Ò4\frzƒ:z‘Ù#
MèÙ{ÖµaËÚ.5ΩezjÜa†≤z.HkQ(ä h5’").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::FloatAttr ReluNOpAdaptor::max_fp() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FloatAttr attr = odsAttrs.get("max_fp").cast<::mlir::FloatAttr>();
  return attr;
}

::mlir::LogicalResult ReluNOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_max_int = odsAttrs.get("max_int");
  if (!tblgen_max_int) return emitError(loc, "'tosa.reluN' op ""requires attribute 'max_int'");
    if (!(((tblgen_max_int.isa<::mlir::IntegerAttr>())) && ((tblgen_max_int.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tosa.reluN' op ""attribute 'max_int' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  {
  auto tblgen_max_fp = odsAttrs.get("max_fp");
  if (!tblgen_max_fp) return emitError(loc, "'tosa.reluN' op ""requires attribute 'max_fp'");
    if (!(((tblgen_max_fp.isa<::mlir::FloatAttr>())) && ((tblgen_max_fp.cast<::mlir::FloatAttr>().getType().isF32())))) return emitError(loc, "'tosa.reluN' op ""attribute 'max_fp' failed to satisfy constraint: 32-bit float attribute");
  }
  return ::mlir::success();
}

















std::pair<unsigned, unsigned> ReluNOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReluNOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReluNOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReluNOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReluNOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReluNOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReluNOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ReluNOp::max_intAttr() {
  return (*this)->getAttr(max_intAttrName()).template cast<::mlir::IntegerAttr>();
}

uint64_t ReluNOp::max_int() {
  auto attr = max_intAttr();
  return attr.getValue().getZExtValue();
}

::mlir::FloatAttr ReluNOp::max_fpAttr() {
  return (*this)->getAttr(max_fpAttrName()).template cast<::mlir::FloatAttr>();
}

::llvm::APFloat ReluNOp::max_fp() {
  auto attr = max_fpAttr();
  return attr.getValue();
}

void ReluNOp::max_intAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(max_intAttrName(), attr);
}

void ReluNOp::max_fpAttr(::mlir::FloatAttr attr) {
  (*this)->setAttr(max_fpAttrName(), attr);
}

void ReluNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr max_int, ::mlir::FloatAttr max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(max_intAttrName(odsState.name), max_int);
  odsState.addAttribute(max_fpAttrName(odsState.name), max_fp);
  odsState.addTypes(output);
}

void ReluNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr max_int, ::mlir::FloatAttr max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(max_intAttrName(odsState.name), max_int);
  odsState.addAttribute(max_fpAttrName(odsState.name), max_fp);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReluNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t max_int, ::llvm::APFloat max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(max_intAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_int));
  odsState.addAttribute(max_fpAttrName(odsState.name), odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max_fp));
  odsState.addTypes(output);
}

void ReluNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t max_int, ::llvm::APFloat max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(max_intAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), max_int));
  odsState.addAttribute(max_fpAttrName(odsState.name), odsBuilder.getFloatAttr(odsBuilder.getF32Type(), max_fp));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReluNOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ReluNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::IntegerAttr max_int, ::mlir::FloatAttr max_fp) {
  odsState.addOperands(input);
  odsState.addAttribute(max_intAttrName(odsState.name), max_int);
  odsState.addAttribute(max_fpAttrName(odsState.name), max_fp);
  odsState.addTypes({input.getType()});

}

void ReluNOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult ReluNOp::verify() {
  if (failed(ReluNOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ReluNOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::RescaleOp definitions
//===----------------------------------------------------------------------===//

RescaleOpAdaptor::RescaleOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

RescaleOpAdaptor::RescaleOpAdaptor(RescaleOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange RescaleOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> RescaleOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RescaleOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RescaleOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr RescaleOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr RescaleOpAdaptor::input_zp() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("input_zp").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::IntegerAttr RescaleOpAdaptor::output_zp() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("output_zp").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::ArrayAttr RescaleOpAdaptor::multiplier() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("multiplier").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr RescaleOpAdaptor::shift() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("shift").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::BoolAttr RescaleOpAdaptor::scale32() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("scale32").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::BoolAttr RescaleOpAdaptor::double_round() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("double_round").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::BoolAttr RescaleOpAdaptor::per_channel() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("per_channel").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult RescaleOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_input_zp = odsAttrs.get("input_zp");
  if (!tblgen_input_zp) return emitError(loc, "'tosa.rescale' op ""requires attribute 'input_zp'");
    if (!(((tblgen_input_zp.isa<::mlir::IntegerAttr>())) && ((tblgen_input_zp.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))))) return emitError(loc, "'tosa.rescale' op ""attribute 'input_zp' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  {
  auto tblgen_output_zp = odsAttrs.get("output_zp");
  if (!tblgen_output_zp) return emitError(loc, "'tosa.rescale' op ""requires attribute 'output_zp'");
    if (!(((tblgen_output_zp.isa<::mlir::IntegerAttr>())) && ((tblgen_output_zp.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))))) return emitError(loc, "'tosa.rescale' op ""attribute 'output_zp' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  {
  auto tblgen_multiplier = odsAttrs.get("multiplier");
  if (!tblgen_multiplier) return emitError(loc, "'tosa.rescale' op ""requires attribute 'multiplier'");
    if (!(((tblgen_multiplier.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_multiplier.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); })))) return emitError(loc, "'tosa.rescale' op ""attribute 'multiplier' failed to satisfy constraint: 32-bit integer array attribute");
  }
  {
  auto tblgen_shift = odsAttrs.get("shift");
  if (!tblgen_shift) return emitError(loc, "'tosa.rescale' op ""requires attribute 'shift'");
    if (!(((tblgen_shift.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_shift.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))); })))) return emitError(loc, "'tosa.rescale' op ""attribute 'shift' failed to satisfy constraint: 32-bit integer array attribute");
  }
  {
  auto tblgen_scale32 = odsAttrs.get("scale32");
  if (!tblgen_scale32) return emitError(loc, "'tosa.rescale' op ""requires attribute 'scale32'");
    if (!((tblgen_scale32.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tosa.rescale' op ""attribute 'scale32' failed to satisfy constraint: bool attribute");
  }
  {
  auto tblgen_double_round = odsAttrs.get("double_round");
  if (!tblgen_double_round) return emitError(loc, "'tosa.rescale' op ""requires attribute 'double_round'");
    if (!((tblgen_double_round.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tosa.rescale' op ""attribute 'double_round' failed to satisfy constraint: bool attribute");
  }
  {
  auto tblgen_per_channel = odsAttrs.get("per_channel");
  if (!tblgen_per_channel) return emitError(loc, "'tosa.rescale' op ""requires attribute 'per_channel'");
    if (!((tblgen_per_channel.isa<::mlir::BoolAttr>()))) return emitError(loc, "'tosa.rescale' op ""attribute 'per_channel' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}





































std::pair<unsigned, unsigned> RescaleOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RescaleOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RescaleOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RescaleOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RescaleOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RescaleOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RescaleOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr RescaleOp::input_zpAttr() {
  return (*this)->getAttr(input_zpAttrName()).template cast<::mlir::IntegerAttr>();
}

uint32_t RescaleOp::input_zp() {
  auto attr = input_zpAttr();
  return attr.getValue().getZExtValue();
}

::mlir::IntegerAttr RescaleOp::output_zpAttr() {
  return (*this)->getAttr(output_zpAttrName()).template cast<::mlir::IntegerAttr>();
}

uint32_t RescaleOp::output_zp() {
  auto attr = output_zpAttr();
  return attr.getValue().getZExtValue();
}

::mlir::ArrayAttr RescaleOp::multiplierAttr() {
  return (*this)->getAttr(multiplierAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr RescaleOp::multiplier() {
  auto attr = multiplierAttr();
  return attr;
}

::mlir::ArrayAttr RescaleOp::shiftAttr() {
  return (*this)->getAttr(shiftAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr RescaleOp::shift() {
  auto attr = shiftAttr();
  return attr;
}

::mlir::BoolAttr RescaleOp::scale32Attr() {
  return (*this)->getAttr(scale32AttrName()).template cast<::mlir::BoolAttr>();
}

bool RescaleOp::scale32() {
  auto attr = scale32Attr();
  return attr.getValue();
}

::mlir::BoolAttr RescaleOp::double_roundAttr() {
  return (*this)->getAttr(double_roundAttrName()).template cast<::mlir::BoolAttr>();
}

bool RescaleOp::double_round() {
  auto attr = double_roundAttr();
  return attr.getValue();
}

::mlir::BoolAttr RescaleOp::per_channelAttr() {
  return (*this)->getAttr(per_channelAttrName()).template cast<::mlir::BoolAttr>();
}

bool RescaleOp::per_channel() {
  auto attr = per_channelAttr();
  return attr.getValue();
}

void RescaleOp::input_zpAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(input_zpAttrName(), attr);
}

void RescaleOp::output_zpAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(output_zpAttrName(), attr);
}

void RescaleOp::multiplierAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(multiplierAttrName(), attr);
}

void RescaleOp::shiftAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(shiftAttrName(), attr);
}

void RescaleOp::scale32Attr(::mlir::BoolAttr attr) {
  (*this)->setAttr(scale32AttrName(), attr);
}

void RescaleOp::double_roundAttr(::mlir::BoolAttr attr) {
  (*this)->setAttr(double_roundAttrName(), attr);
}

void RescaleOp::per_channelAttr(::mlir::BoolAttr attr) {
  (*this)->setAttr(per_channelAttrName(), attr);
}

void RescaleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr input_zp, ::mlir::IntegerAttr output_zp, ::mlir::ArrayAttr multiplier, ::mlir::ArrayAttr shift, ::mlir::BoolAttr scale32, ::mlir::BoolAttr double_round, ::mlir::BoolAttr per_channel) {
  odsState.addOperands(input);
  odsState.addAttribute(input_zpAttrName(odsState.name), input_zp);
  odsState.addAttribute(output_zpAttrName(odsState.name), output_zp);
  odsState.addAttribute(multiplierAttrName(odsState.name), multiplier);
  odsState.addAttribute(shiftAttrName(odsState.name), shift);
  odsState.addAttribute(scale32AttrName(odsState.name), scale32);
  odsState.addAttribute(double_roundAttrName(odsState.name), double_round);
  odsState.addAttribute(per_channelAttrName(odsState.name), per_channel);
  odsState.addTypes(output);
}

void RescaleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr input_zp, ::mlir::IntegerAttr output_zp, ::mlir::ArrayAttr multiplier, ::mlir::ArrayAttr shift, ::mlir::BoolAttr scale32, ::mlir::BoolAttr double_round, ::mlir::BoolAttr per_channel) {
  odsState.addOperands(input);
  odsState.addAttribute(input_zpAttrName(odsState.name), input_zp);
  odsState.addAttribute(output_zpAttrName(odsState.name), output_zp);
  odsState.addAttribute(multiplierAttrName(odsState.name), multiplier);
  odsState.addAttribute(shiftAttrName(odsState.name), shift);
  odsState.addAttribute(scale32AttrName(odsState.name), scale32);
  odsState.addAttribute(double_roundAttrName(odsState.name), double_round);
  odsState.addAttribute(per_channelAttrName(odsState.name), per_channel);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RescaleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint32_t input_zp, uint32_t output_zp, ::mlir::ArrayAttr multiplier, ::mlir::ArrayAttr shift, bool scale32, bool double_round, bool per_channel) {
  odsState.addOperands(input);
  odsState.addAttribute(input_zpAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), input_zp));
  odsState.addAttribute(output_zpAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), output_zp));
  odsState.addAttribute(multiplierAttrName(odsState.name), multiplier);
  odsState.addAttribute(shiftAttrName(odsState.name), shift);
  odsState.addAttribute(scale32AttrName(odsState.name), odsBuilder.getBoolAttr(scale32));
  odsState.addAttribute(double_roundAttrName(odsState.name), odsBuilder.getBoolAttr(double_round));
  odsState.addAttribute(per_channelAttrName(odsState.name), odsBuilder.getBoolAttr(per_channel));
  odsState.addTypes(output);
}

void RescaleOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint32_t input_zp, uint32_t output_zp, ::mlir::ArrayAttr multiplier, ::mlir::ArrayAttr shift, bool scale32, bool double_round, bool per_channel) {
  odsState.addOperands(input);
  odsState.addAttribute(input_zpAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), input_zp));
  odsState.addAttribute(output_zpAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), output_zp));
  odsState.addAttribute(multiplierAttrName(odsState.name), multiplier);
  odsState.addAttribute(shiftAttrName(odsState.name), shift);
  odsState.addAttribute(scale32AttrName(odsState.name), odsBuilder.getBoolAttr(scale32));
  odsState.addAttribute(double_roundAttrName(odsState.name), odsBuilder.getBoolAttr(double_round));
  odsState.addAttribute(per_channelAttrName(odsState.name), odsBuilder.getBoolAttr(per_channel));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RescaleOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RescaleOp::verify() {
  if (failed(RescaleOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void RescaleOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ReshapeOp definitions
//===----------------------------------------------------------------------===//

ReshapeOpAdaptor::ReshapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReshapeOpAdaptor::ReshapeOpAdaptor(ReshapeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReshapeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReshapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReshapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ReshapeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr ReshapeOpAdaptor::new_shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("new_shape").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult ReshapeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_new_shape = odsAttrs.get("new_shape");
  if (!tblgen_new_shape) return emitError(loc, "'tosa.reshape' op ""requires attribute 'new_shape'");
    if (!(((tblgen_new_shape.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_new_shape.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tosa.reshape' op ""attribute 'new_shape' failed to satisfy constraint: 64-bit integer array attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ReshapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReshapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReshapeOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReshapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReshapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr ReshapeOp::new_shapeAttr() {
  return (*this)->getAttr(new_shapeAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ReshapeOp::new_shape() {
  auto attr = new_shapeAttr();
  return attr;
}

void ReshapeOp::new_shapeAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(new_shapeAttrName(), attr);
}

void ReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::ArrayAttr new_shape) {
  odsState.addOperands(input1);
  odsState.addAttribute(new_shapeAttrName(odsState.name), new_shape);
  odsState.addTypes(output);
}

void ReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::ArrayAttr new_shape) {
  odsState.addOperands(input1);
  odsState.addAttribute(new_shapeAttrName(odsState.name), new_shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReshapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReshapeOp::verify() {
  if (failed(ReshapeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps7(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ReshapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ResizeOp definitions
//===----------------------------------------------------------------------===//

ResizeOpAdaptor::ResizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ResizeOpAdaptor::ResizeOpAdaptor(ResizeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ResizeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ResizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ResizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ResizeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr ResizeOpAdaptor::output_size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("output_size").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ResizeOpAdaptor::stride() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("stride").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ResizeOpAdaptor::offset() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("offset").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::IntegerAttr ResizeOpAdaptor::shift() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("shift").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::ArrayAttr ResizeOpAdaptor::stride_fp() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("stride_fp").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ResizeOpAdaptor::offset_fp() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("offset_fp").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr ResizeOpAdaptor::mode() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("mode").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult ResizeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_output_size = odsAttrs.get("output_size");
  if (!tblgen_output_size) return emitError(loc, "'tosa.resize' op ""requires attribute 'output_size'");
    if (!((((tblgen_output_size.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_output_size.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_output_size.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.resize' op ""attribute 'output_size' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_stride = odsAttrs.get("stride");
  if (!tblgen_stride) return emitError(loc, "'tosa.resize' op ""requires attribute 'stride'");
    if (!((((tblgen_stride.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_stride.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_stride.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.resize' op ""attribute 'stride' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_offset = odsAttrs.get("offset");
  if (!tblgen_offset) return emitError(loc, "'tosa.resize' op ""requires attribute 'offset'");
    if (!((((tblgen_offset.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_offset.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_offset.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.resize' op ""attribute 'offset' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_shift = odsAttrs.get("shift");
  if (!tblgen_shift) return emitError(loc, "'tosa.resize' op ""requires attribute 'shift'");
    if (!(((tblgen_shift.isa<::mlir::IntegerAttr>())) && ((tblgen_shift.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(32))))) return emitError(loc, "'tosa.resize' op ""attribute 'shift' failed to satisfy constraint: 32-bit signless integer attribute");
  }
  {
  auto tblgen_stride_fp = odsAttrs.get("stride_fp");
  if (!tblgen_stride_fp) return emitError(loc, "'tosa.resize' op ""requires attribute 'stride_fp'");
    if (!((((tblgen_stride_fp.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_stride_fp.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::FloatAttr>())) && ((attr.cast<::mlir::FloatAttr>().getType().isF32())); }))) && ((tblgen_stride_fp.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.resize' op ""attribute 'stride_fp' failed to satisfy constraint: 32-bit float array attribute with exactly 2 elements");
  }
  {
  auto tblgen_offset_fp = odsAttrs.get("offset_fp");
  if (!tblgen_offset_fp) return emitError(loc, "'tosa.resize' op ""requires attribute 'offset_fp'");
    if (!((((tblgen_offset_fp.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_offset_fp.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::FloatAttr>())) && ((attr.cast<::mlir::FloatAttr>().getType().isF32())); }))) && ((tblgen_offset_fp.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.resize' op ""attribute 'offset_fp' failed to satisfy constraint: 32-bit float array attribute with exactly 2 elements");
  }
  {
  auto tblgen_mode = odsAttrs.get("mode");
  if (!tblgen_mode) return emitError(loc, "'tosa.resize' op ""requires attribute 'mode'");
    if (!((tblgen_mode.cast<StringAttr>().getValue() == "BILINEAR"  || tblgen_mode.cast<StringAttr>().getValue() == "NEAREST_NEIGHBOR"))) return emitError(loc, "'tosa.resize' op ""attribute 'mode' failed to satisfy constraint: Supported resize/upsampling strategies");
  }
  return ::mlir::success();
}





































std::pair<unsigned, unsigned> ResizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ResizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ResizeOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ResizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ResizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ResizeOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr ResizeOp::output_sizeAttr() {
  return (*this)->getAttr(output_sizeAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ResizeOp::output_size() {
  auto attr = output_sizeAttr();
  return attr;
}

::mlir::ArrayAttr ResizeOp::strideAttr() {
  return (*this)->getAttr(strideAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ResizeOp::stride() {
  auto attr = strideAttr();
  return attr;
}

::mlir::ArrayAttr ResizeOp::offsetAttr() {
  return (*this)->getAttr(offsetAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ResizeOp::offset() {
  auto attr = offsetAttr();
  return attr;
}

::mlir::IntegerAttr ResizeOp::shiftAttr() {
  return (*this)->getAttr(shiftAttrName()).template cast<::mlir::IntegerAttr>();
}

uint32_t ResizeOp::shift() {
  auto attr = shiftAttr();
  return attr.getValue().getZExtValue();
}

::mlir::ArrayAttr ResizeOp::stride_fpAttr() {
  return (*this)->getAttr(stride_fpAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ResizeOp::stride_fp() {
  auto attr = stride_fpAttr();
  return attr;
}

::mlir::ArrayAttr ResizeOp::offset_fpAttr() {
  return (*this)->getAttr(offset_fpAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ResizeOp::offset_fp() {
  auto attr = offset_fpAttr();
  return attr;
}

::mlir::StringAttr ResizeOp::modeAttr() {
  return (*this)->getAttr(modeAttrName()).template cast<::mlir::StringAttr>();
}

::llvm::StringRef ResizeOp::mode() {
  auto attr = modeAttr();
  return attr.getValue();
}

void ResizeOp::output_sizeAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(output_sizeAttrName(), attr);
}

void ResizeOp::strideAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(strideAttrName(), attr);
}

void ResizeOp::offsetAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(offsetAttrName(), attr);
}

void ResizeOp::shiftAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(shiftAttrName(), attr);
}

void ResizeOp::stride_fpAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(stride_fpAttrName(), attr);
}

void ResizeOp::offset_fpAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(offset_fpAttrName(), attr);
}

void ResizeOp::modeAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(modeAttrName(), attr);
}

void ResizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr output_size, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr offset, ::mlir::IntegerAttr shift, ::mlir::ArrayAttr stride_fp, ::mlir::ArrayAttr offset_fp, ::mlir::StringAttr mode) {
  odsState.addOperands(input);
  odsState.addAttribute(output_sizeAttrName(odsState.name), output_size);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(offsetAttrName(odsState.name), offset);
  odsState.addAttribute(shiftAttrName(odsState.name), shift);
  odsState.addAttribute(stride_fpAttrName(odsState.name), stride_fp);
  odsState.addAttribute(offset_fpAttrName(odsState.name), offset_fp);
  odsState.addAttribute(modeAttrName(odsState.name), mode);
  odsState.addTypes(output);
}

void ResizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr output_size, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr offset, ::mlir::IntegerAttr shift, ::mlir::ArrayAttr stride_fp, ::mlir::ArrayAttr offset_fp, ::mlir::StringAttr mode) {
  odsState.addOperands(input);
  odsState.addAttribute(output_sizeAttrName(odsState.name), output_size);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(offsetAttrName(odsState.name), offset);
  odsState.addAttribute(shiftAttrName(odsState.name), shift);
  odsState.addAttribute(stride_fpAttrName(odsState.name), stride_fp);
  odsState.addAttribute(offset_fpAttrName(odsState.name), offset_fp);
  odsState.addAttribute(modeAttrName(odsState.name), mode);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr output_size, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr offset, uint32_t shift, ::mlir::ArrayAttr stride_fp, ::mlir::ArrayAttr offset_fp, ::llvm::StringRef mode) {
  odsState.addOperands(input);
  odsState.addAttribute(output_sizeAttrName(odsState.name), output_size);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(offsetAttrName(odsState.name), offset);
  odsState.addAttribute(shiftAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), shift));
  odsState.addAttribute(stride_fpAttrName(odsState.name), stride_fp);
  odsState.addAttribute(offset_fpAttrName(odsState.name), offset_fp);
  odsState.addAttribute(modeAttrName(odsState.name), odsBuilder.getStringAttr(mode));
  odsState.addTypes(output);
}

void ResizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr output_size, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr offset, uint32_t shift, ::mlir::ArrayAttr stride_fp, ::mlir::ArrayAttr offset_fp, ::llvm::StringRef mode) {
  odsState.addOperands(input);
  odsState.addAttribute(output_sizeAttrName(odsState.name), output_size);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(offsetAttrName(odsState.name), offset);
  odsState.addAttribute(shiftAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(32), shift));
  odsState.addAttribute(stride_fpAttrName(odsState.name), stride_fp);
  odsState.addAttribute(offset_fpAttrName(odsState.name), offset_fp);
  odsState.addAttribute(modeAttrName(odsState.name), odsBuilder.getStringAttr(mode));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ResizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ResizeOp::verify() {
  if (failed(ResizeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ResizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ReverseOp definitions
//===----------------------------------------------------------------------===//

ReverseOpAdaptor::ReverseOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReverseOpAdaptor::ReverseOpAdaptor(ReverseOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReverseOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReverseOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReverseOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ReverseOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr ReverseOpAdaptor::axis() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("axis").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult ReverseOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_axis = odsAttrs.get("axis");
  if (!tblgen_axis) return emitError(loc, "'tosa.reverse' op ""requires attribute 'axis'");
    if (!(((tblgen_axis.isa<::mlir::IntegerAttr>())) && ((tblgen_axis.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))))) return emitError(loc, "'tosa.reverse' op ""attribute 'axis' failed to satisfy constraint: 64-bit signless integer attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ReverseOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReverseOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ReverseOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReverseOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReverseOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReverseOp::output() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ReverseOp::axisAttr() {
  return (*this)->getAttr(axisAttrName()).template cast<::mlir::IntegerAttr>();
}

uint64_t ReverseOp::axis() {
  auto attr = axisAttr();
  return attr.getValue().getZExtValue();
}

void ReverseOp::axisAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(axisAttrName(), attr);
}

void ReverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  odsState.addTypes(output);
}

void ReverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::IntegerAttr axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), axis);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  odsState.addTypes(output);
}

void ReverseOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, uint64_t axis) {
  odsState.addOperands(input);
  odsState.addAttribute(axisAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIntegerType(64), axis));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReverseOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReverseOp::verify() {
  if (failed(ReverseOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ReverseOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::RsqrtOp definitions
//===----------------------------------------------------------------------===//

RsqrtOpAdaptor::RsqrtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

RsqrtOpAdaptor::RsqrtOpAdaptor(RsqrtOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange RsqrtOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> RsqrtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RsqrtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr RsqrtOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult RsqrtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> RsqrtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RsqrtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RsqrtOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RsqrtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RsqrtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RsqrtOp::output() {
  return *getODSResults(0).begin();
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes(output);
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1) {
  odsState.addOperands(input1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RsqrtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input1) {
  odsState.addOperands(input1);
  odsState.addTypes({input1.getType()});

}

void RsqrtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult RsqrtOp::verify() {
  if (failed(RsqrtOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void RsqrtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::ScatterOp definitions
//===----------------------------------------------------------------------===//

ScatterOpAdaptor::ScatterOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ScatterOpAdaptor::ScatterOpAdaptor(ScatterOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ScatterOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ScatterOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ScatterOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ScatterOpAdaptor::values_in() {
  return *getODSOperands(0).begin();
}

::mlir::Value ScatterOpAdaptor::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ScatterOpAdaptor::input() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr ScatterOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ScatterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ScatterOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ScatterOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ScatterOp::values_in() {
  return *getODSOperands(0).begin();
}

::mlir::Value ScatterOp::indices() {
  return *getODSOperands(1).begin();
}

::mlir::Value ScatterOp::input() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ScatterOp::values_inMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ScatterOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ScatterOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ScatterOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ScatterOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ScatterOp::values_out() {
  return *getODSResults(0).begin();
}

void ScatterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type values_out, ::mlir::Value values_in, ::mlir::Value indices, ::mlir::Value input) {
  odsState.addOperands(values_in);
  odsState.addOperands(indices);
  odsState.addOperands(input);
  odsState.addTypes(values_out);
}

void ScatterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value values_in, ::mlir::Value indices, ::mlir::Value input) {
  odsState.addOperands(values_in);
  odsState.addOperands(indices);
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ScatterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ScatterOp::verify() {
  if (failed(ScatterOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps14(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps15(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps14(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps14(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ScatterOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::SelectOp definitions
//===----------------------------------------------------------------------===//

SelectOpAdaptor::SelectOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SelectOpAdaptor::SelectOpAdaptor(SelectOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SelectOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SelectOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SelectOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectOpAdaptor::input3() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr SelectOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SelectOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SelectOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SelectOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectOp::input3() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SelectOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SelectOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SelectOp::input3Mutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SelectOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SelectOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOp::output() {
  return *getODSResults(0).begin();
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2, ::mlir::Value input3) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addOperands(input3);
  odsState.addTypes(output);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2, ::mlir::Value input3) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addOperands(input3);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SelectOp::verify() {
  if (failed(SelectOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps12(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void SelectOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::SigmoidOp definitions
//===----------------------------------------------------------------------===//

SigmoidOpAdaptor::SigmoidOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SigmoidOpAdaptor::SigmoidOpAdaptor(SigmoidOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SigmoidOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SigmoidOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SigmoidOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SigmoidOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SigmoidOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SigmoidOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SigmoidOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SigmoidOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SigmoidOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SigmoidOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SigmoidOp::output() {
  return *getODSResults(0).begin();
}

void SigmoidOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void SigmoidOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SigmoidOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SigmoidOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes({input.getType()});

}

void SigmoidOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult SigmoidOp::verify() {
  if (failed(SigmoidOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void SigmoidOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::SliceOp definitions
//===----------------------------------------------------------------------===//

SliceOpAdaptor::SliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SliceOpAdaptor::SliceOpAdaptor(SliceOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SliceOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SliceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SliceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SliceOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SliceOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr SliceOpAdaptor::start() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("start").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr SliceOpAdaptor::size() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("size").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult SliceOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_start = odsAttrs.get("start");
  if (!tblgen_start) return emitError(loc, "'tosa.slice' op ""requires attribute 'start'");
    if (!(((tblgen_start.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_start.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tosa.slice' op ""attribute 'start' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_size = odsAttrs.get("size");
  if (!tblgen_size) return emitError(loc, "'tosa.slice' op ""requires attribute 'size'");
    if (!(((tblgen_size.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_size.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tosa.slice' op ""attribute 'size' failed to satisfy constraint: 64-bit integer array attribute");
  }
  return ::mlir::success();
}

















std::pair<unsigned, unsigned> SliceOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SliceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SliceOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SliceOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SliceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SliceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SliceOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr SliceOp::startAttr() {
  return (*this)->getAttr(startAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr SliceOp::start() {
  auto attr = startAttr();
  return attr;
}

::mlir::ArrayAttr SliceOp::sizeAttr() {
  return (*this)->getAttr(sizeAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr SliceOp::size() {
  auto attr = sizeAttr();
  return attr;
}

void SliceOp::startAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(startAttrName(), attr);
}

void SliceOp::sizeAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(sizeAttrName(), attr);
}

void SliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::ArrayAttr start, ::mlir::ArrayAttr size) {
  odsState.addOperands(input);
  odsState.addAttribute(startAttrName(odsState.name), start);
  odsState.addAttribute(sizeAttrName(odsState.name), size);
  odsState.addTypes(output);
}

void SliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::ArrayAttr start, ::mlir::ArrayAttr size) {
  odsState.addOperands(input);
  odsState.addAttribute(startAttrName(odsState.name), start);
  odsState.addAttribute(sizeAttrName(odsState.name), size);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SliceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SliceOp::verify() {
  if (failed(SliceOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps18(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps18(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void SliceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::SubOp definitions
//===----------------------------------------------------------------------===//

SubOpAdaptor::SubOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SubOpAdaptor::SubOpAdaptor(SubOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SubOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SubOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SubOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubOpAdaptor::input2() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SubOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SubOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SubOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SubOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubOp::input2() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SubOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SubOp::input2Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SubOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SubOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubOp::output() {
  return *getODSResults(0).begin();
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  odsState.addTypes(output);
}

void SubOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value input2) {
  odsState.addOperands(input1);
  odsState.addOperands(input2);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SubOp::verify() {
  if (failed(SubOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void SubOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::TableOp definitions
//===----------------------------------------------------------------------===//

TableOpAdaptor::TableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TableOpAdaptor::TableOpAdaptor(TableOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TableOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TableOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TableOpAdaptor::table() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr TableOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult TableOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> TableOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TableOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TableOp::table() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TableOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TableOp::tableMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TableOp::output() {
  return *getODSResults(0).begin();
}

void TableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value table) {
  odsState.addOperands(input);
  odsState.addOperands(table);
  odsState.addTypes(output);
}

void TableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value table) {
  odsState.addOperands(input);
  odsState.addOperands(table);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TableOp::verify() {
  if (failed(TableOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void TableOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::TanhOp definitions
//===----------------------------------------------------------------------===//

TanhOpAdaptor::TanhOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TanhOpAdaptor::TanhOpAdaptor(TanhOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TanhOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TanhOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TanhOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr TanhOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult TanhOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> TanhOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TanhOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TanhOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TanhOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TanhOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TanhOp::output() {
  return *getODSResults(0).begin();
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TanhOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes({input.getType()});

}

void TanhOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::LogicalResult TanhOp::verify() {
  if (failed(TanhOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void TanhOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::TileOp definitions
//===----------------------------------------------------------------------===//

TileOpAdaptor::TileOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TileOpAdaptor::TileOpAdaptor(TileOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TileOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TileOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TileOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr TileOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr TileOpAdaptor::multiples() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("multiples").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult TileOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_multiples = odsAttrs.get("multiples");
  if (!tblgen_multiples) return emitError(loc, "'tosa.tile' op ""requires attribute 'multiples'");
    if (!(((tblgen_multiples.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_multiples.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tosa.tile' op ""attribute 'multiples' failed to satisfy constraint: 64-bit integer array attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> TileOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TileOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TileOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TileOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TileOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr TileOp::multiplesAttr() {
  return (*this)->getAttr(multiplesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TileOp::multiples() {
  auto attr = multiplesAttr();
  return attr;
}

void TileOp::multiplesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(multiplesAttrName(), attr);
}

void TileOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::ArrayAttr multiples) {
  odsState.addOperands(input1);
  odsState.addAttribute(multiplesAttrName(odsState.name), multiples);
  odsState.addTypes(output);
}

void TileOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::ArrayAttr multiples) {
  odsState.addOperands(input1);
  odsState.addAttribute(multiplesAttrName(odsState.name), multiples);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TileOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TileOp::verify() {
  if (failed(TileOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps3(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void TileOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::TransposeConv2DOp definitions
//===----------------------------------------------------------------------===//

TransposeConv2DOpAdaptor::TransposeConv2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TransposeConv2DOpAdaptor::TransposeConv2DOpAdaptor(TransposeConv2DOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TransposeConv2DOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TransposeConv2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TransposeConv2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeConv2DOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TransposeConv2DOpAdaptor::filter() {
  return *getODSOperands(1).begin();
}

::mlir::Value TransposeConv2DOpAdaptor::bias() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr TransposeConv2DOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr TransposeConv2DOpAdaptor::out_pad() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("out_pad").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr TransposeConv2DOpAdaptor::stride() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("stride").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr TransposeConv2DOpAdaptor::dilation() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilation").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr TransposeConv2DOpAdaptor::out_shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("out_shape").cast<::mlir::ArrayAttr>();
  return attr;
}

mlir::tosa::ConvOpQuantizationAttr TransposeConv2DOpAdaptor::quantization_info() {
  assert(odsAttrs && "no attributes when constructing adapter");
  mlir::tosa::ConvOpQuantizationAttr attr = odsAttrs.get("quantization_info").dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
  return attr;
}

::mlir::LogicalResult TransposeConv2DOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_out_pad = odsAttrs.get("out_pad");
  if (!tblgen_out_pad) return emitError(loc, "'tosa.transpose_conv2d' op ""requires attribute 'out_pad'");
    if (!((((tblgen_out_pad.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_out_pad.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_out_pad.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.transpose_conv2d' op ""attribute 'out_pad' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_stride = odsAttrs.get("stride");
  if (!tblgen_stride) return emitError(loc, "'tosa.transpose_conv2d' op ""requires attribute 'stride'");
    if (!((((tblgen_stride.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_stride.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_stride.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.transpose_conv2d' op ""attribute 'stride' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_dilation = odsAttrs.get("dilation");
  if (!tblgen_dilation) return emitError(loc, "'tosa.transpose_conv2d' op ""requires attribute 'dilation'");
    if (!((((tblgen_dilation.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilation.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_dilation.cast<::mlir::ArrayAttr>().size() == 2)))) return emitError(loc, "'tosa.transpose_conv2d' op ""attribute 'dilation' failed to satisfy constraint: 64-bit integer array attribute with exactly 2 elements");
  }
  {
  auto tblgen_out_shape = odsAttrs.get("out_shape");
  if (!tblgen_out_shape) return emitError(loc, "'tosa.transpose_conv2d' op ""requires attribute 'out_shape'");
    if (!((((tblgen_out_shape.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_out_shape.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); }))) && ((tblgen_out_shape.cast<::mlir::ArrayAttr>().size() <= 4)))) return emitError(loc, "'tosa.transpose_conv2d' op ""attribute 'out_shape' failed to satisfy constraint: 64-bit integer array attribute with at least 4 elements");
  }
  {
  auto tblgen_quantization_info = odsAttrs.get("quantization_info");
  if (tblgen_quantization_info) {
    if (!((tblgen_quantization_info.isa<mlir::tosa::ConvOpQuantizationAttr>()))) return emitError(loc, "'tosa.transpose_conv2d' op ""attribute 'quantization_info' failed to satisfy constraint: Attribute for Conv type op quantization information.");
  }
  }
  return ::mlir::success();
}





























std::pair<unsigned, unsigned> TransposeConv2DOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TransposeConv2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeConv2DOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value TransposeConv2DOp::filter() {
  return *getODSOperands(1).begin();
}

::mlir::Value TransposeConv2DOp::bias() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TransposeConv2DOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TransposeConv2DOp::filterMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TransposeConv2DOp::biasMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TransposeConv2DOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TransposeConv2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeConv2DOp::output() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr TransposeConv2DOp::out_padAttr() {
  return (*this)->getAttr(out_padAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TransposeConv2DOp::out_pad() {
  auto attr = out_padAttr();
  return attr;
}

::mlir::ArrayAttr TransposeConv2DOp::strideAttr() {
  return (*this)->getAttr(strideAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TransposeConv2DOp::stride() {
  auto attr = strideAttr();
  return attr;
}

::mlir::ArrayAttr TransposeConv2DOp::dilationAttr() {
  return (*this)->getAttr(dilationAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TransposeConv2DOp::dilation() {
  auto attr = dilationAttr();
  return attr;
}

::mlir::ArrayAttr TransposeConv2DOp::out_shapeAttr() {
  return (*this)->getAttr(out_shapeAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr TransposeConv2DOp::out_shape() {
  auto attr = out_shapeAttr();
  return attr;
}

mlir::tosa::ConvOpQuantizationAttr TransposeConv2DOp::quantization_infoAttr() {
  return (*this)->getAttr(quantization_infoAttrName()).template dyn_cast_or_null<mlir::tosa::ConvOpQuantizationAttr>();
}

::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr> TransposeConv2DOp::quantization_info() {
  auto attr = quantization_infoAttr();
  return attr ? ::llvm::Optional<mlir::tosa::ConvOpQuantizationAttr>(attr) : (::llvm::None);
}

void TransposeConv2DOp::out_padAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(out_padAttrName(), attr);
}

void TransposeConv2DOp::strideAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(strideAttrName(), attr);
}

void TransposeConv2DOp::dilationAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(dilationAttrName(), attr);
}

void TransposeConv2DOp::out_shapeAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(out_shapeAttrName(), attr);
}

void TransposeConv2DOp::quantization_infoAttr(mlir::tosa::ConvOpQuantizationAttr attr) {
  (*this)->setAttr(quantization_infoAttrName(), attr);
}

::mlir::Attribute TransposeConv2DOp::removeQuantization_infoAttr() {
  return (*this)->removeAttr(quantization_infoAttrName());
}

void TransposeConv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Type outputType, Value input, Value weight, Value bias, ArrayAttr outpad, ArrayAttr stride, ArrayAttr dilation, ArrayAttr outputShape) {
    buildTransConvOpWithQuantInfo(odsBuilder, odsState, outputType,
                                  input, weight, bias,
                                  outpad, stride, dilation,
                                  outputShape);
  
}

void TransposeConv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input, ::mlir::Value filter, ::mlir::Value bias, ::mlir::ArrayAttr out_pad, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr dilation, ::mlir::ArrayAttr out_shape, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addOperands(bias);
  odsState.addAttribute(out_padAttrName(odsState.name), out_pad);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(dilationAttrName(odsState.name), dilation);
  odsState.addAttribute(out_shapeAttrName(odsState.name), out_shape);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  odsState.addTypes(output);
}

void TransposeConv2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value filter, ::mlir::Value bias, ::mlir::ArrayAttr out_pad, ::mlir::ArrayAttr stride, ::mlir::ArrayAttr dilation, ::mlir::ArrayAttr out_shape, /*optional*/mlir::tosa::ConvOpQuantizationAttr quantization_info) {
  odsState.addOperands(input);
  odsState.addOperands(filter);
  odsState.addOperands(bias);
  odsState.addAttribute(out_padAttrName(odsState.name), out_pad);
  odsState.addAttribute(strideAttrName(odsState.name), stride);
  odsState.addAttribute(dilationAttrName(odsState.name), dilation);
  odsState.addAttribute(out_shapeAttrName(odsState.name), out_shape);
  if (quantization_info) {
  odsState.addAttribute(quantization_infoAttrName(odsState.name), quantization_info);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TransposeConv2DOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TransposeConv2DOp::verify() {
  if (failed(TransposeConv2DOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void TransposeConv2DOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::TransposeOp definitions
//===----------------------------------------------------------------------===//

TransposeOpAdaptor::TransposeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TransposeOpAdaptor::TransposeOpAdaptor(TransposeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TransposeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TransposeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TransposeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOpAdaptor::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value TransposeOpAdaptor::perms() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr TransposeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult TransposeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> TransposeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TransposeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOp::input1() {
  return *getODSOperands(0).begin();
}

::mlir::Value TransposeOp::perms() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange TransposeOp::input1Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TransposeOp::permsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TransposeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TransposeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TransposeOp::output() {
  return *getODSResults(0).begin();
}

void TransposeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input1, ::mlir::Value perms) {
  odsState.addOperands(input1);
  odsState.addOperands(perms);
  odsState.addTypes(output);
}

void TransposeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input1, ::mlir::Value perms) {
  odsState.addOperands(input1);
  odsState.addOperands(perms);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TransposeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TransposeOp::verify() {
  if (failed(TransposeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps18(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps17(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps18(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void TransposeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::WhileOp definitions
//===----------------------------------------------------------------------===//

WhileOpAdaptor::WhileOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

WhileOpAdaptor::WhileOpAdaptor(WhileOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange WhileOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> WhileOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange WhileOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange WhileOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr WhileOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange WhileOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &WhileOpAdaptor::cond() {
  return *odsRegions[0];
}

::mlir::Region &WhileOpAdaptor::body() {
  return *odsRegions[1];
}

::mlir::LogicalResult WhileOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> WhileOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range WhileOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range WhileOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange WhileOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WhileOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range WhileOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range WhileOp::output() {
  return getODSResults(0);
}

::mlir::Region &WhileOp::cond() {
  return (*this)->getRegion(0);
}

::mlir::Region &WhileOp::body() {
  return (*this)->getRegion(1);
}

void WhileOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult WhileOp::verify() {
  if (failed(WhileOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps10(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps10(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('cond') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(1))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('body') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return ::mlir::success();
}







} // namespace tosa
} // namespace mlir
namespace mlir {
namespace tosa {

//===----------------------------------------------------------------------===//
// mlir::tosa::YieldOp definitions
//===----------------------------------------------------------------------===//

YieldOpAdaptor::YieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

YieldOpAdaptor::YieldOpAdaptor(YieldOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange YieldOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> YieldOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange YieldOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange YieldOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr YieldOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult YieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> YieldOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range YieldOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range YieldOp::inputs() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange YieldOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> YieldOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range YieldOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange inputs) {
  odsState.addOperands(inputs);
}

void YieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult YieldOp::verify() {
  if (failed(YieldOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TosaOps10(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

void YieldOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tosa
} // namespace mlir

#endif  // GET_OP_CLASSES

