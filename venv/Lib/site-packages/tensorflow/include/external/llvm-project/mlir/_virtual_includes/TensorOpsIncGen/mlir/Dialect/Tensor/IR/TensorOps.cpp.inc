/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::tensor::CastOp,
::mlir::tensor::ExtractOp,
::mlir::tensor::ExtractSliceOp,
::mlir::tensor::FromElementsOp,
::mlir::tensor::GenerateOp,
::mlir::tensor::InsertOp,
::mlir::tensor::InsertSliceOp,
::mlir::tensor::ReshapeOp,
::mlir::tensor::YieldOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace tensor {
static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TensorOps0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::TensorType>())) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be tensor of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TensorOps1(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IndexType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TensorOps2(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TensorOps3(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().hasRank()))) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be ranked tensor of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TensorOps4(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TensorOps5(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((true))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 1))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1D tensor of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_TensorOps6(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 1))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1D tensor of signless integer or index values, but got " << type;
  }
  return ::mlir::success();
}

} // namespace tensor
} // namespace mlir
namespace mlir {
namespace tensor {

//===----------------------------------------------------------------------===//
// ::mlir::tensor::CastOp definitions
//===----------------------------------------------------------------------===//

CastOpAdaptor::CastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CastOpAdaptor::CastOpAdaptor(CastOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CastOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOpAdaptor::source() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CastOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CastOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> CastOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOp::source() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CastOp::sourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CastOp::dest() {
  return *getODSResults(0).begin();
}

void CastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type dest, ::mlir::Value source) {
  odsState.addOperands(source);
  odsState.addTypes(dest);
}

void CastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value source) {
  odsState.addOperands(source);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CastOp::verify() {
  if (failed(CastOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}





::mlir::ParseResult CastOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType sourceRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> sourceOperands(sourceRawOperands);  ::llvm::SMLoc sourceOperandsLoc;
  (void)sourceOperandsLoc;
  ::mlir::Type sourceRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> sourceTypes(sourceRawTypes);
  ::mlir::Type destRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> destTypes(destRawTypes);

  sourceOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(sourceRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(sourceRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("to"))
    return ::mlir::failure();

  if (parser.parseType(destRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(destTypes);
  if (parser.resolveOperands(sourceOperands, sourceTypes, sourceOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CastOp::print(::mlir::OpAsmPrinter &p) {
  p << "tensor.cast";
  p << ' ';
  p << source();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(source().getType());
  p << ' ' << "to";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(dest().getType());
}

void CastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tensor
} // namespace mlir
namespace mlir {
namespace tensor {

//===----------------------------------------------------------------------===//
// ::mlir::tensor::ExtractOp definitions
//===----------------------------------------------------------------------===//

ExtractOpAdaptor::ExtractOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ExtractOpAdaptor::ExtractOpAdaptor(ExtractOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ExtractOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ExtractOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ExtractOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractOpAdaptor::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange ExtractOpAdaptor::indices() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ExtractOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ExtractOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ExtractOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ExtractOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractOp::tensor() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range ExtractOp::indices() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ExtractOp::tensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ExtractOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ExtractOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ExtractOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractOp::result() {
  return *getODSResults(0).begin();
}

void ExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value tensor, ValueRange indices ) {
      auto resType = tensor.getType().cast<ShapedType>().getElementType();
      build(odsBuilder, odsState, resType, tensor, indices);
    
}

void ExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value tensor, ::mlir::ValueRange indices) {
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  odsState.addTypes(result);
}

void ExtractOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value tensor, ::mlir::ValueRange indices) {
  odsState.addOperands(tensor);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExtractOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ExtractOp::verify() {
  if (failed(ExtractOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(0).begin()).getType().cast<ShapedType>().getElementType(), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result type matches element type of tensor");
  return ::verify(*this);
}



::mlir::ParseResult ExtractOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType tensorRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> tensorOperands(tensorRawOperands);  ::llvm::SMLoc tensorOperandsLoc;
  (void)tensorOperandsLoc;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> indicesOperands;
  ::llvm::SMLoc indicesOperandsLoc;
  (void)indicesOperandsLoc;
  ::mlir::Type tensorRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> tensorTypes(tensorRawTypes);

  tensorOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(tensorRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  indicesOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(indicesOperands))
    return ::mlir::failure();
  if (parser.parseRSquare())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(tensorRawTypes[0]))
    return ::mlir::failure();
  for (::mlir::Type type : tensorTypes) {
    (void)type;
    if (!(((type.isa<::mlir::TensorType>())) && ((true)))) {
      return parser.emitError(parser.getNameLoc()) << "'tensor' must be tensor of any type values, but got " << type;
    }
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIndexType();
  result.addTypes(tensorTypes[0].cast<ShapedType>().getElementType());
  if (parser.resolveOperands(tensorOperands, tensorTypes, tensorOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(indicesOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ExtractOp::print(::mlir::OpAsmPrinter &p) {
  p << "tensor.extract";
  p << ' ';
  p << tensor();
  p << "[";
  p << indices();
  p << "]";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(tensor().getType());
}

void ExtractOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tensor
} // namespace mlir
namespace mlir {
namespace tensor {

//===----------------------------------------------------------------------===//
// ::mlir::tensor::ExtractSliceOp definitions
//===----------------------------------------------------------------------===//

ExtractSliceOpAdaptor::ExtractSliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ExtractSliceOpAdaptor::ExtractSliceOpAdaptor(ExtractSliceOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ExtractSliceOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ExtractSliceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ExtractSliceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractSliceOpAdaptor::source() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange ExtractSliceOpAdaptor::offsets() {
  return getODSOperands(1);
}

::mlir::ValueRange ExtractSliceOpAdaptor::sizes() {
  return getODSOperands(2);
}

::mlir::ValueRange ExtractSliceOpAdaptor::strides() {
  return getODSOperands(3);
}

::mlir::DictionaryAttr ExtractSliceOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr ExtractSliceOpAdaptor::static_offsets() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("static_offsets").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ExtractSliceOpAdaptor::static_sizes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("static_sizes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ExtractSliceOpAdaptor::static_strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("static_strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult ExtractSliceOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 4)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 4 elements, but got ") << numElements;
  }
    {
  auto tblgen_static_offsets = odsAttrs.get("static_offsets");
  if (!tblgen_static_offsets) return emitError(loc, "'tensor.extract_slice' op ""requires attribute 'static_offsets'");
    if (!(((tblgen_static_offsets.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_static_offsets.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tensor.extract_slice' op ""attribute 'static_offsets' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_static_sizes = odsAttrs.get("static_sizes");
  if (!tblgen_static_sizes) return emitError(loc, "'tensor.extract_slice' op ""requires attribute 'static_sizes'");
    if (!(((tblgen_static_sizes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_static_sizes.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tensor.extract_slice' op ""attribute 'static_sizes' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_static_strides = odsAttrs.get("static_strides");
  if (!tblgen_static_strides) return emitError(loc, "'tensor.extract_slice' op ""requires attribute 'static_strides'");
    if (!(((tblgen_static_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_static_strides.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tensor.extract_slice' op ""attribute 'static_strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  return ::mlir::success();
}

























std::pair<unsigned, unsigned> ExtractSliceOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ExtractSliceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractSliceOp::source() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range ExtractSliceOp::offsets() {
  return getODSOperands(1);
}

::mlir::Operation::operand_range ExtractSliceOp::sizes() {
  return getODSOperands(2);
}

::mlir::Operation::operand_range ExtractSliceOp::strides() {
  return getODSOperands(3);
}

::mlir::MutableOperandRange ExtractSliceOp::sourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ExtractSliceOp::offsetsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ExtractSliceOp::sizesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ExtractSliceOp::stridesMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ExtractSliceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ExtractSliceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ExtractSliceOp::result() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr ExtractSliceOp::static_offsetsAttr() {
  return (*this)->getAttr(static_offsetsAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ExtractSliceOp::static_offsets() {
  auto attr = static_offsetsAttr();
  return attr;
}

::mlir::ArrayAttr ExtractSliceOp::static_sizesAttr() {
  return (*this)->getAttr(static_sizesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ExtractSliceOp::static_sizes() {
  auto attr = static_sizesAttr();
  return attr;
}

::mlir::ArrayAttr ExtractSliceOp::static_stridesAttr() {
  return (*this)->getAttr(static_stridesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr ExtractSliceOp::static_strides() {
  auto attr = static_stridesAttr();
  return attr;
}

void ExtractSliceOp::static_offsetsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(static_offsetsAttrName(), attr);
}

void ExtractSliceOp::static_sizesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(static_sizesAttrName(), attr);
}

void ExtractSliceOp::static_stridesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(static_stridesAttrName(), attr);
}









void ExtractSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value source, ::mlir::ValueRange offsets, ::mlir::ValueRange sizes, ::mlir::ValueRange strides, ::mlir::ArrayAttr static_offsets, ::mlir::ArrayAttr static_sizes, ::mlir::ArrayAttr static_strides) {
  odsState.addOperands(source);
  odsState.addOperands(offsets);
  odsState.addOperands(sizes);
  odsState.addOperands(strides);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, static_cast<int32_t>(offsets.size()), static_cast<int32_t>(sizes.size()), static_cast<int32_t>(strides.size())}));
  odsState.addAttribute(static_offsetsAttrName(odsState.name), static_offsets);
  odsState.addAttribute(static_sizesAttrName(odsState.name), static_sizes);
  odsState.addAttribute(static_stridesAttrName(odsState.name), static_strides);
  odsState.addTypes(result);
}

void ExtractSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value source, ::mlir::ValueRange offsets, ::mlir::ValueRange sizes, ::mlir::ValueRange strides, ::mlir::ArrayAttr static_offsets, ::mlir::ArrayAttr static_sizes, ::mlir::ArrayAttr static_strides) {
  odsState.addOperands(source);
  odsState.addOperands(offsets);
  odsState.addOperands(sizes);
  odsState.addOperands(strides);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, static_cast<int32_t>(offsets.size()), static_cast<int32_t>(sizes.size()), static_cast<int32_t>(strides.size())}));
  odsState.addAttribute(static_offsetsAttrName(odsState.name), static_offsets);
  odsState.addAttribute(static_sizesAttrName(odsState.name), static_sizes);
  odsState.addAttribute(static_stridesAttrName(odsState.name), static_strides);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExtractSliceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ExtractSliceOp::verify() {
  if (failed(ExtractSliceOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps3(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}





::mlir::ParseResult ExtractSliceOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType sourceRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> sourceOperands(sourceRawOperands);  ::llvm::SMLoc sourceOperandsLoc;
  (void)sourceOperandsLoc;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> offsetsOperands;
  ::llvm::SMLoc offsetsOperandsLoc;
  (void)offsetsOperandsLoc;
  ::mlir::ArrayAttr static_offsetsAttr;
  ::mlir::SmHOu/]#ıkÒyâ¤î,û¹œÅgìØã(9*Zíÿè%}(^Û0b_–(sebíFFqsi|Ú<Š% ë$n…›·?šfìœÕ;z¹éPOè-v]hAàõjFóz
!:®dk|)Q0ØntÀÄÒVW<«cñíˆ«“Aşc)öIRPë¢yêîÌrücbŞ“Kqêxa5@¾L .<±ÉLá:!¿££pÔo¾0Œ,C+4åà+‡:9.ˆiD/E²ÀqR¬DLmÒÏò¼UA\`¢º„,|Uù``…õ^3µZ<FU+T ~óue.ÃjØÂ^MAmHsÔ6ÙUSpWRjjÏqËß¤ZÏ|®jîÍp:¸`ôiíoa°XnôççD3¨u‚¶P¨-FÎxŠ{FñÁĞÌBÄS¸j?aaW[wLélYMĞR+0Ákßİèmzø@N5h^c‘ã)úífkÑ­U¹|ë™4u>
ªEå7‘öü9hZêI‘V‹ÂŒ /nAxà?DhxŒmOÊ~w¨³yRx¼şª¥zïlşYçíœR§³‘£KC‘ë6Ä{x*{™qÁÓFzwt–è}VØ°fÆó‘<{	ja€$fİ¾ÓP¿GÓóÈ6|`ºÅÜò(«ìY¹l°~gêUçÌ\yÀ µRúŒaõèoş)?AãÅ³§…."NzÑİvÂÚ&¥ Ÿ²ïÖM’€ûâ,'¶ûaNPoy&,bm{|rN^-E¸VzvK¯X¼=û®'ŠËXªĞÃpù	Ü¬Û_I!êc:¬<fàä\\èSc—íìjKÃ¯L#u%È»'¨Š: æw–z„2!ıæ)<®æÁ)Öy.ë0¾a…9S³È †Vç\Ğ]÷ÏZøUğq#†Izíâ¥‡­ĞZ_®vìŞH ‘@jW
FP.Ìk
LÑ)³?í`‰B µAÁÆVÍO@Dç4åÈh /y3µæsJ£-¤ŠaëS×ŒMLeØõ[wÔ
sb¸¤²k¼FJ«üŒÏ%â.ÚA¦ËJk’Ñ÷Á6gutç@4•\{U…Õjâ‘£©b8uŸ‘	<š¨¶Tgø÷GE–Ó¢›%Rp$¸õr…Vî Fá^Ğ¤>±¢Õn·+ÎrAèãÓO_ÆÀ7GVt„qUrˆÆ«ùİbwaIóE7ŞùFKÌ÷Äø³ë¤Œ$eÄ¹‚Âí®EzóÌá™~şÉ!~¥qÚ5ò–/Lô’aû´ØOL6gívÿ£qÆ9€	.k7tÅ2¹édYXdh{á2¸úò4ã€mç¥så•`µKÌ¾òºé­êBw%Ìö
mŞ4£ÈT™êñ£ü8p|yTàcÇ hT`$®xTF·>ôP›
„6Í/d½Ÿø¼sn#zHäËd¥íÙwŒá3¥åŒ`Qmæt¹6z¯L,ÚİÁNóöëêw°ÉÎae^åÑ‚33ĞO«6?S¾BrÉ¶Ê<«¡<+tò±@#PY%BAëd!â¦ `sBú#`;§ivqÌVğwæïN{=.ÔlÆïıUÎ«ù/èaî¨ÄP¡äw³nîÆ²«QfzÊ÷] ZWİìzÅ»©ASM#K­Ô÷ı1	qv­÷Ş(™¦5‹4ÅùÅx‡^ ~K;<hÅA-8µa•è§âÁmÇo qü)#;¨1"°w bs¯Ú}8TÆëv¼JT'e•tÑ%‚N¢îŒÊï©…bé]zñr@ä|r$iµ\& BñÔ]>SnçgWà*Bã(PñQo2³ínù’fa'ùzt\' I¤]"‰c²¾p2õU’N p‰gt•qvXNmFß,¸TÏtDQ@!bœpE->â0çXÀ2¦Uà éS€Ña÷Á‡lB±X‡äàìlÄÄ"ôoi	Y²ı¥ucV$œ›E‹Á€pX#‰s¯kI2.Òqë_0$H$ÚsöÀæ%t¤˜C krOÇm¬Sğ7-j&Ş­$Œ…†ü
1`ËBYe Oô‹qgpÅI¾
ç]KøõMØâótÛ8æyv"ÚQ÷KXaÛD=ÔY~×oD›há&ëÉË¾Õ1¸°ëâr²h\vù\Têx°Ë°2ã	ãkmiT'"‰)÷£¤Àñ7[G˜F)1 2LYs4·eIH~(.	»"*9)yp‘|ZÎxwiëóàõ¼ĞíJ)ÑÛ|ìÒãfàöeàŠMÊè
Kt1æÆâQê n_k¬¨ât!ßI¥fÁ¡9Ÿ£ r™IõyRš1ĞÙØe¡Zfï^‡şiPöEU­:ä+ùûÈÔOòŒ#U¾V†i,Òdc?›74„^bî|Q$<¾ˆğVÁAsdHÌ&YlDy@nàz9ì\ÆïyŞH(‘Š)@*qIÙóŠ÷ÜZSÇ¥|Ìc`AO­(#ÒQG4ô#ÛåÚ,`-’¤MÏXcÀ“Iz—wÄ66Êm-WÑ*çñ®ŸuF_j‚{Gpÿö<óZPkó‹’¸/8;v–3"dtN—5K0’kå ñ`Â~kT¤dñP/Ù]\e{~ÌöNéùalÆ7˜"ûôÜ+ãò*üõZI‡d©­r&`Bxi‹<@8íuÕË0J|xg;aáñL@HÌE`Gæ^í.—@öReTöD’>ñéuáüºtÔioÕ²¬h™f·¢a7†ª~¼zÍ`œaÕ']oôNğÄ ã¹®u\pgò{G¼cq£ÎÄ`ÇlêJWå·hø”%xÛ’âM|Ñ{r{N_öîñ€OÒ¦+”8
vuv³¨âŸ¸ßfìv#ªa8<Ê¢é#‚õ¹÷4QàCò—h‘¸GÁz$fuw°¤æ§.ˆt²fGr{'ş{îèe³$¢lTòºJgúAD^kšñ{2‘:5‹TušÈÓe[”¤dñïx“øa`T#Ôö½n!6Úü‡Åı<ŠaIédgÒÇ-SM„øÛ³x}D÷%iÌğILæã2ÏÉc"@áÕmÊCÛ÷/çäù™xı[¢q,^™q½R×+ætQÓ¤°hjCĞ1+¤ïË„;!~5¨hq6±Á»fÅ
nÚêÍıÙ~B.×û5OE:.ÃÀÒÍ|Xhvıêá{l»d¢"ú÷	ãigO8§ØÂ“\s¹Ffp•øÖ·yqd.SDuxî[ksÕ¢^Š>ã(,ìË&AdE]'Ğñ‰QÎz³äÀz¦ßÔ<6ú`pËdµPÆ”=¢ãìÌQ €}è'i+˜¶¨æ
 ÇÕ[Sï0º²‰~¼W>È#ˆÁ[Sx/-(EÕop	Øf$GBlB¶÷±ZbÁCAHC˜¸e,!ƒ2bu'èH?$p•ÁÍmÙ1%h’!h@@*ºê
Öi*Zìlû7Q!eFPk}ñ¯º]|ı†Nu¨ò¸¤© ù"9îñ©  }$scklé¬£!Cl"êÒ)ü1øaÌdzÆá 7#V«tÖWcP›Zóªv&zË\®ˆŠãL,Œ6Rb£T*t æî>ek6³-ë$ìû„i}o"EXB$³-q§xIâ9º	¸j£·¸¨Y±6¸<
¥DGUz‚Æpµ^P|G¬ÚùVfıç{r×Ş©ı‡@y/uH÷1C¢÷-ÍYq[˜ÇWíçâ{]ù•+ÓÑ/CzPÇ17¶Ê{áAÙ›Ø³t)Å7n•iNğ%ù}szbL°M#Å¤toıXıävWÖàVÃÁRbÔèï]/ù~	ŒÄZŒd"i{¬Tğ]ët3ã 'TÛ ÷Í7J"&4}¹ ¼6r‰±€l)#èò¦jh*HæurÖ0OãîEF{Æïíé«Wèš ÷Ra7.Ãé±öSLRiˆi'„hìº{RDŒkşOZk¡‹±CĞmzÆ-&[ÉTÃ­ÈÃ}ƒbg£h’"µz7Q°kµÒÄ$ÚjãWsáÂ WTµ7»õÛÃCZşœ`y&ËtèeyÈqµ 4
šR‹2 !
1v@V6À÷“Øc!&|Øˆoè£ê¡m0‘ª¿ÏÃ—|XÓoû!Øñ«¹rÄİfáèx‡c…RÕÚËƒdqâZ«Ë^M²s½ª”—@<qM % 7Ë°Î%§d}I8`±Cd5-«÷«?h´{s§=Â~€-R°AâÂaz|r0LdFxv¬U²d>ıTÕm"ımH‰-)uŒİkÜ¤ƒ	­‹*v˜ÆÕ_İ!†`Á²PDt,W (`GTíÛÂnLë\d)Ép³ së”Rr°ÿF…eímktÜô“u$6p»ÜÅp±¼uŸf»<ğ*?Aa_4Cåg öEcÑ¸„w€J8lŒTcëR³â+òÓ¥)ÊÛXRV&AVÏË?uO=eHe0
$·Ä 	«ÍûÜŠv”	Ïj*jr^Z-Ël®toh]/â  ¦~xÔg¯cea×l`jEßgÍ$k£åÄm ú_åLl9yÒÙ¢uÀ_€÷	"'8q'—i1-‹‰—}OÇ¥¶,Oa¿'½ÿ«4¼Q-,…¬jİ&/†«M5}€Ï')% #'©;3	u](HD®7c19.¿)Íw«©<'è¨ˆÍäé–` Iæ[†EğåÓ…´yï&®tûÇ(M+Csil9J‹#ü7a“É§,ca‡ òdï
>k¹ı;}Í£ÿ>¿-»<­)¾Ÿ-ü'‰{5=”ª$<5X-9
û®)¬íÏ-$ô¤Nc®VÕ
=6®ÈÛ-çi	Kaß‡W<CGÑGóïò:—G»72V?mø(@I{ê×*Ç(!2ƒm‚o ,©vĞf_Ôq)M…Ü‚™˜fñíSãé’;ÆL;hš°£lƒf\wPGò*D)fÇz4ÀrMÒºM.éÅ³B§” ,L3±!mÚ%ûgT<Ò;Ìê_ÄGe}]k«Èl,^Í[ôg¶â ªı\û{\äX?En>R3"G\zsÎÎÀmz»%ue©š.2¦Qª+º‰'
dèmõîªv^øİVŸT¥A@B§ˆœÓÇÕs)Lq÷q¤³)à«[şír~¹ŒŠò`Eæ#e.ã!E~ 1[qA½e®%Ş*Qô`Ùpµl¬ØB¼ÛCú½öLhÀ˜Ù*c8WøoÓ5p°„v0u 	>•µ×QÜôò 9C.jå?ùxÔ=´5 pzÎPgáÏ.1(¯¥TÛ÷eœiæ,`Sœ±:Ô
€J¬Şd \¸¢S§ˆÙ¶xáÄVÃxƒRŞ/LlMeVœ'õíaúÀY_zW—ëì|`çrÀVAû2(-j:¦	E‡ôÿ>Æa:pgp0n,.o¨½á¨‘t®ºĞ}şåpÕçnS®hníE®€4fŠ~µzyæ3C JÌJ|Ù‘«äàÄßªäHã~|´a-|¤ÓÁOèCğ×t”£¯ânUmí6g[|95nuczún!àöÿÖ‡]Y¸+"a¿pg¥C#24ûItÍ7
Oì_ùÖ6Ç,–©`‚”L}Y.û`Å´–m)ÊpáÁC{'ìNŸDfö{§Eo u;İÙuŸGlB$1C ÃÀ1(h—Ñ¯HılFè#aÉ¯û[sdÓ€ë*ÒÈÜĞ{Apao9£^ˆ³;ÈG„şW¡ª/¦.áo‰é²ÀõÌDÂ¨”Oìh)è¹©q«–wFjScäu¥ÔhøB~!MfS`1rViOëc»XyÄ@÷²êæ!åœA«$ Re>Và>|VãºÖÒXÙuEŒ¨
M"•DWPÑC+ãò8¢aÄ“ˆÊ¡”ug¾eá;,M@[ámZ$ÏfUVr\ÈMj_š4æ"CyÉ—OîC_ìB±+åkm\ºø‚èT'@ ªštçmü#ÆA:{K #&C·Î VÎÆ+^-)ì…2(-9d¡§ÄYNMd‡ÿb@¦ ÂØá°uÀSûEÈc9g"'fË¤¬cŞÜo'áèa……6§NIt&åâş’@ˆù(Wôãkg#mÁê‰Gåg#£¦"˜w;<»È)Š.™T3M	ÔDs¬MHwpş‰KBÓƒ[vg¥=^}OO%(ı½ âOİdv1µl9òWu.ºo r7yßpœµ‹¾)‰ên.:>=	.Ô%Úa¤èÊüy:çzìhw`OÁŸç7CˆĞ‘ 	´Äâééeya”~sWît½x…GéGŞ'A\L0dQŒšvş*Îo;9u%ü5l{	~Aj0(€ÁA0Z%p¬!.Òt6x•z	stâö`bB0‡'UêP ”vİèêÂlÖ‚–ª–9¹hpyÁvj§35cKZùAƒ‚ğ '1“i~ej”k©y<«‚I*f«b{Á:¯‚	UvéıIjzíÃ«iAb)‘ÀëÒg]áw!°0' ºï
aSí¼“Kjâ{âTQæÄıŒK»Ú} Aÿnb`®I¢¢¤Ek-<¯cöeyìÜ"½W|7”Ïò‚wLÑKfAª¯Cº<Şí>`¯MåMà`‹@:üï
mpåm³îRYLCM)@ïÑºŠ}H™ößI|ïØdn#‘xs}ôŸpj9nö'n¼hÃ®òM âxQd}fÓ`-Mb!e)¦GJŠS|BeMrî5É¦c?Öê’|YiÇv<ª!y´è#¬ôáó–i2ÓšÔK2ÌJ[ãs!éÂ® $3ìjkñD4 üğ´S¦Ä
-*eßw/Ğ[ÙĞzwê­?EJ,ø¤ö…È[¤N×Ş±aê¯äĞ†’ÆO{«lWf³Á’x»j¨í‹›|~},¥5=LKX
Í–‘ÅDoò5ÜOÎJédvd¶$Å$Zw8ëfùûCUÂª÷oEì¸ëèü ğ8úPÄZÂÔ €ë$]`õUdºéc3J}†Yº’?MM!£	/OûksˆZk		^tà‚®%-kmc¯gV˜?Mxg¢M1O:º£sZs)æHs°’¢…{ªs®“(<Å¼!zZ¨m0¼1îü°³"ğÁ˜6"=Ôyø£ÙY¶lc“qßÇaWú6.vË>qÅrwtÎIùP¾ppèÅ9º«9e$£\yLóÂµ)ªªKóì|+êµ4+S´ÛŒòì2!Ğ—ÒÏ"¹üaÄ/"°7}ÍægSQ¡²7ìÂËÈ*	ùgF²X±Â»ş/ß
Zj5ä$‚Î}ô‘rm¸º)êP‰ı÷bı;Çì“K-ó5“KÇ’eóõVã-Ç&h·ùË,!üe~}'‚BJ@×g{DÙ7Ù`B‚av©È,\T!eHW/vâi¶/=ÉÖĞ3gÏ ğóıŠ(ÖMV0é‘, ¼a°sÁª¹v{/İfç’U:Æ®ú`HNMãi7í*	®ö­|ûaøW¯ù ©2>¡Á¼P²ÿñ k8q*O(.n
†¥jıC– )hñ½´Bu%7,‰´`–°²T¸ÄkåÇhÄÉG^×ÈÀ&ˆ!Ñ}n1fÙ×äë4ğÚq`hVP¢dÎÎó&æ·¼SF\&¦máÓŒã,Å«3	A²-K  uõPc6éÀun[Æ_Qéqà<r^Åa–ˆk,†ÚP<R±ôàïõ<÷î½Ó€á@Ä(äS³ã6|~s‹ğÜc==)ñ[ç¯):¡ãßgù|H#(It+7àq5ŠaíMé²ôB×aàŸüü0 ‹lqSaÙ2ÚeÃPo<Aı½(¬mûêºf,iïD3IÇÜA¢«Kóäò×yLsÈ€=2o‹¡(“",Èc" ª¡LA$3ôS¥È$És¶hé­iÓÊXè¯óˆÉåjde0
,vå,i–àgÚ‘ıx Šo ±Z vùª­¢KKaì•Y`Êª—¢„o1Å¾íôÈ?ŞZX'òé S~
L3ô§r#µ3ò­ß¤#QÛ| (”v³j{›*#nFùÅÏ‡w[Q„bù¢"ágúÑ¦`#*r÷Õ;¤ä´ÔfŒ!wÑ\Á	Å<t^ d°şÍspgW j÷­r€äÌ.{{xçŒà Óm°$Úqòí†oÔ äVÀbo@“‡Aàôıˆôé£-QôÙ4x†˜XO _^r(üÍC'o3hnîO¦t|2O°4$d…ALÈĞ³¶Úè‰a{6û 4­ 0Ío%. ë°(heWËqni‹FiyIi/61‚HĞÚ`¦Ò+^ª NsO5g’LXjºbóİ×í"ïjóÔa§#Ã"^CGãhÌ%èÇ=%
&Ix…`3m9¹ißço¾CÊ9ÆT2òô{ğ’¡V}óiúÑÊ:›g°6N;_"V¯GNz>ığAşÅ‘‚o¿³Ueò`›/¨L\ö	Ê>YÉáiÁS½ó¾(jšTóN~~Â…zuÎ4·<\nrså!Án;k:øì¸ #Ì‚|=O'w	Ì|LÒÎHŒ=Ç$‚eØÛ/cE³hÃôaEÉw¤iàM`ÓÅôo`¦µ	«ª¡*
mmÛ¤Ò:ı©9Š[™’÷+§gë`÷Fv¶=^îè)ÔâŸºåïÎs,‡ÿf3æşÏ?)r/qr7-Ù{RG!:!ÂWŞMmên¨!á¬u¤¿9BîPÀ‹åp`»×Tw™+mW{²	y#¦(xK!¶JmÂF`ídh'»UEß¤ÍÇR
ç<
vw=!2Ì$kFÁe³ù»ug(/Mfm­z$Ş0{ .eºkÀ+³G%~;aÔH•#TQ[ÕNMÊaŠöä"öã/ÅÓ Mé ‚áèàgºÆ<é^InV}×†¼J6\&WRã¿¨°äDKÑ¾Lrëbá3¥}ª'®S¿hˆóŠ›Ê}`È[­i50a½f<æeò"N3(áÉyş,"òsõï+<'MäfB{`w â	\1¨ÂSÖzĞ$ïsº¦T‚?üÍ¾š²jåâx£VrO_grU­Æ*fÕqç(¬éªM¼5 f¢²ô lürâî%­ÈšƒnN(ïõı!3MPBpña€VÎlŞã­AŸ´Q‡]Úrá{ÌEáH;ä¨_æÕ5¦Ğ9vZ9î":_`½±¥/Ì©?Ò}ÉŒ`Ì`÷("gšvÌñï)ñ	ÇÃtf,†şgV5÷8F__Š`LàİE 0gT/ó=	"%UÛ·ºèïÙÆ¾u+#×ŸF?6Ê$ví0+µpO=ie6äçğ‹ÍC
ù½[aıÉvı*5dç÷ñ¼*|–)eÙ–:"Z>¾ñ(zèúŞ¢ã=æìÒúEı“,á7EQ;¼çôFxÁuÁæ®ŠJOpl;‡%°n‘Få'eÔ"ÍO{ûV­$ÔÁk6¬yI)ø4ÙgÓB£=~0º˜Tr‹¡6óY*aÍƒCş e$Rµ&usM¼Lê¦%+L¨R/D¸UyÊ§fÂLx|3¬êV5Œ”ˆI%s1)Ôƒè›ızù'hiÀªbÍu|p!;û®ÉO:.ë0Ë
±,AUG'=¦Í¬uf9÷‚6¥4©çŸƒ±™SÕİ¡ÁŒ'b#eª3„‰£Ï#,;-øt½úwBOEbeãÛK9#™ÿU4n!@Eæ'¥n[5ûRÀ!û(»T!B;ggo¸+X¯ +oN›mÈ3 M‰{*'`I9Æân¨áRÑ¤1²föóøéÚs“u@©+`ïâí?ÓVÿhoÛ ç7ÁY-¼óÅ¯(|C"{+œ."ñí,ˆıIA
ÚWfÏØ·ÙÇÇ ‘u'qï|Â ëÜyedäçqæz"2w&a÷ğ Â%ÖZ
j\/p+×™m^T¼Bzáêäü-–iâWó1A'şjûbo)jXøF
¬rr`sEÿˆ/³÷²)˜G— Õ­PJ7%­ğÔa•Q6fÑ=vìd_n‚¦È©ëf<ÖÏxmû7jMÜ0h%UäTôËA6ik"E^>r†¡¤ò!ÃXgéd Hlmu<“Š#›zìnü-ÚvJ,´mÀzœŸƒ0
^Lv+ 6İÂQíÉA#u(0™¥*‘1/èÔÒ¢*ZgtzPÃÎãl]—ÃÜ–2ø[C‚Y¤bqUz,Ã¤šÅ fQØ‹DT0ò;ûŒR2éşğ¢¸Ô’M´}ĞEÀ·±î^—÷º¬}½Xµÿ T7YtmulÑ_tewö=cAP™}ú]<t—PwfuÃ.‰w®6v¦/EtÛü:i4÷»@ˆKÕês üd80i¬ÆuyŒ´\ú`³agSl¾P°>x°‚±A8"½~ã‡u°Énšù"ğ(Şƒ‚/
\Ú§Z©y“"`låœ%°N"t< éÅ8¼*j³Ğà ..gTó(˜ö$xöÏJ`°6`GY?:š]Ş<_ñŠ9uºy™ë$pYuÎÑ˜·féçyùÚ|V}vX3}	²Ì?³W Ä:ìnDz_@);d} sVè,UaM²©p[¥{ƒöêÎ(¡¬H+U/™b_;ò:qc$<,á¸[œu…g¬Ùd(9jRq
é4p(&4b+W– ìvf_ÊV1ssÉpß|Ë%pOtb»ñ?ªf(¼ı¹r¸OD4H-V})%È´*’óhká"®`aFXmq8˜~,(¨qD>»r_ğí€-³I>obáY‘o s¨îîB±'"Ü€+1öIaep»L 0,(<Q‰ g.% §¢xÈgº>2,Áš-uÅá+º=.Œi!.Å0à|Be”tLtspUM(œ¢ûÈl,m­@xeV'”K<GsW%U3ä©sb«ÂêxæåGMHt”.Yx]`WRt(Cp ÛİTØ`@<ºoêEô>,|–yí~(±Hj ç§Ds9u‡´A oFÎYˆ{d1UĞIAbEp*;p)V÷eÌiXe‹™.%GPkÓİà5zøDTmc™£Gèä6n×mètzq$(<ë1åb<|wahJcI™V‹ÂÅ®/T+@él?e,x¯eN˜)¨ 
²x:p¼öš¤Ûîüe§íœR…›2§ec¡é2l}| ¯{°ue¥Cl×}xeè$Wø´&Æ÷Ù(y-j'a ¦gİ¶Û!’%G—÷¨uì`ˆÅØÂ|‹àI¸L;&jîDeÊX ¢¹Qúœ"ñ8/½/iãï(µÎv^
ÂÕ":&ì¤Ÿ#ÿAÓèòLs¶za(À?m&(ne2<’Ú´G¸^;óK¯X¶>ó®gKËX0ÄSI]‰Vìí]X ¶#e„¼xæQ~mˆƒC…åäaË‹¯M#tgd³&ğQóÑ:æwŸ[$.Uî!ô<>æS(óynêq¾0c‚3èIÇçÄ7LpÿVñu2ŠxúìâOeÎ´Ô~¾t®è •iêW{.ÔC.àS)ö7LrÅlb$5QÉÎV_*PDf}&Èy'y^1?ç3«-ª"aªSSlmEgõwwt&ì¤²eŞK*îŠì¤z®Û@²ëJiY]e‘P‘¥,}pçD4•TwG„]jÊ™#¹b8ñK¯3_<Š¨’.&gø÷G™G¶Òö›esv24uğVœTàZÚ¤>Uí§Õn3s^:í@©²K]GE5SRtÆ8ñMrœ†«¹\5n½!YòD·pùGËÅÄãÔô£éö4l'µ¡ÈÆê, ºòÌá™vÔh!zµzv5pí–/Dx€ú4È_^wl(r¡q€FpuImk3–ç°y©$8l`Ûs28òú #;€mG„3Œá(Œ·Gœ>Ê;á­êfu%äv%}0¯ÈpC³ü|øxyA``æ¬ V`$®hUFô>apŸL5M'f­Ÿû'xS ‡#ĞL%O$;íÙWd2=å÷Aq=åt)>z+Mn¼™AMóßrâGc6àÇÏáeMí1
8;0PË¤¶2~ ½Rrˆ¶w
¼)¥ztºµh+R}dgÁëg r™r¦Pá;BÒy`=‡Cy'qìGpufyne{?&İ¤â­¥Un9ŞDôù2ï!î¨„Pb!¨w¡jnr¼«‚•frŞöZ<*JwX¹æj˜¿©,afE¡SĞ-dİõ15q6}µö©•v>1Äù xK]`tK¿|hI ²4iÅè# Ai¼N,c8	g»è1!Ø; `1s«ZLTÆ°\üJ]¦$50 ',(ş4ŒÌÏ©¥ éOx‰q0tôXf&a½s>O´ä]*rlæ$F0)fbY!EùYm"»m®øB.0¶iz\&$i¤H"Îc`”ÆP"Õ]²o xïpa¶XNqD8;COõER@6ci˜à¥9b³çIĞ¢U ¤iS‘q`õá¥& ¡I¥ü ílGÄ&t/i’ø·ucW%\»UŸZã´8#	sì§h0¾ÂqsW1äZ&÷{tÂç e‚úÓ i0^m,s''‡a
4§%<Ì¼…”"`ÎKgNO$Îuoqåy¾^÷]IøqM}ô³|Ë:uy4jqóC ßwxd=öy~­×mDèé :ÙC®ó—>ş8´ô{TòúlEtc1{Têü¬É0s{	›óimé"Ô5!ijw¯,ÁõJO¼DQ 0ÚAs(57u`N´;n]T^¹"*s8{ “lÖx
kË¾àyüáíHN)Ys]j“àddtõ@ŠMÊaKv5¥GàgA lW; ©âw¡Ö	$pSÀ¡*±‹E1cÙqÓrĞuÒùØ6E)zto^×h}te’9?ş(k½ÿÌŒOdáuW†y,²mçM?M;%4Å$†|¹E$9>¾£\|fÁAb$BL&}nd]!?säz)ìIÇ.õ2R •ÑÂ;@G‹eI9Ûnçü}k÷-9Ìc@rA/µp"Ò_z|i3[í›€/`doó¬O\GÊ›L?Ä&Ô2Èl	,W}(ïsß}6SrjeHn¦,=óz HI·‹oö±/0+f— "xw$MV1z’|=yç 9 árZI~Dju¬es•0‡/™u(7z|¬·wùı;
L$3 :?õ=	çúd<¼õzHI ?r&`y(0<@˜ouuî1Võxw;!åù`THÈS`G¶rgÁ&ÕPov2äpö(T^~åëeÑ½ÅtVh+Æ»ª{Ÿ`u¢<07 s(~<NXaá 'Ys5Nğ8 '™*å^p'äK|<2-¢Îvh¸ELújqÅ5'h¸œ¿nœòº*I|Ñ¯póMş°}	OG$u¯<kvtV;ˆúá}Fîö'¬ÇIƒ°=h&M…Úõ­·4gÊÒ—h‘::Êä:&j
mV©
Åğ£Lî#fur+:¬Oèÿ»c$UršB'~kŸry;È:a‹W#¸À“m[°¤hõíxüÃ[a@g£túµç0>İşGÅc-ú9IãagÆg/S}Dø
“8Má!ioĞhnìã0aéc=< H!ÏlšêbZ,w.÷p¤“é™qlÙi¥Qc~q7S–?¤|pãàšnxÁÀ1) 1mŞ€3$#¤N61ßº,å.Z(ÈMı	~ <áû%l-`nƒ`Í|)($½=êyY-»d¢&û7	}k!İ=«ù&š{¹Æ'bø‡6iq$,,TDux>®û=Õ…´Z	—>é®hæÛ.DDE0\GrqeN{³åPxïŸô5&Ê`xI%¡\ş–9ªoÅÍQ¨ˆ}9ø-h+­Æ€gİ=Sé,Ú	t-eŒ /Œayo­<Äıme)˜f%Gnl¤j6ç³JQsHk¹E-¡›òch/De8åáDì¡m h2µè`>“*ZV+}BS<pÉ7Õ#m j}Ã/ªsSlıFgıêÂ0¤i˜E¼:x ?:øá`XU-ûgëùIì#aAl2°à¡ü1q(Hv:Æè6$#Vãd‡s&P±Vó £v'hƒ®¨«D,„6Vc£d*dâDï:es.s5¤ìzĞzyO&Fhbp*2y£øib5ºZ°j¹k¿S¬p1E2ù9Y%Fuú‚Æ4µ\a<g„ZñVc|å+r^©—qveI÷ÙC w=×Y9Z8veígÂ;/ø—+ÓÀ/.;SÆ%¡#¤NzcAŸ!Ä—Ts6,Åsî±éğ!i{qz`X0M#U€<*¹H<ôá4CÖ`Ï@rkÜ(o1¿í®Tÿmä#j?´\àG`5b3AãŞ/ĞZ¡S?K·J$&¶m©!¿2øJ°¤l)§d²c(.u†uj•mãèEDSÃíïº:W\ì›0ôrá?çÓI9~sI"ày$r{l:"ReşO^b!;˜=SÂ`HV-d{È*„Ö·h¡~€f² HJb½
'Qô?¡‚D$’hã‡sãğ	0Æµ7>ÚBvşÎhQy$ÊdªoyÀ1&>uˆ3Epù;?(!
qDĞøxWÅ»àQ.\ĞŒÓfgè³æ¥o°—¬½ïË—uRÓk³+é6p«ùvåßvñòX…#‰C@ÚJÅuñ`Û?ŠK^@ºq?Êœ—J}4M ! »­"eç``$}I8c½C!79³øjw`´ks£5rd­P°Áh_i }s0H¢Giö¨Wòd6WíFå­ª˜ù)H‹)!Ìµu#l ‚
í	;öšÆ1y!ÇêÁ’pFd,w "`aTÛ ÂnL©d:ÉP´!cë Òr‚ZfVåq×—|.t\öuó•$/~ûÄõ(­8Õ>v»>ò+?-a_tJì%SökQ°EwˆJ<lÌô{kR—â’°!)‚ûFF­A¶¯NYuo-g%!4´ÔB¬ınúÜçÕ)\Cn òNjùl¾U+8t? ° ¦tpôvªCuJS_ô`
) ErM'9ªŠmi¤~z/e\l)yúÙ§uÀ_@·k xp3/bp³)›“eOWW¤²(Oácæıû¡.¸u;C¤¤cüb»¦ˆêm5U%ÿ'*% ®#$©w3!xt hD«st*Ÿ
iM{g©\©l'ààéÀä.0`#O¢xÆgğå¥±yê.ü°ş…l¯o(£tj|tLC1àVaÃŠÂ·&cs0sTè
<êè&sİ#ç>§=n¾-jV¶-m`ôc4‡{7I?DÔjm5y7)¹ú6 nmÛ,4àpHpû¦Pô$v>Ü[-ã[b	+AÂ‘çu=VÑG»"fö7Cú?a^&mØ-u!k6jV+æ(q°£aw,OäñØfVôs!M‘ü‚™’X¹lUùiú;Æ;¨Ş03l'n,tô²(Q) fMçz†`gË¼%ëÅç„Fƒ” y2 {ÍÚ ógdÒwàêIÅG}9İ	kT¹È]_l_pwöî! ëıxùûl$qh:P*ÏGNx©ÎÌÀm.¹1u!9¾&:›*}mhèdtögÖzú×V«ÖA@b…HÖR§Åsi\¾qò;¤¡,à(ÛşÎâ^ñnò ò£m*jDl¨1Cx!}Å©˜uYü Yp½$eØBc¸	1öLÉÀ˜+ñGxV/x{À´p°¬f0ì‚)<½—ttôr")C"‚å?õyD½»7d òzÎXd!Ïn1†åû`ÚNf{´Uiâ(dQ38]Ô‚ K¬Ğe0L¼âñ§°X¶p“ Âp#¥¼díLeà.ôímº@]e^{U•»,d ¦SFŞ)û 4mH{¦IM¦Â÷>æ}<$8g40~)mOé¯ã¨pe²Q?depÕ¯îÒ†jjùÕhÆ2jšt­xy÷CC¢K$Rˆz•±ã¤åÄW®äP%Oã>lda,HmÓáEhcåÿt”¨˜§‚f}Şu{Z|g!nevz»z!åóÓCÇœ˜ºiªK¾°e…q'2“${CĞí6*màOU™Q¦&6­d“‡T=™<™`åğí;Ú`áéK{',N—Tgöy©io!İ3m]t6T$B$5A$óÆ1*I‡Y:
=|NÌ"sÒ¯r_k^Pñ&¿1>ĞÈørù1paï)!ÒHó·IgåùW©®-¦.ó­¨3‘äÄRĞøq]Vdb)è	¹©ñk–g&JMc¥d¥/PhñO~:	&SH`0vV9ĞEK7!³H=ô"2²îæyl¸Ë{/!P!<vº&<FãûÆuXYïuQŒhºL&–ÀÉ+ãò8Ê›NaÀ–
‹9tve¾¥k¾:EXKÁa`&ŞæSŞzHÄMk&4î"Uø‰–şI_m±)¥ïI^³hªÍ4¶ !èšv9gİ:#îA2i YG $C¿J 6NÆ*jf2>/1¯9Th7äÑaMt¦|ÖF¦ ÒŞåğwPSïÇÉ'c9n²&FÑ&¯JßÜh%à`jU6'æiU&ä”bşrÚ€ní¦ôg^|pæ;m ê™W¥f'jgA¢s;.a»i#/ M]ds¬o	~s0îí2sG6¡ZoC5‰ú• ²Vßæ"56ïØïU6¹«Q`?9{=Ôª¾!™j~Y;~=k¼Èše ø¨ü{:ïznh)7`oã›g»
S#‚Pu ™<E4mËåõlyf”:wVşÒ¤ØGñIÎ$a_,Lpb4Ì}ö«^ÌoÈ#3Ïqdü5n):	şAêt)B”z!Tp;œe&€u2hüyI³tbîrà[uW‡!GÊ@ €v-µÔêb+¶¢vºT½bd6È4hä75fIJùu£Âzä19):9gj¶óiq<³ ×I(d#ãi~_Aº?ÖLAÅf©ìÉb:ïûihTb)•=\FÁ¯«Ògmãg 0e,¸ï5ggG®¨“Cbc~êz1ç4İŒIzî<$a÷lc`Š®ñ£ $ij/4/»C í=üĞ"¾fı°â±Ã7;Ynf	 «Sº|Üe6`ò­ të@8ôêmğee6lrM.Cm)dİxù[N>wHvİAtï˜d`n #Àys 9vŸt.³8nò%{jüjË«âÍ0ò7©P`uîÓhjcuG+ä	&$ êQÜÂdOrä5Å#a&ô3ª³|YmÇ~1p0)3$ê!91åû‡J0Ò‹TJ3èZç+èÒ¾!43ìnwıTü%üğ6S"pj/"eÖe;Ti}@šzwZj!»%#-şü¾ã§êû¤î£–ğiêíäÈ9ÆO{+T #Á“p»z,ã%5R|&~·m<%5<H0*í™€Ç kğµı]ÎnK`pväó$„Bu¼¸ëb{òÁ%UÊîôf%ì¸kbô 0°ê`ä[@z  k;¥¡.]W@¥Tg¾ÉxcaMn¦]º–?K}!á/	'_ù{c>©mNd8Q®%±{-k%c¾Ø¯Mheâm!W):ƒ°Z;,®(w "´Wèsîo!8–<D>e8¨m149ÿè ’oøÉìVrĞø#X1´/“YÿKaú¶n~Ã0qÖp%w4r©õPúp0j¦=6«g#5yDÛç–1)ªÊI6ïìd8B*î•p
q.Øìòí6!ù·ÊÊ&¡îaİ.*q59jlÆdÓ 2w,âÇÙîf]yÍVPB#‚lm~=ï^ú5f ôÌ;e!ğ]¸»kòĞš÷b}Y‰y©Eã]7³I>‡aóvLá=ç*{¿ïG$1º)Ú-vHP åë7$Ü7ÉpBav©è,hĞ!å(×c>àj¶/=ÈvÒríß ]ò°fª|ŸÖ%7ë•l!8K ?Åª»v:>¹&çA8FlRõHN]Ãga6e.¯ö¼\mpmGïù)¤­r,¥ù¼P0ßá€Iu>¿Mè{n*–æ}C'(ihõ¹¾N5%wn€> †º£|²ÆoçGzÄISZñèÔ$Ì¨ñù/]M¸dÑÖõû(ó‘Za@`HT@²vÊƒå&Æµ¶rVX$¦mqT’³ä.ª·A²-*H47ePc6éTuYN^]ég<2ÖEaä£it¦ŞP8:1yø¿´<‚g<täà`Ä8ìs³Û:}.o
ô¡}}kñ}n£9!7ßgÏı|+)Lö£?äñ-"eÎEË4·¢OD´‰ú0pªm3S6ˆ2XcïØ×=ñ<*bmkê; TBhÿT!IÇ±ÜA"-£jÛl¾y3HrG='g:›¢¨b<ég€!ª1TA,2TS¯J$Èc1x£½mÑÊ6]ğ®Yw,Íajag-fíey6àgÒƒqp$
¯ °~ätüŠ¥"POBñè•I	OÚ‚.f„W{+µ½~”¹~i7Ô~]7·è}( >Jl2rçreµ7Ğ½Ï5¥#]Z|$<f22Nx{òš#jMTØéïâ;Qv}ò"¢eúS‡`"&ú÷å{Œ`$
”dœav‘^åõ\zl ŒexüÙcpeK¡dÃ¬R€ì^6 qqâŒàiÉåvz{ò¿ o"dvK@Aû“—Yföıˆôéämuïı5x†¬tŸ_h_^b8÷­@$o*(Ú&N¦|x£N‘4¤$‡AMø0PõÒï©`œk^»…", _9d¡i'.`*°4heWËRal‹foùh{oö9‚LÑbc {ó>*|" 7s\/3c²nTgÿbqİ“PL`kJ(7À`¯## IáJL%¬E<DN'Nx¥ÀcÏ%±o_çwóEŠ3ÒôÍöı[¹FáV}sqrÑî(;b0^N;*NoSši-t¸AşD‘‡Çkï²ô5áaß/¬MğY‚4ùÉµ(ÓÓ­#¾%,nÌTòNz|C•*]C7¥·inr›å1!.+Û:ø¬ºc*,Ä–|O¤&G9G-F}ÒJ€?w$‚7øÑ9¢E“¥á2tqÅÚ >.àKp[egp¢1­a*ú!*NIOŠ$Ò"‰ıè1ƒ[’w)£`OurûFt;=n~xOÌèo³¢ïÏqÿ"cævo/«`/zp%,IûrU";¡ÄGFM,êj˜!a¼?ö½qÂåñ$©ópI»¿do+('z¨pz,#¶ªx0b1¶j$i¢&zaè?RÁ{ ÍG{oÇ4<*vga6Í(
BMg3Ù£=/è¯7UBk-:$~ ó .@eº
Ä#7…X4~:cÅˆI•avPÛÁ~ŒeÈA"~`'÷ãd.SÑ(Mù ¡ádágÂÊ<o:iON}ÖFÄJvu%V“0á¤à°üC&î’L1ùré½m¸#C.i”‘ÊN}*hm5e10è=hh(~5Úv[1)`Ésú$"Ú1~
Ï.=#M¢œtı43!âW1ˆÄÆzÄDs²†U?w¹Ûğz}rp#eFÿo"Õ©ÚduÔ0™ë8$ó®õ¸? fã²ö!Tü~êf¥m{ÂÆJ*şğı!0Izl-ò‹Vî&o{­A7”†m:^2ø[LáåH=m,^fÑvP¦ğ<vCqÌæ*:_4à­¹áÌ­PuËL`İÙ÷@bwŠuìÂw)ñˆÆÚpF8}®ş/S·²)F?_˜pà\E °2\çñ;#5Kuª7(ïóU_3e;+4Ó·>?¶¬$vµ(+°p=ie0Ôwäªİı½{òéép}*4dàòášoü)eÉ¿#V~:r6(zèpÆ k?3ÌÒşAı³%p7EQ;]œ1ôEz·äs-¨ŠŠË0-=.0n¥b7m`)Ş!IivR½ôğ{6®yXé©cuİfğ #-~8šÔr‹ örQ(²Í#Cæ$9â R°¦5s\¼Lj¦%9LªR/D¸eèhV¯&Âdxy9ìêW7½ô 'N3w!<Ä“lºÿvñ#mk@«cÄT1!9÷ÃI;
gî)Ë31(4apG&y_mu`?ó£¥4aÕ¯…·iU_‡\¡AŒ!Z+e91Ä9?!N#-3MhôõŞgñoÅg1ár9W#ûU€o>)  E"?¥f%ûSĞç+ ïTa ?w oø}+X•/!)oD“iŒH³!ı­{%j& AÆÆ'éápU—$3r`÷s zéİ2~-@©2/w`ófõ?Zll4gß¡c,½CY­¾ÓÍÇaPs"k+n õç,ì÷AI^<qÒ_Ø¥ Y—E q7r-|i ::x'd¬÷qîzc"’aÿp¥	ÊÕ^
hY/Gp;—š5NT¼Bz¡ê„ş=Šùã]°=E7ŞbùbáAjk`¸ıĞ.Ra@rEyğ.”Õ²Øq _)n3,V¤ôÅaQœcñ0gà¢2f¤ ©ê#8VşylÉ7ëöpluWâ<A"Hk¦\#:a† %òÊyaéà@X`yT$ëuŠ~¼jÍ$[vN,ôié8šË1NŞL~2"6İà	­ÍD#½d 1!"å37è4>p"ª^g¯V;aãÈ n}CŒŞ"øk¢x¤b)\k,A„’»Å¤wYXM‰…@0â9VœBsI6ô¢˜~õ´3ÒMä2»°n“÷º¬|¹¥64„P7IpuuuÑv}ugö<Guh­}ş]|tŸyf.a×Áw6P.3EÖ™ü~é>U7Ç¡Ksês4ôU=74+¼—0=Ü<\,;bïFWe}vl¾P54	y°‚°A&í}s€]¦ Eö5¶¹Jà>ÒC=ğú·z©x±0ne!:øo7bp48©‘¬(*2 Ò.¾(ódzhÚö q2ÍZğ°7áy3qİŞ?Kñn)%{¹èhp4YqìÃ¨Ÿ7rhçy'úH| –]u	t}	úÜ>gW ÆvíCL}İfé?$i!k3.VØ,]qì:ªŸôvõ{£Ôòd@,¦<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('body') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return ::verify(*this);
}



::mlir::ParseResult GenerateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> dynamicExtentsOperands;
  ::llvm::SMLoc dynamicExtentsOperandsLoc;
  (void)dynamicExtentsOperandsLoc;
  std::unique_ptr<::mlir::Region> bodyRegion = std::make_unique<::mlir::Region>();
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  dynamicExtentsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dynamicExtentsOperands))
    return ::mlir::failure();

  if (parser.parseRegion(*bodyRegion))
    return ::mlir::failure();

  ensureTerminator(*bodyRegion, parser.getBuilder(), result.location);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIndexType();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(dynamicExtentsOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addRegion(std::move(bodyRegion));
  return ::mlir::success();
}

void GenerateOp::print(::mlir::OpAsmPrinter &p) {
  p << "tensor.generate";
  p << ' ';
  p << dynamicExtents();
  p << ' ';

  {
    bool printTerminator = true;
    if (auto *term = body().empty() ? nullptr : body().begin()->getTerminator()) {
      printTerminator = !term->getAttrDictionary().empty() ||
                        term->getNumOperands() != 0 ||
                        term->getNumResults() != 0;
    }
    p.printRegion(body(), /*printEntryBlockArgs=*/true,
                  /*printBlockTerminators=*/printTerminator);
  }
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

} // namespace tensor
} // namespace mlir
namespace mlir {
namespace tensor {

//===----------------------------------------------------------------------===//
// ::mlir::tensor::InsertOp definitions
//===----------------------------------------------------------------------===//

InsertOpAdaptor::InsertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

InsertOpAdaptor::InsertOpAdaptor(InsertOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange InsertOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> InsertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange InsertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InsertOpAdaptor::scalar() {
  return *getODSOperands(0).begin();
}

::mlir::Value InsertOpAdaptor::dest() {
  return *getODSOperands(1).begin();
}

::mlir::ValueRange InsertOpAdaptor::indices() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr InsertOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult InsertOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> InsertOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range InsertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InsertOp::scalar() {
  return *getODSOperands(0).begin();
}

::mlir::Value InsertOp::dest() {
  return *getODSOperands(1).begin();
}

::mlir::Operation::operand_range InsertOp::indices() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange InsertOp::scalarMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InsertOp::destMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange InsertOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> InsertOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InsertOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InsertOp::result() {
  return *getODSResults(0).begin();
}

void InsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value scalar, Value dest, ValueRange indices ) {
      auto resType = dest.getType();
      build(odsBuilder, odsState, resType, scalar, dest, indices);
    
}

void InsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value scalar, ::mlir::Value dest, ::mlir::ValueRange indices) {
  odsState.addOperands(scalar);
  odsState.addOperands(dest);
  odsState.addOperands(indices);
  odsState.addTypes(result);
}

void InsertOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value scalar, ::mlir::Value dest, ::mlir::ValueRange indices) {
  odsState.addOperands(scalar);
  odsState.addOperands(dest);
  odsState.addOperands(indices);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InsertOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InsertOp::verify() {
  if (failed(InsertOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(1).begin()).getType().cast<ShapedType>(), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result type matches type of dest");
  if (!((std::equal_to<>()((*this->getODSOperands(1).begin()).getType().cast<ShapedType>().getElementType(), (*this->getODSOperands(0).begin()).getType()))))
    return emitOpError("failed to verify that scalar type matches element type of dest");
  return ::verify(*this);
}



::mlir::ParseResult InsertOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType scalarRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> scalarOperands(scalarRawOperands);  ::llvm::SMLoc scalarOperandsLoc;
  (void)scalarOperandsLoc;
  ::mlir::OpAsmParser::OperandType destRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> destOperands(destRawOperands);  ::llvm::SMLoc destOperandsLoc;
  (void)destOperandsLoc;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> indicesOperands;
  ::llvm::SMLoc indicesOperandsLoc;
  (void)indicesOperandsLoc;
  ::mlir::Type destRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> destTypes(destRawTypes);

  scalarOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(scalarRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("into"))
    return ::mlir::failure();

  destOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(destRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  indicesOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(indicesOperands))
    return ::mlir::failure();
  if (parser.parseRSquare())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(destRawTypes[0]))
    return ::mlir::failure();
  for (::mlir::Type type : destTypes) {
    (void)type;
    if (!(((type.isa<::mlir::TensorType>())) && ((true)))) {
      return parser.emitError(parser.getNameLoc()) << "'dest' must be tensor of any type values, but got " << type;
    }
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIndexType();
  result.addTypes(destTypes[0].cast<ShapedType>());
  if (parser.resolveOperands(scalarOperands, destTypes[0].cast<ShapedType>().getElementType(), scalarOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(destOperands, destTypes, destOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(indicesOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void InsertOp::print(::mlir::OpAsmPrinter &p) {
  p << "tensor.insert";
  p << ' ';
  p << scalar();
  p << ' ' << "into";
  p << ' ';
  p << dest();
  p << "[";
  p << indices();
  p << "]";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(dest().getType());
}

void InsertOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tensor
} // namespace mlir
namespace mlir {
namespace tensor {

//===----------------------------------------------------------------------===//
// ::mlir::tensor::InsertSliceOp definitions
//===----------------------------------------------------------------------===//

InsertSliceOpAdaptor::InsertSliceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

InsertSliceOpAdaptor::InsertSliceOpAdaptor(InsertSliceOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange InsertSliceOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> InsertSliceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange InsertSliceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InsertSliceOpAdaptor::source() {
  return *getODSOperands(0).begin();
}

::mlir::Value InsertSliceOpAdaptor::dest() {
  return *getODSOperands(1).begin();
}

::mlir::ValueRange InsertSliceOpAdaptor::offsets() {
  return getODSOperands(2);
}

::mlir::ValueRange InsertSliceOpAdaptor::sizes() {
  return getODSOperands(3);
}

::mlir::ValueRange InsertSliceOpAdaptor::strides() {
  return getODSOperands(4);
}

::mlir::DictionaryAttr InsertSliceOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr InsertSliceOpAdaptor::static_offsets() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("static_offsets").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr InsertSliceOpAdaptor::static_sizes() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("static_sizes").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr InsertSliceOpAdaptor::static_strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("static_strides").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::LogicalResult InsertSliceOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 5)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 5 elements, but got ") << numElements;
  }
    {
  auto tblgen_static_offsets = odsAttrs.get("static_offsets");
  if (!tblgen_static_offsets) return emitError(loc, "'tensor.insert_slice' op ""requires attribute 'static_offsets'");
    if (!(((tblgen_static_offsets.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_static_offsets.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tensor.insert_slice' op ""attribute 'static_offsets' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_static_sizes = odsAttrs.get("static_sizes");
  if (!tblgen_static_sizes) return emitError(loc, "'tensor.insert_slice' op ""requires attribute 'static_sizes'");
    if (!(((tblgen_static_sizes.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_static_sizes.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tensor.insert_slice' op ""attribute 'static_sizes' failed to satisfy constraint: 64-bit integer array attribute");
  }
  {
  auto tblgen_static_strides = odsAttrs.get("static_strides");
  if (!tblgen_static_strides) return emitError(loc, "'tensor.insert_slice' op ""requires attribute 'static_strides'");
    if (!(((tblgen_static_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_static_strides.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'tensor.insert_slice' op ""attribute 'static_strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  return ::mlir::success();
}

























std::pair<unsigned, unsigned> InsertSliceOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range InsertSliceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InsertSliceOp::source() {
  return *getODSOperands(0).begin();
}

::mlir::Value InsertSliceOp::dest() {
  return *getODSOperands(1).begin();
}

::mlir::Operation::operand_range InsertSliceOp::offsets() {
  return getODSOperands(2);
}

::mlir::Operation::operand_range InsertSliceOp::sizes() {
  return getODSOperands(3);
}

::mlir::Operation::operand_range InsertSliceOp::strides() {
  return getODSOperands(4);
}

::mlir::MutableOperandRange InsertSliceOp::sourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange InsertSliceOp::destMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange InsertSliceOp::offsetsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange InsertSliceOp::sizesMutable() {
  auto range = getODSOperandIndexAndLength(3);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange InsertSliceOp::stridesMutable() {
  auto range = getODSOperandIndexAndLength(4);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> InsertSliceOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range InsertSliceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value InsertSliceOp::result() {
  return *getODSResults(0).begin();
}

::mlir::ArrayAttr InsertSliceOp::static_offsetsAttr() {
  return (*this)->getAttr(static_offsetsAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr InsertSliceOp::static_offsets() {
  auto attr = static_offsetsAttr();
  return attr;
}

::mlir::ArrayAttr InsertSliceOp::static_sizesAttr() {
  return (*this)->getAttr(static_sizesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr InsertSliceOp::static_sizes() {
  auto attr = static_sizesAttr();
  return attr;
}

::mlir::ArrayAttr InsertSliceOp::static_stridesAttr() {
  return (*this)->getAttr(static_stridesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr InsertSliceOp::static_strides() {
  auto attr = static_stridesAttr();
  return attr;
}

void InsertSliceOp::static_offsetsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(static_offsetsAttrName(), attr);
}

void InsertSliceOp::static_sizesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(static_sizesAttrName(), attr);
}

void InsertSliceOp::static_stridesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(static_stridesAttrName(), attr);
}





void InsertSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value source, ::mlir::Value dest, ::mlir::ValueRange offsets, ::mlir::ValueRange sizes, ::mlir::ValueRange strides, ::mlir::ArrayAttr static_offsets, ::mlir::ArrayAttr static_sizes, ::mlir::ArrayAttr static_strides) {
  odsState.addOperands(source);
  odsState.addOperands(dest);
  odsState.addOperands(offsets);
  odsState.addOperands(sizes);
  odsState.addOperands(strides);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, 1, static_cast<int32_t>(offsets.size()), static_cast<int32_t>(sizes.size()), static_cast<int32_t>(strides.size())}));
  odsState.addAttribute(static_offsetsAttrName(odsState.name), static_offsets);
  odsState.addAttribute(static_sizesAttrName(odsState.name), static_sizes);
  odsState.addAttribute(static_stridesAttrName(odsState.name), static_strides);
  odsState.addTypes(result);
}

void InsertSliceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value source, ::mlir::Value dest, ::mlir::ValueRange offsets, ::mlir::ValueRange sizes, ::mlir::ValueRange strides, ::mlir::ArrayAttr static_offsets, ::mlir::ArrayAttr static_sizes, ::mlir::ArrayAttr static_strides) {
  odsState.addOperands(source);
  odsState.addOperands(dest);
  odsState.addOperands(offsets);
  odsState.addOperands(sizes);
  odsState.addOperands(strides);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, 1, static_cast<int32_t>(offsets.size()), static_cast<int32_t>(sizes.size()), static_cast<int32_t>(strides.size())}));
  odsState.addAttribute(static_offsetsAttrName(odsState.name), static_offsets);
  odsState.addAttribute(static_sizesAttrName(odsState.name), static_sizes);
  odsState.addAttribute(static_stridesAttrName(odsState.name), static_strides);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InsertSliceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult InsertSliceOp::verify() {
  if (failed(InsertSliceOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps3(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(1).begin()).getType(), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that expected result type to match dest type");
  return ::mlir::success();
}





::mlir::ParseResult InsertSliceOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType sourceRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> sourceOperands(sourceRawOperands);  ::llvm::SMLoc sourceOperandsLoc;
  (void)sourceOperandsLoc;
  ::mlir::OpAsmParser::OperandType destRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> destOperands(destRawOperands);  ::llvm::SMLoc destOperandsLoc;
  (void)destOperandsLoc;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> offsetsOperands;
  ::llvm::SMLoc offsetsOperandsLoc;
  (void)offsetsOperandsLoc;
  ::mlir::ArrayAttr static_offsetsAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> sizesOperands;
  ::llvm::SMLoc sizesOperandsLoc;
  (void)sizesOperandsLoc;
  ::mlir::ArrayAttr static_sizesAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> stridesOperands;
  ::llvm::SMLoc stridesOperandsLoc;
  (void)stridesOperandsLoc;
  ::mlir::ArrayAttr static_stridesAttr;
  ::mlir::Type sourceRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> sourceTypes(sourceRawTypes);
  ::mlir::Type destRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> destTypes(destRawTypes);

  sourceOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(sourceRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("into"))
    return ::mlir::failure();

  destOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(destRawOperands[0]))
    return ::mlir::failure();
  {
    offsetsOperandsLoc = parser.getCurrentLocation();
    if (parseOperandsOrIntegersOffsetsOrStridesList(parser, offsetsOperands, static_offsetsAttr))
      return ::mlir::failure();
    result.addAttribute("static_offsets", static_offsetsAttr);
  }
  {
    sizesOperandsLoc = parser.getCurrentLocation();
    if (parseOperandsOrIntegersSizesList(parser, sizesOperands, static_sizesAttr))
      return ::mlir::failure();
    result.addAttribute("static_sizes", static_sizesAttr);
  }
  {
    stridesOperandsLoc = parser.getCurrentLocation();
    if (parseOperandsOrIntegersOffsetsOrStridesList(parser, stridesOperands, static_stridesAttr))
      return ::mlir::failure();
    result.addAttribute("static_strides", static_stridesAttr);
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(sourceRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseKeyword("into"))
    return ::mlir::failure();

  if (parser.parseType(destRawTypes[0]))
    return ::mlir::failure();
  for (::mlir::Type type : destTypes) {
    (void)type;
    if (!((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().hasRank()))) && ((true)))) {
      return parser.emitError(parser.getNameLoc()) << "'dest' must be ranked tensor of any type values, but got " << type;
    }
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIndexType();
  result.addTypes(destTypes[0]);
  if (parser.resolveOperands(sourceOperands, sourceTypes, sourceOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(destOperands, destTypes, destOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(offsetsOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(sizesOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(stridesOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  result.addAttribute("operand_segment_sizes", parser.getBuilder().getI32VectorAttr({1, 1, static_cast<int32_t>(offsetsOperands.size()), static_cast<int32_t>(sizesOperands.size()), static_cast<int32_t>(stridesOperands.size())}));
  return ::mlir::success();
}

void InsertSliceOp::print(::mlir::OpAsmPrinter &p) {
  p << "tensor.insert_slice";
  p << ' ';
  p << source();
  p << ' ' << "into";
  p << ' ';
  p << dest();
  printOperandsOrIntegersOffsetsOrStridesList(p, *this, offsets(), static_offsetsAttr());
  p << ' ';
  printOperandsOrIntegersSizesList(p, *this, sizes(), static_sizesAttr());
  p << ' ';
  printOperandsOrIntegersOffsetsOrStridesList(p, *this, strides(), static_stridesAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"operand_segment_sizes", "static_offsets", "static_sizes", "static_strides"});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(source().getType());
  p << ' ' << "into";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(dest().getType());
}

void InsertSliceOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tensor
} // namespace mlir
namespace mlir {
namespace tensor {

//===----------------------------------------------------------------------===//
// ::mlir::tensor::ReshapeOp definitions
//===----------------------------------------------------------------------===//

ReshapeOpAdaptor::ReshapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReshapeOpAdaptor::ReshapeOpAdaptor(ReshapeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReshapeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReshapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ReshapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOpAdaptor::source() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReshapeOpAdaptor::shape() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ReshapeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ReshapeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ReshapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ReshapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOp::source() {
  return *getODSOperands(0).begin();
}

::mlir::Value ReshapeOp::shape() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ReshapeOp::sourceMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ReshapeOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReshapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReshapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReshapeOp::result() {
  return *getODSResults(0).begin();
}

void ReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TensorType resultType, Value operand, Value shape) {
       odsState.addOperands(operand);
       odsState.addOperands(shape);
       odsState.addTypes(resultType);
     
}

void ReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value source, ::mlir::Value shape) {
  odsState.addOperands(source);
  odsState.addOperands(shape);
  odsState.addTypes(result);
}

void ReshapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value source, ::mlir::Value shape) {
  odsState.addOperands(source);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReshapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReshapeOp::verify() {
  if (failed(ReshapeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps6(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}

::mlir::ParseResult ReshapeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType sourceRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> sourceOperands(sourceRawOperands);  ::llvm::SMLoc sourceOperandsLoc;
  (void)sourceOperandsLoc;
  ::mlir::OpAsmParser::OperandType shapeRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> shapeOperands(shapeRawOperands);  ::llvm::SMLoc shapeOperandsLoc;
  (void)shapeOperandsLoc;
  ::llvm::ArrayRef<::mlir::Type> allOperandTypes;
  ::llvm::ArrayRef<::mlir::Type> allResultTypes;

  sourceOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(sourceRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  shapeOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(shapeRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  ::mlir::FunctionType allOperand__allResult_functionType;
  if (parser.parseType(allOperand__allResult_functionType))
    return ::mlir::failure();
  allOperandTypes = allOperand__allResult_functionType.getInputs();
  allResultTypes = allOperand__allResult_functionType.getResults();
  result.addTypes(allResultTypes);
  if (parser.resolveOperands(::llvm::concat<const ::mlir::OpAsmParser::OperandType>(sourceOperands, shapeOperands), allOperandTypes, parser.getNameLoc(), result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReshapeOp::print(::mlir::OpAsmPrinter &p) {
  p << "tensor.reshape";
  p << ' ';
  p << source();
  p << "(";
  p << shape();
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p.printFunctionalType(getOperation()->getOperandTypes(), getOperation()->getResultTypes());
}

void ReshapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tensor
} // namespace mlir
namespace mlir {
namespace tensor {

//===----------------------------------------------------------------------===//
// ::mlir::tensor::YieldOp definitions
//===----------------------------------------------------------------------===//

YieldOpAdaptor::YieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

YieldOpAdaptor::YieldOpAdaptor(YieldOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange YieldOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> YieldOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange YieldOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value YieldOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr YieldOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult YieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> YieldOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range YieldOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value YieldOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange YieldOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> YieldOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range YieldOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
 /* nothing to do */ 
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value value) {
  odsState.addOperands(value);
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value) {
  odsState.addOperands(value);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void YieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult YieldOp::verify() {
  if (failed(YieldOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_TensorOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult YieldOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::Type valueRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valueTypes(valueRawTypes);

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(valueRawTypes[0]))
    return ::mlir::failure();
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void YieldOp::print(::mlir::OpAsmPrinter &p) {
  p << "tensor.yield";
  p << ' ';
  p << value();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(value().getType());
}

void YieldOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace tensor
} // namespace mlir

#endif  // GET_OP_CLASSES

