/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::AbsFOp,
::mlir::AddFOp,
::mlir::AddIOp,
::mlir::AndOp,
::mlir::AssertOp,
::mlir::AtomicRMWOp,
::mlir::AtomicYieldOp,
::mlir::BranchOp,
::mlir::CallIndirectOp,
::mlir::CallOp,
::mlir::CeilFOp,
::mlir::CmpFOp,
::mlir::CmpIOp,
::mlir::CondBranchOp,
::mlir::ConstantOp,
::mlir::CopySignOp,
::mlir::DivFOp,
::mlir::FPExtOp,
::mlir::FPToSIOp,
::mlir::FPToUIOp,
::mlir::FPTruncOp,
::mlir::FloorFOp,
::mlir::FmaFOp,
::mlir::GenericAtomicRMWOp,
::mlir::IndexCastOp,
::mlir::MulFOp,
::mlir::MulIOp,
::mlir::NegFOp,
::mlir::OrOp,
::mlir::RankOp,
::mlir::RemFOp,
::mlir::ReturnOp,
::mlir::SIToFPOp,
::mlir::SelectOp,
::mlir::ShiftLeftOp,
::mlir::SignExtendIOp,
::mlir::SignedCeilDivIOp,
::mlir::SignedDivIOp,
::mlir::SignedFloorDivIOp,
::mlir::SignedRemIOp,
::mlir::SignedShiftRightOp,
::mlir::SplatOp,
::mlir::SubFOp,
::mlir::SubIOp,
::mlir::SwitchOp,
::mlir::TruncateIOp,
::mlir::UIToFPOp,
::mlir::UnsignedDivIOp,
::mlir::UnsignedRemIOp,
::mlir::UnsignedShiftRightOp,
::mlir::XOrOp,
::mlir::ZeroExtendIOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::FloatType>())) || (((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || (((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be floating-point-like, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops1(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops2(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isSignlessInteger())) || ((type.isa<::mlir::IndexType>())) || (((type.isa<::mlir::VectorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || (((type.isa<::mlir::TensorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be signless-integer-like, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops3(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isSignlessInteger(1)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1-bit signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops4(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isSignlessInteger())) || ((type.isa<::mlir::FloatType>())))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be signless integer or floating-point, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops5(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::MemRefType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be memref of signless integer or floating-point values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops6(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IndexType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops7(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops8(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::FunctionType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be function type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops9(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isSignlessInteger(1))) || (((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))) || (((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(1)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be bool-like, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops10(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((((type.isa<::mlir::UnrankedMemRefType>())) && ((true))) || (((type.isa<::mlir::MemRefType>())) && ((true)))) || (((type.isa<::mlir::TensorType>())) && ((true))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any memref or tensor type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops11(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IndexType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops12(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isSignlessInteger())) || ((type.isa<::mlir::IndexType>())) || ((type.isa<::mlir::FloatType>())))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be integer/index/float type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops13(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::VectorType>())) && ((true))) || ((((type.isa<::mlir::TensorType>())) && ((true))) && ((type.cast<::mlir::ShapedType>().hasStaticShape()))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be vector of any type values or statically shaped tensor of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_Ops14(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IntegerType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be integer, but got " << type;
  }
  return ::mlir::success();
}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::AbsFOp definitions
//===----------------------------------------------------------------------===//

AbsFOpAdaptor::AbsFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AbsFOpAdaptor::AbsFOpAdaptor(AbsFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AbsFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AbsFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AbsFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AbsFOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr AbsFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AbsFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AbsFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AbsFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AbsFOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AbsFOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AbsFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AbsFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void AbsFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(resultType0);
}

void AbsFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AbsFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AbsFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void AbsFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult AbsFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void AbsFOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardUnaryOp(this->getOperation(), p);
}

::mlir::LogicalResult AbsFOp::verify() {
  if (failed(AbsFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void AbsFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::AddFOp definitions
//===----------------------------------------------------------------------===//

AddFOpAdaptor::AddFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AddFOpAdaptor::AddFOpAdaptor(AddFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AddFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AddFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AddFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddFOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddFOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AddFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AddFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AddFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AddFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddFOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddFOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AddFOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AddFOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AddFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AddFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddFOp::result() {
  return *getODSResults(0).begin();
}

void AddFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void AddFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AddFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void AddFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult AddFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void AddFOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult AddFOp::verify() {
  if (failed(AddFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void AddFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::AddIOp definitions
//===----------------------------------------------------------------------===//

AddIOpAdaptor::AddIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AddIOpAdaptor::AddIOpAdaptor(AddIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AddIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AddIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AddIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AddIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AddIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AddIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AddIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AddIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AddIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AddIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AddIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddIOp::result() {
  return *getODSResults(0).begin();
}

void AddIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void AddIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AddIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void AddIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult AddIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void AddIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult AddIOp::verify() {
  if (failed(AddIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}





void AddIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::AndOp definitions
//===----------------------------------------------------------------------===//

AndOpAdaptor::AndOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AndOpAdaptor::AndOpAdaptor(AndOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AndOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AndOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AndOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AndOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AndOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AndOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AndOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AndOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AndOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AndOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AndOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AndOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AndOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AndOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AndOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AndOp::result() {
  return *getODSResults(0).begin();
}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AndOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void AndOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult AndOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void AndOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult AndOp::verify() {
  if (failed(AndOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void AndOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::AssertOp definitions
//===----------------------------------------------------------------------===//

AssertOpAdaptor::AssertOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AssertOpAdaptor::AssertOpAdaptor(AssertOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AssertOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AssertOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AssertOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AssertOpAdaptor::arg() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr AssertOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr AssertOpAdaptor::msg() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("msg").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult AssertOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_msg = odsAttrs.get("msg");
  if (!tblgen_msg) return emitError(loc, "'std.assert' op ""requires attribute 'msg'");
    if (!((tblgen_msg.isa<::mlir::StringAttr>()))) return emitError(loc, "'std.assert' op ""attribute 'msg' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> AssertOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AssertOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOpera&¤TàVùøm¦XOJãìµI	KÊÆ®·€×{#Õ½z½ÿÙ?Î'£h o^Oqıçb3µgr¼O-#UÚ|$,”gY¶ny‘ëocneÜÙÅïÇ[YÄd,*" cpÀ£ "*º£Ôc:ŒàåTbŒev‘^ÁÁ\M~\ ˜e°møcpgVábcíF€äÜ<{!Aâ´åhÓåö{âßÃm€"äVH"ú“‡àôíèôí¢}éİ&xœHŸOp_^bxİÍkbh^öN¶<<£NU  4—@È¸—õÒí`ïk^»0¬ 9Ao'.aª`0ge_ËjklÛniømnç0
\ÁÚ÷âzÃn+ú¦`s]5bÒeeÿrãÙ–HŞ"ëRTj9ö@`ïC"Aó ìeìÇ=T
gK`…¬#o=ğmÕ÷_ºGÊqÖÄÍ6¶}k9–å}òoşIÊ;Š`°vNq_2V®×Njt¸8AüÔÑ‚ÇK¿³Ôt²aš/¨	\ò\oÊDÙÁ¥)Åâ½«®,lÎuózÕrŸÃœ*uÃv¥½
gpå}Ä-{Û>ˆ¬:Í3,ÌÀ}?õRcYÇ<DwÆ‹HŒ9Ç&BWØÑ+bUSÏèÃôqUØ'å}DğC`ÓÅ>np¦Ø‰Gêü¡*n@iÛ¤ÒjÁï­1ƒY˜°ç+£bë> ófw÷=^şø]ÄæÏ½åìÎ1=şk2bº›/-b/8wl]sRU#;_ ÒgÎEmêlØpáO4)¡s9@îóÄóaIÿ_TGc9Gzh8còªhRKq¦hDBâD`Ì!(ÿTÇ›¤Ål×uç…6&g%5Íi
CÀg³İ«}#H
Ufkl®fş y +Be«
€#£¥t~8cÖA•'ôQ{UNÌeÊE‚üô÷ã*.ÑÓlMù ‚ñèówÀÂ=áMKGmÖ†ŒJ~]%Ò“6ã¿èô|TCÑ ¾û"á¥‡Z}ú&ª;¯iœ‘Šƒî}Y(È­4m50(¹ê,ö1òæ[(`M{~,2\stÏ?½#M¤Öf#ı030â	Xu@ÆsÆzÔdïsºE?äÍÛózõ¢z³cFßf"’ùĞ*fÖ1”ç¨Ë»Õ¸2@Gâ²ô!}ncìîô­YŠƒ†J^mu¾rı 3HPR%Z±ò€VÎ&Şñ­qÇMzŞ2áYÌÁà;í¬_æÑeR§À9wJQ¼":_,b¹¹¥Ì-?Ã)ÍÌb‰ç	#wšwÌ"ï)÷È×pF,Æş'V3óò9F›p¨ÍG °"\Ãò!	#4ŸÛ÷® ¯óß¿A?³ËŸ>&Šdfõ0j¼ =ie4äçdÎİBı<[ùïÉpı*1dãRñ/|†ip’ı#?¾q6(zè}^êã÷ìÓîDı“&á4E¶Q{œ³œFp5Àræ°ŠŠÏ0m¥†.´>j-F·'`X~fQÉG{u`y%ÔÒk>¬}	É¨cuÜcÓ£,0º¼ôr‹¡öâX:²Í¡C®"ê0jµ&p3¼Dë¢5yLˆR?d¸UhÚV·?'BLxy5¬îFqU˜!{c)À—ìÿzÙ'lib»cÍTl1a;k®EÈO;gh!Ë±!qAg6yµ÷½qc7÷Â¥¤¨×ŸåƒwÉt×
A§Í)Á,cs#eº0„]½?³Î#){MñÖ½T6SÅgqãÖ:#İù o6o Teæ7¥l[!ïSĞç¿ ¸E$‚?gemø<oZİ¯¡*o“}LÈ³ S©ijg09ÆF--åZÑä5òpçóEúé!Ë 6ŸY%D)+Uqïæå=Ò&ızoŞ¡ã,¿Á'X	¼óÅnxTA"{ˆn¢ñå$¬ıIŞWêÏÜ÷TÙ‘Ç@Õu&p¯|Ã$øÜZŒx'$Ä;qæzc2w  a÷ğ¥MÇÃ^
Y-År:“™=^V=C~±ú„ü?’iây²)'~jûrïakY0KığšPBDrMÿò/Š“ƒ² ØA— Ô©PF'$Vìğdq‘Q’gÑ=éì¢h‚æØ+ëc(ÆÎ}Kvé]Ä0neEª¬Ïc6I+& XC2f$°´²ÅQgl@`Xlqu&Óê#IŸ~¼jœ$ÛTJ.´jÀ	˜:‡1NÎEv;b6İåE©ÉF#4fu‘5bÅ+?È”.Ö¢ŠVgÍV+ÁÃì¢mXÃ#ùK€\¤fq\k×„Š9ÅmwYÙc›…T4âyú:ˆF3éº,¦¸oÄÒQ°;ÀAÀQ¯±g^—7ë¬t­=¥¾ÅPrl©dõÑR1mvôxgU`}û]9t—[&nÓÈw®&P²9EÜ›>:Å%×³gˆIÕb3$¼1|w4+¸—1=Øñ\gûb÷we;S}¾ ¥6Lq°¡A\.í}^ó–õğÀQæ¾ùZä8ÛÃ†9
ÔÛ7^¡y@’“dnñ6!øOt#d>©üj°‘ò/sT÷lˆîeyçGZà¡K7ÁGkqÚØŞ_ñŠ8%ş1‰ê$2H}ÏÃØ#rì‹igèHl Öus\U})âÄM£÷ –„fèZD=_Ña);$x%
0w.VØ(]al¶àtY´{†WîdÎ,áèaÛE/‰"_+ÒOq"¬¾:û˜é…g<ÙMî(9*ZùZ÷á {*/0u#_öTüsPcÊÉmPÚtŠago$j·/Š&¬üÕ½z¸ùUh-N]XÀµN+×£hKà>ªedY(Q4Ø~DH€Ä’Wf<{2_ñïÉ­ƒÁ¶géãI‘¦i2îÎÌr½/b××o}˜g%t?LU/Y~ñ‹Læ/t¿§çqÔoº0O,ãÚ-5Ìà+’º=.ˆYDvÅ À0V¬´PE}(‹Óœ# (´¦ûÄ(|Õ­A`Åä["ÑK<QBeD;ìåqp¯‚ÊØ"ZåAeIt”bÙU0`WRzz‹hF ÛİåÛÏP~ª.êİô:¬d’yínia·Yb°åçEs¹u‡ôP¨}VÏXŠ{C±ÊÍiÅE¨";pav_wÎé
YmÏ„&Àiß(ezÚD
l_c‘'âé2o×­¨<ªšÙ$%|	ëUew•¤6m`[ëIÑ+Â +/Aá ?D,8¥iNno¨ °ix¼úZàéï¼º§íÜ§‘'MGÑèf…my Ïzİe€ÃnŞ~z—É<wØ”&CóX<~ziˆëFÿ¾Úí¿Gƒ²ª#àa˜ÇØA(¹üi¹LY ?jîDãÀoÀ£­sú ñ¨>û/YçËã.Õn'zÓ€Õv‚š&¡¦+ûÅI€èâL"6ûiNà:m&jbhry`Ë^­d¹V:sJ¯Hä=sïgËÁ\ª¤×MıÜíŞÍ_ X0®#zN¼_áö
IÊCÖílkîËI)tvÊ«bü8ÙŠ™;pörŸC´r%ó¢9”8®æĞpÃp.ê1åuÅ=R6³ÌQGSoÜÄ·Î0¿ğu3‚M¢¬êåGQìä^_ºf®Úê÷`ë¾vz4Øj
ÈÑ8ö7ÉqDˆB%µAKÎV]OPDd4z´Ì}ou_s±t3Z¥- Šiî[ÓŒmLg˜úvÅwg¬ä²c{TøÖJªø¦Í`öÛX¢ÓNr›İ÷‹-qç@0„U{dÄÕjò›§¸bTqZÉ‘MxŠ(ö
gø÷GŞÅ–Ğö‰%R`$¼µöÇw®ÆEbZÛ¥, µïÕoò~Î:À©*“;_Æ±BPpEéAbŒ»:Œ"¸%zcE¶	şyGE…D÷ôí ëdŒ.d-!¢îèïD:â¬á>ôÍ!zµ_jŞ5Í–/\ø€û´Ø__vLìrÿ¢qbÆq¤Io{'†…²™­ehh»é(¨úº4£+ mÇNr”"ÌõÏÚG»(é©êrw¤Ì¢
%Û!£È&ˆúá{ü8ø8yPácâ¬Dv` îhUCÿ|åP›M•%Á/vùOëüòj'ØLíN"±éÙWÆ³=¥cœiÁ<æq½:Z«E<–İÁ‰ãÙû+Mëv ÇÎca^íĞ93oĞë¯¶¾½Rrˆ6oÎ8«¡,it²°@)q]eCA«w0±â¦£IRÖ'x;ƒx"qÌCàtöşN-*Ñ¤Ç-ıQ~^dîùoîah¨ P!àw£jLlÂîëbRb:Ú÷R™"Gwšì"»©Ab!_­ĞE÷õ!q2­³Ş©ç51ÅÙÁxÃ_°vKÿ|hÀi,zõiÅà¦bÁéöJ%f¸	#òèq&yv; `c»zNTÆ²UxJU¶dt0Q!ÇN'¢çŞÇ©…bhYyÄñrpäXfDi¹\>@E´Ä]*ClædGà+Bò] ñQo2°ıæ|H‚&1óùz\%'LidI"Ùc²‚"E]‚Z:Ox‰çt%p¶XmqDÚ ûsÏğHR@2!`ˆà@¥+ª7çIÒ¦Wğé[•AhwÁ‰*±a‡wàì,Ã”&õ
>iLÒõsqcs%ÜE[ÏÇ€´%‰qîïI0¾
’cû_uÄH$Ú;çÂæ`·@™Òñmp>ÂM¬Cô7†bŞí4ÈDŒE†ÏK1aîBIk]õTlp¢H¾\£9KøôMÙÖötŞ:¦y6kÊS÷CYYuÛE=ÒA~Í2ÔoVêá€¿ÙË¾à—_p´µ{ââºhgèXUêŞlÚ°fû	«ó(©k
Ô'pj÷·åAõ
E˜G-P²ŞXsd³u@+¾8n%b*9$½{0ƒlÎlI+‚¢(õ¼ĞéYJ)ÑÛ~íÒãFğöô`‹KŞ è;Jn1¦ÂboÁº n]k¦¨âu£®) p/°À¡F+ŸGUCÙ[ğóBÜuBÙüe¨š~ïJ“Ïi]ö U³Ç{r{©ûHLO°Í¢QW‚y,’agM?šs$À^#|©9>º£ØüFÅAb$
Œ¤YlT R{äq0nYÏëü h—‘€Qi@G›eaóŠgÎZK×¨)èj :9l#ÒV:úcÛïšš,`m“üL.YÀƒH?’fô4rèl	lWjãñ®uV[jÂï ï6¦]ó\hT—‹LFÖ¹/|3v&"`wO–3^5–}Ù¥:páÚÂ^MjU¤dñÕ4/ÜU\7{fŒ7øı3lÔ7˜0û÷j÷ş.<¸áZ‚I¨·r6dry(Š8 ØLç4óÎ1Jüys{!¥¹X`ÂHÌQ`p£ZSí&“`]wRÄTv|Ú~äëuÕ½AÔÔh{Äsâh¶fw¢\p+Fñ¸OÉ
˜`Ğ!Yyõdğ„ò:m\xwäKFô2m¢ÆÕ`&l*îCU·|x”·:¾Û[Ê]lH‘grôO_ş«õ€’[·¯Ô.JftB»ÈâÏašNì÷!<AÓ5}ÚÔéñÂô¹¡=ÊGæ—è‘2¸ÊÀ2$b	CeN°Jåò§*î³fsk#ÿ:®éş¦6Â$U4òŠI/úM%^jËôyV3˜Ÿz%³U"›‚ƒd[´¤fõïx|’seHUâÕğıÿ'°Û:ƒÅı-Ê9Yá`mÖÖD+QyÔèŠ²8uEã$)ÈpXNøã:ÏÍc3A)*LBZ÷*õëÍrüÙá”‘Q,VV™1?BÖ7§vQKä²xpÃÀqkä!¿Ş€0%~ ¨D56¡úbÅ*x0HÌl™~<Ó°%lE nƒÀÍ|(r¿]¨áh»d²"û÷ òjc_(ªØÂL1¹Ff2„ø‡²iptoNTDõx6¯Ú+õÕğNŠÏEóª(ä‹-QDAP\˜±™Îy£åÀpöŸÔ57ÈdiË%ñlÖt=¢âÅÈT (<8Ìù'h&:›„ùÇ0ÒñJ3ë¬Ú©~¼W,Œ@s¨Áyo*(@Õoq	ÙbuFB|‚O§aL³ZBÑqAJAŒıM-°ƒòba'TMoep…éÌì™!Í (‚µhD&>Ÿ¯zÖ)J_¼,'Õ%-F /}C¯ªkO=}†N=¨B¸$­¸Í½x'/îqa ]5%;gí|¹M¬§!l&2—=¼üJÌf.~¢07@2Ú«dÖ_#aÛ_O÷3vgzçH.È¨EëL4ˆ7Rw+D/4 ‡ï.m/-³5ÿ¤ìú~9O&DXE%-­}§üIn½º¼o¸£½-I½]&¸,<)µDEU~‚Æ$5_-A=­ŠáV!¼å;.—Î©— aogHwØG7=WY8RÇíãÚGé³;QÁ?FPä¡#dÎrñAF‹@È–T6!Í7î•éğ!í}qz2ÔM#„ÉtjºIüá4SÖàÓ(Rkõ¨í]¿é¦MÀ_œô"j'dTà]ëuB3ÑƒŠ
'HÂáwÍöJ$&±-™!¿6áÉ¹„,)§Í°Öhj:I¦qh“0Oä®GFs’ííè»V\	è» öBb3oƒÉ±Î3JR	È}…[íV?r¬kúO_z±™µSaiJÖm'[È€Ó=Èy c°¢IÒbµKwğsµ‚À$šiÃcwñÂ0F\µ7ºõê‡GOvØÎhQk&R$ª%yÈ7¥4O>;‹ÚRÏ?o,%BtTÒèQWÁO“4ÜQ)&8ÙDËFgè§ïsm°Ñ¬¿ÏcVyZÁo»«Ù>ğû¨vÅZbèi+…
”ÛNÃÇ`ùêÛŠË|M2s¿Z–—À-34Í !1;Ë]ÌâÎeç`yI8aµCd1|»{ª)însãtÃf€®V²ÓBç@*wr0L²Bhò¨W²ô:gìfÅ­¢”ùmNŒ!®Î#Ü ÃíR{ö˜Àİ1ŠbÅ’@Ft/V$(`Gdé{â~L¯,d(éB²!sãócÀÿt…eı|/tÜ¤w“ §qúÍup¡¼åÏt»:Ğ*¿sN4Jå%fucA¸EwJ<,šR#kV6âÓP¥ ÊGÛ)RAF¶A–İê5=%m0$´Ô@‰}ÌzÜç ïÎC*(²nJ-Ïd¿Q+ ;à°*¦0zqÄ2ªkeP×pü`
IkEpÍ+k²Êå”iè}`ëá\lúxú™†£4À_€ãi#|p7õè0“)_‰¶}/OûÇ ³iOÃ¾ãıó« šQ7×M„¬k\r«‚ˆªdq]€ßg9!$D"bU!zsIp]lLUª56s3+*`Í[w«X)8'ùè@ää–`¡L£S^ƒ\EğíÓDğyªnş`ú…­L+ƒcl@t9ZËcüaÑ—`÷ecrÇ"öUÎ
>êùï>kİ#ş÷=ºöh6ŸmN÷c‰†{'wDğ®ä<qH–i¹
û¾`­¬Ê.4p N2Û¢R”
gª\Ë-çUz!@ÚÑ“qW,CGÕe³ ¦v‡#º3r~?mx)!q{vjö+Æ(5øƒaƒ$MícÑfZAq(MUÜ‚™SP™éWóë’;†;êÚaó`‡ftĞòjTlbmÇz ÄFr-Óì%éÉò”)L#²")­Ê#úbUÒuÌ`[ÅGe}ı)Q»È]Cwàf¶âCªÚû»L­XOj>D:0›ezíÎìÔm:«eu%õ&2ÿQªêaº‰gpaèlõæºşJøİÜ‡APB…ˆTS§Ás(Dšôó+¤¡la« êÎâZ½ŒÊ÷`òãe
âfEn¨0[HqıÕşâ*yôbØqµ,­rRÌÛBú¹$\ÉÀ˜£CxV¸iÓtu°„v0ôÀX)<‡eĞmv 8#*‚ñ?¸ Ô±¤7^¡Zò{ÌPe¥Ëoµ,‹…’PúNõs¼]â,$Sº±"‘Á€…Cíúe4¼öq§0Ü¼x“ÁàÃaƒ…Ú	HyIu˜-ôåd¾À\	^{VÓû¬¸¦zÀÖAÛ²,Z:çMÍ’Â¾Â}:,pg`2n).Oé¡ái‘Ñê¹ÑeşåqÑ§ºÂÅhnüÕî@1bŠn´sx÷OS¡KÌbÌ0Ù«%ğ-„ÛªäHAá.l´a,i¤ÓÁoèã¡ßt”§4¿¢Y{ı7q[n<!jewz»p!eö[šƒ]Ø¹k¢i¾pgôW30{I@6mì^&ÉÒ?Ç8Öa`Š‡T= /¯ad°¨í 9ÂtåÍB	{g¬N÷@cöy§Ab!™;ìØ0› B%uC"ƒî5(e!Çñ¯K¸lBÍ'pÉ.úMcGØó> >ƒÖÈøĞauaïA)²óÈ³·ÉGÄÿW®¦n¶Í(²åìD±¨•SO^>ìh)è¹©a«–wFnSc¶m¥ÏÔHøiz0["[‘`1vV9ë"»X=Ô²üª¦!åœO)=P%8VjnVãúÆERÒy÷Í¨I>•SB‘+Ãö8¢!ßqÀ|	+šy”vE¾¥á~|y$KÅmR^&ŸâQö6Hˆ{jÛ2æ"x”OÌCOíA±k¥ï»èC‚åP& ¡úŠt™†¾ş#Æa:áô[E$C}Î¡V
Îv+uĞd…6=K9Téó„Ñ~M`‡}IÔP¢ÒÌå±uĞw»ÇécyFW“'GÛb¬`ÛÌk)á¨qW§íd6å”âş–ZQJí©ôç\{fcg€Ë™Wåfe¢çU²˜s;,"ûÈ/Šë‰÷M	\ ó¯M\s0nmK"Ã#O2vôzZKk5º<!âRÙ¢s}µíçWuî»êPPv|?jß\ÌÍŠ~iÙë>Y:a=0IôœÊa¦øÊìi—+¢jîh	vq+Å”÷ñRRQÀ‘ Y™´A6ËíôLqgÖ~wWü[°¬È•sùKÎ"DooF0`¥š}vş«ßoŠ;;t¡t9h2	îAjp)€ÅAşğœe&‚t2x…Iót\òra Buß£#EÊD"…ıéêÂ*–¢–Ú’¹KtwÁ9jPg5cKZıE‚Æòô&1»i*	/fjò:©q<³‚WE
&«oN]ÁººÆ-ÃbiùÍjyìVªhQc)‘RFÁÏêÒg\bwM1°0'B,Òo
gWN©sjã~âAgÄÿŒm«rš<åa¿.J`¢‹Ù£ã¥xk-<sòé(üÜ#ÿW{òÎóÃ7,ÁNf«+CŠ<í:`® 	 `‹Hzşoi`åm³êVİcM)DÏÁñŸFZ}Hæß%xï™fl#Ñyq?öŸu:¯8lò'zg¼mÃ»òÉ°ã=pQ`}nÓaic\F!¤)* ÊAÜ@e-"®4íòc.öK®“xYmÇn-s9;ôì#¸‰»åöm2Ó›TZÍÊCç3#ù6®)41ínmTôµüğ¶g Ğ
o+eßl/ôZÍà‚ztVª­?I)ïùvó—ÎÉäè†– aê¯mÈÆ’GO;ku†£Á’x»j¨èŠ›<n‡|<¡59-K
íyĞô*ô<İÏÔH©4dä²Ä€[wœøïb©ûàEUCê¶nEì¨ëZè °0ø@”_ÂÔ s!—U µLd¾©^##y(8†*	ı%ã;/]ûsg€*LNtÙ‚¾%1o{s§c–˜mI(g¢1>š¢Z;%¦H0’"½®z®mÃª–4„¸1x[¨m2¼<¾ø ³oñAØ^fMĞ˜¨§Ù4¦Œ]/’AßÉaú¶.~Ú0qÖr!%wtˆ%íPºatë=º«9ç$£y@ÓÇbñ-êÊIRöè†8*êµpR¥ÛÌóìv!¹·ÊË&¹m4Ğ>*õ7?:HâfÕ rr¬ÆGÉnmùÏWÓHK¡à«Uú5ß
Â$ddŞÎ9Tòñ]ôú!ë`™±÷büÆ½‹O,á|K>ƒ’!óô$¢=¦"y³gË¬!+%AE-7‘ Óğ;&Ø!ÙaB’awD©?Ì,X %Hÿ.zân¢¯|é–örìÏ!=ó¬^*8¹ÖaFué‘|!<A¡7Å©©s;}#ã€U*FìëUHNMãSe7á.L®r­Vûpùeï\‡©rn$À,P²Ÿ`€Iyqª»_øwn îìBƒ#)aô¹´f5e7%€´á‚w¢|º@jå—xÄéW^ÓèÄåÌaÑıMn¹fÑÇñëò‘Ce iVF¶v‰ó.æ4¼WRX&¦iáSÂ+³(Ä	G«÷aæ9JT·µxc&­ve[G_]éà|2ŞÕa“ kü’¸@)±´°¿$=Š®xÓÄäBÀ(|S³_6|<f«ğÜ€=m) oö#9g¡wŞaı8X#eöë7äùu"aÎMÉP!¶êßÄ›ı«üntp+Ëm`Ê&‰'š\eÏĞ÷<ü¼b¬mëj»"glÿWwIÇÜ¢E£
³¤2—k3ÍÒG5soˆ )Rb<Ég„0¨¥UA¬3ÔWuÈ&Ègòhá½móJì/ óÍÍan`f0%vM-u„àwú‘ix$Š¯ `V Vø*="aOKcB•{)$¸†®—æ$Wc#7{”xüI2Ü^t7qês(!>
l Úçr2µsÒuÏ¥R+ ro$(´DvsF°{	+1fEüø!ÇäYçvIâ  fú€t "ò÷Ä#.¤a¤ –dœav°^Áåz^¤„e°ü9a*gp¡`gäRpäÍ6{=kQôìàhÂå2nsrŸÊo =V+Â"ú8A‡SéömˆåémUeÕ5xœ„XÿC`zVb8Dj!  D.F²|`ëq4¤4 EHš5—¹Ò}‹a;\ùr¯39D}/.`ë¸vheWËRbl#dkùi,÷gˆiÓÚã'{R:N" SWpc’NLg¿bqİ7ì!ã 4j´Àh/[ƒ"AuN$%lÇuD
'jxÈ3ç5¹tßç/GæsÄÜ½2õk½Qá}g{÷ÕÊzËcpt.B"Vïuz:h-q¸Aş"ÏKÿR´ÔU52a7/ïMr-ËTMa¡(ÅÓ¸#7%,lÎT²Na•~Ã•.]a7¥=xnp“,€&{Û0p(º!,L4>-/¤rgÇ|Loğ§H!5k$"ØÙ?¢P“‹éçô_ÅYàh$KdÑäma¢/Aëúó*om1¤W*ƒı+3'{sç+ã`«uiólV=:şøMÔ`Ÿ;åïÜu$‡~
uînO?)^':Z7,ÉûCU+;¡ÂGNMtëb¸!é/´4¿ÂdÓå‰ópi«¿Bgÿ),%8*
x#¶ª|:i1¶jAêFdÅa^èo¿PÅÛ ÍSaG‘<jv'sì(ZB@e2û¸gÈ
tUbklº ~dó ,e*$#÷4~8
c”¨M•!ôÛW^¥eJAãüôÿë2¦SÓ(ey"ƒãeágBÒ<é>COGRVªIvl%Ö‘é9è°ş cĞv’pkra$/‡r}2%nÃÿi‘š›m}(Ú¬5v±8è½è(
|5röK3(êäsã,6Òsô¦Ï+½cOœNÿ63`â-_1ÆSæzhDîsºP 5õİ»ò{õap+gFıgbÕ»Ò*gÖe™ç$Û*İø7fc²t!8|{êd¥¯İrƒÆn*nğù!2ITRdµòƒÖÇ.ÉóäC–!†):ÿ2ï[ÍsaH;í®^ìÕ R§Ğ9v*qkş":à®9åL­gò~AH`	Ùw@2w˜wÈÂû+EˆçÒpF$q9~'^3smF_˜plàùG °2|ï;9+5µs·*¨mó	ßºE+!$Óÿ?¶N$n51*µp=me Tgämİc(ı½[píÁrì*5dgòyš/ü)%áR½!^>:`8zèZ~"ª=÷ìGüGıó6a7EšA;dÔ9ôFz‡µ`s¦¨h
ï0-¥†.±f%&·'`Ş*Ë‡ö-Z?%õò6­{XÉˆct}$ga‚:-]t0¸ìÔd‹¡vòY*°Ë£Cî0joz5¦ 5W\ôLú¦'yMŠ%R}dP¸Qàuv«6ÊLxi9¤êT5­Ü$&u!kÄ“lÓÿrùgmiÂ§aÉTnq(;ÿî%É;:gŠ!5 abG>{mİ­uc7Ÿt6$4é×…25ûU×M©ÅdZae:1¤¹?£î--{EêôıŞ'ÓOec1"ri9c<ûE€o6m BGü7£f[%ûSĞçé(»T`¢=w.oø}*X-¯é+odM»qø»!İÍ{Ebg XFÆ,‰åRÑå1 `IûúéŞ2I-`©=`ïæí?R7{ngÛ¡!,µÁY…=sdïhPZ"w	n"±G-®ËiYÎvò¯Ü÷ Û—d +•qvp«|m û®a'DÄ÷q½fzA2w"’açğdÆS\#
\/Åpq—ó=NTüB0!ú¤e=ƒùê] 5e7şjùbeIgY ¸
íĞœP@vE~ĞR“×ª Ør6 t©PN7$n,ğÅa½u”eÑ=ç
¢6n&¦è)k#zVT{}kvëMô(d3u]âT<AÁrIj¤|6:f¦ ¥ôbygéAà`x yewë"Uo~¼jM,ûVt.4iÀ‘€’!1hŞlv9"4İ¢E­ÉF(·;d"‘¥"á39è^«¢êkgV3IcI&l_A,"ik€X.bq\k,B†v9á¤wQÈ}å…P°ç9z?dBwévü¾Õ’	>3aMa43‘æ|u¸,|=­>V„T0ri‘uõÑV5uwt<'p@‘}r}0t¦[v.\_ÄRÉs®vts;eşöwix×9×šKUj6øU87t+¸4=ì´}_bËFUewul.Pµ6lyc‚±C&¸[û‡İ´€ñò-¿ùJø6¾CD=ĞÚµH)u ó“)nô%!Yø]".i>‰•p*b²B.ód
qhIö%yggzğ0;2áM{?yºİö?_áŠ=Ê¹+èe4qqÎÂh7rÈo8'íHm }Qi\5w	ÖÎk2õÀæ¯véCF}Sİq©;$y)89rØ,]qìr(¾ô~ós9ÖêDÎ,aôBKİ;™"ß+Ò_qb¤ª,ù˜«<g…w¬Ñå(9*Zù
;é4y ŒTk	I–DìrFpÊ2~1srÉ|zt
%kï(j¸›³7Jfm<Ö¹^ºÍdÈuv\)!@t*’3Hcá,®pa X)y6¸wB4¨,’wNtû0uòmè­áI?o e`±bŠ}ênÌb½'bŞw+A×˜auX»Lu.l4é‹Xï/%ó§£xĞoø>|†,ÁØ%wÅb+•º},a.Å°À)b(”_T}’ñy_a(„bùÀ,|•½@`…ä^)J<EY@'63Yîcup¢ÂÊXÄXeaO:|t$ÑPW`GXcjËp Jİ!ÚÜHtºnêDô*,t”}í~	q‘Ph°ç!¾Dq¹u4¨=fnY*{V±áuØÍADC`*:pcVo÷N©ZeN‘'78ÅcIßê5jzD%eZc!Kèu6o×-¨|¨›$%<	ëDåu¡ôu)jJëi‹Sà-5+aé`D,8omcš|}- %²):¼¼šäûüú'íÜp%›‘'McÁ>ó0Á}(ËsÕu‹…nÔ{z×è<Wz&äsÙ<{MjEa¡®Fİ>Ò¿O· (ì`ˆÇĞ1`$‹îI=L[00jïDgÊ;à‚=S{pá¸/¿&AUÍñ‡•Î2^sÀõ4¢š&‰¤£µ	úglb¶ÛiOÀ:m&¨cm4*:’ÊéE8^óJ¯y¤=ó*gÃã\"„qI}©Øì7[ x ®#:Œ¼àäqOŒSC…eä*ëI)qgì; x_ŠÑzvWYÔeÕg!4$æ@(ñynê5şa Y!è OCçä·Âx÷T`}3‚]ú*êåÇ-Ô_>g¦zêÖµ@êuL.dK*H‘)ä7ìr>ÅIB5µAÉîTs)NP$æ<:mÈd?yw3±e3~«- Šk$SÓôM`gõwTw&`$¢k¸ŞrªtÍ¤c,_@¢ËOi›]$‘z§Jutç@4”\_e¦uj`™)¹dñ:“<Š¨öepw·ÇÅ—Pô›eS`¼gòv®¢ `
Ò$>5­Án3{İ2o@å²“K_Gµ"RuDñDrV†a9ün½a[ğD·ùeË…Äçän£ëü`%£ Æx®tºóÌí™|T|!{5zÚ5)í/ø±€b¶*^&llr}¡a‚æp&Imk'Dòı)bmh[q29úø4£( oç…sŒ‘ -—Mœâ©a/âFu%ÈöF%	0«Èˆûé³|tø8yCàcæ Vb$¬hUF;>ìPÛ*,OBd½q%şój"ĞL¥Í$$mÙWæª=¬ı”AÙ=ät²6îZëm5š}™ÅÍ÷ûñÖë6¥ÍÂa4E>íÑª:;9uÀË¯¦³Öl½RrŠ6mª	¼«1¡ktyµB)Q]m`Aëg0š²¦ aY2ÒR`9‡CyfqÌEtuâ?n,Y9.×„a-}U8İlvñfï`n¨¤LP~©øwãhæÒ¼«¢V•jz^÷x(@
™ìj$³©Ade¡]tqõ1Mq6½5ş%½2?1ÅÙÑxÕ_°tK¿|hGI,²5k…`.¢áéÖFfá¹	!±è±#St`soø$l@Î6T,JE¦d•a)‡J¢~U^ï¡…géIx QrtäXf$d½x>MµÄU*Snæ$g +#BÂ]Tñï2³å¬ı2&9´éz4^%$Li¤I*Çc°œFP UW²
"Ox	odµs¶iLtDÖ8:COÕKPP aè$-;Â“çIs&Wñ$ùS•Qt÷Án1iğüáí`Gõ$}:?iJô5acW%Ü»MŸ§Ãˆ´
!(s+¯i06/rsÿ_uàH,Oz×Òå(u¢:Ñ¦ktvÂeé[ô2‡"*¯54ÌvqhÎ
Se oedodåKşVg}KøtMÜöò|Š£yfÈq÷CYß¥wÑDtTY|ÅSÕ:D¿èá >[K®ç—5Ş244ûâr¢lMtm1lTªŞ%ì©°6ûM»òaeéÔe ijt/dÁuÏ:D)q  +Üyqt·u@:¾(n—#*9°{hmOx_kksàu8e(N`ÑS\è“bnà°vw`ªON ùSv=¥Åè+C² nW{¢¼âu¡_)dpà¡½_ÇcYsÑbØsÒ¹<É6s©Øvÿ^ŸWeuæUºI¯-ò
k­ÿÉEH£W&q,’açe?›34„"„pD	>-#ğäFáqbeJl¦[ld_$7}¡j)î]Í,ıšX(•™¢)@giiÒÓJçeÜtCõ§0Ìc@{A
½(#Òc0 t#3ëí[‚m`mÓ,lo,GÀ™M?&Ô6&ÈeyWó(gá®UuDYVj‚ï>bo†¦9{X $iTƒ&ö¹/z;tb"`uo71jÒ}={d I™pÁ.ÒÂ~}bt¤eñ•e/}UL7f^Ü7Rù}32Lã7œ0{õ‘!sú.<¼ı
h¯Ih·c$n
i(Š<˜ï:ÕÌ1lõh;!åñrBÂHÈQeGæZ -&´PmöWäDö8TÛ~aëuQ}…TVTh.D"*oŸb÷t4t7q~üNéa˜áÔ'Q{òfü„ â™ûe}puäKG¼#-:Fô`RãL hwÅSn²„5.¼ÙšjI|8¯róN8Wşªñ€G²?w¯”>vtTr»¨Ê-aïfä÷ ¬C±0#=J¦í…Âuc·4qJòèZ8ÊÁ2db*ev±
dò§.-î£j]2{#ÿ¦¢ÿ1&ã$ubšJ'ù$>k»ò{;ªƒ1:%‹U#`Ães”¤`šïpüÓÛehA¡uzåí%¶ÕşóÇí-â8IaegÆD/Q}øq»(Eá!impHLÎìt8·Éc< s¡EdĞêBzeõ.÷ &‚i püÛa¥€YRS^½q¿pÓ77vpË¤²hxÓà1 ïÖ€3!!äFe65Õz.E.ú0JlıÛv >óû`li`f# “9~9(z=5úñ{t¹l¢fûÕ)pks_8©P&âºL{yÆwbØ‡–	s2.TTwxnû+×U°V	—D¢®$ìi/ADM^˜ñ˜UNy³e x¤Ÿ„54Ê`yé'¡|N”=ª`Eìqè€YÎø5H&#Z©ÆUÕYSë<¬ÓvşSŒ$(ŒÁ#yg-0Ä_ox	ùn%gBl¦Hòç»ZÑQ`HKéE<¡òbp/Ä,wo0„áìä=#x2µmèn`$<›,x6yB{¼tÉ/õ%mV jeÃªªwWlõ–nuèÂ8,=˜$¼9ğ&7dDá(Xlu${gë|ùIì«aal2²Š!ø1øjì~?ÆáVcÖ©dÖs*pŞZñr'w®ª«D,¬6Ro£*t`Æï2m{&ó5~¤ìú‚z9NdDXJ ªÿyçòiê½¶9°n:c?™®Y1]8ª=Y±DFUø‚Æ4µvÉP<o¦Êq6cşå{pöŞ)W	q.eIu%ÑAt=ŒÕy9B˜G	íêÊ09³9Q`/PÆ$¡*¦Nzá Qf™L—T)Í3î¡¡ ğ!é}qj`°I!¤ =
¹@ñá4#öáãÀRkoÔ¨ïU¿í®…Ußœì`âs´VàQ+5
QÃ‹gĞú¡>·Í·H,v´:™ ¿vp	² l!§m²–ja.ipj;0OÉ¢eD{‡åí°:W-è›`öRávgëÉ1~+KR)Èyg„Ygº:R$,lŞT]j¡™­S9ÀjHû/f[OX*„Y½do¢b²b@Újì
;Q°7·‚D$hC‡aéF	0F<µ7’fØ"@ş8hay Ê$ª%y 1$$<Yˆ2gRË.(`*1FÒøQRÀÇøs&™ŒË*gè³ï¥m0²®GÁ—lX_Ño2©H4a«³~ÅÿfQíX'#…KOJaùâ{
K^i2b·Ê–¦À9=Í !)7Om¢Îeg`$IxaµCr5=$;øª?h$as£5‚æ„¥j°áâça:}20M¢AhvW³d;_}gE­*–ùih)Y)æ×sŒ#\ ƒ	¯	Ö¸Æ‘ß!ŒêÅPFt, (`tmÛÀ~L«e8‰P"!sãÄÒb(vÍq\—x.!üÄu! qû\÷a¥üÕ¾v;>1ğh·'a_=`Hõ%t7KÑ0¥w€J<l|Öwks—b’[¥)z‹8RB,!¶ŸÏÛwoee(-t %´`H¨uŸú¼çj]ÿOCnjrN
Gd®E=<7¢ m
$~pÔv*au@×üD
Ò	BÅ^pÃ%;¢
ï”i9$góí\,¹yÚQ†#uá_%÷	c'xr'“ì“k›É—yOKa¤0(mÃ¿çlû«5ši?¤j\d©"ˆÊM-İß')% b&U«~Qp_ Ol*6s1;jaÏ[&#u©<'éêÅÀí– ¡"z–¦;\Eğå…°yª.-°ô…¥O+ƒFsj|;l*1ô!Á¡Â7$gsÎ2ò\O
>âùÿ>yé¡ı>e=»>h6¿m2ücˆ‡k?W`Ôª <5(µi¹
z:"´íÚ.4p¨n|&ÿ&:Ôtv>ÜÙ-¿Yj	Aš±§Qk=CWÕe³‚æö‘Gº72|;mØ)u+|Ôid(u°#h$Mç{ĞfT;#E‘Üª˜:™lU2iÒ9Æ-¨Î0³m…Ntóğ"Q)fNÇo¨2MÑ¾-%ıÅ±„bƒœ)3°"!‚ úgtÒw¨ê]ÅGu}UkK»ˆ]_I_ğe¶î!~}T{{(¤XW5b8P~/GXz+©NDem:»%u5¹6$2Q›êu{‰g1 èTduö*şZğ=VÔƒ@@SLôÓ§Õs!|_ñû9¤+-àªÛ~NêV½ëğ$Ò£g
ä#Enh1,y!øÅE/%¸+Yt"Ypô(yØBœCò¡½´\Iá˜ğ«PO0v
x
;´t°,t0m¢	>µ½œdLt> 8A+‚u?øyô=´7N QòiN@F¤Ë/1(.¥ÛPÚ
	ïqU]Oâ,dA¹8Ø€„a¨re0>îñ'€É¾jÀ’Â|Immed˜/°me2È}~=WMµ©ìá §s ÖAû´4=J>¦	M’B¬<Æ}}1|,tg020)noí-å¨Uğ¦ºó?şårÕ'ÿÒ†(nzÕnF8b«|¬zyÿcc(KüRz™¬¤òDİ¨dPCã&d<a H4ÓéoêÃ½Wo«¸½â1e=Ş7{[|:!negz{xaç÷ÑÓ‡5yúkâi¸ºb…s's‘<û`Ğİ4RmìOW¹Q>ç&–±`“—T<¹.»BÅ ˆï)jpaÉK{%¬gDgŞy&Aoaı8ÍùtNT<B$5$àÆ0(msS.ñ|VÌsb¯úrvPÓ¡¿¾§ÒèğÔùBpiï9æRÊ#·égdû[©/¦.µ¾(2±åNdĞè•A]Z–lb)è=9©ñªw¡GJCc²dqhxGr07tYQA1vV9 gâ3¿X=Æ 2°êä!å•Ëë-AP%<Eªd<cˆºÆEÒy¹÷QŒ¨šO$•&UÀñƒ*Ãò8î™Vaå–Š¨±$vo¾¥c¾lm(KÁi^&×ìqÖ6H(Lj‰<äbSú”OŞCWé3#¥ï+It;ø†íT¾P¡êdgÕf#DA;a0 GH$S=Ì¢ÎN+d˜ä2$/5Tã½ÄÛymtşKÔP¦EĞÙç1wĞs?Ï@'s9+f\°5F[¦mhÿ^k/çèaUÕ§Îv$c4âşÒÚ m%í¬Vôãz!tzæ'mè¹_Ef'ãe}¡¸s9>C{a+¯˜²MCÛLó¨MA~s0oÍcÓo?~GI-¡º 2úVıæs=·M—gW}®¹+TPb?:{ıxÙš¾i™É&?Y*~=[¾4Xe èî|]•;çzîh 7`GÙ™e3S€PTà°´F¶}ÉöıHyg”nwGöp¼ØµEñKÀ&bO>d2`Œ›6*+ŞMoÊi;eq%ü5NY:~)j2)‰%A”6øYi&’vx±sA³eæş`àRõÿ‡eZ]ÂXvİèhB+ş–˜’!jT4Æj¬#5cKZùT€úì'1±l2go¶û¡q4»×u~¯c_Ãº±Ö,År©«É{:åS©`ab)—\VÀ{«RgYãw/1°0",m
Gr®a3Jcã~âzïåİˆK¹r4,alc`‚NÙ±`µik-<Ÿcrí=|ı"¶Sÿº2æ³#7,ÙFf¨©a|ôë<d5`t#Hzôïhğ!o»îzõc?)@ßåù›d}h™öoA8ïPdl1!óy4s9Ö”t:“qnr%nn<hÃ#óM1ò3©ZA`}î@`(c\glä%% ÚQÜBfMRævÍ£a>Öª“|Ym¢b<ğ)Œ;ğ*;¹­±åãZi0RŠÔk3ìø;ç3hò¾i53ın$}tô%üğ¶2£Ğ /"eıg/tZÍç¸vwRâª»-şú´s‡êÛ$ì?– i¢†-ä(‚²Ä_{ãT# ãÃÒp‹z<ëŠ[|^~×}>¤5$,J~
í;˜Åfkv5Õ_Î˜{Iápsä²$E„{u¸ïb>{{ÉFUÂìöl'$¸ëâh u°zAÄZâR ’ë9¥“]7`g\d%2É^cgO,¦y¸–?K}%ã+/_»ss 0«Nlù
%±k-c‡w”Ú-mh2göM9W.:# ;-®X˜2¢´ß*sïoO°†Äü!yZ e5|9çxs ³gòaPv`”Ğ™ˆ#¹1 'QMkaú¶*~Ó0uÖr1-4ì)ıĞºppët=¾«=ç #yDSà–!)¨êIaä†8 *ªµ4
q=$Xìòl6!Ù—Ê‹&±ìqå$*ñ7wxí®fTÑ p'¬@ÇØî]áMuÒJ¡‚©Eæµß
ZZ5à ÖŒ9!`,°ºaêØ(5bıAñN(á5³A4!sğLc5ºç"y3íSŒ4:!Ò%%=ºJ	 a+Dî5YpIbRarûÌ$P!åH÷.<àj1¯=I’RbïI s8Fª8±Tn7ì•,!ìA wR(ùvz?=&ë–E:FäòUhN]ãa7g. ®öí~{pıG§Ùh¤ar&¥¼R2ÿa I8uª=Mèn*¶¡îhC– pha9.F5%6,ˆ5¨„²¢\ºäbg‡zI_SõÈÀ„D©Ñ‘ Ub¸rÑöuãò‘š"ac0hwB³vL«s&v5ü5vV@&¦mátâ¿õ( -5&(7gAö-Jµ·Pc6áÖwvÆM_i’á4~Şåa®jü,ĞP8O±ôzw´|‚ê´SÄd@t(ìu¢Û>}2g	ôĞ£m},Qc«9.¥¶ßg†}~ )hö+5äqseÆOI a±‚ş;äŸx‰r xûm Ó)¶‡0ªiÏÒ÷09y¾7b¤mkêû 2n$ıT&i;™L	",!yÛä¶µy|;è’g=qo ¨’b6Ùw .ª%TA¼"Ü-È$ c’`¡9m4Êyø®x÷¬íájae0$rï-yöàwÚ“ùl$®/zeAtomicRMWKind(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "kind attribute specification: \"" << attrStr << '"';;

      kindAttr = ::mlir::AtomicRMWKindAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("kind", kindAttr);
    }
  }

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  memrefOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(memrefRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  indicesOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(indicesOperands))
    return ::mlir::failure();
  if (parser.parseRSquare())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseType(valueRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(memrefRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIndexType();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(memrefOperands, memrefTypes, memrefOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(indicesOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicRMWOp::print(::mlir::OpAsmPrinter &p) {
  p << "atomic_rmw";
  p << ' ';

  {
    auto caseValue = kind();
    auto caseValueStr = stringifyAtomicRMWKind(caseValue);
    p << caseValueStr;
  }
  p << ' ';
  p << value();
  p << ",";
  p << ' ';
  p << memref();
  p << "[";
  p << indices();
  p << "]";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"kind"});
  p << ' ' << ":";
  p << ' ' << "(";
  p << ::llvm::ArrayRef<::mlir::Type>(value().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(memref().getType());
  p << ")";
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::AtomicYieldOp definitions
//===----------------------------------------------------------------------===//

AtomicYieldOpAdaptor::AtomicYieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AtomicYieldOpAdaptor::AtomicYieldOpAdaptor(AtomicYieldOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AtomicYieldOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AtomicYieldOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AtomicYieldOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicYieldOpAdaptor::result() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr AtomicYieldOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AtomicYieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AtomicYieldOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AtomicYieldOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AtomicYieldOp::result() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange AtomicYieldOp::resultMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AtomicYieldOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AtomicYieldOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void AtomicYieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value result) {
  odsState.addOperands(result);
}

void AtomicYieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value result) {
  odsState.addOperands(result);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicYieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AtomicYieldOp::verify() {
  if (failed(AtomicYieldOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}

::mlir::ParseResult AtomicYieldOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType resultRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> resultOperands(resultRawOperands);  ::llvm::SMLoc resultOperandsLoc;
  (void)resultOperandsLoc;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  resultOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(resultRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  if (parser.resolveOperands(resultOperands, resultTypes, resultOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicYieldOp::print(::mlir::OpAsmPrinter &p) {
  p << "atomic_yield";
  p << ' ';
  p << result();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void AtomicYieldOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::BranchOp definitions
//===----------------------------------------------------------------------===//

BranchOpAdaptor::BranchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BranchOpAdaptor::BranchOpAdaptor(BranchOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BranchOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BranchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange BranchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange BranchOpAdaptor::destOperands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr BranchOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult BranchOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> BranchOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range BranchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range BranchOp::destOperands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange BranchOp::destOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BranchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BranchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *BranchOp::dest() {
  return (*this)->getSuccessor(0);
}

void BranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Block * dest, ValueRange destOperands ) {
      odsState.addSuccessors(dest);
      odsState.addOperands(destOperands);
    
}

void BranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange destOperands, ::mlir::Block *dest) {
  odsState.addOperands(destOperands);
  odsState.addSuccessors(dest);
}

void BranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange destOperands, ::mlir::Block *dest) {
  odsState.addOperands(destOperands);
  odsState.addSuccessors(dest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BranchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BranchOp::verify() {
  if (failed(BranchOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}



void BranchOp::getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context) {
  results.add(canonicalize);
}





::mlir::ParseResult BranchOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Block *destSuccessor = nullptr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> destOperandsOperands;
  ::llvm::SMLoc destOperandsOperandsLoc;
  (void)destOperandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> destOperandsTypes;

  if (parser.parseSuccessor(destSuccessor))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalLParen())) {

  destOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(destOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(destOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.resolveOperands(destOperandsOperands, destOperandsTypes, destOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  result.addSuccessors(destSuccessor);
  return ::mlir::success();
}

void BranchOp::print(::mlir::OpAsmPrinter &p) {
  p << "br";
  p << ' ';
  p << dest();
  if (!destOperands().empty()) {
  p << "(";
  p << destOperands();
  p << ' ' << ":";
  p << ' ';
  p << destOperands().getTypes();
  p << ")";
  }
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void BranchOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::CallIndirectOp definitions
//===----------------------------------------------------------------------===//

CallIndirectOpAdaptor::CallIndirectOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CallIndirectOpAdaptor::CallIndirectOpAdaptor(CallIndirectOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CallIndirectOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CallIndirectOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange CallIndirectOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CallIndirectOpAdaptor::callee() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange CallIndirectOpAdaptor::operands() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr CallIndirectOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CallIndirectOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> CallIndirectOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range CallIndirectOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CallIndirectOp::callee() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range CallIndirectOp::operands() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange CallIndirectOp::calleeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CallIndirectOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CallIndirectOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range CallIndirectOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range CallIndirectOp::results() {
  return getODSResults(0);
}

void CallIndirectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value callee, ValueRange operands ) {
      odsState.operands.push_back(callee);
      odsState.addOperands(operands);
      odsState.addTypes(callee.getType().cast<FunctionType>().getResults());
    
}

void CallIndirectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value callee, ::mlir::ValueRange operands) {
  odsState.addOperands(callee);
  odsState.addOperands(operands);
  odsState.addTypes(results);
}

void CallIndirectOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CallIndirectOp::verify() {
  if (failed(CallIndirectOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((std::equal_to<>()((*this->getODSOperands(0).begin()).getType().cast<FunctionType>().getInputs(), this->getODSOperands(1).getType()))))
    return emitOpError("failed to verify that callee input types match argument types");
  if (!((std::equal_to<>()((*this->getODSOperands(0).begin()).getType().cast<FunctionType>().getResults(), this->getODSResults(0).getType()))))
    return emitOpError("failed to verify that callee result types match result types");
  return ::mlir::success();
}



void CallIndirectOp::getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context) {
  results.add(canonicalize);
}

::mlir::ParseResult CallIndirectOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType calleeRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> calleeOperands(calleeRawOperands);  ::llvm::SMLoc calleeOperandsLoc;
  (void)calleeOperandsLoc;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> operandsOperands;
  ::llvm::SMLoc operandsOperandsLoc;
  (void)operandsOperandsLoc;
  ::mlir::Type calleeRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> calleeTypes(calleeRawTypes);

  calleeOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(calleeRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  operandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operandsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(calleeRawTypes[0]))
    return ::mlir::failure();
  for (::mlir::Type type : calleeTypes) {
    (void)type;
    if (!((type.isa<::mlir::FunctionType>()))) {
      return parser.emitError(parser.getNameLoc()) << "'callee' must be function type, but got " << type;
    }
  }
  result.addTypes(calleeTypes[0].cast<FunctionType>().getResults());
  if (parser.resolveOperands(calleeOperands, calleeTypes, calleeOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(operandsOperands, calleeTypes[0].cast<FunctionType>().getInputs(), operandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CallIndirectOp::print(::mlir::OpAsmPrinter &p) {
  p << "call_indirect";
  p << ' ';
  p << callee();
  p << "(";
  p << operands();
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(callee().getType());
}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::CallOp definitions
//===----------------------------------------------------------------------===//

CallOpAdaptor::CallOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CallOpAdaptor::CallOpAdaptor(CallOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CallOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CallOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange CallOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange CallOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr CallOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::FlatSymbolRefAttr CallOpAdaptor::callee() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::FlatSymbolRefAttr attr = odsAttrs.get("callee").cast<::mlir::FlatSymbolRefAttr>();
  return attr;
}

::mlir::LogicalResult CallOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_callee = odsAttrs.get("callee");
  if (!tblgen_callee) return emitError(loc, "'std.call' op ""requires attribute 'callee'");
    if (!((tblgen_callee.isa<::mlir::FlatSymbolRefAttr>()))) return emitError(loc, "'std.call' op ""attribute 'callee' failed to satisfy constraint: flat symbol reference attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CallOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range CallOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range CallOp::operands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange CallOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CallOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range CallOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::FlatSymbolRefAttr CallOp::calleeAttr() {
  return (*this)->getAttr(calleeAttrName()).template cast<::mlir::FlatSymbolRefAttr>();
}

::llvm::StringRef CallOp::callee() {
  auto attr = calleeAttr();
  return attr.getValue();
}

void CallOp::calleeAttr(::mlir::FlatSymbolRefAttr attr) {
  (*this)->setAttr(calleeAttrName(), attr);
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, FuncOp callee, ValueRange operands ) {
      odsState.addOperands(operands);
      odsState.addAttribute("callee",odsBuilder.getSymbolRefAttr(callee));
      odsState.addTypes(callee.getType().getResults());
    
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, SymbolRefAttr callee, TypeRange results, ValueRange operands ) {
      odsState.addOperands(operands);
      odsState.addAttribute("callee", callee);
      odsState.addTypes(results);
    
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, StringRef callee, TypeRange results, ValueRange operands ) {
      build(odsBuilder, odsState, odsBuilder.getSymbolRefAttr(callee), results,
            operands);
    
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::FlatSymbolRefAttr callee, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(calleeAttrName(odsState.name), callee);
  odsState.addTypes(resultType0);
}

void CallOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::llvm::StringRef callee, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
  odsState.addAttribute(calleeAttrName(odsState.name), odsBuilder.getSymbolRefAttr(callee));
  odsState.addTypes(resultType0);
}

void CallOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CallOp::verify() {
  if (failed(CallOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::ParseResult CallOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::FlatSymbolRefAttr calleeAttr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> operandsOperands;
  ::llvm::SMLoc operandsOperandsLoc;
  (void)operandsOperandsLoc;
  ::llvm::ArrayRef<::mlir::Type> operandsTypes;
  ::llvm::ArrayRef<::mlir::Type> allResultTypes;

  if (parser.parseAttribute(calleeAttr, parser.getBuilder().getType<::mlir::NoneType>(), "callee", result.attributes))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  operandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operandsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  ::mlir::FunctionType operands__allResult_functionType;
  if (parser.parseType(operands__allResult_functionType))
    return ::mlir::failure();
  operandsTypes = operands__allResult_functionType.getInputs();
  allResultTypes = operands__allResult_functionType.getResults();
  result.addTypes(allResultTypes);
  if (parser.resolveOperands(operandsOperands, operandsTypes, operandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CallOp::print(::mlir::OpAsmPrinter &p) {
  p << "call";
  p << ' ';
  p.printAttributeWithoutType(calleeAttr());
  p << "(";
  p << operands();
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"callee"});
  p << ' ' << ":";
  p << ' ';
  p.printFunctionalType(operands().getTypes(), getOperation()->getResultTypes());
}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::CeilFOp definitions
//===----------------------------------------------------------------------===//

CeilFOpAdaptor::CeilFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CeilFOpAdaptor::CeilFOpAdaptor(CeilFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CeilFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CeilFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CeilFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CeilFOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CeilFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CeilFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> CeilFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CeilFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CeilFOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CeilFOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CeilFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CeilFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void CeilFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(resultType0);
}

void CeilFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CeilFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CeilFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void CeilFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult CeilFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void CeilFOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardUnaryOp(this->getOperation(), p);
}

::mlir::LogicalResult CeilFOp::verify() {
  if (failed(CeilFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void CeilFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::CmpFOp definitions
//===----------------------------------------------------------------------===//

CmpFOpAdaptor::CmpFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CmpFOpAdaptor::CmpFOpAdaptor(CmpFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CmpFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CmpFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CmpFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CmpFOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value CmpFOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr CmpFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::CmpFPredicateAttr CmpFOpAdaptor::predicate() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::CmpFPredicateAttr attr = odsAttrs.get("predicate").cast<::mlir::CmpFPredicateAttr>();
  return attr;
}

::mlir::LogicalResult CmpFOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_predicate = odsAttrs.get("predicate");
  if (!tblgen_predicate) return emitError(loc, "'std.cmpf' op ""requires attribute 'predicate'");
    if (!((tblgen_predicate.isa<::mlir::CmpFPredicateAttr>()))) return emitError(loc, "'std.cmpf' op ""attribute 'predicate' failed to satisfy constraint: allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CmpFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CmpFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CmpFOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value CmpFOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CmpFOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CmpFOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CmpFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CmpFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CmpFOp::result() {
  return *getODSResults(0).begin();
}

::mlir::CmpFPredicateAttr CmpFOp::predicateAttr() {
  return (*this)->getAttr(predicateAttrName()).template cast<::mlir::CmpFPredicateAttr>();
}

::mlir::CmpFPredicate CmpFOp::predicate() {
  auto attr = predicateAttr();
  return attr.getValue();
}

void CmpFOp::predicateAttr(::mlir::CmpFPredicateAttr attr) {
  (*this)->setAttr(predicateAttrName(), attr);
}

void CmpFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, CmpFPredicate predicate, Value lhs, Value rhs) {
      ::buildCmpFOp(odsBuilder, odsState, predicate, lhs, rhs);
    
}

void CmpFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::CmpFPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute(predicateAttrName(odsState.name), predicate);
  odsState.addTypes(result);
}

void CmpFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::CmpFPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute(predicateAttrName(odsState.name), predicate);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CmpFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::CmpFPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute(predicateAttrName(odsState.name), ::mlir::CmpFPredicateAttr::get(odsBuilder.getContext(), predicate));
  odsState.addTypes(result);
}

void CmpFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::CmpFPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute(predicateAttrName(odsState.name), ::mlir::CmpFPredicateAttr::get(odsBuilder.getContext(), predicate));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CmpFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CmpFOp::verify() {
  if (failed(CmpFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((std::equal_to<>()(getI1SameShape((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result type has i1 element type and same shape as operands");
  return success();
}



::mlir::ParseResult CmpFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::CmpFPredicateAttr predicateAttr;
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"false","oeq","ogt","oge","olt","ole","one","ord","ueq","ugt","uge","ult","ule","une","uno","true"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "predicate", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'predicate' [false, oeq, ogt, oge, olt, ole, one, ord, ueq, ugt, uge, ult, ule, une, uno, true]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::symbolizeCmpFPredicate(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "predicate attribute specification: \"" << attrStr << '"';;

      predicateAttr = ::mlir::CmpFPredicateAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("predicate", predicateAttr);
    }
  }
  if (parser.parseComma())
    return ::mlir::failure();

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  for (::mlir::Type type : lhsTypes) {
    (void)type;
    if (!(((type.isa<::mlir::FloatType>())) || (((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))) || (((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::FloatType>()))))) {
      return parser.emitError(parser.getNameLoc()) << "'lhs' must be floating-point-like, but got " << type;
    }
  }
  result.addTypes(getI1SameShape(lhsTypes[0]));
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, lhsTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CmpFOp::print(::mlir::OpAsmPrinter &p) {
  p << "cmpf";
  p << ' ';

  {
    auto caseValue = predicate();
    auto caseValueStr = stringifyCmpFPredicate(caseValue);
    p << caseValueStr;
  }
  p << ",";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"predicate"});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
}

void CmpFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::CmpIOp definitions
//===----------------------------------------------------------------------===//

CmpIOpAdaptor::CmpIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CmpIOpAdaptor::CmpIOpAdaptor(CmpIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CmpIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CmpIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CmpIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CmpIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value CmpIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr CmpIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::CmpIPredicateAttr CmpIOpAdaptor::predicate() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::CmpIPredicateAttr attr = odsAttrs.get("predicate").cast<::mlir::CmpIPredicateAttr>();
  return attr;
}

::mlir::LogicalResult CmpIOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_predicate = odsAttrs.get("predicate");
  if (!tblgen_predicate) return emitError(loc, "'std.cmpi' op ""requires attribute 'predicate'");
    if (!((tblgen_predicate.isa<::mlir::CmpIPredicateAttr>()))) return emitError(loc, "'std.cmpi' op ""attribute 'predicate' failed to satisfy constraint: allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CmpIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CmpIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CmpIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value CmpIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CmpIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CmpIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CmpIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CmpIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CmpIOp::result() {
  return *getODSResults(0).begin();
}

::mlir::CmpIPredicateAttr CmpIOp::predicateAttr() {
  return (*this)->getAttr(predicateAttrName()).template cast<::mlir::CmpIPredicateAttr>();
}

::mlir::CmpIPredicate CmpIOp::predicate() {
  auto attr = predicateAttr();
  return attr.getValue();
}

void CmpIOp::predicateAttr(::mlir::CmpIPredicateAttr attr) {
  (*this)->setAttr(predicateAttrName(), attr);
}

void CmpIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, CmpIPredicate predicate, Value lhs, Value rhs) {
      ::buildCmpIOp(odsBuilder, odsState, predicate, lhs, rhs);
    
}

void CmpIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::CmpIPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute(predicateAttrName(odsState.name), predicate);
  odsState.addTypes(result);
}

void CmpIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::CmpIPredicateAttr predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute(predicateAttrName(odsState.name), predicate);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CmpIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::CmpIPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute(predicateAttrName(odsState.name), ::mlir::CmpIPredicateAttr::get(odsBuilder.getContext(), predicate));
  odsState.addTypes(result);
}

void CmpIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::CmpIPredicate predicate, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addAttribute(predicateAttrName(odsState.name), ::mlir::CmpIPredicateAttr::get(odsBuilder.getContext(), predicate));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CmpIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CmpIOp::verify() {
  if (failed(CmpIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((std::equal_to<>()(getI1SameShape((*this->getODSOperands(0).begin()).getType()), (*this->getODSResults(0).begin()).getType()))))
    return emitOpError("failed to verify that result type has i1 element type and same shape as operands");
  return success();
}



::mlir::ParseResult CmpIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::CmpIPredicateAttr predicateAttr;
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);

  {
    ::llvm::StringRef attrStr;
    ::mlir::NamedAttrList attrStorage;
    auto loc = parser.getCurrentLocation();
    if (parser.parseOptionalKeyword(&attrStr, {"eq","ne","slt","sle","sgt","sge","ult","ule","ugt","uge"})) {
      ::mlir::StringAttr attrVal;
      ::mlir::OptionalParseResult parseResult =
        parser.parseOptionalAttribute(attrVal,
                                      parser.getBuilder().getNoneType(),
                                      "predicate", attrStorage);
      if (parseResult.hasValue()) {
        if (failed(*parseResult))
          return ::mlir::failure();
        attrStr = attrVal.getValue();
      } else {
        return parser.emitError(loc, "expected string or keyword containing one of the following enum values for attribute 'predicate' [eq, ne, slt, sle, sgt, sge, ult, ule, ugt, uge]");
      }
    }
    if (!attrStr.empty()) {
      auto attrOptional = ::mlir::symbolizeCmpIPredicate(attrStr);
      if (!attrOptional)
        return parser.emitError(loc, "invalid ")
               << "predicate attribute specification: \"" << attrStr << '"';;

      predicateAttr = ::mlir::CmpIPredicateAttr::get(parser.getBuilder().getContext(), attrOptional.getValue());
      result.addAttribute("predicate", predicateAttr);
    }
  }
  if (parser.parseComma())
    return ::mlir::failure();

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  for (::mlir::Type type : lhsTypes) {
    (void)type;
    if (!(((type.isSignlessInteger())) || ((type.isa<::mlir::IndexType>())) || (((type.isa<::mlir::VectorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) || (((type.isa<::mlir::TensorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger())) || ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))))) {
      return parser.emitError(parser.getNameLoc()) << "'lhs' must be signless-integer-like, but got " << type;
    }
  }
  result.addTypes(getI1SameShape(lhsTypes[0]));
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, lhsTypes[0], result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CmpIOp::print(::mlir::OpAsmPrinter &p) {
  p << "cmpi";
  p << ' ';

  {
    auto caseValue = predicate();
    auto caseValueStr = stringifyCmpIPredicate(caseValue);
    p << caseValueStr;
  }
  p << ",";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"predicate"});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
}

void CmpIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::CondBranchOp definitions
//===----------------------------------------------------------------------===//

CondBranchOpAdaptor::CondBranchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CondBranchOpAdaptor::CondBranchOpAdaptor(CondBranchOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CondBranchOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CondBranchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange CondBranchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CondBranchOpAdaptor::condition() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange CondBranchOpAdaptor::trueDestOperands() {
  return getODSOperands(1);
}

::mlir::ValueRange CondBranchOpAdaptor::falseDestOperands() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr CondBranchOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CondBranchOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 3)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 3 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> CondBranchOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range CondBranchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CondBranchOp::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range CondBranchOp::trueDestOperands() {
  return getODSOperands(1);
}

::mlir::Operation::operand_range CondBranchOp::falseDestOperands() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange CondBranchOp::conditionMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange CondBranchOp::trueDestOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange CondBranchOp::falseDestOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> CondBranchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CondBranchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *CondBranchOp::trueDest() {
  return (*this)->getSuccessor(0);
}

::mlir::Block *CondBranchOp::falseDest() {
  return (*this)->getSuccessor(1);
}

void CondBranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value condition, Block * trueDest, ValueRange trueOperands, Block * falseDest, ValueRange falseOperands) {
      build(odsBuilder, odsState, condition, trueOperands, falseOperands, trueDest,
            falseDest);
    
}

void CondBranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value condition, Block * trueDest, Block * falseDest, ValueRange falseOperands ) {
      build(odsBuilder, odsState, condition, trueDest, ValueRange(), falseDest,
            falseOperands);
    
}

void CondBranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value condition, ::mlir::ValueRange trueDestOperands, ::mlir::ValueRange falseDestOperands, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(condition);
  odsState.addOperands(trueDestOperands);
  odsState.addOperands(falseDestOperands);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, static_cast<int32_t>(trueDestOperands.size()), static_cast<int32_t>(falseDestOperands.size())}));
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
}

void CondBranchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::ValueRange trueDestOperands, ::mlir::ValueRange falseDestOperands, ::mlir::Block *trueDest, ::mlir::Block *falseDest) {
  odsState.addOperands(condition);
  odsState.addOperands(trueDestOperands);
  odsState.addOperands(falseDestOperands);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, static_cast<int32_t>(trueDestOperands.size()), static_cast<int32_t>(falseDestOperands.size())}));
  odsState.addSuccessors(trueDest);
  odsState.addSuccessors(falseDest);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CondBranchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult CondBranchOp::verify() {
  if (failed(CondBranchOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}







::mlir::ParseResult CondBranchOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType conditionRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> conditionOperands(conditionRawOperands);  ::llvm::SMLoc conditionOperandsLoc;
  (void)conditionOperandsLoc;
  ::mlir::Block *trueDestSuccessor = nullptr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> trueDestOperandsOperands;
  ::llvm::SMLoc trueDestOperandsOperandsLoc;
  (void)trueDestOperandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> trueDestOperandsTypes;
  ::mlir::Block *falseDestSuccessor = nullptr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> falseDestOperandsOperands;
  ::llvm::SMLoc falseDestOperandsOperandsLoc;
  (void)falseDestOperandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> falseDestOperandsTypes;

  conditionOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(conditionRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseSuccessor(trueDestSuccessor))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalLParen())) {

  trueDestOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(trueDestOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(trueDestOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseSuccessor(falseDestSuccessor))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalLParen())) {

  falseDestOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(falseDestOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(falseDestOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(conditionOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(trueDestOperandsOperands, trueDestOperandsTypes, trueDestOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(falseDestOperandsOperands, falseDestOperandsTypes, falseDestOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  result.addSuccessors(trueDestSuccessor);
  result.addSuccessors(falseDestSuccessor);
  result.addAttribute("operand_segment_sizes", parser.getBuilder().getI32VectorAttr({1, static_cast<int32_t>(trueDestOperandsOperands.size()), static_cast<int32_t>(falseDestOperandsOperands.size())}));
  return ::mlir::success();
}

void CondBranchOp::print(::mlir::OpAsmPrinter &p) {
  p << "cond_br";
  p << ' ';
  p << condition();
  p << ",";
  p << ' ';
  p << trueDest();
  if (!trueDestOperands().empty()) {
  p << "(";
  p << trueDestOperands();
  p << ' ' << ":";
  p << ' ';
  p << trueDestOperands().getTypes();
  p << ")";
  }
  p << ",";
  p << ' ';
  p << falseDest();
  if (!falseDestOperands().empty()) {
  p << "(";
  p << falseDestOperands();
  p << ' ' << ":";
  p << ' ';
  p << falseDestOperands().getTypes();
  p << ")";
  }
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"operand_segment_sizes", });
}

void CondBranchOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::ConstantOp definitions
//===----------------------------------------------------------------------===//

ConstantOpAdaptor::ConstantOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConstantOpAdaptor::ConstantOpAdaptor(ConstantOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConstantOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConstantOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConstantOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ConstantOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::Attribute ConstantOpAdaptor::value() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::Attribute attr = odsAttrs.get("value").cast<::mlir::Attribute>();
  return attr;
}

::mlir::LogicalResult ConstantOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_value = odsAttrs.get("value");
  if (!tblgen_value) return emitError(loc, "'std.constant' op ""requires attribute 'value'");
    if (!((true))) return emitError(loc, "'std.constant' op ""attribute 'value' failed to satisfy constraint: any attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ConstantOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConstantOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ConstantOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConstantOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Attribute ConstantOp::valueAttr() {
  return (*this)->getAttr(valueAttrName()).template cast<::mlir::Attribute>();
}

::mlir::Attribute ConstantOp::value() {
  auto attr = valueAttr();
  return attr;
}

void ConstantOp::valueAttr(::mlir::Attribute attr) {
  (*this)->setAttr(valueAttrName(), attr);
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Attribute value) {
 build(odsBuilder, odsState, value.getType(), value); 
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Attribute value, Type type) {
 build(odsBuilder, odsState, type, value); 
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Attribute value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  odsState.addTypes(resultType0);
}

void ConstantOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Attribute value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstantOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult ConstantOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseConstantOp(parser, result);
}

void ConstantOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult ConstantOp::verify() {
  if (failed(ConstantOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}





void ConstantOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::CopySignOp definitions
//===----------------------------------------------------------------------===//

CopySignOpAdaptor::CopySignOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CopySignOpAdaptor::CopySignOpAdaptor(CopySignOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CopySignOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CopySignOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CopySignOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CopySignOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value CopySignOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr CopySignOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult CopySignOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> CopySignOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CopySignOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CopySignOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value CopySignOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange CopySignOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange CopySignOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(),(mm¦B*Áõ¨1ƒ{Èç/¢bëwaëFv³=^ş¨EÔà»õoËq<ÿB3gîí}­2?(rclØûR"3_¡ÂCÎMmêz˜!á<vĞûyÂïëÄÉEãpIûOTEMkmz(|]#¦êlKi¦BJãaÍ"`èWµQGš¨MÇWZ <wg] œ8
BÁg³¹ß'ò;Efk¨ºdşeõ.Ba»€#³…0~xFkÅè@±#DUËÔ_eÊA€üô÷ç:ÅÇilùhÂaàag‚Ë©IogmÖ‚¬Jv\!Ö— ¿h üGĞ¾–HqúráädZu¾'¦Ãÿi˜¡Šî}	(È
­1m´0x½ê8cö5òö[#ht¨sú<bÒcöËß+½#¤=&Cıp#%û]1HæÂ,TTês:UàowİÏø{söx£bÏg"1¹Z*fÖ0§¬Õª]¨7@fâğô3hübêî!­©3KÆ_^(îğı!3	P Z±òÖÎ.Îã­Ü*Ş2õYÌñåH;m­]®×5S§øy3\Ñï":E`½¹±¹Ü)/ĞmaÈnÈù÷A#wÚwÌŠ÷-ñHÇvp@,{†êgFq÷’yO›pMäÙQ ²"\g²8	.1Åßö¨ª¯óËşEkãÃ;ö&fp;°pO=id8ÔçìÍR
¹¿[òíuÌpıb4dçæñ?ü†huk5#>:ñR8zèÒŞ²áåH_÷DÓèTeƒ&áwAQ;·4FzíÁs¦*šêÎp µ†n°^v¥¾7`	ß"˜G{ö@½-Ìój0¨y]é¨stİeÖÃ£,~0š¬ğb¡öòYj²I·A®0Lï0|µ¢us|ülê¥%8HB;F8TäšV§&ÂLxy{¬jS5èÔ¸$n#)Ä“ì¿jÙ'liÀëcˆPl1%9ÿI_;gë)Ê±lQQMfy§~½|cwóŸÃ¥¼­Oß„ƒ·ÙTÖNİ¡ÁŒg_cuº3„M7"Î#*;Mèä¸Ş7SOÅcaçò?7|E o>o!@eãwåfJ!û[Äçû(ºTq€ow!oø})Zİ§¡/oD’}ŒÌ£°|Ez' HÆt/©áJÑ¤1²`æóĞúéGû 6“-@ë/`ëæí-ÓÿmgŠáã$±ÅIM½ÓÅîhR"{˜o¦qô-¬ıoAdŞWBÏE÷ Ù“Ç Ñq# ï|Ã`û=8ÎhgNlÄWqæ{#2sb a÷ğ¥-Â%×
Y'å`;™=_X¼B:¥úìü=’éã_¢=E7şlúr«	:¸BùRR`2EşĞ/“W²ÚQ—õ)TZw$V,ğGe”P^gñ=£é§nÂ¤‰.ks8ÖÎs}ë7è]”0lvUú üÏÁ3hk¤:& ­òÂYgm!`pQlyeÓécUŸ.´kİ6[vJ.$i@›¸š†1NÚLv;"6Ü	båÈf#±d4õ"Å3?¨”Ã¢úZoŒSÁÃÀãlEÖ‚%økCÂX¤zqlj,Ã„šÅ°cYØM‹²ã9ë_œ7Éïô¦˜~ôÒ) 3ĞE@U7uî^†÷ºì}=µ®€QsYpiĞeıÑVuuvô=gQHœ}ú=84—:r4	Ãmsç6P¦{EF¿ş*étCû×€kÕ`r5üU|W4/¼—0-¦H$ûbóVueW`¾då6Hq°*°S'ımZá†Üô ‘ö¶ùbñ>ŞC†=
Pú¥ZéyÃ³qnõ!|[bt<Q©‘¤(j²ÑR .òTSóhÔt%xõÓ^qùwÀCPyšYß>^rŠ
-%º-Éæ$0MuæãØCsêfy'øÈ|TÖ{w\})òÜ?(°×àÇ€tè@D}[İa©;`y#s.VØ,]qì² Ÿö[%¦[“FîDH%å5¬HËÇ/2û*Â[afä¾<ûø¨œbíÙç(h.Rù*ÿí4ihÎs‚èbDbÚ:ASÃ9QÚnÏ%cé$k…ç~švì8Õ=.¨İTH-^\)àõ&‚òh[e>®aeihS2Ğ~n,ÄWd|š2GñìÀÒA¾e©áI "yêşÌbıwbŸ“(Ö˜q1P+LEEnI,ñ£Nå/%¿¥£hÔkº0ª-àÛ-4Ağ#†º=,ŒiDnÅ°àaR¬@D}’õ¨WQ(€¢ÿÀ(<å­@`Áí^cÑJ6WB>T#ëãq1ºÂêÈãZè@OHt”!Ø%EWdWB{Bßp ÛÑ¤ÈÊ}>nêÙô,dÖqäo	eÓX`°e£¶Es±UÇõP =F9ÎN0ÀØÌEÄRè*?p`n_wzMédYm‹¹%Á;Ùèwkù@NU}Zk‘ájè6kó­Gèm®“™dt4Lëaw•Êôf9hJëI
‚© -Aià?D$0lÏqO’o~¨âxxáş’ä›ë<ş§äSç3‘§MA€6é0„{i*wÍuEÓnï{q—È<Ø&ÆóÉ<[ka…äFüşÛ¿JÓ>²á2ì`ÃÙM,ÃìI¹LZñ*kîdçÊ€
½RúŒ s¸>»oQç[÷—ÕN6NzJ‘UsªŠ&¥¤²òÕY’€è¢ze>ûh/y'êbmUz9’Ú­e¹z:wJ/X48ï®gË‹•ª¤óIüiÌîßüO X ®boˆ¼áà;I¨CÇívjCËA+twÈk&xXßŠÑzæwß]%UöaÄ<ëæÀ0óp.ïq:Qa…;B"7H@ÇRçœd·qşğwc¢Mú¬`aÇ3­Ô^^>r¬Úü€µ@hW.ÌKJÉÑsò7íd^Ä‰b ±A‹Ù
PDî0P¤Èmo}O;åå3«m ŠiªprŒmL/˜u_uÅIwfì´òkn¸Ş
º¬Ï´¢®Û`âïM{’™çñ¥
sqçA4Õ|{E[…Õjãˆ£ørñ‘xL8ˆ¨¦.gøóÇÁ†âæŠesp¼åbEVª¤DàZÇ >µ«Ñi&{Ş2`©²“KáµR4ÄñDsØŒ«¹œb=%YòD³¾GùGÃ…ê÷Pí¥ÿtŒd'„ ‚Îé. ¨óíä™nÔÍax±zŞ5Ym—!Lú’ˆûuØoH6dìzûˆq‚Æp„Ino7Åöİ©eQehù¡;¨gÿö$ ;‚xçN…s„” Œ¥ßˆÂ¹(è-úFs¯Ìæ
)Û0£@™ê±7øxşixP`cb¬0V $¯h@g6ô ›­4_/d½šú7ìSjE#ÜLÏÏdäíÙ_dã¥çˆAÕæt¹=ÎZ¯lxŞİÙÁîòÛk;ë6àUÎàwıÑÊ;3.Ğk®§şŞ9Rgˆ«/¨®¾¯Qàdhtò-`kAde^Cë'  â¦ mVö#h;‡}&iÌC°uçLşO[=/Õ¨‚­ıt~Ÿ&ïø/ïqî¨„ .áàv£bäÖ<«‚!fzŞ÷{0[Wìjÿ¬AdMámŒDM·‘ı1 &­§ß©¢=!ÅùÀxƒQğwK°|(Ä	,ò¥yÅá§¢ÅáÒ( ã¸#¡è "Øf pkèJLUGòu¼
U6$„!°!NâüŒÎïù%béIzqrpôXb i½X~Pm±ì].QMædV +Câ	UñQîcwıìù’*!&ázXe&HNä"H"Íb¢]ÖP"ñY0N 
xˆ§tq4XNq`Ş:»AÏòIXD!mùàD)+¢¦i’0¦°¤ìQ•ğy÷$±H‡üä,æÄ.µ/i h’ı¬eb%ÜŸE›‹E€´!‰w¯éL!®Òsú$DH$šy÷Âæ ¶¢˜× Mp_Ãq¬ô
7…bBtÜÌ¥†¼1`Š"IdDOáUj8åH¾÷_IüõM™v¢|‹ræy6ÊQweXÛ‘wÛF)ÔYjÍ2Eön@›¨á¨¾ÑÚªÅŞ ´´ÿóğºlvé1X\êŞ¨Šşvû	»óaíhOÔ'!‰jö¯ä@ñï˜TiP °{ØYwt³e@_¾(|MTe"+=¸{0|ÎhTkÎòàô¼ÀiY(AÛXì“"fáĞöô`ŠÏèKv5'Æ`oÓú *[k¢¬âu¡Û©r”Àé¹ŸÀaÙñòF˜uÒĞÜ7a«Úrï_—ÛhYöUš{úk¹ÉK²ÌcU¦Wy|€egMxœ›3u€F&f}ï:¾#ÈlFÃAb$KL¦YmDt _àh)ú[EîıX( E(dG+ei™ÓçDÕ[I×®|Dc@zA½(#ÒVd#1ËåÄ,`a÷íLO]fÀsM?–6À&&llI-WÑ*ã[ñŸ}F{n‚(@ïç}óC Ll–‹,BŞéc8;v"b`an—9Z“}ßå$=p	Ûƒ~aU%dá•/Ù]7~Í5^=½7L†=œ ¯µ	ãı.,¼eH‡i©¿b& &y(‹=¸-5õÎ!Zı|o; ¥³`‚HÌY`2^Ín’PMåRdTuQ›náë5µ½•ÔÕ(/Ì§.if7¢p5†u}¼OÙe‰aĞ'Y)õMáŒ ã‰ºåmtweIG<'-¢Æœa‘§ªêW§-¸•¯*8¯|‘‹rëN_şªt€@–_³§…vN^pWë˜êñßFìmf¬a’0-Ë¥éÁÆuù²tCQÊó—`‘:¸èÁz4"HeV±
¤r³Œî²vSsofÿ:®è³$Â$UÒãO!ê/D6kKõ;R+ŠÉze‰U#›Àãe[•ä`ôë|ì“[dIU£Õò½o%¦ÏúWı.Ë8YqtbÒæD.UuÔøÛ³xmEc$yÌäXo¾mã8‹Éc"@áÅnĞzCÚ÷n÷¾˜I™püÙàE…QSZ™a¿V×7§rQ‰¤²xoÆà9räSï^Ä3%~!¼fuv±ı»vÅk.Ú0ˆÍ<Ø~>Óûeje`oãÀ“Í|Xiv=Îás|ël¢bûw	³ia¾(íXÂ_L{¸Âff•ø‡¶ip .NtDõyª{+ÕÑ²^šâ®,*
/ALE0\#ĞñUÎ{óEÀxçÔ56êryË'ñ\Öğm²âEÌq 	x›Œğ'p~š’©ÂÀÃßZuëìÒÉ~¼Œ "œÁiz-yÄÕiu-Èf%cBl‚j÷çòZÑ[THCŒéExáÒûbp'ÆMweáÈd˜aÍ n’5]@LD@.Ÿ.z–yB[<lÁ&%!mF Jj,ë/ªkWlü–{Nõ¨à¸déÍ¼x#;îñ± Xu »gëléYì£aCl2²ÆéüıbÌv<Vñw 2Öët—G#QÛmRcF«w#zªª¡LiÌvS#P
d`Çı:m;n³<ÿ¤ìâ€û-e&D\c!«ìqçxiâ½ê‰j°¡û™îUˆ]2¨L<XµdGUø‚F4µ^Q}FîŠñVeü#;v×Ş©—PKkeXómG‚æ=íX9S¬Â?íçï3-ù—;RÁ/T€+"$Âzáua¹ŠÌÖT)ı2ïÕs^p!âmqxb0M!…Œ4¨H(üñ6SÆàÆ@RkYT¨«]¿élĞOÜä".?õUâ\Fë5+ÕÊš#ğÚé6É÷K,&¤}@!¾6p™°€e)'Ìò–zhnY¦qj—  êEF[Çíìººw\Eè òWa'çÇÃ±üIRIÍiOì¸+Z<kşOj¡Áµs\`hkÖ&[È4Ò?È€}bs H‚cµ &q¡wµ‚Ä$ªeÃ‡sÅÂIpæµ7ºõX“BîXÎli&J$ª${˜1¥d:È)ÇŞXËk(1JpTÒ(@AWÁÅ“$ÜQÁ6~™Ï gè³ï¥mpƒ¦ºÍƒS(ZòoAûjØ6ñ«¹gÄvbÓøÇ#…­Êëƒ#`hâÛË]Mrs½ÊÔƒÖ=J4É$a0ë_‰"Îe÷iV$}8mõA`9=ûú«?i,k3£eÃn€¯°òÇ`*|r0\²CKiò¸_òu>[ıVÅ­"”ùmJ‰*
ÿ•oŠ#İèÃ­‹;üœFİ!âÁaUFtlW h`WTí{ÂnEû	d{ÉPóqsëZrŒrÿV…qİ–},tÜôw“Y$q~ÜÕdäüyr»>àb¥Ua^4Kålö#Q¸9…w€J<lÜcëR—âÒÓ¥mŠ#Û*REFîA”çË_uO9e	'dH$¾ÔmˆüÍøØïEwÏC**önKßlşT*8Loã0o¾n0ÔwªCeTÇüpA…ŸbÍ%k¢ˆùÄa&c(ûä\løiÚÙÌ£tÀUÀ¶	k'Yxx7’è0•)›‰¿}_OĞÂ(2(Oâ¿ëıwë4¸Q=Æ-¦j#»â€¯Iu]€Û%i% "&Uø{SId]!LDªŒ6s1*
iˆZw©\©8"è Òä`!Y¦†=\uàà‘ }ë.»¼ºåPO/ƒsoA|)lË!ü7`å“B·&cs‡&òVŞ*<ª¹ÿ:zİ£ÿ)ö=¿¾`îm^}cˆz?W}DĞê¸<uY·!¹
ö¿ ¼ÏÚ.0ô`nrË«Ô
t¾\Ş-ç[zIEÛ“‡W-CUÕC³#¦vÇG«72?lÊ(){7ê*Æ(5°ƒeƒ$Má{rJĞq)M±Ü€˜’VÜùUó`Ò+Æ{¨Şiòm‡atĞ#ó*T)fOÆj„vOÓ<oèe³°B´,3² mÅÚ ÿGTöwÌâ_ÅF}=]j;ÉusÈoàl·èªõL5şÛLâH_j::‹VXjéÊLÂin)!d%¹š "æA³îº)'`ødõò¯öZzİ›´A`B‰tÒ'Åc)Máò;¤!là«sîÌã\¹ŒÊwbò£e*â#*¨q[lq-üå³˜"Yå*Ùdµ?íĞBŸ	ºıvXÉÀùØ«ÙG8UúNk™´u°„.rvõ’	>}–TÍôö	9C.Âô?ù}Ôõ´,N âzPDáK~¥(¥úUZ	·yŒud,LS6°{ÑĞæ„Cì@e0,¦çæÈ™ºx“À0ãxƒÅßL¡Id7™:¼)eúÀM^;_I•ºäü@âCÄæEè¶$<J:äXa–`®.Æ}:(pg02~)*Où-áªĞè¯*Ñ;ÿetW¦®Ò†hnùÕşÄ0JŠµzy÷Fs CÌFŒ|™•«¥àmäß®äHGónn´a=H¤ÑÁLøCåótœ£˜¾¦Qkv}Ü7k[|9!neszë~aåöÃG%qY€¸
"iº¡cSO"›4ûMÕİ.
ì[Ã×.†l`“—V}™.ûaÕğÎí9BpñÉk{#àNÏDcÔyçEo!¿;ÍÙnŸS|Bd5C$Ã5(i—Ñ¯¨yFL#qÉ!z_sFÑó€o¾ƒÖØäÔáqa£(¦õH³×Ég€{G©«æ,µIÍè²ååíTĞ¨…Q]^øìr( ¸éõ¯Òv3ÁVb3¦dµ¿ÔlùGn0Y&vJ!~R9×ïsw«HÆC¶iîæ!ä˜Ë«lA@!uF...FcÎºŠÒ	Ù¤T€¨:M&„WÀÑ;jÃò8¢qÀ–‹±oÎ'½¥áú|aMKÑi#KhÎàATfxÀMjšwæ"WxÌë_òSíô+¤íX\»í†étó¡îšt»Çİú"Ö:å°W%B7Ï VÎÆot/ä•3u-9Tá¶ÀQÄ]]v†|	ÖQ¦ ÖØ÷ñwĞUÿÇ‰c.Cf²'`Ë¾¬kŸÜo/áäaÅ•§Îr&õâ~’ÚI%é®ÏçVHzæ#rîváf/£ïQ2˜r;>ûÉ;Š*Ù³^	ıDï®M€SrpêÍKÓG"ı…?ZOO1°ú [òD™ær7µíœ¢W4îº©0rww~ß@ÜÍê²)¹ê>h:~=M<”Â% øËí(×:äzïhqI6aGÑç¦WS Ğ‘à9Ü¼Áµ?ËíµL}w”~eWwĞ¼ø•BıJB&@_?bpa¬š;&"şcÛÜkÊ?:t¤ü5|:zAk0-€…AğK˜e$‚`6x•{²tµâî` R¶Ï''Qê@`€WÍèbÂ –†–š–©nt&Ñj 3-cKZ¹ƒ‚ìà0Éo:mgj6{¨q}»Â×E(b«cMÑ:;VÀfhíÉj:íÓëlUfiµ]_€*Öo\sr
W1´0'#,(ï/Z-¨Y[jã^âJQg€yŒi« ›( `ÿnS`Îe£áåmkiuOšcòÿ8lÜc;Wı¢[Ï³“w,õNfAª¯Sš|eí>p1¯8¥	¡6‹h:vë+môåu³îRÍDAM)@ÿ×{›NV9ıŸ|(˜fj#Ñypyö¿|zC8nò&{n¸jÃsõÌ°r‰RA`}ìÓRma]E!ä-&FiÊQÜÀderæ4İ¢c~D«“|YmÇv=ø)+´Æù±á÷mf’›\N7Íúæ3#hsº)$#üj~|$°¥üäöS:¢Q
/:aßa/DZıÀz6ê¬»Ee)|ø$ó‚Úİ¤nÓ–°iê¯rHªÒæGs«q‚¦Ñ’x£{¨êŠ›|rš|y¥um\J*ÍÙÅBkö½İ?Î¸:Iétvæ²AÕ”[qœ8ïdûëÉMUúªônì¸êÀüà°°ş=TSFÔ €ë[uF“<
¡xe%¾É^c#mh†Y8–lIuk+/Yûw^«	.N$ñƒ®%ñz-bçf†˜¯MhCb"meW:¢£[;m¥X¡’"€}«rî[Óy–Ä´!x[¸m1¼,ïzªògğáœTb-™¨ Ùt·Şm’UŞáaúö.~Ë0qVvwtØé|Ñ¾pp*…¾©9g$¥yDóÇ2±mêÈIóì†3jï…4S½¥úÌrì&!é‡ëË'¹ìqQn.°wxÌ†âfÕ 27üÂGÙê]øOSÒ	Z±‚«ovµÛ:ZZ5ä ÎÎĞ0ğI²¿iïÜˆñrı{ÃûŠM,£%—K<‡–a×ôH³"Ÿe"s£üË-0ª!Ò-7BiP ×q;Í7Ù`B’ev©Ì.LğaåH÷ovâbæ½=NÒraŞ ó¬Nê8™ÖUV"é,,¼C°6Äéév;?`÷>:ŞìúUX^]Æa7e,®v­^û
ùg¯É8–½q.¥Ğ8Pğßğ[8e®·ìnn
¥îık†h)hõøtf1%7,¬´á†à¢Hºäkç‡jÄÈWXÓÉÔ¡Ì©ğyOl~ùdY×õëLò‘šGeR YVF²tÎ‹ó*æõ¼V_X&¢OáVÂ³:Ğ+ML¨7²-J@?µVs2éØeFOÖO\íğğ|2èÅ`Öaj(–š@8R±ğ²ÿ4,‚ï4ÓÄàRÔ,ìSçlv]>gŠtÜƒ:}iÑ{æ«8­µ×g})#)Hô«uäñu eêÌ ¶šßÄºé‰ø-0|
Ïm!S–‰2ÚeËĞw<Iı¼c¬lëjºb,5ÿqw	ÃÌ¢$óJÛä´—aN3ÈÒG5snZ ¨Òd8ég  *µT(;ÔWıÈ%Èaòx¡ı}“zQXø¦÷Ì\ajagdwÍ(y† ghÑùx%Êï`ğFäVø íª[OJãèIiCÚÎ®Çç4”û{#Ô¿ˆ½şÈ9Ş3³è{ :Om2ûçr#³3X¼Ï%fYÚ|&l[f²jo‘›+#m]œØÁÇÃ9…réb"$sú¶`f*ùó Ô{„ğ ­fìqt‘^Á$<{\ œa ÙbprF5cã¬P€äÜt;9{AâJànÂå¶Ûyâ‚oÀ#ävP"ú‘ÇOğòıÈôù£íÜ5x¥œÔ	ŸO`_^r/Í…BDkf(N¾J¶x|¡N±  0¥@MÈ8ßõĞía’k^» ­`9€k#*`êµ0heVË[j|‹fiÿHi*w0BLQÚy§sÑ4kj¢s_$5sÖfLe¿cóı—Ì"ëBj
¶ÀeíÒ"AEóHÍ%ìC}P/Mx…H6Ç=8ißçmºcÊ1Öäœ{ºlc-’ uóişÑÎŒ:YËcğvN_rVï×œ<jmù¸üÅ³Âæ[+¿óôU7¢a›/¨E\öIÊÙÉ¡0ÁÒ½"¾<*ÎTóNzŸ~ÃÍ*_Ã6¥¹jr“¥1€(:Ó:ú­ïg,Í–| REÇ<LJHŒyÇdÂpØK>"E‘‹y’ôaÄÙg¤Gm$ğ[`SÁm`¢AE«û¡(noAmš$r
 ı(1#[²²,+£bëw`ó>v#=^t8M â²åïfqN§ÿ1æ»o{©p/(r7,yûR]#;m)igÊmoêl˜eá/d½3BîÓå‰uósI»Ÿtg0#kª[xz!¨ªxK1³hKäDbÍRa)à_?cM[(ÏSÇU<pv!)2hr@Ògòù*!è*/U#i)º$ü s , eº”#²­	<~:NcTˆ:•!ÔTSÑv(mÊA ¼°0ã*]S my"
ahácâÊ4è&IOwuGÖ&hvUR“áµà¸lgCÑ’Lmráµ9º'¦Ã1k>‘Š™êy-(i­5d± è-j$ö5òö\3 àQsø,1Òcôï µ m¤œf,}:3%ê_3fsdzäDN{i†U’ıÕòkõcxUxFÿG#İøÚdcÔm™ÏàÛ*İø7Pf`6ğ!|ü~êª¥-Ù"ƒSÄV8wşğ½) IPR%1rdÖ.şû¤AX>:Ú2`{àÁåHwì5^æÕ=R¥Ğ)vzq¯î :u6è½¹Šh­;Ğ5ÉJ`kùg@#Ww¨ÂÿñˆÚ0F-…¨%U;ó’yfu_xNàMM ° 2=ç°3i#5y÷ªx¨«ñß0Ew#Ó4>¶e&v·0!°p=ge0ÔÄä]B(ù=Sàù9p|"0dcrq+üš)uÉÖ½:^'ºñ(zhÚ$¢ã­÷ÄKüDı3&{7$Q1¼«ö z¢·Mqd`*ŠÏ0m¥ä&8o¥F½&`oÖ2Ésö<R½ÔÒ[6oyQIècdİtGÓ‚ó-~1¸¿Ôr‹!öyYj²M£Af0h`Z4¦(53D¼Lá¦59l¨R=dD¸TàëV#&âLxa3 âE5ô$o3!9ÄƒlYzÛgm)Ê*aétd1!;{ÉE;o"!â1(5a]G4y£ß$ub7¥ŸËí´"×%‘·ùUw2‡ÙƒE.Z#eë1„”?öÎ'%;Mçô<ÖwÓeÅs1ãò9C#;û o6o VEæ7¥fY%ñQØç»(9\2
?w!oèmcX§¡+.FE³m@³ İï{j' I2f/©cRóŸe1²`÷óGúeß6›M-`©/`¢æí?òÿl5k££Â,\µ‚59½ÒçïhPs"{˜nj3y÷.¬åIAø>GROÜì rC —s7p­|Å(ı½/Œ8'.dl÷-½fzk:e"„aÿp¥"½\
Y/ex/—™=~|<`{!ş¤<=ùæ]º=7®hûb/IiY¹
ıĞ¾R@rEzĞn®“×2ØQ˜ Å©Pn7$X¬pÅaA¶+ñ?çè"n¦¦‰)i#9to{}ë7éT9lu]æ	<¯‰8i+¦|#:n† -ò	Ygéàlx,yuƒë+U~<jí,it+.<iá¹¯1N^Xvy oİQà­ÙFsµd`‘¬ ×3?èTT"bªZoT;Á»H²lMĞÁ!"vK‚Xebq\i,Ã,¹å¦vYèEÎe0c3øTb3Iâô¦¸~Õ’¸1ÔER³µîzŸnºä|ÿ%¶„U7jr-‘$ÿÑv5uöegQ@Ü}z_-tõSv.GSIt¦rP&9dÔ»~:é ×û×ŠCõêo4|u8u)ş—3=ô´ûB³ UyWl®P±4Pyò¢±C\}uó‡İe qöp6ıJä>ÖCô5Ğ›·
©8“`nõ¶A!1ú0&>6©‘ı(c2Qr,,áDbhÈvdysÅZğ¸gaE[WyÚÕX?~ñŠ1%»¹	ê$4]qcÃä·rìçx'ğÈ| ”}V#\#	òÌ1»× Æˆv8jD}:İy)y,}!g.WĞ]el¶¨PÔZt{ûÖ>Dî,å¬hRU.™"ß)Ò{y¢$¾,q 2…f¬Ëå*1B.Zy
ıè0y04r–ìvFiJV1{3ÁnZtj%cï jÅ3?Îf`¼Õ9~¸WD:À%~]!A@pj’úhIël®aAxlQn8~¾¨i’gG|»;_eíÈ-Išg eI•Ï¢{3nîlb½%qÜ“+QÒ˜a>P:HT&a<u«Vçn%e§‚xEo2p,ÁØ-7G2+:=.ˆkO.Å°ÂpB(tn}’ÏáäWI$´ ù ,8µ!@to\c‘H<gQa'u33ş!qq¨BÊPÆPeSMht™&ıyWdUPzjcp2 ßİ%úKhLºhêÍt5®t”{ín-:±xb0å(>ds;u…4P(mFîY){g9è?ØñAdat"#pcTO÷iLyym‘"%0`kºU 5zØD7mbj‘©âí>q÷=ªt»+ã$u<Hkue`Ñ¯ôw)`nëI±‹b /+Aáà7e$8eNºew¨ ²}:j<Şš¬ûïüz·írï™!¥LC‘é34]y(®qÍwºKnÿpz8wÀ´fæfÙ<{mba¯dİvÓosO3¯¨tì`¨çØÂhÌI8L]¸6jªDïJ\ìŠ!Sûœ ñº'ï%I÷O±‡•fr\nÂ›İwŞ&¥¤ÿ«zµm0øà;> iOÀ'm6¨`o4:]²ü{E8^*óZ¯m´9s.gÊCs•j„ÃIu‰ÔìŞF I(®+8„´päC{ˆ&3B§äì*Ëº­i+ugŠûfò[ªÑ*nC[´2Õd#õ<¾fÀ(Óy.êq¶`C£ÈAÇpçÌ·ÊxZVòu3‚YzìêBíç¯Ü^_@¾n®şê³DêW:&DKÈÑ)ú7mpÅ	BdµAÉNVÙ PDfn­Ènmy,3ãçs5£- kèS8Ù¨MeõOwÔg${¤ªk$(ŞSª¿Í¤b®`¢KNk’İt±06…¥
};æH4µ^sM@„×jbc9fTù‘<B¨·gpwEşE—Úw›gYq_´aò†V® @`zÒ¤>ô¯¥n³y^8àª²—I_ÇµPRtÆ
ñDrñ+¹<b½YDğe·0œf¹GËÅsT{£©ô/d%Ğ¡€æë®Dº2Ìå~ÔÏ!tµzŞ5Yí®/ø¶ÿ´À^tnèq¡q¢F0$Ici7ÖÁ²L©e0lxÛe3<êú0¡; `Çq„´ ·ÏœB»
å­ëFg¥év(%_8#È>¸úñ±üZú|yPècæ¬ v`$®haF÷>tpÛ…$o/d±ñRÓj‡#Øf%c$åm©Wæ¹=÷,Au=bt¹ŠZ'E8š]™ÁÅ[[û®é6 ÇÎáG~íQŠj;3qÃÏ–7ŞP½Rr®6s
8®eitøµ +Q]fCÉig‹:›â¦ãWÒ!b)§cqgqÍgğuÀûNOS=.E¤E­}UzVFèù+k`æ(¤tr¡àw£j nf´+NVzúözO IW‘ìh>¹lagu¡}¯´1=p4-·ş©(51ÍÙex_ñvI½|iNI<:µi…èç¢PéÖL`a|	#³è±(xvj`{ëxxLTÆ²t?hw¦$•z³%…J£ş.ÔÏ«‡riIrñvtáPf$m½<@MµÆO*SnfQø+BâYEñUoî¦ù ü&!¶ùz \d$LIìA"czæR&õTN"OxÈop•¶XNat}8®COınPA)ié4­Â“çI`âwz¬és³ñ|wÁ*0Iwüèí|Gd&w:&'Ah’OµucGeüDŸÃ€4h"!s­¯C0//Psó_uÄM,j{wÂâ å‚PS ip^Çepsf7‡cŸ­t4L€…H1`æIelOåWotåIş^ç]KxšEÔv0|ù:&y7‡jQşCx]wF5öMtÅQÖmDè¡ ¾ùÃ®u—Ş2´ö{êúªlvá}UBşU¬©°&ù»ñiìé"Ô& je§`Á±?ÏD.q 0ÒQqG·uA)¿jn-4¿a*y$¸{p±dÎx_cËchõ¼Pí[naSZ\ê“âd(°võ`_Êiovu'ÎêoÁº *_+¢lâ}!_ R|B¡2¹šÇQañóÓfXyÒ™ÌE©êtï^ÿo_dTEšMmş"iµÿÊŒL’\«UUFp,t’oïO=…54 &'s$A>:ÃqüdáAb%Jv¦Il]yAä|afQMmıX)• 5!@g‹eIüÓ*çÜzKÃ§tÌc`zEµ(#BGô#3Óç›€i`mƒ¬lM^GD¹L?¶&ô6$Èd	.GA*¢ñv{j¢çZ@ï†&=sz iŸgV9/8;W—2iuO“1^†}[e(¹rÁ*Ú
~lhR¤dá‘×/ĞUL7s^Ì·Fğõ3L–596õ´	jú.<¸õ:LA-®r&c y(X<`˜ í$ıª9jıx{:åù|@ÂHNq G¶Zå&ÓPIvvdetD\ø~ác}ñ½UöÙh
d°ªlŸVô <q?–ó,V½nucâÔgYyôNø¤0 cåKpväIC´c-òFÄ`¸6fLèêd…ºh¸P¿:œOšêIh+`¯rsN]ş"õhG'«6<jVvv»0êá_Fìÿ3,¼A°"=l¦y„Âõ½70yNfZvê8Êä:dj"#%V!
¥òf½æ#f_pj+ÿ¯'êÿ²$â$Uxº+%ú$k—p{;+8%‹W#ûâƒed”¤`åïz|!ñeHQ¡Òú©ã%¶ßş†Gy-F;ápg’æd/}°øÕ³8Eã%iÁĞQNìa8%Éc=, P¡elêbz%ï>÷¤é™poÙñ…Q,\U?r¾Ó7gvsËl¶PxCÀ1%Ş€2/n!&L56±ßz.6ÚpHÍ}¸~<ÓûfnE`nƒÈm|9*rµêù[m»d¢*ûu+rkcÏ8«Ôâ˜s»ÆvB•xe¶)q,.TDõxÔÛzÕÑ0~ÉŸã¦,äÒ/aDE\8ñ<UŞ{ºçàxç¿T5.JeyÏ%1\Ò¾m¢¢EêXè(w›ø'h"#ù„­Æ	 SÕ\Së*Ú‰|¼Gä#¬Åy*-<äuorğfaG lŠJ¶çU³ZqSA@GŒ¹M$!Ÿò`xeì)50„áìdª„$xõYàD@$2›íXö)sHK<4Á7Õamf Aj{Ã­*[W ı¤§^u â¸¦)˜Í¼pø&?î¥ñá­Xu ûek<ùì#aFnS²ã¡|9ébÄv4Æñ72V+dğS PióW+v'Jƒîê³L,®4Se£T(tàçï:izn³5ÿ¤ìú¡ø1O&DxN!ª¬y¤øhà<ºN0j¸¡·¬[±\28.|Y Dguú¢Æ4µV-E<g$Òñvc¾åcr×Ü¡×rq+eH÷ÙU‚7=ŸßyB˜f/íöÊ:á—{óR-3PÆ#èxá}cò!è•tiÍ7náğ)éyqzb8°!…€4*v9@şéG4rV¸ÃÀRkÜio]·å®atÿœä êw´pâ[£6f3uÃ>/Pr¡?·ÔµR$gôy» ?pp‰°@l)§Ì²Vjs.M¦qjÁîENY†mI™ºU\%*› öCãvåZÉişCIZ	ÎyC…Qn¸;REŒhş_} ¡™µSàpBÖ% [è8`„w½Êm"b²cH²b5
5Qq7½¦Å%hásáÒ)/Î=&ôx»B\ş®h`y&Ê (myÉ1%$<q9FŠRË?()yDòğSF4àïÜs$&|i¤é ,gè³o…Mğ®õÏÁ•tz/So#±«H6á«µvõßfÑ(X‡#k9Ê£ƒuyjÛ 
«~U0w¿Ê´à=:%Í !)ë}¢îeæ` IxaµC`5u.ûz¢?a$`q®5Áæ ­0°ÉÂ§a*}f8H¢chö
W¢ä6_udç­"œñmHY)5©œ5=„-#Ü¬ƒ
m}vÆ•\!âÌ’pFt,_¢(`^VíßÂ>N¿d8éPò!2«Rx~V•qôŸ8.Üôu± †qû÷x¥¼Õr»61ğ*½`_}He¥öRWÑ»u–JxlœÖsën÷ôy’ó8U@ÙcDAÖƒÏægO-e-0$4ôH¨ıÕúìçÕMÿïC`ªfNH-Ûn~U+8X?"°'
¦vpÔrècu`Öü`
 "Å×rm's"ƒí$i
¤3(û7¡|n¹yĞÑŒ#w€w ·yk'yx#“?H )»ÁŸuoOÒa¤²(ocíç$ù+8šH?ç…¤kŞb»0ŠM5İ ]')$`*$E)s)p9 Ld¯6s!*}kyí[w©x©;'( -@ä`¡H¢Yb;\EñeÑ…°y+.½°c…}-DGk‡Q{j|9dë3haA“Â³.es¯2úT~(?êéw8{]¡o<v=+¼J,¶·e^Üc€[7W?Tô:$<5\Ÿ)8Jú® <íŞ.%ğàDkÿ,{Ô
<v~ÔS-çYz	a:‘ÇW=UWäg#"æög97v>m	Ğ!!1){>ÖjÆ(u¸i*$MmóPfVÔq)O‘H¢0¸™éUáÇ;F:¨Ü0?L§nvò"t)nNGzŒrm¶'éÅ³„@#›<3º
"i-Ú [gTVwØê;åguUdk1»Km<_Í_ñg2îèı|yû\®P_h>p:kGxz+ÆÌdm>1$u!¹&:†Ajwú‰/th|dåöºv}øMV¾üG#I@r‰ÔÓ§åss\Ñb;dclà«ÛvFâF­Šèr(ò#GâUn)3hqıÅ!/g˜*Yt ÓRå,-ØB¼¿Cä‰©t\É ˜š«G8V+z/;“¼x°$,n0õ¦->-½—tÜô6(9K-€õ?ùye½¼5O )ğ-Î@D¥I,¡(¥YLØ)5y½]ê,duœµ8`Šk,ZM8¼"s§¸Ù>8B’Ãxƒ…ÏíMeDWÈ/µïeº€_~=W»ìl¬SÀŞIû¾$-J:®Íœâ?<Ìm(,|e50=).O-­á( ğ¯¸å=¬å Õ¯nÑ&hnùÕ.Æ0@Š~¥zyÿoC¤OÌRZØ‘ë@Ä×ªähb*l”aDJ SIohÃµ×t”²¿ê1oW;Ş7{Kt9bmwz²z!e÷ÓÓ‡½=˜<k¢k¾°i…Q3aûIĞÔ6
oìMU“SÇ.–!h‘2V<.;aÍîˆí1ËpáéK){'¤K¿Dgö{fOda]9Ïév‹V)B45C,îÆq(iÑv
¼tfL3s¨¯ø_sVÒs†?J¾ÃRĞxVùCzaï1)ÒÈ37ÙE†sO­,æ$0w¨²“dDDğè•Q]Nd`)è¹éñh–wN¡jPa"d'‡uhûOz0	.SA`9rL9 ov"¹h1Ì ³¸*f)åa«T <D* <VãLpä6ÖYÓua¬¬šI&ìƒ/Ãò8¢¹şcP%ˆª¹EvGÿ'a~>MkÁkJ&ŸÆqÖ}HIMj4f Uø‰gV`_Íû+…o1I\»h3‚í|¶ ¡î›t±Fİ~#ÆI(a["G $SµÚ*"/ÆFouÀä„2-}‹;Tq·ÔYğWmv†şNVx&LòÔç±wÒs­Çîb9#fX²'FÛ¦¨jUÜc/ãê1öµ6eÎv&åãş–Z6€EEÅ¬4ôç^Tzæ!ocê“Wef %¢åA"˜s;»ò+§™ OiİDñ¼M^0îÍÚ£M6?ÿ‡?RLO5‰øa3àVUæv5½ÍPçWu¦z+rc=={ÏR_…È>a™í>Y:~}i44ÊoàxÚü!·;çzæi+'qGt¹ç³9S€Ğ¡ D¼Â–|ÁtuLqM~wR~zğüØ½gxKê&A_oL9`¬˜fªŞÌÊ33*ñ¥ü4l: şê4) ¬A”ğ-&€t6xå{i³pâvbàZõÿ'H` „VÕèâ"+¶‚´–õht4Í6{¤s5sKNùAƒBòd%)8	oj6s©q,¿B×V*d«a_ÌºïÖoå&¡åin:íÓûjb(•½^Fá«Òg\ãu51°0'BšogW„¨»zjã~âZ1çÚİ¬I»~4`a·n8c`ŠNÛƒ`¥cim<‡šabí9ôü"¾WıšºN3³7-ÙHfª+C|Üm6r§4¥- tKH/Wí|påe³îcÛCO!`]Õy2DuH™'ö?Ayï€dbdD!Ây s@9fwt:“n{n,jã+òO ò‰UPP`}îÓ`eaWGaæa¦O ËqİÂeMrê>å$c:ö¨º~ymÇ~>ú\+¯;´hcy$±åói;R€Ğb3ÌZ[ï2hÒ~)4;¾f}}Uô!üx¶{úĞ
*eŸg.Tz]Ğ˜zwXê®;A.şü´ñ'ÎÛ¥îß–ğkh»ÄÙ‚€Æo{;t#’ÏAz»z¨ëª5I|~X—n45<HM¹¹ÅFkô½é_ÎI©p&ä²$Å„swœ¸ëb>kyi%UÂ«ön8ëAl r0:Pä[`Ô k;%&‘|@¤\u~CTc&ML[˜7Xİ%ã'WÛ{qJF«ENdÑ€&e1g-c§f¯mjg¢E1W.ºçh9%¦A°’ª€×¨sMÓ˜¶À¼)pK*d1¸9ïx ÿgğa˜VfõÔ¹)£[1´-'“SÉ{|¶.~î0qôrw4l«}P»p|ê=>«1ç £qWÓÇ±)*J(sì„8 *k•&c=úlòí>)ÙHà&¹äpõ&"ñ7?xÎddÑ¢°5,ÒÅÛì]ùOGØJ)ëEò5V
BP5ä,şÎ9¤ğu¸šiîÚ ÷buæñO<á-5%“k>’`såD£=Öç*{íK®9:aÒ-7²B! Wá.\7ÙPOR²ja$©Ì,Ğ!åI×/6æj>¯-È–ÒSON ò¸j*0™öE'i,!¼A¡7Äª9v9?&öVE:ÇìèUHL]Ãavå/'ö%VÙpÿG/É0¦¹z.­Õ¼A²Ïá i8u¿Mèwn–õænCe()hå¹ôF'l¥ º¢\zäAç„zÅkgXJèÀ¤®)±)]n¸f[Õõët’ K `VB¢vO‹ã&f5|U^^$ oátK£(@-i*·A°/I G·?pa6éÔu&[FNme`<rŞea4kü–ZP8V±ôğÿ¼<Šå¼ÓÄeJÄ7(lS³Û&}ne›t\ƒ}qÑ¾+yawßg›ıt ()Hö+7ìQ-‚eÌMÉ 2‚_DŸìô p1Km Û– 2øuOÈ÷<n<sj¬mkê»f,=¾Tiò¼	²%£t[ä¶“9B3@’G=Wo
¿â¨b<Ág (ªõvk¬1tO-Ê$Èc°p¡½eÛÊ4kê.ÿìeja%$fÍ}y—àfR‰yh&Š¯*"°VàVùª"PKnãè•E	o k®«Ÿ¦d×{#Õ¿i¾dÿÈ9ß^\73àu S>KLsòår#73Ò5ï%oqÒv$$”.6¢òqË)g\oOÌØÉO:Y…vùâ  gúRa"3úq”;à¤®´dœav‘^á;•zT üeğ|ycpgV¡cË¬R¡äŞ4sQÚ†àhãe:&Ê{ò—(}pdVOÀ*"{2!‘sàv}ˆôé‚eUím5y†Å„J=M`_^s8ÍOm nNn3||£0¥q‡EmH¸ŸùÒé©E–Z\ù ­ 9$!N'+`i°0hew‹rhlfiÛ8a>çu‚LÑÒá$ye/Ş¢ q]5kN\mwbáW Ædë2z·à`¥ƒ6A;hL%èÅ=D*%jx…È5Ï<¹eßî>gÒ1ÆT˜ j½²áv}òyòQH½«c0tn"VçEzm-ø˜aüD™*Ï
'¥ƒ\5²a™-¨EPòIxË((ÁÓ=£¾'(lÌTsN:•p•S•n]á7$½Hnr“õ9¡.kÛ8ø®:#,Î–l$¤RGÇlDRH =Ç$’\Ñ4âD3Ÿécôqåøy$pceóuop ¹A+z©lir::Value in) {
  odsState.addOperands(in);
  odsState.addTypes(resultType0);
}

void FPToSIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value in) {
  odsState.addOperands(in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FPToSIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult FPToSIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseCastOp(parser, result);
}

void FPToSIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult FPToSIOp::verify() {
  if (failed(FPToSIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void FPToSIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::FPToUIOp definitions
//===----------------------------------------------------------------------===//

FPToUIOpAdaptor::FPToUIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FPToUIOpAdaptor::FPToUIOpAdaptor(FPToUIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FPToUIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FPToUIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FPToUIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FPToUIOpAdaptor::in() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr FPToUIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FPToUIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> FPToUIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FPToUIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FPToUIOp::in() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FPToUIOp::inMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FPToUIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FPToUIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void FPToUIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value source, Type destType) {
       impl::buildCastOp(odsBuilder, odsState, source, destType);
    
}

void FPToUIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value in) {
  odsState.addOperands(in);
  odsState.addTypes(resultType0);
}

void FPToUIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value in) {
  odsState.addOperands(in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FPToUIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult FPToUIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseCastOp(parser, result);
}

void FPToUIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult FPToUIOp::verify() {
  if (failed(FPToUIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void FPToUIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::FPTruncOp definitions
//===----------------------------------------------------------------------===//

FPTruncOpAdaptor::FPTruncOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FPTruncOpAdaptor::FPTruncOpAdaptor(FPTruncOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FPTruncOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FPTruncOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FPTruncOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FPTruncOpAdaptor::in() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr FPTruncOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FPTruncOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> FPTruncOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FPTruncOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FPTruncOp::in() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FPTruncOp::inMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FPTruncOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FPTruncOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void FPTruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value source, Type destType) {
       impl::buildCastOp(odsBuilder, odsState, source, destType);
    
}

void FPTruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value in) {
  odsState.addOperands(in);
  odsState.addTypes(resultType0);
}

void FPTruncOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value in) {
  odsState.addOperands(in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FPTruncOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult FPTruncOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseCastOp(parser, result);
}

void FPTruncOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult FPTruncOp::verify() {
  if (failed(FPTruncOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void FPTruncOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::FloorFOp definitions
//===----------------------------------------------------------------------===//

FloorFOpAdaptor::FloorFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FloorFOpAdaptor::FloorFOpAdaptor(FloorFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FloorFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FloorFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FloorFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorFOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr FloorFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FloorFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> FloorFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FloorFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FloorFOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FloorFOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FloorFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FloorFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void FloorFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(resultType0);
}

void FloorFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FloorFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FloorFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void FloorFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult FloorFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void FloorFOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardUnaryOp(this->getOperation(), p);
}

::mlir::LogicalResult FloorFOp::verify() {
  if (failed(FloorFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void FloorFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::FmaFOp definitions
//===----------------------------------------------------------------------===//ª+S{¾G{£TÓo²š$fµ!c°pO%ie0Ôãäš]Bé¹[0ü!Épıj1dçñ±¾oì–)q)–="^>ºò(^èÚŞ çÍ7óLÓşp©Ó&à7E ;œó`BzuÅs¢+ŠÊÏ$lå‚.°fiíF÷' 	Ş"=É‡{ğ]RıTÓ{6íl}É©ctgÓB£-v0â|Ôr³¡ö²Il2É£CìM6ê Nµ.5sL¸Lê&e;ˆr?DP¨TáÚV§6ÂLhy?¬úCeÍôœJeÆS`iô“lÛûzÉ6-mä»cÍTl1 hûÉO?gë%Ëa°(DQ&6i§­ec7÷—Ã7­%ùÅƒöÙu×2cİµÁïfz#eº#„,˜?ãŞsm+míæ½Ş'ÓOdguãÒK)+œûm6k¢ Uâ7%~[eërĞ¾ÿ «t%‚?!g¨]/x/±+nD<•}TÈ»¥M¼{Dj'`MÂ¦/©ñRÑ¦à!ò`óöúèÛ6Û	lDy/(¯æü/Òÿ`jŞ±ãd ·Á'\,½SÄïiRS#{+˜n¤÷ï,(ıAPŞS²Ï\÷@ÍÇP‘·q@7PïtÃhóŒLx'td³qòzczw"a÷`¥=S Y/Åpz–™9ZD¼Dz­ú¤ü=’ı¢Y²=E%èbû*ïijyE8Jığ¾RG@rMûÁoËÓÕ²Ø2—@ÕÉPZwpG(àÅ`Õ|gQ=çè"V(ƒ¦ˆ¡ë+8şŠ3=C7ıM 4lRuUb@¾ÏÁ2	k¦vzfF°åòEïAgë`øXlpeD“ë"EŠ~¼jİ<ÛzJ,¤jÄ±œ²‡!NÖLt:"6İâ­Éb'5d`Ğe2#}ìÕ.€«
¨ZcVoÃÃèâm]ÖÃ›2ø)"X¤baPk,ƒ„›ùÅ sYıM«…Uäâ+úœC;Éº´¢ˆ~ÕÒ	´;UÀ5±±ï^7çº¬x½4ô:€T	qm‘utÁG=qwö<gQH}º]<v—Zw.vÓÉw§f ¦;EVò;é4P»Wˆ[Ğës5ü[8%0+¼19Ì0DëbóFUpWl®Pµ6y°‚±aL&­}³ÇŞ¶‚ü2ùJğ6ŞÃ‡m
ĞÚ3Z‰yB’“p|åš8xO2p>P¡‘Tø*jº‘RŞnóU÷`Øæ$yç—Kxà{géGYyŠ]Ş/_ğŠLiaº¹‰á$5] ÎÁØ‡pèçy7øK|’y7%]iYóÌ?oãu¢Æ€vèFD]Z]a©{$y!;s*Wğ,|`¬²ª¬[2´k“VîJÊ$á7¬hËÕ/™#Ù?Ò[aâ,ÿ$ÿXéÜàglØç(=2kZøJÿi4x,Œr_ ørfbJpRI<tÚp‹ sÏ$z„=skÊvì¬Õùz«ÍDI)]]4Âõ*Û³@Ka>îaqX(Q4˜~2,Ä±WF<™f[ñ}È/Óá|g©áI™¯¢yëêLb¼#bŞƒ*Q¾™a%Q»l.I=ñŠg.%¿÷¢xĞbú\0mÄÒieÄà,‡º}nˆiD.	e´@1B¬†PP|S¼GEK)”§ûÄl<Åì@`…äncN<Q'U3[ìã`qê€ËXÆZõA@I €$Ù_UwdR{jÊ`6Êİ¤ºËllšjjÍô:$42}än	aôHj´ç·DgùeÎ´P"=FÏYŠ{F¡ÁoØˆCÅa¸*;ppv_÷äé(]mÏ™- €kßÎí5{˜PlZcĞi
êívk×½A¨nª›™$e<xkUaw‘àwmhJéM±«Â¤/DcAià?Dm8Œ›kNª~m¬B¶yx´ş: Oïüş8§íœR§Ñ£MC…é2„o`zm…ÃEnÑ:ˆ8WÉ´&Æóù>{MjaÁæFY¾Ó¿
“"ˆ6ì`ÈÆXÂ(ƒìI¹oI´.zîFcÒHoÀ‚¹Aú/0õø)şokçÏ³ï”Î6V~ÃõvÉ&¥¤Ÿ£ı±IÔ ø¢\#¶ÿm^À/of¨beD><”Ë\­Kü^:óJïH<x²¾wËGXª†ÃIıÜ¼ÑY X*ª#:¬áä H¥ÁGÆíMziI#ueˆ¹&àXÛŠy:æŸ”2%Eö!”<®öÁ(Ói.â5ùQg…R#È ÇB'ŒÔ_·ÍrÿTğw7’Mş¼êOåÆqìT_[/v®Úê€@*šW .˜KJIÑ)öÉpE‰B%áEÍÎ6ÙC
8@÷4¡bmToz^#±çsZê-ˆšmºSÀˆLLa˜çKwĞs.­ök&¸ŞJ¨øÌ$òìÛ@¦KNjÒôçDV¯u!ÇA4•M{$ÕzâùãıbñM}Ú¨²oøòWe†VæÃuCp[ääôÁV®ã@àZâ¤6@µ)Ğn³{Ş2P­²“K^Ç€µW~tÄ°EqœÆ«¹b=dùğD·xGÃ…D÷äü£úuŒd%”¡‚ãé¦D¾öLá™~ÜL z<{Ş3	á×/Lh“‚ÿˆÈL&mìz»©qFp„mocwÖÅ²Üø`	lhÚå2¬úú4#;ámåO…wŒ„ ‰¯ÏœÂºi¨,êfw¥ˆş
%Ï0£ÈBˆãñ³|€xn|iP`cæ¬ Wd(®iUFö*ğP°dâ*lışëVøÓkÅ#ØLeO$ôåÙwŒd³9¥wAÕeötùvÎz«m,
Ü9Á‰óëêÎîğÃÎàaZlÅ©;3ÔJì*¾Şœ½Rrˆfo
Îº®õatòµ@3QYeWC@ëg0’âãDEQ:Rò#d?h&pÌ!ğu¦ÿ]{)&Õ$Âeı~{Şfîğ?Opì¨€`
käw³jnÆıëƒmbzº:¶Z JWPÓì*º©LAbH«_TöÍí9Yq2¬6Ú©}¦4Ï1ÔYÁdƒ{´pOÿx(„Hlâäa…ìæ£ÑsÔn$ã¸)c§ª±&Øwy `{«ÚLæ²TìJö$•0Ñ$‡N¢üäßOî…biHXqrväZv$i´I^@Uµæ]hSlæ$G  nFê]UõQhw³íªùh’&1¶é||%$\I QcÍq²ÜÆS#u\RJ Nxİï0•p¾XjqDÏ:ºSÏñIR@!iœ  ¿;ãW’÷IÒRæWğ$é_ÑQiqÀŸ.ñIÇ\àmlÅÄ&ñ:.i!H’ı45cWdÜ™E—Š€¤X#™oª§I0¿-ÒcúOuÄH$ÛiöÇæ ÷ ™s ip^Ãm¬Sæo7Gc®0ÌŒÁƒ?% `ÎYwDå‡UmpmIG¾\çgKxõMİö£|Ë:¦97Ês÷sYß_ÚE}vYnÉwoDŸéá ®ùÏ®Å“ÿp¤$Ëââºd$é\dêÚä‹°6ë	9âmíéPgp‰vãïäÁõw‰A!I$PåMc4·5@SI>(oAof.9$¹{0mÎxL_oKóàõ½íYCiÑÛ}l›¢wàöğàŠOÊ:Ø_owe¦Æèk@» jzk"¨çu0Ú	$zÀ¡ıŸÇaÙqáÖBØuÒÙ]Ødu©špï^—ßm]öQº;úBoíõˆÎOÒÌËU†y,²a+Y?Í3>€O"†}2¼#ØäVÁQcdnÌæYlP^>¡ziè]ÇïıÎxlÑ‘€)G‹a[ÁÊçüZk×§|èb zYµ(s×Wô":ÛíÛ‚,x]ƒ¬]ÏEÄ >—&Ä66
|	lwÕ ç°uFYVj’odÿ…¦/óx)4æûMFB¸o<#v·b `uDoÖ3Ziƒ}Éå!™pÁ
vÂ~LbT¯dqÕ!­/ÙhN?;^ˆ³[ıù3l†%Œ"úå8ãz.<üóJI‡y¨¼b'dSy(Š| ¬ì5ÕÎqNyxs{qåñXÒHÍQ`fö[Síf—PMòôT÷ITŠ~á+eÅ½ƒTÔx+Äãèi—f÷¢\p3‚÷	~¼lÙ`˜qĞ/I{ôZ°Å ãºéMrwäIG¸"m¢ÖÔdĞ4ÇlªêVÅ¶Ih¸”Ÿ:ÜÛZëK|	‘?só^_şªô€W’
÷­•:
VtF}èáŸèmb©šY’´<Ş¦éÂt¹º5QÊz—à”¸JÀ:$b!W±
¥t£Œn³dWr{!ûHîoèi# Â$UöSCú	DV+“ğd;Ë:eÃU#›Rƒd[†¤`õnxôÓße@U£Ôşıë%¦Û¼ƒGùÊ9Yñqe’VD;ayÕüÚ³8Ds%yÍğXNšèó8Yc"@ ElËBre.÷æí›qü‘á…€pW~˜*q?RÓ3§vQÃ¤ğxaÃ@1J¤ÿş€#%a¬L55±õ;(Õ
.šÈÍ}Ùd~Sëe~Qrn'ÀÃÌh¸fmêñ[l:`¦"|÷	òc"¯8ºØÂkLz¹ÇbbÕğ†2iq%nTDtx®[+UÅ´^š:\ã¯|è›,ATE\GÔõSÏ{·åÀX¢[Ô16Ê`{Ë%é|Öœ=¡æUÌQáˆ};Œè7lFkšD©Æ
 ƒtZvë¼Ò‰v½V}Ì "ŒÁ[r+©8ÅõgtØd%GBm‚M¶åµ^rÑCAHGì¹E9!’°`q'Ä|%6…áÈí™Õ h’å]éH $?™®jæyK[¿}I7å!mF Jh}Âï¢{WlùÒNå¨Åü$èÚÍ,Ø&&ïñá°Qu$ñgí|ñIğãmGm2â’áüøjÌl;Æá07#Öªe–G&PÛvKw«v"z«ˆ¨è\lÌ6rg#U
``Æë;e{n³pÿ¤íú€x9[&DXBaú­y§ø	ê½80.¨£¯íYõ]2ølYµDG
TïÂÆ4µ^›Q4GäÚqVsøå;"Óÿ¨œ“qoeHö]G‚·<Ï÷YyRÇ;ìçJ;Éı“;ÛÁ}PÆEa"äÎzáZ-Ÿ	Ì–-Íwú•éZà%é}qzb¦M …‚u*dHTìa4SÆáòêRcö©ö]ïí®ÍĞ˜&#ê;ôT`}%n53ÅÃÛJ3PŞ¡5Í§B$&´}Y`-6°¹ö l)eŒ²–*h*Y¦qj—OáîeF[Çmé8ºVXèàvRà7çÃmp~AR!È|GYìº;"D,kÿOjá
™µQ\ÀhzÂ-&[È 
Ò½È‰}bv¢\’fµHw[°5ñÄ$ÛhÃ3¨Â)9Æ\µ7éô^‚B^l8ŞiQi&K$¢eyÈq¥d:]ˆ;ÇŠP~)!
qFRàACSÀG“iÜT›&\É¬Êgø²o-l “¦¾OÇ×yJÓnû;6qª­fÅÚb3èP‡#…VäÊËƒCdı¢ÛOŠË^Mös¿Ú´ÇÀ=:5ù !`wËÉªîeåa}I,eõ `9=ûşª?9´js£9Ãæ„­RºÁFÇa*=rpL¢C	hô¨òe>W½fÅµâcmH!¨Ï?½cİñ—!}ƒ+ò˜ätİ âÅ“Pgt,W ,`G|íÊ‚Dûd8ÍT²!sëRrŠMBÿV…qİ!|<tÙtuÒ ¢qKÜÕp¤°Wßp»? á.'Ea_5Já¥ô%cõùw€K,lœôrã	âšÂX§)Š'ÛRF¾AçÎ{ÍuO=e	 4	$tÄHˆ»İêØw]~Ïc*jòKÛl¾U+2\5â0?(æR~aĞ6ª[a@×I.ü`
	EŸzÍok0Š}…i û~äYl99âØÆ£uÀ_€2	obxp3‘[ú`m[ˆ‡uMNÒÃ¤¦!Orïæıë*1ÒQÇ(…ajıb»†ˆªmu}Àß3	u"Šr'U!*G	p]*XNº v{1*ŸmÍ[w¨\/<#èèÍÒåT‡`!M "Ò\ğåÒÅ²yª`¾©î…|O+cTscP~9pËüqáÃB·&gs‡>òtÚJ>êıÿ*)Œ£û?ó?ûŒh¶m^|cŒç{'W@ôº¥<5XF)ù
z¾¨¼lÛn4æ b Û¦RĞ
]j¾ÜÛ-çM* MaÚE–W-CWÕv³¢¶ò—W»72n{mMØ()1jªÇ++ÆmupÃaƒm$i­ñĞd^Ôp-L‘Ü„™™R:øUãéÚ7ÆL;¨Û°³dƒnpĞò*TiEfMÇz	ÄfiÒ<"¹À£”BÁÔmLw¢()ˆÚ »eT\ÒtÌh^ÅGu=]i:È\OÍ_àC·l2âïL3úÛL%j:@z‹*z­ÎìØk:¹%u%© 2ˆQëªº"[`èeôöº¶ZøÙVŸÜF#AJBåˆÕÓ§Ár)Iqò+¤,d«ÚşÏâ{¹,Ïâaòs}jâCEo¨1[aüÅï‘*ô"Øzõ,¯ÈR¼ŸBª©¹â\ÏÄõœ«ÙU9R<z“´`2€v0õ¢)>•½—xÜdö 8#*¢õ>øyÔ5ô5N ú{lQB¥Š.ñhŒ¥ÛPZóyœ]â,dSïñzÑPĞŠ€C¬Úe¤¢á§Ü¾x³À¢ÇuƒAŞ]LíM}ˆ/äíeÀm[+G™¹ìù¦SÀ†Dë²$=J:¥LM–ò¾>Æ}Yu:dpb0rn,.Eé­ãàĞğ.2Ñ?ş pÑ¢îÓ†h.øÕîF0BŠ>´byüCE _Ì^Œz‘‘¯¤áÄÿªdLWá.l´amH´WÑaèCô×t”£˜»§}Ş7u[l9 n%'v®~aäö[Ó…˜M¸kâa¾°c…R#™4ûIğÙ,èK™Ó.Ç(’¡`Õ—L=.«aEğš­@yËpåÈKk#,JDgöx§Eo%m;iØ4t8f %c$ÃÄ1 i ÖÑ¯½VFÌgrÈ¦ûcVĞS€Ÿ>ƒrÉüÄùraë)¦ÒÈ&ç·É{Wiªk¦>´oM8³åBPüU}^øn9à¹©q«&wFJS`¢t¥MÔhø.~4)&S€ 1vV-ĞZn'"»I-Å"¶8úä!áœÛëmCP1<V*.|VÇŠuº&fÒ[ÙåUÅàO.•WÀÑ+CòtàpÎaÀ–ªËùÔvf®¥¡¨<OK¡i!Z&ŸæQvhˆmj&2æ ø‰–OÖCZí±+¥şI	;¨‚íT´ !ëštùÇùû+Æ!:a€E A¦Î
VÌf/nqIĞä„0 --®)Tà?Ä±Ğ^It‡ëAAæ ÂÜï±0SºçÉUg!f±'FÚ&¬hšpo)áèa×•R£lMu&åâ’Z€ì,pæ\zî3nj™Võe'¢îQò¸vnòÈwš¨™³L	=`²¨M^3 ®KÃÃO6i=JOO5©ş™ RçtİÇv­µí_çWpîû«Ppb?;yß~\İŠ~y¹ë>]:p-I´Úi¡èÊ|y‡+ezìxU	7aE‘›çó^GG‚ÔÑnEØ¼Ä?{‹­ Lae”>vGş[ò¼ˆ•_ùLÏ&_?L1`UŒšvî¨ŠÈnJ;;y%ü5|
	,ê4)€AŠ
ğ}e&t6y•{I3tçê`äRó‡'UÊ@DÅDQİèìÂ#—ò–ºÖ½btvÁVz´35bOJéE“‚òä1Ii?
gj6é¬28«‚åG:nS«c_Åº»ã_\¬f-ímj:íÂ«dAj)ÅVí+Ò.\ewsñ`g‚,ïWfW†¨³Kv¢~â
çÄuÉI»š=¤#ÿja`£#`¥ik%8/ß"àí)öÌ&[¾Wÿ²£Ï³¢7,Ùn"ª«C¸|œí?`¯,¥-¡$I;m¯+môåm§nS}AM)A­ÅëF}LôÏAmmˆln'Åic=¶?Ÿe:­9nó'{l­jÃ«²Í´ò¯PQa}ìÒ`=CMG!d)¢G ËqØÃeMrî4É¢g>Éª–}]nÇ^< 9;¤ê#¹¡¥=i2E‹ô-Ìû¯3íÂ¾)53ünıT´¥ìğ¾W/§Ğ
/*me/\Z­Õ˜>eª­¹+->¹µóÊ™¥î—¶°)îç¯åØŠ’ÆOoëtC‚ãÑÃx»x¨øÊuÛ|v}8¥1mKBÉ×ÍBiö­İwÎoiépvi² Å†[vœısbëûàE!Tâ¦r.%ì8ïÂø °:ú;SÔKCÜ ĞkK$“]T Ye¾ËN`#Y,†Y¸×+IıãK-û{s^«-JdÁ‚f%[k-c§c˜«M`g¢i1L.ÿ£ĞZ;-òIĞ”¢”»ª3®oÓz—|E¼axK:muü{îú 3fàA˜RbEĞÙ¨£Ù1öÌMkÓS_ËaTû6*vË pZ2w4Ì#ıĞêxik–}¾«9E$£\|DsÇÖá/¯RI'óü†(B+ê4RµÚ2è6!ë”zËd©hqõ.k±7?(ÜöævFĞ ²'¬Â÷Ùn}ùïWÒIX±²«ş´ŸZb5ä$ÖÒ9Õà_lºaê˜ˆö`ıO×Z‹O,ç5“[=‡veóÔDãmŸgcz³íËh1*%Ò93ÊB	 ×Ò+$Ù%ÙpIB–awE­Ì)]Ñ!íHÇ/>çr·¶=È–ÒroÎ	€ã<N°8ÙÖ=Vsé(!¸@ 3Åª¹v;7&ã†U*ÆhúTy]á7dn(®ö­Jû4ıG¯ù©r.¥Ñ¬PøÏf€L8q®ıOh{n
¥nıIG i@ı±¤f1%6<ˆ¼å†ò¢\ºÅkç“sÄÍCzFIÔ¥Ì¨ÁÙWn8&ÙÇõë öÁšaC mVB²sÎó"ç¥ì^VX'¶máVâ³hÄ.®1Q¶-J ÷õT36é´un_b_}éà<2oÁaÆkï–NP0S±ô{¿ (î¼Ó¤áBÔ5)ìST¢û6=*w‹ôÜ‚=p)dOwò»9
¡·›jì|(#-Ht«7ôá5CaÎMÁ¶£Ä2ü	øap1i!SO–Ép›dĞ§=ı°Jcìlëê» f,ÿUwIÇÑ]H£EcJsä´—qN ÉG5cmû ªÓb|Éf) ¢¥TAî3æE­È%Èr²x¡¼l“ˆ_¨*?·Íñjag$vİlq–àgÚ€9y$‹¿b°v`Vù*­"XkNóè5I+RÊ¬«—ç‹„V}#Õé„¼tÉ{ŞoL3³î$~KA7õæp#½#Â½N¡#PË|$,ôFrm²O€{‘›k#4nMœÈÁOÓeZY…t©"" 'èĞ`**`æÔ#; àäbac‘SÁÅh]ó„e°|Éa`gV¥cÃ¬R€äÜ2y=oQâŒàhÓe¶mŞ{ò¢w€)á^@	aÿ‡Càì¹¨äí¢$Uüİ4iÆœŞO`[Rr8Í©CTob(\®.²||³N4¤0¦AIÈ˜4wõã­Èc;~»Ã`í`8o#.bïñ0haÊcji‹fiù .ç1 LñÚc¤{Ã+ß¢ Oc_%g’BLg¯sãÜ“o"ÿRTjy¦A`ãCƒ&.E³HÈ%íF=D'_x…Ø3F=iißç¾aÎaÓÄ²­j½ƒiuóqîsË¬:š!´|NS3VáÖ›j1ø:AşÄ‘‚ä¾¦Ü%²`›*èLLòMËÙÏ¡)ÁÒ¹#®,hÎdòkzÕz8Ã*dÃ'%½Hdr§å1b{Ó:iìºCc|Ù‚|$RfYc<Mo“IÅd¢ØÁ?A–íƒõq—HW >} ôkaÓÁop ™@«ú¡hJ-›¦Ò"‚}©1ƒ[à÷+£n«/0zG~³=^şøAÔà¿›ånÎe<‡ÿsâşo/¨so)R7,İûRE'iV¡ÃF\mo~‰ Ã¸r´¿9RìÓÄ«QótA¿=TnÈo,jªhc¦¨|2K1ö^[ãn`å!ì?UÄÛƒİÓA
d‘<es	 vÌ(
BÑe£ù»'H
.Tbcì¸tz òP/Bd»„!ö6~3bÄØAå"VÛÅ_‰nÊ	‚üô'÷c*ÅÛ(MıdƒaùegÄÂ<è>	KC}–† Jt\'Ö–ë¿è°üCÑGºPLpûvá$õ Zlº&çF¿iœÑÊÏî}hÈ[­$m±2àí~,P÷4òuZ3lbÉsú-ròs}+½#M¡vfı$se I_1ÆIÆzÔDîkºU?õİ›òygò8£bfße&D©B*f41çXèÊªø'@Fâ²ôpmöbêî#©°‹‡[ÆN9l<ªğİ!3Hz$*¡rÎjŞó­@Ÿ;ß2áSìCåH;í¬VæEuN§P)wZôÏj":_4Tàı±¥­Í¨?P)ÉÌ`Éİ÷f#wÛtÌÂÿkñˆ×òdf|(‡	¿'V3ó28F_Ú0àÍe ¡6Yãñ!#1Û·«(csYßïE+ƒMÓ¶¤$tµr+°pg=Ae0ÔgfoİG
y½YğM5)rõ"5dæroš/ü¶)qÙ;½'^>:º>hzèú¢ãiÿÌCşGõ &á?eq3Eœ³ôlz×s¶¨È
x0n¥¦.¢>~‡E·)bŞ"è;v-R=UÒk6¬yyË`c`İ>c›Š/~0ºlTr«©öçYk²l£cîE0êiZµ¤=st:Lë¦`9LˆpR?D8Qh~\§$â
x03¬êW5/t

%!-Î³\›ÿz[umiÊ*cÍpp3!9û¦mKa:gc!Ë!(AUGpyEÕ­uk7SİC¥´©Ó8¥/·¹UV‡L1iŒfz+mr;œM?¡Na-+Mèô§ş óOÅa3áRU9#ûe„o6k rEb7ef[%;{Øç
(«T(‚3uaoø})XÜ­e+kDG“uŒŒ³`İÍ{Eje$\Fæo©ğpSŸ$1ø`gsòé›'›I-@©/e`ïfí=ÊUmloÕç,µéYñÓGïhPS"	nª3ñç,¬fkEşsRiüs Ñ—CYµywp%|ã ï½2ˆu'odDõqæx`2s"ğAqğ%ÀGVO
|/¤p8µ9=\T>Bz¡¨¤ü?’ùn]f=E7|húb$IjY¸nuĞºr#@iEÿP/.“Wâ ÈQw u¡qF%$,øÍi•QœqÑ%çĞ¢nƒ¦	«C#5öN{}Ë%éMÔ0l@ugâ´Ìá"io¦0\:d& ¥öáYcábààxlst1ã3u|õjô,ûVJ.,i ç1nŞ(v;"vİ[à'¯ÌF#µd*‘%"3=hLÒ`K*So-V;ÁÃH nT’ã¬Ó"úkR‚Y­bq\z,Â„Š±ñ¤iYØe
…T°"9úÌB#iztæ˜~Eö$1äeÀ»5îN•áºìt ¡¾t?Rm‘uõyT8ueö<eEB1}û}.t·[~.Ç8Ët,6Pæ9UÜ¹ş/é0ß»ß IUê14ÿU 4+4—p=h´Lûb÷')]eWl¼P¥4 y°¢1A4&uuó¥İl€Ñö56ğIâ6ÎC=Ğú7X©xunô!9øn"d>©P¸(j²‘Òt*óTûhˆödy÷Çrğ 97ÁC[^i8İŞ>_ñ¢5%º¹‰jt4uaÎã€rşgy'xÈw qus^m	ğÌ;±õ¥Æ vèJr}oıa©3$i!OsTÙ,]væ³¨ôr!{“öîld,©7 hkÕ#™"ß+Pxq¢¦¾,;š¨…b¬Ùá(9*ZùJ
é0y*l)O–ìsF ÊVSCérÚt‰%cï j„3?Êdh¼Õ¹z¸ßDÈ,^_-@õR"²³hHán¦aa$X(Qv˜~((ÖšVF,»"_ñíJ­óÃ-gÀåc!½¢Aên|b%"ŞŞ!AöÈaep½LDV,{8q‰Lç;%ş§!xÜm¾v<áÈmmÇS)K:=.ˆi+E°À1B:–pN’¯Ó¼W )¤û<­@h¥ä^c“J> qgT3?îcyi¨âJùÆJïCEHtå&QnU`wRvjmx Ûİ$Ø^Jv²fj]tO¤dyíd	a±xb°g§¾Dsù}…´p¨!FNyª{G±ã3ØhAÄC *{pa\w}ìéYoÖ™r%GÁkUWxzØD%ovc‘¡Oâå4)ß,¨|j“]$$<ëTå3<¹ôw(hdãI‘‹Á­©/T+iéæ/T,8Œ¯mO:w¨°):z¼şšäÓi|9§íR£™§MC‘>`0 wa(‹{¿uá…Ãl×|z7È<WØ”"ÄuÙ|{haE¦Eİ¿ûşO·³ˆ"ì ‚ãø]@ ‹ni¹Lb°vb|D£JV`¢eSëœ"ñ.'goIåÏ9Ì^zÂİ|‚6…¤£å”M øâm#¶zkOÀ+mM(bm4:<MeE¸~:óJ¯84=óìgOÃX5o„[IÓ‰ôì×•_ S ®#:.46aä<MˆÅ
'lìjË­8+ugh»&ølÛŠQjæw![7Õî!d<æ`(Óy+èqşQa…YÈRÏSïäD·Vp«T{"‚\ú$bgda­T^]R¾v.Úè€•sêW
Q.K*èq)ö7ºpUÅb$µMÉÏvqRaæt$Èmmy3‘÷s8«/ i°sÓìM`g¼ıuwÔu$¬$2KJ°ŞCªl®ô¤æ®Ë`½ÉOi”İç‘O6¡§
tGL4\aMMejæ™ ¹"9±l4bª¦eèóGÅ´Òr“dSw$=¼ñzÄV®‚DàhÖd6µ§Õfi{N:È¨2áKÇˆ5sRsÄñVrœ¦§¹œ5b½mÙòN76ùmËFvÜ}£tt¬/eP¡fé®DºûÌe‰nÔÏ!rµ'x^59m–.LZ’€ú6Éd\gläZõ¡aBÆpŒi#k”D²ı©oejÛa2<fú4«'€oÇ-¥sŒ m7ïœÂıa­îF%v:/C0òÈ‹ú¡»zlx:yRHwä  \VC$îhqF÷6pp¿.…$ÏdeŸûüój‡!xl¥ï$çm.WMd3=-÷ğAÕ5ft9>§ZoM,º^™‰ÍóÛä>ë>2ïæáWEOmåŠ<31ÑËï¶§ş8½RrÊöo¨‹<¯©ato5K+3]g5fÁëg0»f¦Pé RÒn`+‡
y$qhGêuâ~LeY=.Å$À­0]ZÜFìùeïkîè„PN¡dw¡j8în¼ªš•lxz÷Z BU™lj»"AfM!_A÷¬1Myv:­·Ş+å5‹9×Ùaz‹W¥vK¿xbeI5ºµkè.¢áéŞN$ãi+#3è±"ØF9 `q«ÒwLltÆ³\çJU¦$pg‡N¡şŒ^Ïi¥céIzeÑrväPd,i½X4 m±ÌI*Rdö$S, +Bâ\óam6±m®ù
°&14ñx^,$LK¶I ìa2œfP"Õl nx)åeÕq¶\O1Fù8úAKõJp !i¸à­*ÂgI’2$Wğ$ésÕÑqõĞ‰.
õIüèíjÅĞ%tV/iAhh­}#W%L»EŸ§Ë€´"	s»¯`2º'asû_Än&F{óÂb · ˜Ó¡it^‚m®St6‡:­¯4à,‡D´1`ï IeFOåqo2åI'ş^÷]KxõMõv²|t:¦y6bAuCI_ÒwSD,Öy~l5÷mDŸèá :Ùm®·Şx4²ûâò¸lIvéVjŞ¨i°vùi»ñaféNÖ# «bo/xAı{Od"QD°ZÚHs0=u@(¾hnV?#*:8{0}ÎX_kKÿàs¼ğÍIN+Ñ[\ê‘jf ’öuà*gÀ j>Kv5'WbgÉº j_{¢¬ât¡L	2ršà!"¹XÅqca91ÓbXuÒñø4w«~vï^—ßo]teš9¯?şBk=ıHŒCÜ#UU‚y,’eåL=Y34€!&sG>ş)éüVÁAb JM†[ld]@?2áz(î]gåı”X8Šm@FƒeIŸÓÚåE\ZKE§4Îc@na½(#ÊWt#3Ùå»
N`m‘,JïlGa?&6.H,,wÕ*ç	qÚuH[tj‚í`|†¢51Z k>—	,fÖ¸/;vc dUG×1t=G}]Ûâ !™páÚÂ~LBF¤4ùµ*/oul7b^Ì7Pù}2Lf?<2øõW	bzn<´õzH…i*Ÿq&d"a(C< ˜í1ÕJ1Zıxw;!åòy@bHÄQ`G-Zå&QgöPäTö T…~áëuQ½}Üİj+fâªig÷"y7q~8Løa áÈ'YsşNä„p ã¹ºå}psækG¼+%¢ÎÖ`”·N"êWå¥pº„¿8Œ×’FI}Ñ/`û@_~«õBG7·¥—<8VuV »¨êîáÿf¬÷"¬îa³°Â¦í…@õ±·%gqÈĞ—èc8Ê€:eJ ! V0¡â£<î¯fWrk+ï®/ì÷»&F$]4rK's>k“ô{V9²›:%s#ÓÀÃes”„`õïxü%ÑgHE£Äúéï%´İşÇn-J1Yépg*Æ,/S}ôøÒ3<M%ë iNĞ@nì#&Éa= @!wlÊBÚ$>÷ Ği™r|ùé…€Q,^q·P»7+vQË¤²(xÀ1+„dÖ€35o!~L56±×º/u"Ø8Àm}X~FÓûefa`lƒH“í|¨2µj{sd»f¢#ùsºkcß8«PRšHszÆfbøƒ¶iq%.TDeh>ª["õÅ0	¿lâ®(lë-MdD \ÈqÉU^{³åÀxn—ô5>Êxyo1\ş”4¢bÅìQÀŒt>ègh+P¤zÄe€Ï}h{¬¬ÒvôW¬ #ŒA;cyo­hÌÕg,	Øf%GrlJ–g30ÑS@JG¬õe~¡“òbp%d.e0¡iÅlu8’µ è$` >/ZòxJH4|É3Uym {JdÁ©ªyWsı†­Nõ¨Ên¤©˜)<(ø'?nsá Xhu$ùgûù)l£aAl:²6¡|xjÈ~7Fá?cV|dFS#P›~ó6+6/;ƒ® ª'«d$¬6e#t*8âçï2es.°?±&åø€ò#O&DXB)ªi{¥xiâ½²H°j8#?)¬i±[2ø,-yeDEUúŒN2ŸNQE¤êñNcüå2v_^)ŸÓX q/ex÷]Ùc€¨=W]9SšÃÉmgÊ)±—;óa-RpÆ¡+$bráAA•ŸI—T)í*ìé:p!é0qzbx°N!»€<
¹hdá'4QÖä0I@Rk-Ô(í¿é®Ağ9d"à;´Uà]ë53qÃ¸	'ØÈ£T·Î·J$6´|› ¿6ö	°ˆl)¥L8–j8.YSJ×gáşEF{3m±¸ªW|'i öRá7gÃÁ¹ş1IS	Èyc$YìºP&kşO_h!.¹µQÀdhf-f[èc¤i½‰l h:óH¶b5
'Qr7µ‚d,š`ã‡#áâ	0æ½9š´Z‡f^şx”®hy%Êª%y 1e$u>Y ?Ç›RK5(#
sl"xAFäG°”S/(\Ù¤Çeà³í'm°“¬¼O@•}ZESoñ«ø6ù)¹voß`ñøP…#‡CXÊb£eùêû?
ŠÃVi²k¿J”ÇÀl:1Od!p5k5¼ª†mæ`}I(a5C"54!ú.?h4ks;5Ææ­Z²ÅÂÅc.ur0m"a+hô¸Wº¤._ıFÉ­M ùlH)!©Î•~®!\ Å
­;şÆ³]!bštFt,9 ,`GTåyàLªl8‰Pú)cé°Ò" (V…qÜ—f.Üõ#µ †p{L× ¥!Õ­vû>!p)¿i=4j ¥ô7aQõ4¥uj=dNÖckrŸâ#’×%)ªBF®!Ïé5o<e -0f´TH!}\òÔçrU,ÿÍK(ªânkùdæo8|?"0. tpİv²Ce@÷’|

	å®rÎ')¢€m i¤om?å\d9xZ}„£uÀ_ ·+cvxr4“?èa“)“‰—)ONšC¤º(MÃ¾ç­û+4šq5Ó,E¤hÔl;ª¨ŠM1]À]')% *$U!{
p},IE.4s5+½iÍYw)-),'hè@å%¶h¡m …LEğå»8y¯,¿°z…-O+‹ah |=LË;}iá#êµ$}s‡22v.
:èùÿ2{Üƒo>ç=²¾h¶“mnôaik7W7@Ä+¤==H)¹-ú. ¼mÊ,<ğ nd&¦dÔ
v¾¼Û-çY{	I­±‡U==m·"®ôm½5?\-mø))+ªŞ/(50ƒi
lEåóQd{Ôs!EüYšv™ºUâác;Â ;¨N0Ql‡ltPò*]) fNÇv„cOáü'¡Ç£b·,2ò bÚ {gTëÈj}ÅDu;İkQ»K} [Î_pcön(ªÿLşÛe¦X_j;FhŠGXx	©ˆÏÄm>¹%ua¹~&2®a¹`º‰$kèdõö²öHø}vŞT'ƒA``…ˆÔÓ§ås!\Zñâ;n£pà¨ûºÎf^9ŒNò Eb£e
ËEnè1x,ryÍm/˜JYô"Ip¥,¥ørúCz«¹öxÁ@¸˜«‘G<Vr.{#´p°Ef0u"!>•½×|üôö`C/‚õ?ìy½05B¡òKÎPF¡Én±-¥ÛPÚ4	wYœ_gj,nC¹:±,¼‚Fk©Úe0¼&s¦ y¾x“eBxCÍ~MmMe ôo:P]\{W.;ìü 2sävAñò4}J:¦	ÍÊºD}YQz,po72v)4Ok-è¨°x¬ºq?®årÕ4ìR¦`nñUîæ0Bƒ~5z{ÿSCKÌRˆz1é¤øDßªdHé&l´a-H¤Såo(Ëm×t#79BwuÔ5{z|9#neZZ!åöÓÇ…‰5}¸¸k¦aÎ°b…Q!>ûIP\6BllOÑB.¡ §T5‘.»aÅ°ˆí-êpáÙKL{*¬Doö{.Eoeı{ÅÈv¿T8B$5H$aÆ1(qgq¯
=|L'sÜ¯N_CTdSà?0¾ ğèøÔñ$peï1)äòè1·E€sU)®-¶,}¥¨âåÌ$Ğ¨e]Nìb1à9iñë¶wnjBc¦d¤­húg8		S @qvw1jGê7s9(=Dô°jn!õÉ©%AJe<f*/<Dc=¨DÒQõuqìš&™.WÀQ+ãò0 ™†aÀ–€ª¹v.g·%d¾<E iáqZ&³æbÖvHÌM*06e qøˆ¶nşa_ì°+tåI\9l"ít6¡j:tçİü+ìAá"O(,A·N(VÎækq/dt2%-58Tà·ÔÙĞ_6É~hÜp¦ ĞÔç5wĞS¾Çke9f²#DR&,bSÜa/$âaÇİ§Ì)V&ªâ~FÚˆ<é®4ôç^a\{f mj™Wef'£ïQªS7<B½È+>¯ÛóM-UFû¬M¡^s8éík²C6wÿ?XoK%ú`2ÂTær½åí½;»_u®³«pn?{ÿX|…	¾-™é4Q|~=L¼”Ûe øÊ|s3çzîj1I1pGç3Si À™¡.9¹<Â´}Ãíõ]yf”:w}ü{P¾ÚµEéCÌ&q_=N`Šj÷«ŞìkJ!yëñ¥ü5lm:%~êp)G”Xğœe&
vtxõ{I;|•bşM`Sıß‡'\BI ÄtİèêJ)–‚–š†zjt6ç6h¤97gAxù%‚ú 5™q:]-kj–{,q5¹¢[M
b;cn_Ó:ºÖ8Åt)ïij:oSebQb,•Ó\fá¯«Rg\ãxC1´0qƒ,²ïUeWà“Rbk~ãxgGİŒK3˜<,aÿn(ck‚Y#`$kj/8cÒe:üü"¾g}°’Î³C7,Ùff®¢CºuÜm>`¯è!t‚H:ü¿hğåm÷îRÏC_!@ß”ûF^}IşÿA|ï”djn	#Éy4sH1å¤v23ynv'yl¼jã«tÍ°r#«Dru`{îW`mk0G ä)&!  ôâdMrî6Å"r<Öyª|YeÃ|=ú();6j#¹÷±eók%ÒéÔJ1ìZgáRp+%3nnõVô¥| ¶Q¾ ĞJ/*eWg+TRıN˜zÊm;+,üø´ó/JÓäîÕ–°iêœ¯dØ‚²FO{»~£Á x;z¨ãË1|~·|<51J<"MÅ@kö·e_Îš}Iipwdš$‚„w\¸ëbûëÃ,Uâ,öjl¸ãÂì  8~pä[`T ‹ë¥"“uU@æ\e%®I^c!Md†}¸6?Aİ%c'Wéysˆ_+,NdÑ‚®d±k%g&c–ş/Mhg£M)S(ºgV;n¦H'È¢Ş*s.oc8†P¼1xN(c1¼;mø ögğá˜vpë¹¨#İ1öŒM/Ó1ÿÉq6ø¶,~Ë8wÔzw4ä©=Ğ¿ppâä5:+9ç$£<yNÓç–±)nÈ ûæ&2B"î–4
BµÚÊğà4Ù—êï&<ÌqÕ"ñ7/xÉäf\Ñ 2'$bÇUî]øg}rJq¢«fôµş
ZZ=ä$ŞÄ9T)p]8>ihØˆwb=Gû‹O,é\=›{>Ç2qótd£?>çby³íIìQ:!R-1’JQÓá3Ù5{pS@ÒafØ=Í-\Ğ!ápÿ#>æj¶¥!È~Òbï i’ó¸l(xydYV7é•$!îC 7Åªyv~?&G–E2ääùUHNYÃaån(¼ö­^ûp}G­Y
†)r$¥Ğ<T²áÄI:u®¿^è?nh4/îíc‡()ju9 f45w3<ˆ´ ¦²£\nÄkç‡z`mwZRÈD¦M©U¹&Un¸dÛàõëò‘Š"!C hTBºvÎ‰ù&à%½uVVI&§má^n³)tm.`7A2-N 7½pa6átuZFoUif<2^ea²¡sô†ÚT8S±äğ¿´|Bî¼ÃÌqbÌ(nS>û[6}>eü\;u	Ñ;â«9 µŞgıl"")Lö«7áñ4¢uÎEéF ÏÄŸø	ø,2p1Šm0ÛA–2gOQw<õ¼clmkà£ l,ùDuIg›_	¢%e£Ûå¶·xN3Q²T=sm›i(2`<Éa€ èeTA.3ÔW­h$Éc’l!¼mÓÂyè. wŒÌá`cc$dM,s–àcÚ±yh$L¯2"ğVäVyŠ! POJëès	¢„®µ¤„×{#M¿:œdşÉ9î\z7£è 2>OL#Úor#52Ò=Ï%R#Qú|$,<~$nP{Ğ+#=|mØÁOE)Q‡vøâ eúÀ‡`"*nvT:„à$äfœsvUVPÕ,z|¢<e¸üXcpgW¡sÃ¤x(ä\6{2QâŒchSe´Ø{r°m°"ìVÀ	"ë³Sàö¨eé$mEål5x†´†HŸG`\r8Íc$i**N.Nö|iãN&¤%¯AMêT5şÒm‰au^»$­ 9!o'.hb°0heWJRbd‰diù:i&÷1‚Lñzë.{Ñjü$ OsW5aÒN|g}bó}SHÌ"ë24h²àb£fAó@ì%åÇ}DNKpEh3Ï=¹iÿã¾GJ1îTÅºı+=Rc=óqúÑR…0½«c0vO;G"Vï×Ş
9n-xºüÄãG¹2st5<¶a»/èMnrBIi)(Áó=¡¦%(lÎ|óNrµcã•(}Ã7b=hnvÓá1&{y<ø,º!,N–}¤Re;Ç4lTP¬IŒ=×$âØÑw¢e¡çi›ôyEØè>}ñk`ÓTop*¿C«ø¡*(9mš¤ò*‰İé1ÁYÜç;"bîs`ófvq=^şneEàÙ¹åoÎQ4…u3fşGwt/<P7,Yû]U+s;©@eäMlèn!¡z´ä½}ÂjÑÖ‰{8IªŸTg˜+,'}ª
y#§ª~K16JkâfbÍ*iè7¿AÅ[àYçS*G5<Nvg >å(	BÁeµÙ»7À
?ufk¼º$ş áb.Be» #7';6|8&aTˆA•#ôUûa^m‹A|d÷á*ÕÓ-Mû ÀaèágBÂ<iAGb}Vö¨JvQ-ö³&ã¿j¸øCÑ&¾²X1ûråe$Z}ú'îC7iœ±®³èmU(5m3dèûê, ÷7ğvs3 àËyr,0Psô§Åeµcm´g#,ÿ03 âWq¨FSÒpVDnq†U‚;÷Õ›òzu`x¿7rFØf"u*Ú*2nÔ0™ê,Yªı¸7 fâ2ö!|ôpbşe¨Ù«£;ÆJ*®pï!sAtR$:¿ğ¡ÖF.Üóciz”1†:^2áy`ÉïH9í¬^:İ%RbĞ;tiñî:4à-¹§Í,?Ğ=éÎpÙyp@#w’gœÊo)ñˆ
ÒuF$agS3÷²9D»p4`ùe¸$0pç³99!3µU7*tate &result) {
  return impl::parseCastOp(parser, result);
}

void IndexCastOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult IndexCastOp::verify() {
  if (failed(IndexCastOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}







void IndexCastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::MulFOp definitions
//===----------------------------------------------------------------------===//

MulFOpAdaptor::MulFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MulFOpAdaptor::MulFOpAdaptor(MulFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MulFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MulFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MulFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulFOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulFOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MulFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MulFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> MulFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MulFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulFOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulFOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MulFOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MulFOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MulFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MulFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulFOp::result() {
  return *getODSResults(0).begin();
}

void MulFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void MulFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void MulFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void MulFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult MulFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void MulFOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult MulFOp::verify() {
  if (failed(MulFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void MulFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::MulIOp definitions
//===----------------------------------------------------------------------===//

MulIOpAdaptor::MulIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MulIOpAdaptor::MulIOpAdaptor(MulIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MulIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MulIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MulIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MulIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MulIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> MulIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MulIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MulIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MulIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MulIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MulIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulIOp::result() {
  return *getODSResults(0).begin();
}

void MulIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void MulIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void MulIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void MulIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult MulIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void MulIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult MulIOp::verify() {
  if (failed(MulIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void MulIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::NegFOp definitions
//===----------------------------------------------------------------------===//

NegFOpAdaptor::NegFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

NegFOpAdaptor::NegFOpAdaptor(NegFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange NegFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> NegFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NegFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NegFOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr NegFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult NegFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> NegFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NegFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NegFOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange NegFOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NegFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NegFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void NegFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes(resultType0);
}

void NegFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand) {
  odsState.addOperands(operand);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NegFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void NegFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand) {
  odsState.addOperands(operand);
  odsState.addTypes({operand.getType()});

}

void NegFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult NegFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void NegFOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardUnaryOp(this->getOperation(), p);
}

::mlir::LogicalResult NegFOp::verify() {
  if (failed(NegFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void NegFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::OrOp definitions
//===----------------------------------------------------------------------===//

OrOpAdaptor::OrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

OrOpAdaptor::OrOpAdaptor(OrOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange OrOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> OrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange OrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OrOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value OrOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr OrOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult OrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> OrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range OrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OrOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value OrOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange OrOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange OrOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> OrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range OrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value OrOp::result() {
  return *getODSResults(0).begin();
}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void OrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void OrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult OrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void OrOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult OrOp::verify() {
  if (failed(OrOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void OrOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::RankOp definitions
//===----------------------------------------------------------------------===//

RankOpAdaptor::RankOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

RankOpAdaptor::RankOpAdaptor(RankOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange RankOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> RankOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RankOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RankOpAdaptor::memrefOrTensor() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr RankOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult RankOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> RankOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RankOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RankOp::memrefOrTensor() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RankOp::memrefOrTensorMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RankOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RankOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void RankOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value tensor) {
      auto indexType = odsBuilder.getIndexType();
      build(odsBuilder, odsState, indexType, tensor);
    
}

void RankOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value memrefOrTensor) {
  odsState.addOperands(memrefOrTensor);
  odsState.addTypes(resultType0);
}

void RankOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value memrefOrTensor) {
  odsState.addOperands(memrefOrTensor);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RankOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RankOp::verify() {
  if (failed(RankOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops10(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops11(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::ParseResult RankOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType memrefOrTensorRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> memrefOrTensorOperands(memrefOrTensorRawOperands);  ::llvm::SMLoc memrefOrTensorOperandsLoc;
  (void)memrefOrTensorOperandsLoc;
  ::mlir::Type memrefOrTensorRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> memrefOrTensorTypes(memrefOrTensorRawTypes);

  memrefOrTensorOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(memrefOrTensorRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(memrefOrTensorRawTypes[0]))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIndexType();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(memrefOrTensorOperands, memrefOrTensorTypes, memrefOrTensorOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void RankOp::print(::mlir::OpAsmPrinter &p) {
  p << "rank";
  p << ' ';
  p << memrefOrTensor();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(memrefOrTensor().getType());
}

void RankOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::RemFOp definitions
//===----------------------------------------------------------------------===//

RemFOpAdaptor::RemFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

RemFOpAdaptor::RemFOpAdaptor(RemFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange RemFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> RemFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RemFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RemFOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value RemFOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr RemFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult RemFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> RemFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RemFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RemFOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value RemFOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange RemFOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange RemFOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RemFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RemFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RemFOp::result() {
  return *getODSResults(0).begin();
}

void RemFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void RemFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RemFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void RemFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void RemFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult RemFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void RemFOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult RemFOp::verify() {
  if (failed(RemFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void RemFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::ReturnOp definitions
//===----------------------------------------------------------------------===//

ReturnOpAdaptor::ReturnOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReturnOpAdaptor::ReturnOpAdaptor(ReturnOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReturnOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReturnOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ReturnOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ReturnOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr ReturnOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ReturnOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ReturnOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ReturnOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ReturnOp::operands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange ReturnOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReturnOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ReturnOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void ReturnOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
 build(odsBuilder, odsState, llvm::None); 
}

void ReturnOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
}

void ReturnOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ReturnOp::verify() {
  if (failed(ReturnOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}

::mlir::ParseResult ReturnOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> operandsOperands;
  ::llvm::SMLoc operandsOperandsLoc;
  (void)operandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> operandsTypes;
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  operandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operandsOperands))
    return ::mlir::failure();
  if (!operandsOperands.empty()) {
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(operandsTypes))
    return ::mlir::failure();
  }
  if (parser.resolveOperands(operandsOperands, operandsTypes, operandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReturnOp::print(::mlir::OpAsmPrinter &p) {
  p << "return";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  if (!operands().empty()) {
  p << ' ';
  p << operands();
  p << ' ' << ":";
  p << ' ';
  p << operands().getTypes();
  }
}

void ReturnOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SIToFPOp definitions
//===----------------------------------------------------------------------===//

SIToFPOpAdaptor::SIToFPOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SIToFPOpAdaptor::SIToFPOpAdaptor(SIToFPOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SIToFPOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SIToFPOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SIToFPOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SIToFPOpAdaptor::in() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SIToFPOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SIToFPOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SIToFPOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SIToFPOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SIToFPOp::in() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SIToFPOp::inMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SIToFPOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SIToFPOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void SIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value source, Type destType) {
       impl::buildCastOp(odsBuilder, odsState, source, destType);
    
}

void SIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value in) {
  odsState.addOperands(in);
  odsState.addTypes(resultType0);
}

void SIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value in) {
  odsState.addOperands(in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SIToFPOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult SIToFPOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseCastOp(parser, result);
}

void SIToFPOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult SIToFPOp::verify() {
  if (failed(SIToFPOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void SIToFPOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SelectOp definitions
//===----------------------------------------------------------------------===//

SelectOpAdaptor::SelectOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SelectOpAdaptor::SelectOpAdaptor(SelectOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SelectOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SelectOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SelectOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOpAdaptor::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectOpAdaptor::true_value() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectOpAdaptor::false_value() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr SelectOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SelectOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SelectOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SelectOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOp::condition() {
  return *getODSOperands(0).begin();
}

::mlir::Value SelectOp::true_value() {
  return *getODSOperands(1).begin();
}

::mlir::Value SelectOp::false_value() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange SelectOp::conditionMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SelectOp::true_valueMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SelectOp::false_valueMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SelectOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SelectOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SelectOp::result() {
  return *getODSResults(0).begin();
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value condition, Value trueValue, Value falseValue) {
      odsState.addOperands({condition, trueValue, falseValue});
      odsState.addTypes(trueValue.getType());
    
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value condition, ::mlir::Value true_value, ::mlir::Value false_value) {
  odsState.addOperands(condition);
  odsState.addOperands(true_value);
  odsState.addOperands(false_value);
  odsState.addTypes(result);
}

void SelectOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value condition, ::mlir::Value true_value, ::mlir::Value false_value) {
  odsState.addOperands(condition);
  odsState.addOperands(true_value);
  odsState.addOperands(false_value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SelectOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult SelectOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseSelectOp(parser, result);
}

void SelectOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult SelectOp::verify() {
  if (failed(SelectOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(1).begin()).getType(), (*this->getODSOperands(2).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {true_value, false_value, result} have same type");
  return ::verify(*this);
}



void SelectOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::ShiftLeftOp definitions
//===----------------------------------------------------------------------===//

ShiftLeftOpAdaptor::ShiftLeftOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ShiftLeftOpAdaptor::ShiftLeftOpAdaptor(ShiftLeftOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ShiftLeftOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ShiftLeftOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ShiftLeftOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftLeftOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShiftLeftOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ShiftLeftOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ShiftLeftOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ShiftLeftOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ShiftLeftOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftLeftOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value ShiftLeftOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ShiftLeftOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ShiftLeftOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ShiftLeftOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ShiftLeftOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ShiftLeftOp::result() {
  return *getODSResults(0).begin();
}

void ShiftLeftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void ShiftLeftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShiftLeftOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ShiftLeftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void ShiftLeftOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult ShiftLeftOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void ShiftLeftOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult ShiftLeftOp::verify() {
  if (failed(ShiftLeftOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void ShiftLeftOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SignExtendIOp definitions
//===----------------------------------------------------------------------===//

SignExtendIOpAdaptor::SignExtendIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SignExtendIOpAdaptor::SignExtendIOpAdaptor(SignExtendIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SignExtendIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SignExtendIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SignExtendIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignExtendIOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr SignExtendIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SignExtendIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SignExtendIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SignExtendIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignExtendIOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange SignExtendIOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SignExtendIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SignExtendIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void SignExtendIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value value, Type destType) {
      odsState.addOperands(value);
      odsState.addTypes(destType);
    
}

void SignExtendIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value value) {
  odsState.addOperands(value);
  odsState.addTypes(resultType0);
}

void SignExtendIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value) {
  odsState.addOperands(value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SignExtendIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult SignExtendIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseCastOp(parser, result);
}

void SignExtendIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult SignExtendIOp::verify() {
  if (failed(SignExtendIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}



void SignExtendIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SignedCeilDivIOp definitions
//===----------------------------------------------------------------------===//

SignedCeilDivIOpAdaptor::SignedCeilDivIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SignedCeilDivIOpAdaptor::SignedCeilDivIOpAdaptor(SignedCeilDivIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SignedCeilDivIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SignedCeilDivIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SignedCeilDivIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedCeilDivIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SignedCeilDivIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SignedCeilDivIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SignedCeilDivIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SignedCeilDivIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SignedCeilDivIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedCeilDivIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SignedCeilDivIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SignedCeilDivIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SignedCeilDivIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SignedCeilDivIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SignedCeilDivIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedCeilDivIOp::result() {
  return *getODSResults(0).begin();
}

void SignedCeilDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void SignedCeilDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SignedCeilDivIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SignedCeilDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void SignedCeilDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult SignedCeilDivIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void SignedCeilDivIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult SignedCeilDivIOp::verify() {
  if (failed(SignedCeilDivIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void SignedCeilDivIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SignedDivIOp definitions
//===----------------------------------------------------------------------===//

SignedDivIOpAdaptor::SignedDivIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SignedDivIOpAdaptor::SignedDivIOpAdaptor(SignedDivIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SignedDivIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SignedDivIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SignedDivIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedDivIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SignedDivIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SignedDivIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SignedDivIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SignedDivIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SignedDivIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedDivIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SignedDivIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SignedDivIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SignedDivIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SignedDivIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SignedDivIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedDivIOp::result() {
  return *getODSResults(0).begin();
}

void SignedDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void SignedDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SignedDivIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SignedDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void SignedDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult SignedDivIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void SignedDivIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult SignedDivIOp::verify() {
  if (failed(SignedDivIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void SignedDivIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SignedFloorDivIOp definitions
//===----------------------------------------------------------------------===//

SignedFloorDivIOpAdaptor::SignedFloorDivIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SignedFloorDivIOpAdaptor::SignedFloorDivIOpAdaptor(SignedFloorDivIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SignedFloorDivIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SignedFloorDivIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SignedFloorDivIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedFloorDivIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SignedFloorDivIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SignedFloorDivIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SignedFloorDivIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SignedFloorDivIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SignedFloorDivIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedFloorDivIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SignedFloorDivIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SignedFloorDivIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SignedFloorDivIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SignedFloorDivIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SignedFloorDivIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedFloorDivIOp::result() {
  return *getODSResults(0).begin();
}

void SignedFloorDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void SignedFloorDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SignedFloorDivIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SignedFloorDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void SignedFloorDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult SignedFloorDivIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void SignedFloorDivIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult SignedFloorDivIOp::verify() {
  if (failed(SignedFloorDivIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void SignedFloorDivIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SignedRemIOp definitions
//===----------------------------------------------------------------------===//

SignedRemIOpAdaptor::SignedRemIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SignedRemIOpAdaptor::SignedRemIOpAdaptor(SignedRemIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SignedRemIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SignedRemIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SignedRemIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SignedRemIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SignedRemIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SignedRemIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SignedRemIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SignedRemIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SignedRemIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation€h=’}àmr9E7ÿjïfëI*Y °@ìĞŞR@vE®Po“×¢ ˆa‡ Õ©P
"$¨ğÕa·1|cÑ=/é¢Tn‚¦˜©ï!mÖÊ{}K7êmĞpl]UãD¬ÏÁ2(¶A^G2b% åãÇYsé ãlytU—ûc|Ÿ~¼bİnÛ^J-´i€]ˆš†0NŞLr:26İà%¡IG#¯d Áå"Õ3?ºÔhÓ¢ªZov:ÁÇÌ¢nšÃìø[G’Y¤jqTh,ƒš½Å¥g	™m‹Í º9ú^İr3şğ¦˜o’)´3ÔEÀÁá~^“ó:­|½±.¤T%Xrmu9Õf4ugö<vAPÉmêQ,5—ob/kÓ*«&®6P¦:ElÛş:ùd×ºõÈIÕêstüu|W4kì5$Ù±\LùbóEFEeW~şpñpà‚¡e"ı{£‡ı´dñr²øJñ(†5FÎ·[)yRÓ‹dOåG!èGbe~©¼(j²‘W_.óT
³hÈæ$;÷Í^t¡*7ÁGYy›|Şw_òÇ9%º±Éê$0YpÌGØ›pèçigèLlDÂuwUlRE}-òŒ?E³Ç¤F€rè\9İei+f9 KXsVèm]qì² ä[$ô{ÓòêEÎ.á¬hËÕo™"Û{Ò[Eô¤ºfû¸©<g$™%çh}*Rıï¨4y(WvC_öExrFbJVRSklYZt‹%c(1h…š³'ŠfüôÕ9jºØmHm>Y-UÄå.S³hOñ+îac|)Q(€nÜL@ªÀ’GF<º3 iÈì×A¾g©æY´µ‹ mCêîÉa¹gbŞ“+QÖˆ1P»L\Q.Y<ñÏMmo,¯¥£xÔo»<pîlÀÚ(1Aå*‡ø9.	iE.É°ÀqB¬ÔPLy’îÓœG@L8…æùÄ%<‡½@`•ä_c‘JtFA'u1ï¢q!¢ÂêØf[eAHd„dÍUVy[
~jËpßMäÚÏJ|;njÜ}>¬p–yåvYa±Xj0ï'Ds¹u‡¤D¨=GÎ_Š;B±Á}ÌÙBÄC¸*;q!vN÷LèY,Ë™F% k_èuzøFTeZg‘£îí6j·¬C¨|ëÊÙ`5=YiTáwD‘åw-hOêM‘	â '+A« ?D,<„oKš~~¬òi:x¸şš´_ïäş§éÌV£‹‘®YCUè0„c}k‹{eÃn×Z×H,WÌDgÆóY,{(!¢F}®R€ÿG—:³ˆ6è`¨ÇñÂ(‰hA¹h[¨>jïNãB\Àò½SúŒ!÷¨/¿/AæW÷GÁÎ6~BWvš&¤¤ßãÿI„áàN"¶ûkNÄ/m&*bM:8@Îy­ ¸^*óJ­X}çîgËÓXõª‡Ó	ıÜïß¬_  ¯
* ¼^áåQˆB‡íhJkI(ue˜¹&øKŠR:(¢WŸ[%Ñæ!•<¯æ@$Ò}.ë!>:„uB³èPVCçŒÖ¶ÎpîTàe3H2¬êáÆ­ÔF_¼v®šè€@úOnÌi
ÌÑmö6Í`ÇˆB1õAÍÎˆ
PDãt:±Èm/y^3qås«/ 	mªSšŒiLeœ´I{Ô7&¬¬¢	k¸ŞJêünÌäâ&‹`²KkÖôç‘Q‘g.}aå@pÕ\cgÔjâ›£¹bãŸÑI<Š¨¶DGø÷áåÓÒöšaks
¬õæÁV®ÁT`Ó¤~Ty°¯Õ.³Şt®Ğ©²ƒ[Çğ5PV0DwDvÜ–«¹Yr¿=ÉòDwıGK…”»Vü‚éáŒe"” †ÄéE*öìå:nÀ›!z-OrŞ0Má¶/LğÀÉú5Øg_6.ítÿáqÀÆ`„io{7´Åò¨dXdhSá2¸út¥+€måÅs,€"¿Îœâ:é-êDp¬Èö
%›2£h0ˆúğ£|ğyè8yQàco¨ vd"ÿ|QF÷>ôT›En…dÏ.dù‹êüQ*‡#0L¥Ï"¤íÙeä£-¥öÌCÁ|æt¹:[«[,ŠİÁİãÓı/%ã6àGŞaUEoÑ«X91/Ğ?¿4>^5Rpˆõo’Î½§1àDitâõ@*QZe7CAëgpZâ¦£RJ'a;…Cy&1ÌGğUålÿN{5?Õ¤Ò½ıps‹Fî}/ndî¨„Reäu§JLîÃ,û
•gxÎæZdJc™ìJr©hLfMñ[§Ä	·ı)p6möŞ!©½¦=sÅQÁ}‚g¡vK»|`Äa,:±i…ì§²À©ÖJtå¸	'3ì°bñwD`y³pYL\gòU¼z6dõtõ1‡N¢üUÈŞzé¥fiL 0vdäir iõX,MõÄ*læ-F Bê]AAuTÿ2³íæù’&1ôøz@\d$LI SI Ìc²ÇP"PM²N"Ox‰wtq¾T*)`Ÿ8ªBÏáH @!i˜èDì;B“çLÓ3âwğ¤íW„ği÷Á-o µq—<à?lÆ„/õ=iAH6íµucW%ØËE‹ô\#‰r¯«	2¾&Òsû_1ÄHdß+÷@ä`¶âØSàipNÃmérô7‡cPŸ÷4ŒÂ•O1`ÎIegõUoq¤AOº\åi
ıµd÷¢,Î(¦}6ÏÊAvCHÇwÚt-R]~ÈƒzDßààä¾ùû>Õwˆ0€¤ùâæ»e\ré\`î~­‹16»	!óuíáÔ& ‰*÷/äÂôNËDiQ ¨^Yud÷u@(·(nM0>",)"9{1’l?Î|L_kŠòçõ¾ÀåYN)QÛì³âfà™ötâŠOÊ ìlOv5§Çvo º)nwk¢ìvu ß)°vOÈĞ ¸ŸÇgØYğÓBØ4’ÙÈc©Úsï^—:i|ò=D:£;k¹ıÈÌO‚ÄãDS‡x-T wçM?»3€
&Æ|İ 4¾¡ØüGAAb$JÌ§|D] oáz)şYçï}ÍX(4€ -BG‹eiİÎËåEÔ[iÇ%<ÜcbzA¨(cÖWqg3Ûåšb,aRm“ªLç]GÀƒY?ÎfĞv6ˆlH,wÑjçKğŠ}F[b‚ìDş„¢=ó^ hŸ‹LBä¹om:v—bb`pO—1ZÓuÉå(ypa
ZÂ~LjUådñ”0-ÙP\6{^Ì·Z±ü:lÆ?œ:ûñ	ãÚ/d¼õH‡I¨¿r`y(‹<ç5ÕÎ<Hıxw;!åñ\DÂHÌS d¶zBIí6‡PM¶SäTöTÛjàéu©­TTÔh*ô£*if÷¢rqu×ó~½FİA˜ñĞgYôNğ„P ÷¸úá]tgçF¨#-¢FÔpVÇnªîWÅ·hù”?+¼ÛšêO|S“²v·N_ö«u€
š".§ŠÔ.JtVûØjÀßRíes¬q“°9Ë&é…Âõ­wuOQÊÒ—ğÑ¸ê@xdbeW±
¥ğ¦d¼ï·f'bk!û¯ìh³4Æ$U4òšK'úkÿôs9šó(>5ËU'›Àƒ$[”¤`ômxüÓÛeHUãÔú½àerßõÃæımËqYápg’ÆDQuĞùÛ#8]ç-iÌĞX^šäâ(Óc"@¡Å,JBÚó.uP$ĞïpüıáÅQ^™Np¿Rš×%çvë¤°xxÁÀ0K¤ÿÒ€#`	~!¬H$r¡İú.Å:z(ÈÜùÙtlÓòdnE`nBÑ“Ùx(ryjá{l{d$2{÷)âjbM8¨ØÂ
l
ˆ¦ff„øƒ>(Qd.TDåx®ÿ*Õ…²L	šŸEçolÍË/FEp\&ğñ˜`Şj³åÀ|¦›Ô17ê`aË1±NÆ¥-"âÅÍ[°	m«Ìø'h*š¤©Â¤CÕ[këX¨B‰tüHW>Œ#Äq/­8ÁÑ+q	ØgeGBhšH¦ç;ZÑY@XCL©E<Š“òbp'„qu4…aÌî‰! pÒ´\í >—¯ZÆ	yNK¼|I&•!-F K`mcïª{W}÷Æ­Nõ¨‚¸$é˜Í¿x'7îñå yu$ûgé<ùHlãal22‡¥ü¸:Ìd~Çå 6 #T¿d–W#S›[ó«f+zƒ"ˆ*«L,Œ62g!T:xäÆo>e{.óÿäìzÄn-K&DXB!(ı}§øIêí¾³j¸ã{™¬]ù]2°|yµFGU{‚Êuµ^Q<W¤ÚõVbøä;rÇş©×0As/eHã-YCf¦=ŸY)R(Æ-íãê+-é;ÓÁ/TÆ°#,Îhásˆ™È—T6)O#ê”íp!‹yqzbY¸L!…€$yHüá$SÖáRÃ@Riô-ıM®íÏaÅĞ_œd"*?¤ÀI ë0BcÔCš›3ÈÚá¿ÍK,&u}™ ?6ğ‰¬lirÌ±–kh&YŠpj—N!îEFz‡íí(»W\ìÛ ~Ra7çÓÍá}YFÈ}U…Aì:?r,ozO^j¡±µCTÀhBÖ."GÌK„Ó=ÈÑmÆb2¢’b¤jwp°3µ‚Ä$`Â‡ráÂ)tÆ=7ÉuŞB~¾š Qy&H$¨diÈ5ád:ˆ>çÚZÚO?h!oqDÒyG4ÀÆ“ C¡&MÙŸÊdè±ï¤h°“.¿ÏÂi*×oSû+üuñ£¹vÄßr‘é@—#aÔÏÚJƒ£eàç[ ËPIõw¿Ê”—Ì}5Ì q1Ê¢Îuç`}I8a´C`19»²ª3i´kr£9Ãâ€­SòĞ"×a*ur0L"Shó¨W¶Åz_ıfÄ­"”éiH‰)$éÎ‘o®+Ü`‚
©ª+åœçÑ]qÏâáPOt$W¤l`GTíÜPÂLëd8ÍR2awè‘Ór	ÿv…QÙW|.uİôg“ †qïÜåp$¸ÑŸr»>¢jÿEa_}$
ååPöka¸v€ 8l˜ÖsíR—òºÓ8¥iŠÛR)F®@gÛ1O=e-!*d|Ôhˆ½İªÌåÕ	>ÊI*ªòNNMÿn.5+8L?ãp{
ò4orÄv"C%@WPNb
°OEŸsÍ'jæŠé”iY¤
ûå|l¹xYÙ$£tÀ_À-Ij'yp7uNb1“)»É“}NNÃ ²hOc¾æı{«seU=ÇL…²:Ìb;†©ªI4İ€ß#-4 š"&Uë;	t],HMë…veqV*?
aÍSwë\-<#èldä²`!IŠ‚\ğm‚…°yën{ğû¥-Mk‹C4k t9cË0üaC“ê¶"#s—5r|Ÿ
>êù/;Í!ÿ>÷=».h·-­g$ˆ{5W/$Dª¥<-]•)¹
ª¿ ¼­Ş.4ğ n#Û¦Rä
>¿\Ÿ-çYxAš‡>GoÕF³²¦nÇGû'2Z?eØ)l{RªÆ+KÂ(%4ƒkƒw$-í{f^Ìq)M)Ü€»V‰©M³)ó;Ç?­¸¡,‡--Ñâ)T)gOÅz„smÓ­'é£„@”,3² )Š(¿gT<ÒgÍêÁGg|İ[+Ê]kÍ}ğg¶oªu\Sû[M,\~`:h:6ÚVX{¸ÎÌÄmyğeoe8.#ÎQ›ªú‰'`øTdõf¸öZxİFŸÌADFAÈºÓ§Ác-XŸ`ò;´a,àêÙûÎâ^¹Êú %ö¡e
òREn©-_qJıÅ/˜*Iô"Ù0µ>­HB¼ŸCúùv\ÁÀšØ«™E86*~“àt0”(r0õY>‘=’dÔòòa9A.Šõ.øyÔ­55K¨ò:JP ¥Ë.±,¤[PyN÷iülæ|ES$ğ~`Ğ‚”I¬^e0¨¢ñ÷Ù¶x²ÀÃ|ÃµŞOLi]eœ$õiaºÀ]	~zU•¾nü	¢SĞAk²D<H:§LM’êş<Æ=	1z,pe02~%/oé-á •ğúhÔ?úåp×ö/ÒhnéÔîf4@ÊvõjysCa kÌpˆk‰Ó+$à	Ä^«$H£.d´q-L SÄsè±ut€£9º¢o}^;{[my!oawj»~!ÑâsÓ…ÜU]¨¬j¢i¿xsÅSGr‘pqIrİ2mìOÒÇ,–¡`0·X-™f7`ÅğŒè9Ât`ICo'¾Egòy§{ay;}ÙuÏQlC$eC$‚Öt0i—Å¯>½~FN#qÈ+ú_sVĞS„;P?ƒÓÌéĞuAp`o)æÎÈ³³ÉFÄ~G©®æ<¥~Í¨¶•åìHØ¹µQ]^ìd)éí©ñ«$s¡FIRa¢d¥ĞhøEz(&3A!6R:Nê#»H%Ìv·°êîaåœC«m@Q!tNê.|VãºÏUÒYÙôU„¨šM&”WÂÓ“+ãò:æ¹uÀ’ç¹Ô$f¾eà¿<mKAiF^&¿áQ×v@ÈMkLš>b"Sø–K^COí ±(¥nM\ûèSÂåT¶@!êˆt9Çİş#†A:ğzàZS$C¿Î +ÎÆ+uÔå„2=9Î(PáãÄÙĞOMl‡úYÖP$ ÒÌg£gÀWı×É'#=&
¢#FÛ¤¬hTk?áêa}Õr§
vFFõ¥âa’úRŠHmmôç\{æ#e€âŒWåfk£÷P¢˜0;8B÷Èc‹¯‘§A	İEó¬MÕZ#0îÍ[:ÃƒO2û•^OI5Iş%òVİæróõÍçWeä«+PQb>?hÚZÌª?)ê>Y;~-I¼”7ŞEñLÚìy—;çzèh		raGÑ8æ£SC‚¥˜¼†–{KíåLyg—ngW~`¼x”oékÎAM/L0`„š:rXş«ÚäoÊ;2ñ¤ütl:	ÿK ¡A´Jò¼%&‚egx•9I3p]âº`òSäß&UJBÀFièêÃ5–â†“ÖY¹ktwÁ.j¤3)gKZ[EÃ†ûä1¹i:	mgn¶k)q<¿ƒE*f
«`^]Á²ûVåf)ìhz:éû«Q:)õPVˆÎ+Ãm\awW1°0'n{ïgWìé§OjãâZQñÄİ‰Q¿rš:¦qÿnfa ¹£è¡kj.|Ÿcòí9ìÈ"¦G¬³šŠ3Ó',ÙNn ª«Cú|øør`aï4µm t‹<¬¯mğç}·ìØLCm*D}åû‹FuH¹÷ßayïˆd>3ÁquH9òŞtz‰=nö'{z¸jÃíçE°FS‰QQdynÓamc]G%ei& ŠQÜReMrotI£k.×*“}	d†v=ğy¯:ñê'ğyåğm2Ò›J2ØÚgs©F¾-4sülnPvåøà²S¾¦Õ
o.gßd+ÄZÿĞìzwCî¼»E/-şl4ó£NÃ¤OF–´xê¯îÌ‚’æO{«DB‚§@Òn»~¸éŠY›||X•l8õ!=LZXNÍÅåFcöıİNŞ}IéqfäòfÅÄ[eœäîb^ûûÁ EEÂªôn%ì¸ªÂı0°2ê1PÄ[Â”°i[µ—UWp¥\eE¾I^`#MlçY±’oIİ%ãE//n«;s¨^«MOv\Ñ‚ä%!ktc¶#Œ˜£('¢e1>²³°Z;,îL{ ’§”_:sªoÒ¨—~€¬!z[xer©9ïı ³cğ˜"Ğìø#Ù!¶Ä/“AßÛ` ú6>vÊ5qÖroOE75Ì+ıJºqpú„=ºª8§%á{Æ–±9«jYHãî†8jêE4Sı±ÒÌr¨:!ù—ˆË ùì0Õ*+ñ5z|ÈšægÑä²7¤â×Ùî]ùûWîJ§‰ªH¯½ßZÊ1`%|Ë;Ô àM±½iêÙŒMç`ıÇ{ÛG-ç4“
>‡Ğa²±@£
ç"{³íÚ¬1ºaÒ-w’F×ã: ™7ÉpC’iv©=ˆ-Š íIÇ/zò:´¯<é’TsOÏ@!ò¸Z¢(Ù×	Ryé, ¼aà'ÅŠ¹w:}6çD:ÆÌûõHnMÃi3ù*®÷­TûpıE¯ë†­`nåĞ¾PROaÁH8oîınähV¥NıB‡0)hõ)¼1%w|Ø´¢†²¢|úÍ{ï‡kÅüSzÃèÄ$ÌñÑ¿LTkºfÉÇõïâ±šaF LV`³6ÊÊc&çå¼6RrY&®kğdÂG§(À	/ª6S¢=J  2åPc2é–u^Ã_]éğ=2ÊÅa–nı×òPhRñõğÿ4<îœÓåàBÆ(,S|³ß6}>g‹äÜ‹-})ñaö¦9á·ßgÏı}'a\Ö«wäñ5BeîLÉ@¦Û_ÄŞí‹è$0`‹h!KÕ‰2š%‹÷|9y¾cídëâ» `lÿTwIÇ+İ	¢g JPä¶—yN#È-soJ¥e–b|Ùg° (à`A§sVWíÁdÌa³zq½.“NyønX{÷İíjag$fÍmj’`gş‘õ| Ëí
"´Tàvù®­XOJóíH	"ÜG®×æÏÄW~ Õïoe½üÉ.Î^L7³èd>oDsJærk´3Ó¹+"Qz|t<v)¢ly‘›+#o˜ÚÁÏÆ-…føbb`fëÑ†`":`÷Ô;à¦®Ô&˜agVåÁM~^ œd°ÜXbpgF1bG­RáãÜ4}{uâmáhÃe¶ Ûkò¿’oc¤
áHdï‡WàòıHôé¢mEmİth„ÜÄP—_d^^v ÍBDo"(Î®N¶(h®NÕ4¥1@LÈ(×õÚ(	a{>»¯e\­ 9DÇ'.aû10n g‹Rbl‹wiùi.÷1ÊL‘Úã¦y×W'R£cOac’n\-»bóı—ì"jRz¶’`nCC">AóLØ%üÇ=dfKx…È3Ç=¹hß÷g¾gÊp†ù"öuoµ’ãW|÷eîàÊ¾:‹c vNo_cRï×–j-é¸Ad„‚Ï[
¿2³Ôeòa›~©L]àËØåá)ÁÓ½ã¾),hÎDóNzTnÕCÔ.Ã7¥Hlrå5€n{û*|¼ŞCb,ÌÖ|4¨RÆ<omòIŒ,Ç ‚6ÙÑ? EQÏmÃôqEÉä}ğK`Óo'p¢™˜B«î¡z
.d›4Ò*ı©!ƒ{Ì2÷w£hîw`÷Fv³-^èø_ÔjŸùåoŞy<‡ÿ3äîÂ/¯v?8R'4Ù|RQ#?¡ÂsÎMmên(!a¼~´¿9jîÒÄ™stiîßTdÈk</*º|k¦:xK!önKâC`h ¶QCÛ!ÌMS
g…xJvg 6Íh
RÁ#³ù«%È
O?Ub*¨º$î0á!Fd»
€h³…&~*aÔŠP•3ÕQËÕfœaÊAÂ¼t'óç*Õó(]é"‚gèácÒÃ<éMOC}Ö†Œkr\EÖ’bÿè´ôB‘O¬ƒLúvàµEÇKº&§Ä»`İñŠPê} Ø;í}m10¸½ê,ö5òvJ3(àÙwê."ÒsÔO+­'¤<gFNğ03%òMq ÆSÇrÔDşs®†U’?uÙ‹ò{õâx£"Vße"Õ¸ú*nÔ9™ç8­úª]¼qeâ°ô lø2ëî¥­ÍŠäK(~¾äü%rAPB$J±òÁĞŞ.s¬ Ÿ”‡;Ş2àYÌÅåx;ğ¬^æq%R§q97ZÑ‹ä"3_¨¹±¥}Ì­Ñ}ÍÙfÉYó`#wšwÍÂÿyñˆÆ€bf,Ç	ş#R7ç²=GOpàÜA pE2\gó9	35•Û÷ëèïó¿Ej·Sß?6vwô0gğpO7i)0ôæäÍBøŸ[qíEÉpù*udãsáº.í–+uK—½#N::¸(yèÚÚgóŒ1æìÓzDõ—"â7E¼Qs·tFrÁuÀw¦¨Ê©Ïtl¦†.°n¡V'&`	º"UÉƒ;rS¼%ÔÑo'¬8YÍ¨ud]gÒ £->0ş¼Ár¡vãX*²É¡Cï0Mê`z¥f72H¼Jê.4=\˜Qr>DQ¸E`Şz§MfÀLxy¬íW5ÔœH%;Ÿ')Ä’ìÛûzù&mi)«kÍTl1!3ïŠÉO;fëgË{µ(aQ@6q§_­pc"÷Âåá©wŸEƒqÙDÖZ­É%Á„gZ#`»3ÀmÉ=£Nc-;[è´½Ş'SKtc0ç²`Woİû n$o LQæ7¡fK5û[Ğb»(¹Sæt!oød&I•7¡kot…}ŒÈğ QÍcEj' 	9Â„/éárÕò¤1òdçñÅøı1ûvºI-P)+(ï¢©=ÒşdoÛ¡ç-³áUY½ÑÅçhRn{	˜oòwôf,¼ıiESWÒÎˆ÷Y—Æ ‘•a!7pî}Ã ûŒxgdÔñqçzc2wˆeçñå-ÂMÇ~
Y+Át9—‰5JT¼Rz úh=Òù²]"=i7~j[bÇiiYe¸
µÒdR@bMwĞzŒŞ² xqw"Ù©PNr$t¬òÅQµqœeÑ<ïè"Wfa¦Œ©©#:Öl{wk;êMÜ4l}tâ0´®Á2Ii¦<~V:f†á%r%ãYgë
ààZd{WëcU£tôjı$ZVJ.´iÄ™x¸?1(ŞnvsBvİb$­LFoõ3d!‘d"(3?ê˜Â  ªzg‘V;áEH£lT’SŒå"xK
P.ebq\ilÅ9¹á¤~YxM‡\8b1ú?„J3aºô.|Õ43İa±ùìtºº¬|=<µ¾„T	zmrõĞVuuSô<gQ@}(:|÷[v.R
7Év®.Xc3EÖGş:id××ˆkÅê 4şU86+:—1=]´Z {bqnUewel>P46y,‚ñA&Ñwvó§İ5€ö¶üHp>ºÇÃ=JĞÚ·Z+y—“`n1v!øf`t>4©‘¼hd²ÑÒ&saóhøô4yfgZp¾;7aG{7yšİš>@ñª1%¸¹iê$4mqÜÃrµrèçs/yè| œ}u%a|+)pÌ}³õ Æ%~aJd}Õe«(,}!k8qVĞnUuìg¨´ô{õy+ÖìDJ,eŠhËÕ/™"ß:RYqb¤š,s©œ‡k®xå9fZù
ÿi4ypšc– ìrFbJ"~[É~Òtò%cï$j™r?‡fl´Õ¹hø]D/Èo^e)Àõ2*’t`lá"®ca'X,Q%˜z4¨DVF0»"wùï¸­óÃ¾g©åa‘a—"yjîmB¼'rŞR)Pô˜a}P:lEW.Y<qDç/eş';x|oºp$ÁÓ-uåå+‡ºi.im.ÅÁà0B´”ilu’û-UA8”¢{Ä,,c@`…ä^"X<"q
%T3=îósoªÂÂiÎvåQMht&Ñyw5`[RxjÇpH}İ¥zİH|ºvêİô.®`”8ml	1³XjšçºD{¹}ª´A }fåYR{F±Mw ØiAÆC¨*;pfV_wLìqo™%ykÕi1`ÈLmzcÙ eâí6k×-è|¨›$7<MkTåu±‹tw)hjëM¹K‹Â¢/P+aéà?F,xŒßm/š~}0n²x8¼½(bÛîış¥í:R§›‘'=cq,é2Ôwy(»[Œu…€$ WzWÈ>Wi”$Æ÷Ñ<y(j&a¡¦hİnó;¿Oóˆ>l`ˆ'ØuÀ)‹dI8DG°6jîdeh=Ä¢}Sæœ$ñ°'m/KãÏ3‡N4^zÂÕpš&%¤9£:µI@xãL6´úiOà.md¨bo2<¸ >¯A¸^*ó*¯X4=s®enÃPµ:†ÁIü‰\lßO x`#zŒ¿<aäO ¡A‡mìnË%-i+tgÙ»6xÛÑ>tuö{4'÷v!,<®ff(qy}êu¼a…N&µÈ@ÇPç¼À·Npxt¹u2‚Aø¨j!eÇ1­ÔU_.¼:.Úè€—*jÖU.eI*ÊÒ)æ7Èp.E)H.µAéîVpdæ0¡Èi04yV3±í7C«m èi*YÓmOgPÿpuÔ+w&`¤1+k¸ŞJ¨lç¤ê.[@&ËRkİe‘0 §*qç@4ÕT{Ek„Ñjb9£9"84ñ¹<º¨ôgº÷çÅ–Ğ®›_s`Zœwr1V®‚E`jÒô>0÷§İnós^:ÏÀyºWK[Ç µWrfä2óEr¦o¹œb½&ù%rD70–iLË„Ä÷T}#nôŒd!F!@Æé®ºql`¹~ÔÄ!zµ\z^=m:-lø’‚û´ù}|^6lìr!q‚æp„Ikk9–Å²]©,dhÛÀ2 šú0£;€iÅ…w®@"¬·D¼ŸÂ`é¥<F3%€v*%I0£È%ú9»¼hø0qtàbæ­ Tb&/xqFr> QŸ…&N'd=úøS)#Øl¥ë$oíW.ä£=!÷¬AQ=ät%>†z*Mvšì‘áÍóÛ÷/©6¨e@á EíQª;:Pëç²>şa½`s,¶oŠn¼¯qmt_5B+A]yáog$v³t¦@áQRR`b;ƒq&{ğGrudïN;,.T¤b%uTxÜDhy%ïpn¨„P"¡dw£hMì+<«‚4•$h ±Z Hup™(j8»­cf¡Udvü1=I4-µ\)­7E1õÙÀx£W0vK»xhDI$úµi…è.¢YéïN ã¸(3±é³$Øw9	`{+ÚTLLTÆ¨T~Je& •2±@g7$ş5Œ>çe…BéKxñrttXd$i·8>m1ä|"Wdö$G #jê]	]ùqc:³}®ø &g´ùrE\$$fAå3Y"Íc¶œÆp&Ô9’N Mx‰ïE•m¾ZLaD^8#cïõJPF6%i¸à,­3ÂƒåIÔ2®Uz¦(SQiöa/,±IÇüğmeÇÄ.üv/m!H²ñµacW%ü»iŸËŠ´;'={?¯i8®/sı5ÄH$:{÷Âg µª(Û¤ix\m¬Yl'‡cœ¯<MŒ„”	--aî	m%O¥uo0í'¾^o]i¸ıMö²~Ë:6y%-ëq¶c[_dwZD4ÖE~ä_oD¿hã >ÛÛ®]—ş1´­{#úºl-~éT©^%¬-¸5û	¿§iíé.Ô' ‰*õ­íAõ(OL-Y)°9ÚIy=5§u@®,n¿'*=©{8“Nnp_{Ãvàq¼ĞíYNkñ\Tì›àfàtõàªOÚl[v7§âêgÁ²`n_e lâu¡_,p
H¡¹ÇcÃyÓFĞwRÉØ%©Úvï^İ:]öa’=3ök¿ÿX„n’å£U¼G†m,w’eç]7O¹34€b†n5$<¼£dıáab$BÅ¦Qlt]`ãx(ì_Æ{ıFz)•7¢)5)BgfA	Ó‹ïüKSç<ÄwBzAm½ #WQ2Rt'1[ï»€,`m‹¬LÇTGÀ‘O?–&ğ4&Èl	,Wq*ñ	ğ?uw[jî@d†ä=rz¾ Pi·©Göy/<;v— "puO—1J=´LÛá Y™xáÚ |H`P¤dñP//IoT7^·Wùõ3L72ëõ¹	ãÚ
<¼uzH­i(¿z&d}(Ä<˜,å0Uä1JõyuA%åñXBòH~Sdg¶Rå&pöRäHö(t~åëeÑ=%TÜôh#Ä.ªiŸfÿ
r7Æs:~$Lòaxáq'}{uNø¤ c™?å]pwäEKM¼#- ÆT`ÇN*êGÅuhº]·x”QšnI|µ/AcDWşou gB÷¯>J^~V¹¨êïÁRzw&¬–C °b=â¦è¥Âõ½?9Ê'òEè8ÊÆ8,baV¡%Òğ,î·dWra#w®¸á$Ã$UpR'ş$e»syv:b»8,E#»À£FI”``õïhöÛeHU£|ú=ï%¶_üÇu-Ê9]áqgæÆL/Q}QzO38Má,imĞpNì£ªÉs"`!@n2È@Ú÷$õ¤±é›RğÙã…áqSVıt¿SÑ7çtQK¤°jxCâ1+ò1õŞ 3!n! L56°Õ:&å#>Ú2HIı(~">ÛûenE`d “M|Y*z½êôSl»e¢"ûç)bkc×{£xBšd{9çVbüø§¶cqg.ntHı8¼Û*U•°|	2Ÿ7á®<lcade\Qñhu~{2¥àx.ŸT4>J yJ%°^T”="båÌQàˆ‘ø$h+Ê„sD€ÃÕ_Sk8(Ò‰v¼Vº "ŒÁym­8Äıoqøf%GBlBJ¬çT³zÑS`@K;go¡0pbp'Äd0…a	ì¹ xÖµVè H`~»¦ZviH[œ>É/İ!mB
jmÁ'ª{Wlı´­TõªÒ¼¤u˜Å<Tx47o±a XFu&ûek|ùHlbabl#²¡ íèjÌvÆ 0#öãdUS'P›j{=«r'z£'.	ªC«.<
g+P
pàfï:e{,³=ÿ¤ìúÄúuM&DPb!*¥yeøKâ™²ğj:£¿›¬y1_2ğxY5Dg Uúæ0µNÍA<G¤Ôñvaşå9rFŞ)• q~e ÷Ñ%‚§=×i1S9N…í¯Â;íy—9ÓA/hÆ¡#¤ôròAN›J· TiÏ6n]á6ğ#é|qvb°m!Å€|™h]tá4SÔñSÀFkÔ¨ín¿å¬	…p_dbà´t`qi53ÿC «'ĞÚ!_Å—J$'¶y›`¿6ğ‰° l §MºGbh.Y†uj¶oÁ&EFK—mé8¢w\h›8öeá6çGI°~QiR	ÌyŒYlº;R®cşg_b¡¹4sÀ`JS-&[ÈJ¤Ó=n²`8(H `±3q 7°‚ä$dŠ¯váâ	0Æ5GšõÚÃBXşnœˆh}y6Hr¢fyÈ1e&>ˆ>çörÈ;?(a*sdòğQs6ÀG2TPÁTÎŒã"&gh3n¥i°3®½OKŸ9ZoS;‹a4õ«(vğßfñlX¦+IC”|j!£gYbÛŠs^L²s¯z–UB]5í )%K¢Êeg`2mIiC4<=D»z*?M4jsb5Cæ ­r°iÂ×anc0M¢N	xş0_ºä>UõDÍ¥¢†ùmH‰!‰*•qµ#Ü C
­;v(Æ!ß!ÏÂÔ2rFv,S $`yTíÛànlıh8ÉPº!1kĞtÈ0ÿv¥qÙ—8.mÜôw’!†pùĞU`¥Ufû> ğj¿!a_=4Ho­ ôsÑü6Ew„J<l”ôbëB—f=²Õe)hxJ®E–.ÏR?uO=e-/($4äHı\úÈçRU	ªC*¨òNKßlşU`9\?Â0¬0}pÔtªCm@\°ü`	NÅ¿rM%a¢jí”iy¤=å\l¹}Zï„óuä}!?k'xx7›è2‘(›‰·9OkÓ¤¶(oCºç|û³|ºU?GÅ¤*Øb; €Ëm;İ@^%R"&U){Ep[(nNª…6sa`
iÉ[p©i)</(èíÈäP–b¡a¢G;\EPåÓ0y®f0ô…¥ngLBrj |*LÃ3økÁâ÷&gs®2óVş(>êêxq]£e>×=ğ¾©h6¿m(üfˆu7U?DÔª¤|5X— ±Bú·¤´eş.$ò`Nr[®VV"(t<tª%çQp	Aú.w=!WÕGO¢¦ö÷G»7*^;-Ø!U)y¢ô#f(5°¢kƒ%MÍsğfVÔr)G“ü‚9’V™éUñéá;F,;(Ş°£l§ntP7r
)-foGz„rMÓ<%hEò†bƒd3°&!y( {gTÒwÄêuÇNu-÷-kZ_M_u_ğg¦î!*õ\ûûL$]j:r( Gxx©ÏÄmj9)}%©>&6A›ª{‰'`ètdsöªşZxHVïôGS@@tR¯Ås)^:ñò3¤£làÙğÆât½Œnò ò!e
àEl´1*Lu}Eo/˜fyô"Øpg,¶XF´ŸcÒ‰yö\ÉØ˜+}g8TúD{´a°Äv0%‚H>µ‘tÄôö ;C&Bw?øyÔ½t5N 9ønî@L¥Ë*1®ÛtZL	eY<]Kbd[#:Q$ô¢„J,Ze0¼£ñ‚°Ù<xò0çx…Vmíle¸/¸ídºP]^rWÿì| &S@VAû²<uJ;¤-åÈ¾>~}91:,2E82})loiíe¢ğğ¤8À?ze`õ§îZ†inõÕ®Î&@cv¥zy_CCkKoRr1‘.¤`Ä f`%ã(lla=H,ÓÉoèãµ×T”£˜¿á}Şgs8t}!few`´x)gîÓS‡]˜¨k¢i+°o…ss‘=ûEØ½6méOÛÇ.F©`“Öt&›.³aÅ ˆm!zJpãÉKy6¬NŸ`gvyfEo1İ!ÍYt·V,BD5a$ÃÄ0(h^Q¦*<|WT!sÈ/{_pVôÓ¿P¾CğÅøÜù!pam1)6RÊ¶µáEûW©n	 .¾ª¤‘óÌDĞ¬µquDlb)èi¹cñ)t¡B
Sc£f³th¸O~0)tS¡@5vf9™Ïn7#³(=  µ°¦æ!åë+-Pa<wª&>VãÎ=zæWBQyuUŒèš.5G@É£;Cô8f¹aä¶¨Š±”~
eö%á¾\MKI9yfSöv@ÀejN06æ"{xıöLÜC_é +°ïKp»è$mT¶ ¡lš6¹ÇÜ~#Koa6 8gh,GŸî VLÆ/|u°ä´2$-:y\a7ÄYP_ItFşKVt&ÒÙeáuĞs?ÇËb9*fO¸cB›¶¡jßÜk'åàeÕÕVçÎ	~&í”úş2x0€<í¬6ô÷VTxæ;m)ê³_åF'§mQ¢˜s+>5;È+Š§4óM]Dó¨M ^+0îÍksƒ_6ıE7rOK=	z=`ºVİì`=µm£w}.2«0pc?/qãxü­ª¾9‘ë<Yxv-e¼•[e({
üx9ç{æa1E7aEU™ò³S€Ò- ,‰¾D¶yË­õLygWwWş]ğxĞ„EùIÊ&BtL0`„Ön0ş«~L/J:;‹ñqü%n5:q~!ê09…A”;ğ:œ!. t4xq@3v=âühâZõõ‡ouÈ` „V%]`êÂ+‚–v9©jt6Å6"¤35`KùWƒàòd'*™l2Xgkws¡ql9FwA*f+k>OÂºº~{Ev)íIh:mñšhQb)•±\pÁË«SeZãw1°0' šïgW¨“Cha~âZçÄÕ¤I9¢<¤eïn(c`€ŠÙ#h'ab->cbí9üİ"+¾Gõ0’O3!%,Ù,d +C|Üï>h/ O |)@zôo}øámsnRõC}+cÿÕû›D}J™öA o»d"nA!Áys9öt “)fò'ltbc£fÅ²òW@`oäwBlc_G!di¦ êQùÂBM ì4Íïc<v*³|imG~<ğ@!3´ê+¹1äñİirr?T@;ÌÚg2"àò¶)t1xn>ıTô§ü°¶C¢ĞB/gmg/ÔZÿğº^Vê¥»))şü´ó‡jÓ$æ³”úiJiäx‚ ÆO{ëT‚ãAØz;z¨ëŠ5›~'|X|<¥5-,Jïù°Ebiô½ÜÎ°I)ppä2Å„ku˜°üb>ûñË8UÀºözä¸êâø ¨°ºPÄ[B´ ªkI¥F]@¥T$%É(c#E,°7aÕ'ãi.Wû{q
V#h,dÑ¢®%³k-k§c”¯J1g M1U6º¡{;-¦L"ÿ¢w¤oËSÅ¾%|Rªh1,9ğ	 °gôÁ¸VrÜ9©£9v¬/—Q×Kq6ş¶.~K0rşt!4Ì¡ù*p`êä=.«9çd!;JÓÃœ9)¨Ê]óì¦8*f<
s1ØNòì6%Y·Êë&ğìaQ.(ñ7~xÌ>îfÑ¤²'¤AÇyî]éORJ±€»mú5ª*ZX1ä$Şß9Ôğ]¼4izØ‰—b½Æù€O$cU5³o>‡ºaóéFª=şça{µçë¬1º*R-%°+0 Wá/{?°pb–apmä$yĞ!íHß)?àh6¯5ÈR~Ïî
<³¸l*8™ìV?ù-!ÏA 7å*±vv?½&+¶@:FìúÕHn_cEe5å,®w¯^sp}O§ùA†©r~­p<°¿ã‚I8U,·MènLœ¤ìıC§()ht¹¤f-''tˆ4€†²ãX0Äkç"x„ÉrZGÈÆ$ì)]l¸dÑnuéø C hUB²vNƒ÷&æµìUVX&"o!Fcÿ(Ä5 ·-a³/J 0·µpa6ùõwZÆU}ùà<p^Uaà¡cüÚp8P±ôğü4<‚®>òÄàBÑ,ä"»Û0|>gät\ƒ0}8ÑG{à¯y©·Xoıxy+ö+?dq%*uNYÉ@÷ SÄ|‰ğppkm2Ûp6É2œ5ÏÄ÷}q½¾b­méh» d&şTwIã™T	¢©hùp6—yN3j’U=so›` Wb4Ãg€`ªuU`,"ÔU­Ê,Ìa<’x‰ñmêYâ¦!÷ŒÏádae/$vE,qHèuÚQp$¯Z"¡vàvÙ*­*XM*ãê•I?Ú"—¤‰„Õr#4?”­ö);ßTY7'hg s6Fl3Úurbµ#Ò=ït%6!AÚx$dFrºNy1'Ñ)cagÍøÁÎG?y-~qâ" oøô(":Úõ+ñ ;¤à$şTtœav’^ÁÏ-zX euüxcxgV!`Ë¬R ä\6soa²Œ h[åö[{ò€o0"äV@H"{D‡såöıˆôéÂmUíÉ5x†š„x?M`~Nr:iBn"*îmN§|<£\90¤<‡AOMĞ·õÒm‰aœeV» ù K1!o''`ë°4haWJhlf`ùXkrw1lÑ{Cn{S>+|â sw/7a’O\g¾bcÕUbÌ6irh9¾È`¯ƒ"QóHÌgìÇeD'Kx…Âsou9ißâu<Gj3×Ô½¢ıo½Úá}ùyòñB¥:µ—c²vj;^"nïÓ¾j-è¸Aü€‚Ç!¿2°ÔPuòa/*M}r=wÊqÉ«*aÓ=¡¶,lÎTñ^}~@+}æ7m=Ifr“á1&*Û:z¬ºgj,L–l¦2GE,Lwò/H=O$òÑ?¢A³Çá²ôqÅÚ }úK`S…mp¢3Akú!*
oMm¤"ı©1ƒ{¨÷+‹`êufñlv±=vşøMTà›³åíøq,‡w3fåÏ/©r0R,YùR]";¡ÂgÎeeên˜5áN¼í¯9b:óÄ‰sqI)Ÿg˜!({ªx#ç.y[9´j`K FaÍah?AÅû í-gSÇ<+6o 6¤ *BAg³Ùr&È7U`k¬:$î!ñ(.Je¹
…#¯…94z:"cTª8•7ÔAÓgV]mâA’ü¬÷a"•Y(m{ €a(á%ÂÔ<è<hMV}Ö¦jf\%6“ri·è°ôCÑú’L1{rá,=‡z}:/dC½i¸‘¨9")(H;y5e±bèwê,²5xöZ3(àisx,"R{ôNÏ+½#m$œb#u03aâ_qˆæ[©z”Dj{º¦"?õİò÷âx#7rFÇg*ÕéZj fT1‘ã$Ó#ı¸7 fâ`)lüzêê¥)Ñ
…ÆFew¾ğÿ!sisR,±r¡VÅ.Öó%A60:z2ùsLÁå`8m¤|õUuR§ğ1wtQ¯î"z]à=9¡L­-ğ=É^hØY@#u:wd`})ñˆÇR`dd‡ö'v!÷5F_ºtàİE22çò9
#%Ë·ª/¨­c1ß¿E)#\óÿ=´F$v%a#´t=yerÔçä	õK¸½Zpî5Ar?*udçzq²Oü¦+uÉ½(^>òu*xáÚß¢b-,áÆSşDÿQfe5UQ3X‘ôFzµàS`¨ˆÎ0y¥.°n'G·h	Ş"=Ü‡{ömZ=%@P6eyYÉàctİgÚ£-~$š¼Tr‹¡öâ{"²í£kî %j Zõ¦(5st¼Nh$!;NˆYR?d¸uàË^®"bDxy;¬ê_7Ü˜
3®3s!)ÄSlÿÙ#Maä«cÀT`1!3ÛÉO;gë!»;1(Ag.y'íUc?oŸÃ6¡¶¹ç‘…·áuE0<‡›¡ÁŒgx#e3„™=.Î#%7OÈô1Ö3sEc1qĞ9#›q /6s¨BEF54f[%yQÁç·(–T#¢+w!oø};x¯¡+gD“pH1 ı­{%h' eÆÆ=!ó2òŸ¥1²`cñ!òè)Ù&--h©/5`kæí?P7>l0oÓ¡c4µaY=Ó˜ïlPC":ú~a3õç.¬¿IanWÒÌ]u Ù·Å …4e7p§lƒ(oŒy'lÌ÷s}:b2g"pa×ğ¤rñ~"}-Ep{—©=Rt:J~!ør::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SubFOp definitions
//===----------------------------------------------------------------------===//

SubFOpAdaptor::SubFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SubFOpAdaptor::SubFOpAdaptor(SubFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SubFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SubFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SubFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubFOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubFOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SubFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SubFOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SubFOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SubFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubFOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubFOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SubFOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SubFOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SubFOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SubFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubFOp::result() {
  return *getODSResults(0).begin();
}

void SubFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void SubFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubFOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SubFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void SubFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult SubFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void SubFOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult SubFOp::verify() {
  if (failed(SubFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void SubFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SubIOp definitions
//===----------------------------------------------------------------------===//

SubIOpAdaptor::SubIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SubIOpAdaptor::SubIOpAdaptor(SubIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SubIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SubIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SubIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SubIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SubIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> SubIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SubIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value SubIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SubIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SubIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SubIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SubIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SubIOp::result() {
  return *getODSResults(0).begin();
}

void SubIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void SubIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SubIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void SubIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void SubIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult SubIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void SubIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult SubIOp::verify() {
  if (failed(SubIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}





void SubIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::SwitchOp definitions
//===----------------------------------------------------------------------===//

SwitchOpAdaptor::SwitchOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SwitchOpAdaptor::SwitchOpAdaptor(SwitchOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SwitchOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SwitchOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange SwitchOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchOpAdaptor::flag() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange SwitchOpAdaptor::defaultOperands() {
  return getODSOperands(1);
}

::mlir::ValueRange SwitchOpAdaptor::caseOperands() {
  return getODSOperands(2);
}

::mlir::DictionaryAttr SwitchOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr SwitchOpAdaptor::case_values() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("case_values").dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr SwitchOpAdaptor::case_operand_offsets() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("case_operand_offsets").dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult SwitchOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 3)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 3 elements, but got ") << numElements;
  }
    {
  auto tblgen_case_values = odsAttrs.get("case_values");
  if (tblgen_case_values) {
    if (!(((tblgen_case_values.isa<::mlir::DenseIntElementsAttr>())) && ((true)))) return emitError(loc, "'std.switch' op ""attribute 'case_values' failed to satisfy constraint: integer elements attribute");
  }
  }
  {
  auto tblgen_case_operand_offsets = odsAttrs.get("case_operand_offsets");
  if (tblgen_case_operand_offsets) {
    if (!(((tblgen_case_operand_offsets.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_case_operand_offsets.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(32))))) return emitError(loc, "'std.switch' op ""attribute 'case_operand_offsets' failed to satisfy constraint: 32-bit signless integer elements attribute");
  }
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> SwitchOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range SwitchOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SwitchOp::flag() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range SwitchOp::defaultOperands() {
  return getODSOperands(1);
}

::mlir::Operation::operand_range SwitchOp::caseOperands() {
  return getODSOperands(2);
}

::mlir::MutableOperandRange SwitchOp::flagMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange SwitchOp::defaultOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange SwitchOp::caseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> SwitchOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SwitchOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Block *SwitchOp::defaultDestination() {
  return (*this)->getSuccessor(0);
}

::mlir::SuccessorRange SwitchOp::caseDestinations() {
  return {std::next((*this)->successor_begin(), 1), (*this)->successor_end()};
}

::mlir::DenseIntElementsAttr SwitchOp::case_valuesAttr() {
  return (*this)->getAttr(case_valuesAttrName()).template dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
}

::llvm::Optional< ::mlir::DenseIntElementsAttr > SwitchOp::case_values() {
  auto attr = case_valuesAttr();
  return attr ? ::llvm::Optional< ::mlir::DenseIntElementsAttr >(attr) : (::llvm::None);
}

::mlir::DenseIntElementsAttr SwitchOp::case_operand_offsetsAttr() {
  return (*this)->getAttr(case_operand_offsetsAttrName()).template dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
}

::llvm::Optional< ::mlir::DenseIntElementsAttr > SwitchOp::case_operand_offsets() {
  auto attr = case_operand_offsetsAttr();
  return attr ? ::llvm::Optional< ::mlir::DenseIntElementsAttr >(attr) : (::llvm::None);
}

void SwitchOp::case_valuesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(case_valuesAttrName(), attr);
}

void SwitchOp::case_operand_offsetsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(case_operand_offsetsAttrName(), attr);
}

::mlir::Attribute SwitchOp::removeCase_valuesAttr() {
  return (*this)->removeAttr(case_valuesAttrName());
}

::mlir::Attribute SwitchOp::removeCase_operand_offsetsAttr() {
  return (*this)->removeAttr(case_operand_offsetsAttrName());
}







void SwitchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value flag, ::mlir::ValueRange defaultOperands, ::mlir::ValueRange caseOperands, /*optional*/::mlir::DenseIntElementsAttr case_values, /*optional*/::mlir::DenseIntElementsAttr case_operand_offsets, ::mlir::Block *defaultDestination, ::mlir::BlockRange caseDestinations) {
  odsState.addOperands(flag);
  odsState.addOperands(defaultOperands);
  odsState.addOperands(caseOperands);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, static_cast<int32_t>(defaultOperands.size()), static_cast<int32_t>(caseOperands.size())}));
  if (case_values) {
  odsState.addAttribute(case_valuesAttrName(odsState.name), case_values);
  }
  if (case_operand_offsets) {
  odsState.addAttribute(case_operand_offsetsAttrName(odsState.name), case_operand_offsets);
  }
  odsState.addSuccessors(defaultDestination);
  odsState.addSuccessors(caseDestinations);
}

void SwitchOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value flag, ::mlir::ValueRange defaultOperands, ::mlir::ValueRange caseOperands, /*optional*/::mlir::DenseIntElementsAttr case_values, /*optional*/::mlir::DenseIntElementsAttr case_operand_offsets, ::mlir::Block *defaultDestination, ::mlir::BlockRange caseDestinations) {
  odsState.addOperands(flag);
  odsState.addOperands(defaultOperands);
  odsState.addOperands(caseOperands);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({1, static_cast<int32_t>(defaultOperands.size()), static_cast<int32_t>(caseOperands.size())}));
  if (case_values) {
  odsState.addAttribute(case_valuesAttrName(odsState.name), case_values);
  }
  if (case_operand_offsets) {
  odsState.addAttribute(case_operand_offsetsAttrName(odsState.name), case_operand_offsets);
  }
  odsState.addSuccessors(defaultDestination);
  odsState.addSuccessors(caseDestinations);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SwitchOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SwitchOp::verify() {
  if (failed(SwitchOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops14(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}







::mlir::ParseResult SwitchOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType flagRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> flagOperands(flagRawOperands);  ::llvm::SMLoc flagOperandsLoc;
  (void)flagOperandsLoc;
  ::mlir::Type flagRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> flagTypes(flagRawTypes);
  ::mlir::Block *defaultDestinationSuccessor = nullptr;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> defaultOperandsOperands;
  ::llvm::SMLoc defaultOperandsOperandsLoc;
  (void)defaultOperandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> defaultOperandsTypes;
  ::mlir::DenseIntElementsAttr case_valuesAttr;
  ::llvm::SmallVector<::mlir::Block *, 2> caseDestinationsSuccessors;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> caseOperandsOperands;
  ::llvm::SMLoc caseOperandsOperandsLoc;
  (void)caseOperandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> caseOperandsTypes;
  ::mlir::DenseIntElementsAttr case_operand_offsetsAttr;

  flagOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(flagRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(flagRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();
  {
    defaultOperandsOperandsLoc = parser.getCurrentLocation();
    caseOperandsOperandsLoc = parser.getCurrentLocation();
    if (parseSwitchOpCases(parser, flagRawTypes[0], defaultDestinationSuccessor, defaultOperandsOperands, defaultOperandsTypes, case_valuesAttr, caseDestinationsSuccessors, caseOperandsOperands, caseOperandsTypes, case_operand_offsetsAttr))
      return ::mlir::failure();
    if (case_valuesAttr)
      result.addAttribute("case_values", case_valuesAttr);
    if (case_operand_offsetsAttr)
      result.addAttribute("case_operand_offsets", case_operand_offsetsAttr);
  }
  if (parser.parseRSquare())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.resolveOperands(flagOperands, flagTypes, flagOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(defaultOperandsOperands, defaultOperandsTypes, defaultOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(caseOperandsOperands, caseOperandsTypes, caseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  result.addSuccessors(defaultDestinationSuccessor);
  result.addSuccessors(caseDestinationsSuccessors);
  result.addAttribute("operand_segment_sizes", parser.getBuilder().getI32VectorAttr({1, static_cast<int32_t>(defaultOperandsOperands.size()), static_cast<int32_t>(caseOperandsOperands.size())}));
  return ::mlir::success();
}

void SwitchOp::print(::mlir::OpAsmPrinter &p) {
  p << "switch";
  p << ' ';
  p << flag();
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(flag().getType());
  p << ",";
  p << ' ' << "[";
  p.printNewline();
  printSwitchOpCases(p, *this, flag().getType(), defaultDestination(), defaultOperands(), defaultOperands().getTypes(), case_valuesAttr(), caseDestinations(), caseOperands(), caseOperands().getTypes(), case_operand_offsetsAttr());
  p << "]";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"operand_segment_sizes", "case_values", "case_operand_offsets"});
}

void SwitchOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::TruncateIOp definitions
//===----------------------------------------------------------------------===//

TruncateIOpAdaptor::TruncateIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TruncateIOpAdaptor::TruncateIOpAdaptor(TruncateIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TruncateIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TruncateIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TruncateIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncateIOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr TruncateIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult TruncateIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> TruncateIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TruncateIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TruncateIOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange TruncateIOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TruncateIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TruncateIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void TruncateIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value value, Type destType) {
      odsState.addOperands(value);
      odsState.addTypes(destType);
    
}

void TruncateIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value value) {
  odsState.addOperands(value);
  odsState.addTypes(resultType0);
}

void TruncateIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value) {
  odsState.addOperands(value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TruncateIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult TruncateIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseCastOp(parser, result);
}

void TruncateIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult TruncateIOp::verify() {
  if (failed(TruncateIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}



void TruncateIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::UIToFPOp definitions
//===----------------------------------------------------------------------===//

UIToFPOpAdaptor::UIToFPOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

UIToFPOpAdaptor::UIToFPOpAdaptor(UIToFPOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange UIToFPOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UIToFPOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UIToFPOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UIToFPOpAdaptor::in() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr UIToFPOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UIToFPOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> UIToFPOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UIToFPOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UIToFPOp::in() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange UIToFPOp::inMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UIToFPOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UIToFPOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void UIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value source, Type destType) {
       impl::buildCastOp(odsBuilder, odsState, source, destType);
    
}

void UIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value in) {
  odsState.addOperands(in);
  odsState.addTypes(resultType0);
}

void UIToFPOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value in) {
  odsState.addOperands(in);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UIToFPOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult UIToFPOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseCastOp(parser, result);
}

void UIToFPOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult UIToFPOp::verify() {
  if (failed(UIToFPOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void UIToFPOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::UnsignedDivIOp definitions
//===----------------------------------------------------------------------===//

UnsignedDivIOpAdaptor::UnsignedDivIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

UnsignedDivIOpAdaptor::UnsignedDivIOpAdaptor(UnsignedDivIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange UnsignedDivIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UnsignedDivIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnsignedDivIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedDivIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsignedDivIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr UnsignedDivIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UnsignedDivIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> UnsignedDivIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnsignedDivIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedDivIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsignedDivIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UnsignedDivIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsignedDivIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UnsignedDivIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnsignedDivIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedDivIOp::result() {
  return *getODSResults(0).begin();
}

void UnsignedDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void UnsignedDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnsignedDivIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void UnsignedDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void UnsignedDivIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult UnsignedDivIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void UnsignedDivIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult UnsignedDivIOp::verify() {
  if (failed(UnsignedDivIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void UnsignedDivIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::UnsignedRemIOp definitions
//===----------------------------------------------------------------------===//

UnsignedRemIOpAdaptor::UnsignedRemIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

UnsignedRemIOpAdaptor::UnsignedRemIOpAdaptor(UnsignedRemIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange UnsignedRemIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UnsignedRemIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnsignedRemIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedRemIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsignedRemIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr UnsignedRemIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UnsignedRemIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> UnsignedRemIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnsignedRemIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedRemIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsignedRemIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UnsignedRemIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsignedRemIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UnsignedRemIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnsignedRemIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedRemIOp::result() {
  return *getODSResults(0).begin();
}

void UnsignedRemIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void UnsignedRemIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnsignedRemIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void UnsignedRemIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void UnsignedRemIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult UnsignedRemIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void UnsignedRemIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult UnsignedRemIOp::verify() {
  if (failed(UnsignedRemIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void UnsignedRemIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::UnsignedShiftRightOp definitions
//===----------------------------------------------------------------------===//

UnsignedShiftRightOpAdaptor::UnsignedShiftRightOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

UnsignedShiftRightOpAdaptor::UnsignedShiftRightOpAdaptor(UnsignedShiftRightOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange UnsignedShiftRightOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> UnsignedShiftRightOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange UnsignedShiftRightOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedShiftRightOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsignedShiftRightOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr UnsignedShiftRightOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult UnsignedShiftRightOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> UnsignedShiftRightOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range UnsignedShiftRightOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedShiftRightOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value UnsignedShiftRightOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange UnsignedShiftRightOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange UnsignedShiftRightOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> UnsignedShiftRightOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range UnsignedShiftRightOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value UnsignedShiftRightOp::result() {
  return *getODSResults(0).begin();
}

void UnsignedShiftRightOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void UnsignedShiftRightOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UnsignedShiftRightOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void UnsignedShiftRightOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void UnsignedShiftRightOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult UnsignedShiftRightOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void UnsignedShiftRightOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult UnsignedShiftRightOp::verify() {
  if (failed(UnsignedShiftRightOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

void UnsignedShiftRightOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::XOrOp definitions
//===----------------------------------------------------------------------===//

XOrOpAdaptor::XOrOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

XOrOpAdaptor::XOrOpAdaptor(XOrOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange XOrOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> XOrOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange XOrOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XOrOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value XOrOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr XOrOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult XOrOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> XOrOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range XOrOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XOrOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value XOrOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange XOrOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange XOrOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> XOrOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range XOrOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value XOrOp::result() {
  return *getODSResults(0).begin();
}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void XOrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes({lhs.getType()});

}

void XOrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  odsState.addTypes({operands[0].getType()});

}

::mlir::ParseResult XOrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseOneResultSameOperandTypeOp(parser, result);
}

void XOrOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardBinaryOp(this->getOperation(), p);
}

::mlir::LogicalResult XOrOp::verify() {
  if (failed(XOrOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}





void XOrOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir
namespace mlir {

//===----------------------------------------------------------------------===//
// ::mlir::ZeroExtendIOp definitions
//===----------------------------------------------------------------------===//

ZeroExtendIOpAdaptor::ZeroExtendIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ZeroExtendIOpAdaptor::ZeroExtendIOpAdaptor(ZeroExtendIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ZeroExtendIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ZeroExtendIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ZeroExtendIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ZeroExtendIOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ZeroExtendIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ZeroExtendIOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ZeroExtendIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ZeroExtendIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ZeroExtendIOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ZeroExtendIOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ZeroExtendIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ZeroExtendIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void ZeroExtendIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, Value value, Type destType) {
      odsState.addOperands(value);
      odsState.addTypes(destType);
    
}

void ZeroExtendIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value value) {
  odsState.addOperands(value);
  odsState.addTypes(resultType0);
}

void ZeroExtendIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value) {
  odsState.addOperands(value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ZeroExtendIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult ZeroExtendIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return impl::parseCastOp(parser, result);
}

void ZeroExtendIOp::print(::mlir::OpAsmPrinter &p) {
  return printStandardCastOp(this->getOperation(), p);
}

::mlir::LogicalResult ZeroExtendIOp::verify() {
  if (failed(ZeroExtendIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_Ops2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}

void ZeroExtendIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace mlir

#endif  // GET_OP_CLASSES

