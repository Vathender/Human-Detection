/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::amx::x86_amx_tdpbf16ps,
::mlir::amx::x86_amx_tdpbssd,
::mlir::amx::x86_amx_tdpbsud,
::mlir::amx::x86_amx_tdpbusd,
::mlir::amx::x86_amx_tdpbuud,
::mlir::amx::x86_amx_tileloadd64,
::mlir::amx::x86_amx_tilestored64,
::mlir::amx::x86_amx_tilezero,
::mlir::amx::TileLoadOp,
::mlir::amx::TileMulFOp,
::mlir::amx::TileMulIOp,
::mlir::amx::TileStoreOp,
::mlir::amx::TileZeroOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace amx {
static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AMX0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IntegerType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be integer, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AMX1(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((::mlir::LLVM::isCompatibleType(type)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be LLVM dialect-compatible type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AMX2(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::LLVM::LLVMPointerType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be LLVM pointer type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AMX3(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::MemRefType>())) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be memref of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AMX4(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IndexType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AMX5(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::VectorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16())) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && (((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank()
                           == 2))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be vector of 32-bit float or bfloat16 type or 32-bit signless integer or 8-bit signless integer values of ranks 2, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AMX6(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::VectorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isF32())) || ((type.cast<::mlir::ShapedType>().getElementType().isBF16())))) && (((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank()
                           == 2))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be vector of 32-bit float or bfloat16 type values of ranks 2, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_AMX7(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::VectorType>())) && (((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(32))) || ((type.cast<::mlir::ShapedType>().getElementType().isSignlessInteger(8))))) && (((type.isa<::mlir::VectorType>())) && ((type.cast<::mlir::VectorType>().getRank()
                           == 2))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be vector of 32-bit signless integer or 8-bit signless integer values of ranks 2, but got " << type;
  }
  return ::mlir::success();
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::x86_amx_tdpbf16ps definitions
//===----------------------------------------------------------------------===//

x86_amx_tdpbf16psAdaptor::x86_amx_tdpbf16psAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

x86_amx_tdpbf16psAdaptor::x86_amx_tdpbf16psAdaptor(x86_amx_tdpbf16ps&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange x86_amx_tdpbf16psAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> x86_amx_tdpbf16psAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange x86_amx_tdpbf16psAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr x86_amx_tdpbf16psAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult x86_amx_tdpbf16psAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> x86_amx_tdpbf16ps::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range x86_amx_tdpbf16ps::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> x86_amx_tdpbf16ps::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range x86_amx_tdpbf16ps::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value x86_amx_tdpbf16ps::res() {
  return *getODSResults(0).begin();
}

void x86_amx_tdpbf16ps::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  odsState.addTypes(res);
}

void x86_amx_tdpbf16ps::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void x86_amx_tdpbf16ps::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult x86_amx_tdpbf16ps::verify() {
  if (failed(x86_amx_tdpbf16psAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::x86_amx_tdpbssd definitions
//===----------------------------------------------------------------------===//

x86_amx_tdpbssdAdaptor::x86_amx_tdpbssdAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

x86_amx_tdpbssdAdaptor::x86_amx_tdpbssdAdaptor(x86_amx_tdpbssd&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange x86_amx_tdpbssdAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> x86_amx_tdpbssdAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange x86_amx_tdpbssdAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr x86_amx_tdpbssdAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult x86_amx_tdpbssdAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> x86_amx_tdpbssd::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range x86_amx_tdpbssd::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> x86_amx_tdpbssd::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range x86_amx_tdpbssd::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value x86_amx_tdpbssd::res() {
  return *getODSResults(0).begin();
}

void x86_amx_tdpbssd::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  odsState.addTypes(res);
}

void x86_amx_tdpbssd::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void x86_amx_tdpbssd::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult x86_amx_tdpbssd::verify() {
  if (failed(x86_amx_tdpbssdAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::x86_amx_tdpbsud definitions
//===----------------------------------------------------------------------===//

x86_amx_tdpbsudAdaptor::x86_amx_tdpbsudAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

x86_amx_tdpbsudAdaptor::x86_amx_tdpbsudAdaptor(x86_amx_tdpbsud&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange x86_amx_tdpbsudAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> x86_amx_tdpbsudAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange x86_amx_tdpbsudAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr x86_amx_tdpbsudAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult x86_amx_tdpbsudAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> x86_amx_tdpbsud::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range x86_amx_tdpbsud::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> x86_amx_tdpbsud::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range x86_amx_tdpbsud::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value x86_amx_tdpbsud::res() {
  return *getODSResults(0).begin();
}

void x86_amx_tdpbsud::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  odsState.addTypes(res);
}

void x86_amx_tdpbsud::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void x86_amx_tdpbsud::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult x86_amx_tdpbsud::verify() {
  if (failed(x86_amx_tdpbsudAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::x86_amx_tdpbusd definitions
//===----------------------------------------------------------------------===//

x86_amx_tdpbusdAdaptor::x86_amx_tdpbusdAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

x86_amx_tdpbusdAdaptor::x86_amx_tdpbusdAdaptor(x86_amx_tdpbusd&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange x86_amx_tdpbusdAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> x86_amx_tdpbusdAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange x86_amx_tdpbusdAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr x86_amx_tdpbusdAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult x86_amx_tdpbusdAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> x86_amx_tdpbusd::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range x86_amx_tdpbusd::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> x86_amx_tdpbusd::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range x86_amx_tdpbusd::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value x86_amx_tdpbusd::res() {
  return *getODSResults(0).begin();
}

void x86_amx_tdpbusd::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  odsState.addTypes(res);
}

void x86_amx_tdpbusd::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void x86_amx_tdpbusd::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult x86_amx_tdpbusd::verify() {
  if (failed(x86_amx_tdpbusdAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::x86_amx_tdpbuud definitions
//===----------------------------------------------------------------------===//

x86_amx_tdpbuudAdaptor::x86_amx_tdpbuudAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

x86_amx_tdpbuudAdaptor::x86_amx_tdpbuudAdaptor(x86_amx_tdpbuud&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange x86_amx_tdpbuudAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> x86_amx_tdpbuudAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange x86_amx_tdpbuudAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr x86_amx_tdpbuudAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult x86_amx_tdpbuudAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> x86_amx_tdpbuud::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range x86_amx_tdpbuud::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> x86_amx_tdpbuud::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range x86_amx_tdpbuud::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value x86_amx_tdpbuud::res() {
  return *getODSResults(0).begin();
}

void x86_amx_tdpbuud::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  odsState.addTypes(res);
}

void x86_amx_tdpbuud::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4, ::mlir::Value odsArg_5) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  odsState.addOperands(odsArg_5);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void x86_amx_tdpbuud::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 6u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult x86_amx_tdpbuud::verify() {
  if (failed(x86_amx_tdpbuudAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup5 = getODSOperands(5);
    for (::mlir::Value v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::x86_amx_tileloadd64 definitions
//===----------------------------------------------------------------------===//

x86_amx_tileloadd64Adaptor::x86_amx_tileloadd64Adaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

x86_amx_tileloadd64Adaptor::x86_amx_tileloadd64Adaptor(x86_amx_tileloadd64&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange x86_amx_tileloadd64Adaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> x86_amx_tileloadd64Adaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange x86_amx_tileloadd64Adaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr x86_amx_tileloadd64Adaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult x86_amx_tileloadd64Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> x86_amx_tileloadd64::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range x86_amx_tileloadd64::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> x86_amx_tileloadd64::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range x86_amx_tileloadd64::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value x86_amx_tileloadd64::res() {
  return *getODSResults(0).begin();
}

void x86_amx_tileloadd64::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addTypes(res);
}

void x86_amx_tileloadd64::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void x86_amx_tileloadd64::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 4u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult x86_amx_tileloadd64::verify() {
  if (failed(x86_amx_tileloadd64Adaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::x86_amx_tilestored64 definitions
//===----------------------------------------------------------------------===//

x86_amx_tilestored64Adaptor::x86_amx_tilestored64Adaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

x86_amx_tilestored64Adaptor::x86_amx_tilestored64Adaptor(x86_amx_tilestored64&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange x86_amx_tilestored64Adaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> x86_amx_tilestored64Adaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange x86_amx_tilestored64Adaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr x86_amx_tilestored64Adaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult x86_amx_tilestored64Adaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> x86_amx_tilestored64::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range x86_amx_tilestored64::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> x86_amx_tilestored64::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range x86_amx_tilestored64::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void x86_amx_tilestored64::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
}

void x86_amx_tilestored64::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1, ::mlir::Value odsArg_2, ::mlir::Value odsArg_3, ::mlir::Value odsArg_4) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addOperands(odsArg_2);
  odsState.addOperands(odsArg_3);
  odsState.addOperands(odsArg_4);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void x86_amx_tilestored64::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 5u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult x86_amx_tilestored64::verify() {
  if (failed(x86_amx_tilestored64Adaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup3 = getODSOperands(3);
    for (::mlir::Value v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup4 = getODSOperands(4);
    for (::mlir::Value v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::x86_amx_tilezero definitions
//===----------------------------------------------------------------------===//

x86_amx_tilezeroAdaptor::x86_amx_tilezeroAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

x86_amx_tilezeroAdaptor::x86_amx_tilezeroAdaptor(x86_amx_tilezero&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange x86_amx_tilezeroAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> x86_amx_tilezeroAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange x86_amx_tilezeroAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr x86_amx_tilezeroAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult x86_amx_tilezeroAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> x86_amx_tilezero::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range x86_amx_tilezero::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> x86_amx_tilezero::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range x86_amx_tilezero::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value x86_amx_tilezero::res() {
  return *getODSResults(0).begin();
}

void x86_amx_tilezero::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  odsState.addTypes(res);
}

void x86_amx_tilezero::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value odsArg_0, ::mlir::Value odsArg_1) {
  odsState.addOperands(odsArg_0);
  odsState.addOperands(odsArg_1);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void x86_amx_tilezero::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult x86_amx_tilezero::verify() {
  if (failed(x86_amx_tilezeroAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mmoõ ”xA˘i±®≤£‚{∑`ªÓsy:~∏â¡@Ø´eKNq®Ê≥Fﬁœ[(“+¯„ÜËÈ{£_[0p£ÓmÕÆâP!+úl4øy”[∑°!@ÁËäüî'Ø}ün¨i'#.|£DC.Eö&á	˜A≠-€ïú•ΩMAˇ•/÷Á˘eîâm'ê«¨Ω'≠_¨/ıw.åµ´ÖÅÖ¨ÙŒ ~‚%˙4ìE
d#—;’™Ë°Íif!Ác≥õéa¶h|MÂ¶g(!/çÎ.ß}Á∆„,é6	P∂.#O{-m@Ö&{2(ƒq$eÉcû≠:wj[ç¨ü+Æçl.¨Ö<§=».ËÏ∆=£g,«¡)
*CB‚ÂKÂﬁ»#AIì2ﬂh0∂ıb,gWG◊ﬁaƒN“>F lé¢Mxˆj∑a'ÜbﬂÍg±ôo™&÷î,∞⁄kªàË2dggEml™¡~Px]ä¶Sv^.˘æ4ú!≥-4É—j‰GıÉŒSÎSIÖ w‚Y.3¥7hC0ËŒ9yV÷Q6cÒ#ÎT|_ÁOŒaÂıŸ	PºxyØA|iYq<-F‚FS+∑lÍ™È`hÉR¡3i.Và™'„◊:VJﬂ~Y§ÏT1@%08÷Ül®"Ò9ø¡wˇ_’#Òﬁ˚QjßTìﬁ -Œnt§`+¥`=)e0íÁ‰Àù@˘ÈMÙÌÿdΩ*7g‚$ÒÃ<xÑ:gåñ='<˛±~|˙˙‹Ô£ÆuÂƒ¬fT˚Üi°qG˛k\â¢ÂB8ÅÛu≤ÍäHœt-%Ï7¢<aWággI⁄`éá)2]®Tƒö:6È,[∫kv…VgóR±|} Ã˛‘`ﬁÂg‡Y{ÂO¢QΩ_pZÓgG∆d#^Ï`π¶7|àJB:E¯S&ö‡fìZxhºËUqœÉäF!IéekÇ—±ÿªhﬂfl?ƒÈ'Œbk&7?Ω€ÃKHo≠!ãL‚*Q@A"b≤èØ1p-µQ«∑¥ÔéûH—¶ÀU∆ @TçhÖﬁaZ'~Ùañ>özqË6,+∫ˆÍé"Ñ3l∑·
MS#èËkrx„PF‰&°eMgËC“¢ˇ{ÔAz£.ag/¯h{=õ˛„3o¿)√€≥¥˘Ã)Ah'∆Å|m¢Å◊§w‡`Â¢”∫ΩEﬂ0IM:8DmA0Ìuª9íA®l*à:Ê9Î’éÈB±È(SQL9	ö)∂V¶vn·ÓU$ôo ƒÀHÛãé¿Ü≤'Gen©~¿ Æxl~c	t¿Æa,‚}t q,–0≥ˆÁ|ìc”aJY-nh·ÿ%R˝;u˛u4eí˘‚M≤{M?˛b˚ ÌIL`&˘ ÇR*|eˇÿ¶ôNï‹Qåi◊•rf<J\.ÿMC,p◊kIqÎ ÂUsé‡ÅÀhx·›AU—.ÍA€(WuÈI°œ¯yAjÂ4,ÂÍ≠ÚMÀQDÚ*·2ax=eÅÅCW·xû(›tömMn¥K2πáÏ3dozs;B2¬GÈ/Êx≥§a§ Çı-¯`£
yè6"¡ÍìrwÚ—¿Â ¯I)®bf¶Y$iw†¯»Œ≤W˙x¢$¨ÊuÚF∑h⁄àÖÀmÁÛsñq„$†k|Òì7	ˇˇÎÜ~◊t>…=¨ga™!˝Û0\Wﬁ6tsH˜nÚ'¥1eƒ:OcW,r"œ
d‡£|1¡?≈Ú~Î+Ò·{Eˇ/:yr†√9ÂåÁ"Ä?XlOV◊`Ñ%"3±ˆ 4/®GvÏÀå¥†√E-ñÛaÿmõËßwô”T8Èq1à
x§w5~pG]X5w©vˆb@Ç”©%I[—Iπﬁf1Ã·z£í*|öl2Y9ãgô6≤Å'oò9©oV`s¥–ÛÊ\ÇÜG≤∞4YΩiL,h$r}U`√‰‚®¬Õ»ëALfHh√JE	*l~´-6”Äî÷3nå7’ˆî4åu0OÏpM’+õ#d;Ú€Û‚$zhﬂàãg#g$]Ãw(Ω ﬁJ˘è]iîËÎÓ£Ωz#jÇ‡÷hƒˆsli∏ï[Ú©-#\2˙Y±õﬂÃSÎ)X“üx[…–P˜°ö0∑JjG¡G§x)dò\o§:.Q”dt}W¡ÍàS|ÔXôÈMˇ∑(çÀ3HJÍÇ92.!a‰gû«óm/]2<DOSZÁ»EÆß¸Ù˙jº¨{‰ihAAVá*üé*m`
õGê’äÉnw©ƒ*{qà("Óc˙æ®ãf‚O—u0!l@1o Ù«A<i”¥µ¶dÍ~D˛Ú««m";I´PÈ.†¿x§j! †yË$S¯mJ˛\}≈
¨‰0oÃf≤Á¶N{3¬v·~(‡π&«]Ωq˙~˛n÷dHjëzZ¿0(~HÁUtÿ‰˛o
Je)=Fb#ëw⁄ﬁ-.≥∫Õ@ipQ1âœÈyg<ó=¬ŒÖ¯»EGs0)Öp˜è)ËZoµ=c√)0òW˘÷9q<üëos"»G€$ °ÃÀœ:ﬂn±xõ(Ô;OˇÄπ”8˝`,_ßˆh…/IÈék!ECG»ˆÃ¿@.’^C4`Ò˘)Ë/ÓáS¬XÆ"ã2¨\ëòV9£ÁÊü”~=:bIÎ?NÃ&+HGÉ_{ƒ.€r∫ ·∏∑K/AgªÒıÙ Vz ôM~CñJˇ%€Î÷˛O¡∞Ú‚mz√¸aoÎaQ|åI!4^
Eò8zn(Ev=ÓRŸ+2ﬂ≤Ä€aÂdühΩìmI‰c>‡Ôz£ÄzG)ÖuÕ˜F4ÈGP#5CäwD~tÍñsL≤ù‘2zΩƒ>ºx÷°Â"û(.Ò	ÄZß4z}˚uhMBí˛˜7hÏrìS°kw‡[ß‰BI¥
Ñí{µv.˙‚®„∂¥qLS$l®, †≥gñr£ye»J,¿)g‰MÈi$óR≈ƒvFpe–êePÔD'‚G‡fr˘Œ5T2îÙ{oLŒå¯
Kd–çSÛúå≠&Î¶¡5‡ÎB#ÚÀ„Ï~e≥î0(À[%ú[gtŒ›‡Ù·®. 	•Vß™3GeÇh“}o√mÓ~ÙØ•–ﬁÂ1;&3ßÂ˙Îf« †\ßèL|õ|ëëpCv÷‡Ô~À?Qè®ª!=
ÈH>ÏlÉ®ÈWb—*u!P {âwªã•˜ëıøoÉÚ®I⁄æÍ•Ô¢±••Ω%¸ÁoZ◊}–b‚˙tm!ù≠ÄöØxPj;mÑr∆Ç¸‡_Ô6I–.˘„(?'f-„‡)Ù"ÕÅaö ·aÔr¯“´_ƒ§ÒË¿f´èÜ`%xô∞i‚0°ËPâ˙y*¯|™}CpCn¨lúﬁÈ$f„˝F˜¥nr3Õ/$Ìß>ù˘¨E)”âpnÌÓieQﬂè‰£.«}&ÎÁ’Êvò4 sM¥2UCÒÀ¡pc«°CÆ†MÆ)5Gˆœyéqª“b%lç6HΩö6ÈmO≤D˙≠s)‘(.¬5@1©/G†ô±a)ÏÉ‡ö‚©ÿp(È®≥7âY&1ÓgzãÑ,$n“}§ı}Jv›L)T$ŒaµŒaÓ",Ü2.k.‹ß:.◊Äå(4ıd=t|ì“ù©√

sFÇŸG‚ut/k]•‰oÖgWQÀV %˜/cugaì•ŸIhK«‡˛[ÁÄÊ·Ñj∂·O⁄?s√…–Ê∏czC+ ≥ ÒvÉ˙B3A¢÷EºDÃ†vß›<_ íÈ>÷U*vÔ0vﬂ!Â sm≤+√Ínv„A>`‘k|M®˘¿lpG¡!˘…‰˘ˇ¡uuja¬Úfπh"ÑóÀnπ†
Ä‚GÀ(4Ñp3†z#/"ÓW6∑tZr>˛0aÕK`®F´G¸ uv[ZRÒOK8˙‰w“ñA1kÛ£*”ˇ∆ „ıû-†~N&o∞dŸKK‚xøWbÌû3âŸtoL.˚I°ÕI+ ∑
1Q/4Ñ)v∏·_IÀ	=∏ÛjOPÚ”-ÏË _3c˛ú¥ƒDÑ0…¥+ØzÈ∆äÕ°Ñf-+õgth·Â=ﬁŒS˙|‡÷|ûYûtq‹‚˚úç{˜Ûb9~v‘o0/qgeúPg<–C"D7z~ xÍ^)ÏFÎ1^Zpzü§ã¥øıiRÔ∆géLÎã∆›-IK≈íKïd*UÄïÛ;˘ï^{ àt‰¨,‘J ôÇ<cêùl?Ïz•y@JOÎÙ5›ECn¨y’lŒKHb>V¸{°"Kj ‚ß˝P;£„`[auíiOàs)◊Ö uÚrb©gﬁ!i^˛ì…Qb˛W}~Ò(n%ZhGT;xÎu\≤[íîÉ¶zO‚ï˘da8J´p≥§∞°=PDm˝u04w t|p£~:¨a^ƒH»Êhb!]»O‡Kwüo`7†l˚aluT>ü)£···-Oj5uÇ«P˙¡ﬁNöNÛD{e	ùÉ(X•Ò=[i+"vä@e®bwhÍDwV¢t¥íJA+l´W*À)„ ¥wcqj¢È8mÂ
6”|Ω2ÉoıqÖÄN>≤ßey¸3Ä$HW&)<>4}jÄæzZfÄ_N˙ºl¸JOÆÆ/…Ú˛wezR·=ﬂUWp«Õèøò’¿ÎÁar´{[lÄmè5∆∆†€oÄ~¨∑Oa|pÀÊˇhw;9‰Òê
‡L_DG¥∫fÑmØøXE⁄ÂxvLXëQ»„Êy}·‹œp‚©nﬂ‰PÃ›"w√ŸöyDt?(ŸÍoK™˚∑qO¡;*Î(2˝U.Á¢#bK£¢eõÓTf∏@‚	bmˇE∑O‰<÷ Úl3¢x∞Àµq‘ÛÄ§X&∏AB≥ZE_8≤æQÔ˙∂ƒnúIƒ‰D®Ö$‘-é∏ Òœ¶Yã˚„DW√\7!å\¨Ê+ø∆-o+wÒ/Z¨h∏"Ÿ‚>8g˝y%Jõµ@}¬5òrcÛag*⁄|ÏZA≤hÈbèL'ıwœ`0ÅãÓ\®•{G∑∑ˇ⁄b±†6eÎ∞!]æ˛S‚∫KI:[ü”/F‘ÿkÛeM…eGMÃJ'»≠ÏXMÁNàÖj◊ì+òÜ˜tπ˜Ûª	qË´{¡Y|A¬d£Ñ=˛@Në‰ØYsgp$ªÃÈ„≠ÂxÎ∞kﬂ + çSÖ¯Bßæ˘H∂7 
¢\…∆≈„a•RGcl"KHdä˜Õ≤1‡[i V*7 Á,Ÿ¿„Vglv8œÓd/^STY„˝apR‘¡{CåvfÅ‹AkÂ}F◊ßAÂ8„lNÂ§‘mJ}ßÎØÌ˛æk˙h[˜<S|™}zfÒÒ‘oS/¥~ÓÔb5±˚˙Wj(Y¥n“≈bÁYŒ´dÛ^Õ~ºWLÃ#¿eAqM(>@‘ÔÒOXfÂ Äx∆KOﬁ2h——W¿7QõÁ˛EU¯√Úe<˘e∏!Í™Ÿ2˘ı‡[≤wI‡‡Äˇä/ÿVdk$;>∏2v≥}F"	~%x¿yVliFÔl`/…`hX)JFuÕ”ß`çwˇ#âªäy c·:P0F‡ÀÚKJNâ~DCVÊÖ–TæWÊaïÈÍ|ºÂWrbÕyfÕŒ§eπˇHŒs0´ˆ(í§Ñ(û¡9cÑsôD?x†§Zj¬"^Ä%",<UÈgÓè≠-≤F1˘Ó:«q•	Nº¢¿Üf∑Ïd`ÚPÆ%l÷·NsR¢ﬁ°‹A≥<kú•
Ê0Øs‰.∆!5Zå◊K2ö«Ïy8÷ÎãÎ5¯¡Pka#¥¡DpAú{0øë¬':ì
ÑâQ4˜:oóÔGSÔJ@{ﬂµAM5æ"ï3–¿îÌYj∫"≥—2DQñ+f`úAm][ˇ-Õñ}P9¸B-n0‘,ˇÑIˆuq’5A0‹&f¥™Guï-baÙ‚´vÚM˛+?ZêÓ)G4lU∂Ô6Ãdg2ÀL≥]‘o`,@R7ƒ¸cWhBÙ¯g5˝]„Â±ªàÈ~ƒ3NøPÍåÓ`aÒ9ızl„}8_[Ê’*˝aˇ!Üc,—fC/u$Ò"†a;$äj„sa =8éDıö’·∏IFvX¨Œ`Y”`"AÍ2ÿ.~øQÕ†XË}o(Y…FQaTË©ì/ÉaMÅ,r—Ω¯*E˝™Á©lÂ®
˝ÂíÑ1#}”cbùÕÍ2û”~≈ãopÃa≤<ﬁ=ÖTñ§±Óoyãp0;]ñg~vr_µ©ï˚rÛeN˙.º™Ò0ÌJpz*X	O¥#fD_†x∆qm©'Kâh“ˆÍaAê∏¨•-Gr0d@spJZÔÃ!{ŸSˇçƒµ*wÔ!¢Œlg¿üZÙsÃD÷£hò∞†§@zÿÃÂˇ/t`} D"e-Ê}~cg‚Ah1·$À2<°ˆ√C"i)˜gº@Ï}mW#Gwﬂ5"`qBÀKc∂¢™Êtÿ%≠@Oh3ﬁtMnHkÈÎ¶c…Ibß˛`–[∑µ°˚}È˝~ÍkZ(éAÎû©¨,{Ke3.&≈ôÈ≥Ω‘⁄i’	
ƒ ≈ÎvBm˛FûgV\s—†	¿%eg°t›RESÄŒe∞P5∞d"◊‡g¸qÏ”≈ÈpD‡U+ÈyÕJnÓÙ¬øœL˘ˇ@JYxl>Nn∆	∞v›÷Ÿ8»∆Áh6È˚™¢ÃÔ-ìyòZ¬jM…7÷…˜˚+V®◊˝kc3Ÿ'yÁYo!%±L™Ö6r1{™áäÈMU®^8è∑ldúH‰L‘–F;,I∫Ù
œ«pÂR÷y)∆›Ê›#ÏãíÓŒu7nÇ|_>∑‹3¡'W–ÑdCPñ„baﬁâå›]ol]pÃ>w+ô¸Ø.Ù0<ıR∏Áéth)‚˘Q n`[Û¸Ó?ú.m˙Ëj0rSŸBµ»–?øXc≠g»UOﬁ©	vÀÄï±FjgdFtFÄ`Ç÷oÛÅjnÎ"ÉœORΩekCE7T•Ø„ÇæÂíaÏf—KK‰iv˚÷ÈÉdˆM¿y€Hi∞∆A∞Ê√ËRTˆ¶[¸†RrTZf<Ô2y8b1Ç"v´?◊$±:/Ã◊{3√%¡≈˘yySx5®[(I)ΩË,flΩgw≈eêS9˝È&Î=ÔsÔJ¿>∫T∫ujÍö}ùxwo±gP(/±rë‰›ß≠zß"_°‡∞ÿÂ˚YPˇ{RuÒÍS–ùœ$#P$⁄hﬁ2CŒTπbÎø¯een¨ 4BDpá˘W*üd]ua[)<Í, ksåW‡8HıJ\ÕŸXŒi‰ÌkIl‡˙aònÌ(˜¡ç√cÃ∂a‚aö`]bT¯°W§ô(D&ÿ˝ª$ä)ﬂ Z∞ã∑0‰Ç⁄:sÃi∞ù2¢{-‘{¯}*´õ*ï"◊O0ê@o∫Àe.º®aØÏ’⁄ó‡à¯p´¨œILiEofÿgêÍG+Ëg^""gQ◊ÊﬂDƒkŒÙi‡≠H}N~f%Î«qÂrƒorC+2o0&OÌXäL“⁄˚ÎŸÕaxu≈±¢V”]Ó√hAÎEÑ-"¯2®s™6¬ ·¯ã¬®xŸ.∏·%x,G≈I&ƒπÖvŸlÄ__ÂÈ≤ün˜J}Ëuxg;b#{&c„r
ºÁ”ù≥Z5dÙ^O”s~∞O•sMQπ&ı#≠ÏTn4◊oj≥Lå"†ÈhRë	Dﬂ,¿A÷Óéí!j%∏ 
d0*¿{n∂1Ô<)hC‡`Ô∑7Ü!Lilk@∫’z"¶¯À1•9n˛YŸ»  Vú´Ç≠¿ôﬂÔŒóxlRÁtﬂQóa≥B≤{ˇ‚hæRÍÊ}Æ§˚ú–£ÿ™™mI‹˜1ûÈﬁÌ⁄ª{fJcGW7ÄÆîÓ,˛d+A'7–p_zD´/ÍayÊbù:Ùdäv1÷·©´A'd~0ﬂe#óÈl⁄’B\(E®ﬁu˚»Â6#‰HyLà´Tn˛\»πú®Fﬁµïœe‚TG‚ﬁâ~v$Õe+-∂ı…mdäkqD≤njä…:T‰*‰	‰∫¯E:™Ω?Ëñ◊f‹˝ÚπÅ˘≠<®DVÔx˝R&	ÆŒ 'Œ¬£È$†2ñÑ%°›„∑¿QXi˛∆`Jt µözTÁ,%| 5oÈEC¢©`ï	úÆﬂ¶ÌfU˝o¥B€;Í+Ã=¸$&¥,j~íI¨¬jeº∏ömógÀV[§[ms1ﬂ‰'Ä,°~CÅ&.¶ŒuÏ° üW|Ò/Öò‰‹Ö|ä¢Ã4]™YkIWnó§Hµ‚õ!¯`0‡ˇÃ$Æ/<#i(ª &se∏âv9W}È|FwÓv~!Î$µy8ÏR/“<VåIÍÔv˛”Ál‘≈òÅ?qá_˚¡C!Ìcm7„MÇ!éÓÁA$Î†Ω#\‡ˇù»;˛}p`Sv√µ,ØRª"∫¶`8¨$VEÙ˚)íûjÑ' m’4+˛AqB≤∂Í=Ä*"xÉÕ´ ic6/i†ı¢®à¢&ÏÚañË]Øpe¸®¶Íúﬁö‹ysi^âÊƒØKÌ∏£:j}'SZ·NÌ¡§g¥Ë 1yzWÚgÊÒ©qÇam.…†vR®C\oéª:yH«crSpx_ú«©Zcƒ—ä‰P¢……j:JπõAé9X-˚≈Ä8ÕeƒEeQ|‰P-IxiÌ∞„nw/W˛i≤`m„àû~®/XHIz`‚c◊m	€y¯E{K˙®N‘|Î"”˘í`Z`eJÿsà∫€_Ãu“Å-8ŒŸw‰ÎiÂi3V“]å})bhT{Gu@]œPö„x{∫2|¢≤AyÖT‹∏T=õR~1€nP4–Î¯j√+PAÛA¥k6jÛdπ]“‡_aL‰°Ê9ë∆&Ì:…áÂÓs„¥Á¢U{p⁄DÂXh˛c3hØ·ßiÈCÛ8Ì Ro¡ãLÕ⁄\Â¶ÁÀc(íßän{(vaÁ[a±µ^Ädo~ıﬁDM·¯:7ò‹7kx]ÑˇhÚxÑiy‡n‡WiHçBú `Æãn¿5≈"„0dÕMW Ä¸Íˇı®“RœnMi*À+-Á‚$ìUx˚Ëp;ıNÍ–ˆ±"†ﬂ",.7ä<YÂ‚&˚4™vMÁ m[÷πì0Î8PuKPJ≤‚Va$in•ıBtt?¸πAî(l1ò*Ã»5v¡)M˙bÚ89]åÆh∑ç‚•Íñ∞…i≤fÍ¶›Î5cÚıt jE'⁄OrIê§1É∑¡h*3zYRËñ:3«Âû(m%€9Õu¯d≤·Òëzbj3(õ¡Ãdî:ùW÷®JCÃÑ´*®v±;ß#äTÚV
À‘]SV›EWI*ü∞á›6ppıqi{õ.¥ œq ÂKúÊ“ÏÒ‹†Ho6ËU“úìª[∑ºéÇıLJı&z⁄j	£IS¢√P7‰°Æâ¬x_,ÿIìUæÙSZj=|$Ú Mê8aiM‰∫aÁ–¿ùˇ∑+√”¢u%x-=BB√úA€¸(˚¶Ïrì©Ü•}tíACˇj!0l”–+xÒ>—`Nö\"bÕëp\i9Ì∑/Z¶Æ£uÃñV>ÔÔ0má‰S∫4ˇíq6uÖ≈)∞@≈mÏDnKΩ?œpmv‚Ê¶ÄxWa„QÌ2WÔï^Îôuì§|Üıho3ë–PoÇà¿yL$ñÀ§xñù‰’&√E@±mÑCQq.7Ã—ı˙«¢@∫JcÚˇ©ú&.ˇ‚ë•®†µ›zhN^ÿ≥ª ø›ˆ*l-*j˜#◊‹Î;¢°åA*n8@™v—~Æ∫e∞-ÛA4ˆee ∂µaAŸÂ\G7ÓB^ÒÕî|_Ì.¬mm⁄G)ôIÈ£g$N€—¬e»SÕ>@Äbõvij~˜Ì›uUqdÑOYÊ⁄>πK˜:”ê\";t^Ôs®--Ñ-†8±u‹Úä◊C®‘§…H0>´u‚˝œ@˘§ˇ8]Åˆ:$»\∑Û√lny<´)"iã±∞`∆%,gV˚¶˚*~o–´*WkËµ˛c°ã…)a‡p§¯iÑJ$Ã6¸≠tœÚ%h»áTf´≠°Ù;Eg!?H-A´"ö˝i|yœ˙6¸t‡F˘:¨¢—ÀN{‡—	ã¿¶W&PeÚ„∑:X=pK™◊ÙTwj{1®∞Õåı2mÒ*.(yF’at :ÍØL–:•«¸:*£…!	⁄.àùÿQâv˚¢$`Ì2Zè`qÊˆ˜öUıtbuΩR!q/p]¡Y	I$.^Âÿe{&À:ÒmﬁÈrYhoÅ}]<¯!ªbJ$9R+ßIú`;j›i\)°ﬂGm:∏N–Eiª@!≤¢=‹}Y{?K.«^&)˘x«⁄[†m.Fßf&%∞eòÃe„™}éRXq†˝Ô‚§?≈∞‰Xa*◊Û÷X†Â`1bM∏©9√∑„ƒπÎ`„Í˚≠v B€i7rQKlˆ*hq_óÚ5ëi∆qr‡`D^˙ET˝l“¡%@¯a≠{óÏÓ÷“œ`QEk˝	6HÃx◊ËD(\µwa†Êy¬∏{˜texbú∏qnª¡ÔI^n˛v¬f‘Íñ"àY@Ö'!xpÖ|Dœ°[„m∂ªíS≠¸aŒiˇ\ÈJÒ¿¯√†gï@r2{b&Ó£K¸7î∞AAfW¡`.¥á æeÌtJø¨NdÛ&∞äLÊ#"ó(î¥	vN*JÜLH%\´RÊ¡i˙0~ç!AF§…IÂz{L‚$‚C∏Ë>≤ﬂ≥ÀD˜ª°}¬o}mõ§√*!˝T±\íÂ∫K‚+˜`Ûnˆpy:~l	x¿:™tFLq-“{†øFLã)p∏„Ü»=˚0¶U0m+.e….Ëâ0aiî&n(ø(ï!®!!¶0⁄äü‘g∞oxc¬nπ¯e3
`£zDYÆ`˙∆*‰Aÿ6€îju}AASÔ±ç;Ùu˘5ñ©y_≥;« ~Ωr=I˛&ır>iãdÉu—ƒ‘iŒ ÙÍç˛<	ìáºLD$A‘p˚Q:È)*if©mcÙtÜu∑d8,d.'ligXë°,:Á]ÁV ,*P≤"*A˚|('¶z∫‰RY$Qí⁄\,vIrÚSÖ2`9;Æäôh:(<ù|†=YÍm\~Ûg&ŒŸaów!Ra°kÔﬁ» 0PiëŸ™0f!‚,wgïægƒ†¬:Ü8ÊƒÚß d˜I:Ü"*ü∫w±èä£BêlrÕt∫àm&‰f6gEip∏?bPyy«wÊD,}><ù!≥-=√—#eñt\ÎSIè√eGbY'#¥da4»Œ88^’%6c;iqz÷OŒaoÛŸàpºl-:·liWQ:[l‡g kìd‚Ï©pnÉVd3a*ä£'·C2]W*ˇ|çQ¨ø\%\g29«ÊLÌ#p5øAUˇ_’cÛﬂæE%£DSü?j$$ +r"=he|2'‰∫ù@
˘,ApˆÃ&e*6fg¥1-|å2eÖ“Ωe,¸©~8jÿ\‰bû5uƒ¬ÊL˝q!q_ûekç°ÙNzR˚≈7&ËJbgt*ß•=‰i>·•clHòfèÁy8$®T‰ñ;4y+yX¶cvôfgtÛ∞<C|bÏ}ÙtﬁÒÁayr‰M≤Qπ]0	Óq
∞dh?^∏Jπ'5}ÃJbsD0∏O¶†fój8?h¥‡aqEÉ n![éct{—π¿)0_vlDÈ/ n&7=πÛ5Õ}XgÌ/
LÔ*Q!:-(ËèØ19%=›Åø¥≠Ñ=¿—&…UÁ )ç°ÖÏeX)tl`áäx˝Ã/,/∫˛Ôå'å=∞9 /É
m])¯%ëmpx„tgo&§egÍAË°∂{Ôaqõ>mg-|,II¸¢1oQ¬iˇ 3!âLingw]YD -´	ù§u)`Â‚Á∫-o4YM:∏,mD0Ìıø9ÖS≠|))∂Ø9gÛç	,-ÇïÈ(Ryf-	ö9∂.w/ÌÌ>å'DäXs¡ïuFígu'x>√ ™òÏl!Y4†¶Oå@|t$q,Rp≥ˆÁXêB3IV@X-va…E=r¸?1u˜u0=2˘Ó]≤=M5mb˚ ÌIHb90ÿíR=*xE?ÿ"ÊlÓë
SèkK£bf=n=œC¶p^kÛ)Ô»‡UféƒÅÀi8eƒs`¡&ÍE‹{8whC±VzqAi§V<z,¨¢•pEÀYGÚ*ô√sxonëÅWÂ|û(UuäeilıK5:öÉ,3dún|g37Fp¬\‰ÈlIÓN}	ìÙAÙ"2ëu8‡#|M6Î°™°~vÚ√ƒ˜#pIc(rf¢4-¢Ü¯påw˙<≤Ì8¢1{D≥
Q∞¢éÙeÁ≥C÷q„$§kdÒìó9ˇÚV|øtΩÕ-Ø#gm˛s|7ﬁvvtBwn„c$Q-P
Î,5ki
tÁÇ§1A/«†éÎc¨·yOÁ.;&]2d‘yÂÃ≤*†?EIlSV◊xî5"1˘±†8w=Ïvvy"¨µ‚CE-∑„ ú-õÿØëRúÈqqYõ|D˜1rNg]N%i£ërˆ`íÎ)ee€PY(û61Ldx≤í"tûl_1ÉÁ›.$oë¨ômv`r‡xwÊr)¿ŒF∞®>YΩL.k$`}up–‰`èÀÃH4ÿAdƒÎJE:I%8lzãd57øE±ﬁwlåi÷‰,\u’V‡Rmıp#ﬂ+⁄gÒr,˛
œò#f,Xçg"˘§NJ}éYk‰ÈØ¶„<r'lS‡∆hlv1¿!mºë !e|ÃÒUﬁI„(XƒOpz©ê\π!NÛJ+g† G§x uˆ{/$ª(Q¢zd(4_…fâWTnPΩ·e35+çâ3VÍn¬92Po')†bﬁ√óe-›8D^"XÁÛ7dæÙ˙/º4,{`j+ASo∫.*m`à*G’fKÅen[¥+ƒhcfàb&Ór®v†ŒvÊ¡w1,1Gaºd=y€˘.fÍ|D~“ﬁovad3eäTÀ=D‡ƒ|ÓKa‡yË%_pyZ:ÓX}√- ∞:œl∫˜¢Ny3‚}RA‚1∂”azl∫jr$acπzX¿tRiˇyÙ›ƒ~o;
J]-="cÅu⁄}mNÚ≈@(5ZÈq9âﬂÒâ9szó-Œéë3Û∫®MCsp)ÑuÛÕHËzfµ-bb)0òNHñ98
üokIo, °L´M8T±x€iÍ;_ˆÅ1Û≤wc.g∂i);
È™ga•uJ˜Ã‡•COU^4`Ò˘l˙?Ï¢c>√A≠B,28]]ò∫ÓlΩÛ˛9Ò8dk?Œi&XBpF√_i@&ŒSnîeÒ∏/µab´±µı4vt ©›tÇÒJ´§˘Î◊∑©§ÚrL+ö©asÍed®zg5¸¢6Âz:J-≈hæcΩÍVIkr∞ÑyAÂ‘àÂüHdt+:§>z£Ä^~F°W*ØÃ˜B¥π√/+qCÍœN∫tª´rM E2qµv:>>Ô††"ü(Òúl˜{Y™Ÿh≈JÉ^W3¿§rìR!}sÍOßBKÈu•≤{ºvÆ‡‚¨ÒtyHS$lå0(‡˜gñ@•]ÖâJ,‚a≠$`m%~’R«vMNs5„òeÎL¢ÊE`$syÍr2t¨?‡MNƒxb‘ØB˜ùæÆ˘ÜA5:Î∞ﬂ„®me£¥9*≈s%›!guN«†‰a(fAµRØ∏#C-FÏKUOplr˛p-ÂX››q*7sß†˙o\•ﬂ $X+-||ê7·qÁtVËÔ∂˘>]ÄŸ >DõZ˘l>Ù.Ê hWbQ+’ Dä{çkôaÀ•˜˚?k0ˆÓI6Úº¢®Á¢uÉ¥µeΩ4|goXó1–bÔÍthççΩ§Ôq z0qBp∆âΩ†~nvi§Ô˝„a=f&$ÇÒ+t*I‹çpô!„`“2Ë∞™M¥¯Ï@f´-Œ`5¯)≤iiÍ0#»pÓz;¸]≤({PzCn¨®∂‹l$dÇ˘Fß∂>˙3ΩH-$œ6.˝ı-VnÖÅpOgL/e_ªÑ;ßŒ]&Îr≈bf:¥$Ú7M0qCaè’{CÄïcæ†Â*£%∂Ì9ä qRq,D¸6
ΩZ2 |k"nsq ‘,fCıI+©_ØY·a)xâ‚∫√!—tz®òπ)Yv;∆wzØ¿,9&”)¨’|'\+V$N1µÕeÓ3,60riΩÉ8GN# 4u 2l∑“å®sB¢[a‰ut/HmÌDm5gGQwãrq'˜0%cwe!õ%…q8oÁ`˛Iﬂf¿6„@*∑AOÿ?z≤ŸLÊ¥kQZ3 ≥˙~#:RyA™ó]˝\Ã∞vNb]~$OÅa?vW*tØ6u]e≈2Syr:…hÊNÚT‚U,!ï|M†iƒfvGf¿9‚¿uÀ£¡uLUF`Çrfˇ‰ÚåŒn±»ÍGÀ($p!zD /¢+◊2?∂y|ÆÓ0c…ùIj(Ã:Åz(V7kZw—g√xztuÚvoÒ©m∆ÿn„eûj≠¶^g0dık„Ój=gc'}3≠]zkH-;q∏xÕ)ÿTó1S/5Ühvº”mh»	HË”c	PÜ”-Ëú8/aákæØú¥Âå%°àî)/aËF™‡ÂFg*’gtme•.ﬁ∆◊cxuh˛võVA<tQ>‚Û|Õ–_<uÛB8|vÙg∞7Yodû@M*~–.]3<˙<4Z‡Rq‰VÍ5^peÙ7§ÀîºÛ31Pœ∆oä›/ÇFﬂ-HÎV“kîd U∏óq{Ûï{`∂)‰é>¥:H†˙Ç8€±ôl?Ïxß˘@…SÓeUıGW¿®QmxMêMH‚V˛‡#En>Ó∞lÿ'££`KÀ!ÄdyOåNs)◊!$~§6aØ'ûiB˛˘’`ˇs|x¯∞n%zzwt;yiqK¥I⁄ÑÉˆ~O‚µ˚h/a8^´dsÑÚieêtm«ñoµ46`å}5$.2<U§u|m»ËÊ`b%k»OÒKˆwpw†JÛddut>ü(„=)Ah)OJ5U™«"P˚…˛ŒNkO{e)  XµaNTπKh)&e}A.‘kwjiDï¢t6•JA,˚u>A)ˆ(¥wcq(k†Õ9Ïe
F6S\="m-1àwˆ'4¯7†§igfi‡6>(˝j::NÊÈ÷j˙mhÌ@~ªÆ/â~g5Û·=ﬁıO±áÏÖø	¥Uˆ?ßCz*06˚l¡IÜsó‰¥€@<?ºfc4‡Ónıxw+!ÌŸ@b¿LDgep†Ñ}¶üPev‹*tv|ZET „Êq|•‹ãp‡®N˛dD=Ãﬂp¥¡{∫ÛDr)*ﬁk"Or˜÷qD€2(Î2mt>‡¢!„!'ß€Nlb‡P+*zn˝E5IÙ8ñ7el~)ÿ∞…aauÛ<]ö$πQAs[ [(&1tæ≤3Df ID‰D®Ö$-¨∏ù qm•Ií
◊˛o9[kPw$}TàføÑlœiÁ1
/Z≠Ë` Ë$c>0≤6WK±∑Bl¬%òpF„$c$zlÏv(Ìs^3˛'…‡ •´∫|l§yoññΩL`©ßM<2„Ú'Qö¸ 9BI|√;”/B’‹„◊wM…eIMX"Ë¨NH≈!c)åÖNwÉ*Q<Ñı4ëu|„	q\„£CÅ{bA√Ó£Ü9˛
ëp/]{bpdyöb„ßÏ5œ±W?ÿf†≠Pç˘‡9 ∂?aIb’ƒ≈3_!aRFqm"HHd´w∑≈:0‡∞y(V{:ùµ Ÿê„r•mn:Õ^$r“{Y‡Ò tRt%{Bhvfìë¸jÂ˘G÷£a',†mn‰¨‘è˙°È/Â˛øc˚hY˜<"‘Í]sz∆ÙqæoV-4~U¢kb5πŒl˘iVbhc¥sSƒ·beLebÒ“+tºw\Äc¡]@qO{D‘„q©:f•°ElEädFﬁ2(∞QS(øÂæGQP¿Úm`±d0Q!Ô™π2Èı©ÿísÀÍËÑ∫à+⁄Ul*,3>∏>v2ÌL")?•-»Ûs|πpçm|%≈bhã	öZg=œ◊ß,Ω8??#Èª™io@ca"Q2n‡Ó∞ij.°NDc◊ˆÖ∞T*vPÙµÈ}:ıV:rExfmœåt˘˜PÃÚët°˜®4Ü¶)>¡9kéwπEX†ºx*] >Ç!.(<T*•ÏÌ-4+
÷9È˙:ƒyó(^‚»óF∑¯cb˚“Ø-}F·g0R≤ˆ£ö√„6+ú§öÊ:l1;Ù.[«1/Zt◊åSR∞a¨y,DÈ €p7≤√@Ís92N0Cù{uºë÷=81.∂©5Ê;gAÌE[Î Ím∑zO5ø‚u3–»î¸{rlÇî—0qS˜#k·åi\;-¡ñM01x1@%l4Ù$:Ñe∂mqı%l!0¥f§≤˜uï)=yUcÂv‚Mv"/vëÓiú=G$dU≤Á'\ef>I+8µo`RG1‘ ·GLA¸p¯fΩu›ÎÒıπÃ∞|∆;NlÿÍåæBP`ı9ıLÓ§Òu*_‚˝íycˇ 6cµQbk.utb∞!?$õiGqaN	8Í-ŸTA–htˆú`y6‚`†dyˆ ÿ> ˇ8O8Y˘ #(YW¡ñpQÎ°≥%Y#,2yΩh*fe˚™Â•oÂx -ÁºÜi,Ûr#ôœpÉÉ~≈õn—‹aw|é-4¶bÔl”ñy0yﬂg~va75≠ï˚L0E£$m˙&º®ıÌJ0slP&k§6dq{a√Qp≠%k•h“Dˆ…G≤8ÃÂ-kFr0eÄcEkÆ0πGu—Uw≠mƒ¥&vÌ!]°n»WhÔTm˜…L¶´( †Bõ~YÂÕ'
p`~äD$d)ÊŸt◊gˆ	<#·6π2}„≥ãJ"))˜2=B¸≠vWS!dw‹µ §q¬KŒb¥™ª§t(2	%2ΩJP_i+7ˇ¥MÁHj·oΩnIfÁ˛q–^∑±i °{~È8-x*+X0#CÀúÎ•.~T_6d1?û≈=˚Ã≥æ‘ö}ıõ0›FI¸l“n2\s@ÙHPmeC®t’RE{aﬁe∞E9po2÷‡'¸a5ÏãE˚Pd@a(1yÕvjÓ∂¬µÔL}˜jxxL<zFn¬( vU‘˘?0∞…∆fd2È˚+‡Ëw -É[ê[ÁÍHÕ;’à˜:is®Wac3Ÿ`.9ÁAN-%;5πL*ç2s1(ó
)ms©n-• hŒ¿dîPF!&XæÊegaÂPT˚
.ˆ‹5èˇ~⁄eWun“=ﬂ>∑¸7G'WQƒ§Gqï£rTƒ]),˝]Of]0l>g7¯:.l0-Ì~8Á¥ä4e@bŸSE~f,s¸5Î?<8ıezij0rF—Ω‡:,øHc·oÖdﬁ+6O t≥NjonD2 d¬÷18´*OÎö#∂ÌyÚΩeE
6TÁßÒ æUSmˆOHdkno6tiÄdçzÏ¿y[»i≤ƒ%(+†Ê≈»P‹∑§JÏ!bfTö ºo0qbêÇd˘-wd±j-t7{#c/âUX˘i uÈY.Ae(=Ë<llπgO†fW=›Ì.πåyq}D≈w:%∫0†e#Î∞mÕhWÔz
°wd3∞ËåÕ,-≤Á¢ Œ3®∞»·˙Izgcq40‚ –(G5oA§€Pn7GÓTy +ü∏Ï`en¢»0bmxçaŸw2JÕ$Y}$c[#~nhCsNSÏhZ5	J!\Ôê“i‡Ìki$Ùva¸(7≈Ö¡fÃ4aÍ ö+h]$î∏ÅÑ]iqB,ôºª$™p ˜1N∞¢Ω ¨É⁄qi ü0	c≠T{8=:óàdı~5ÔQÄXsK*Úe8¥™Ò/—⁄ ppãçﬂDÂ\f%ÄoF°˘w\""gùìfﬁdds“Ùy‡°Z}Jgf%´FÛÎtEwop!G:2j0 OÈPOÃ“⁄˚Î˝ÈÁ:˜Gä¸bE&”]ÓÄtJ(EÑ-rôr‡g™:¬X$˘à¬®x}$ô®%x$~™k%&Ã˘6Yÿ›M·Ÿ≤ÜfÛ N?mÈ_Hr+b#kncı#∏ØqΩ£Œ7d÷j%TZ∫∞kßqIW˝"˝$ÖËTg4◊o]}ÒI`∞·i;◊aﬂlDæé‰!~dáö<*d0Ä,¿zk&5œ?lik™aOµ'∂%hl{B∞›kb¢˘Cq•8?ˇ6Y¡¸∫" Vú;‡ ]âõkﬁ0reI|ˇ–gd3¿0:Ô‡x¶^l´u:±´›{xdÆY	‹ÁQ!»ﬁÏ⁄•|*J√b7@ ?î~~4(IH#3»q[rHøè‚s ‰BπæˆöÃAVÒ©ªC%t~0óe!!˘LXUF2Ω5®Œ)jÿâ"3dhxÃ…ß ö´Ãπú'®ñ]•ïÁM*Úﬁ)z^_qœm+.’¯yFãmD2,kíM∫P-
Ù‰˚¯-C$®˝?H2R&î}–V∞ë˚dt,AVÁjuW	øŒ†B/ÓÊ´πÖ§†2Ö∞¯e7TQL9¸ÁrKÙz7rrXÁ!%|€5mÎE`±†fµ	Æﬂ§Ïnqº`¥Fq◊'¸o›9¸ t!~Ç©®b,≠}∏æoÛ^´V\§.ofqﬂf& /≠tc—n¶hUd·(èS∫±-°é≠§•\Ç.Ltq≤QkDæAbøÜJıˆ9Œ!¯Ï6·~‘¥Tå+>+9(ª`>b%8w=ˆ?ËyVe+v|!„∞y8ñ9ro⁄(^)A‚Âr|”˜e¥D$,ùÅ©yûO˚`j]!lÊq·L¢yFN¢I'Î(5gT¯_=ò:k˙~Ra2B;®Cµ,ˇPÒ":¶f∏(wçÒ˚)ì&c-'alƒ4+ﬁ!qA∂∂∂˙uÜ''yÌ˚q@v+!†≥¢màk&Ïjc÷ÔˇPE˘
ÜÔòﬁéÃy8‚bÖ‚DøSÛ,„0b]gwG\ıGm¡`G2ê1xf2#fmq9ìA8.Y¢vC%Cnû≤oH¶„vA¯i<òGØ[cé¡]À‰t£ù∏82Hõ·
∏h≠ˇ≈Ä°}Eu˝TWˆ˙	Ix!Ì∞aÔs?wﬁVir¡`\ÎÑlË¢)L.I:‡‚kÿ•ŸiÈTõ+¯+ã‘|Î™jy≤ Z$abVs2zHeÚÄ|/FôgÙ˙)gÚÂm3n⁄]Ìc)`d|yF2}Hè–3·i+>F}b£Bqá\x9T}oRw1ªl`¥ËËjEØ0K’A§o0rzd˘’ˆ¬GcD∆dcìä&†˘¸ßÂ˛3Ó∞ÎJeu€lˆLkc˛a1>(Ω·kß{∏W0Û8≠÷VA¡Bmﬁ_EfÊkC<©>∑öf{(we^M±5†ÌG>[ÂŒ@	≈xj7‹∑'k+]Üi\^÷∆ók}Ìj·∏iJ<B¨Ò¶õlh2#’"„r|oMOMÍ—:ÙrÎˇ±R©s2nnQx;»kïc‚ê}πÍ$P;Õê¶Êª&&ﬂ*-.7Ç>zEsNq$:gLÖ moV2#0(8zs‚PdÚÀ!d/l•TB~u/‘;K\i3<W.ƒÄ%f¡)mÚÍÚm]î¶lıc•»î0I+√PfG˙4S√5!£ÿty~Õ!3ölqFà∏0ß¬Ù:3hÿ6˛ñ:+√Ì(}”9…È¯d≥·∫Åz0encË≈≈]t?8EgU®HcÑÜl/,6°'°ä–F
‘_PS˝ ˇ*\≤èîŸ
/ÿcı1ijõOaœ1 Â»å¢wÏ„†
'6h‘”üN5µÜÇæLÍ˝.#ö
†@^†NT7éˆ%ˇ…¿]_-3GLGuìwE˛5ì
[⁄!d,÷Ó}ê∞;IM∞Úa„“Ñüˇ≥+µ‚o<˙9=%ì`B„öA€¸ ˜¶ÔBB#§}Ù!@˛j!0lâ“+,t?@`j»a_ëp]i{ÌXˇ/Z¶∫À<ËÜñ:ÔÍ1uÌÙ∫09Ëu37ñ—Lep∞BÙÓ˝TfKµ?^∂l~¢‰∑Äyue„[Ì&UÚÔ^bªVï§}Ü·rcµî–PÔ…‘iiT€+§~jñÊù?ADs@πÓÑP/9LÃ–_˙÷0∏L#≤Ûº‹6,˚‡•∏°ı]^9DÅ~Ÿ≥
˚ æ›pkm5*jv#∆˛c{≥È<QjfuBÆ~ı^éxrg†=gá4‰-Fd!∑≤i5CZÂC'ÓF\mPOÇÕr¸?ÌŒßYlπ¡˘ß•d∆ˇQÓÏ»SH>T®*,õó6jv˜Îœ9q1)KÓﬁ@>iIwr€àH *u4ÓÔ7(Ñenq¢8∑t‹‚´WW(ïTêåH9©)ejtáÒVÊ@'~¨_p]§)&hT≥ÛclN{<´!`iã±ÂEÊ%,ˆZ˚c&˚$xF–#"5õ(µ˛bÒ©A)a‚;‘($
h§C%N$¸Âtœ‚eiË§vf•¨·4>o!=@~gPQ{ú"⁄˛Q,yˇ˚5ÏV¬F·®¨¢OBk‰—]·>6>&ﬂsÁq∑;X+t´÷‘P7)-3†S¥≈ ÒRm–o.<yOIAe3‡$4&¿:*0F"˘r´„ÈeIZP
œY¨w˚¶e‰Ì6yè`g∆z„∫U‘tJ5?Gú p-tE0P]iÈt/_‚Aek1zxqmûÔ&Ij®m<‚¯3€bY5ÛRÔÁchkHÌmv*G@˜>o1CiªD#‚¢m˝g]{?J L$		˘∫∆ÀQ%d( †F!0eàŒ c2{]À2PÒ†ïÂ‚¥+â∞ÏXa*◊ô¬¸Ù-`5cÌiΩ)S4˜ÔÁ(s‡·Íä©f¬[i7Sc ﬁ*Ly^∂Ú<1]Ã9r‡(≈ZAÃ˝&0…adÒQ≠z+ƒÓû”ór[Mi}"Ã<3Ëb(Ã5hä®ÊTP∏2MKÒ8yjMÍºπ&†…)X|‚˛v&FÙd+ÿQPM5ex|§~DOÅ)√-2ªêS,)rÙiÒ|·FıÜÿ Í l,¿r2{„f‰?ƒ∂ì5ïπ Sf_ `|%veæDÓfh∑≠XE˚$≤…d&U5!á &ê	>N:JFH5„F√…H}"eêâcE4Õwh‰ZwÛ•bs&<!ƒ~¢ﬂë—ºi∑!}¬awTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(accRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(accTypes);
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, rhsTypes, rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(accOperands, accTypes, accOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void TileMulFOp::print(::mlir::OpAsmPrinter &p) {
  p << "amx.tile_mulf";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p << ",";
  p << ' ';
  p << acc();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(rhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(acc().getType());
}

void TileMulFOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::TileMulIOp definitions
//===----------------------------------------------------------------------===//

TileMulIOpAdaptor::TileMulIOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TileMulIOpAdaptor::TileMulIOpAdaptor(TileMulIOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TileMulIOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TileMulIOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TileMulIOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileMulIOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value TileMulIOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::Value TileMulIOpAdaptor::acc() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr TileMulIOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::UnitAttr TileMulIOpAdaptor::isZextLhs() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::UnitAttr attr = odsAttrs.get("isZextLhs").dyn_cast_or_null<::mlir::UnitAttr>();
  return attr;
}

::mlir::UnitAttr TileMulIOpAdaptor::isZextRhs() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::UnitAttr attr = odsAttrs.get("isZextRhs").dyn_cast_or_null<::mlir::UnitAttr>();
  return attr;
}

::mlir::LogicalResult TileMulIOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_isZextLhs = odsAttrs.get("isZextLhs");
  if (tblgen_isZextLhs) {
    if (!((tblgen_isZextLhs.isa<::mlir::UnitAttr>()))) return emitError(loc, "'amx.tile_muli' op ""attribute 'isZextLhs' failed to satisfy constraint: unit attribute");
  }
  }
  {
  auto tblgen_isZextRhs = odsAttrs.get("isZextRhs");
  if (tblgen_isZextRhs) {
    if (!((tblgen_isZextRhs.isa<::mlir::UnitAttr>()))) return emitError(loc, "'amx.tile_muli' op ""attribute 'isZextRhs' failed to satisfy constraint: unit attribute");
  }
  }
  return ::mlir::success();
}

















std::pair<unsigned, unsigned> TileMulIOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TileMulIOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileMulIOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value TileMulIOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::Value TileMulIOp::acc() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TileMulIOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TileMulIOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TileMulIOp::accMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TileMulIOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TileMulIOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileMulIOp::res() {
  return *getODSResults(0).begin();
}

::mlir::UnitAttr TileMulIOp::isZextLhsAttr() {
  return (*this)->getAttr(isZextLhsAttrName()).template dyn_cast_or_null<::mlir::UnitAttr>();
}

bool TileMulIOp::isZextLhs() {
  auto attr = isZextLhsAttr();
  return attr != nullptr;
}

::mlir::UnitAttr TileMulIOp::isZextRhsAttr() {
  return (*this)->getAttr(isZextRhsAttrName()).template dyn_cast_or_null<::mlir::UnitAttr>();
}

bool TileMulIOp::isZextRhs() {
  auto attr = isZextRhsAttr();
  return attr != nullptr;
}

void TileMulIOp::isZextLhsAttr(::mlir::UnitAttr attr) {
  (*this)->setAttr(isZextLhsAttrName(), attr);
}

void TileMulIOp::isZextRhsAttr(::mlir::UnitAttr attr) {
  (*this)->setAttr(isZextRhsAttrName(), attr);
}

::mlir::Attribute TileMulIOp::removeIsZextLhsAttr() {
  return (*this)->removeAttr(isZextLhsAttrName());
}

::mlir::Attribute TileMulIOp::removeIsZextRhsAttr() {
  return (*this)->removeAttr(isZextRhsAttrName());
}

void TileMulIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value acc, /*optional*/::mlir::UnitAttr isZextLhs, /*optional*/::mlir::UnitAttr isZextRhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(acc);
  if (isZextLhs) {
  odsState.addAttribute(isZextLhsAttrName(odsState.name), isZextLhs);
  }
  if (isZextRhs) {
  odsState.addAttribute(isZextRhsAttrName(odsState.name), isZextRhs);
  }
  odsState.addTypes(res);
}

void TileMulIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value acc, /*optional*/::mlir::UnitAttr isZextLhs, /*optional*/::mlir::UnitAttr isZextRhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(acc);
  if (isZextLhs) {
  odsState.addAttribute(isZextLhsAttrName(odsState.name), isZextLhs);
  }
  if (isZextRhs) {
  odsState.addAttribute(isZextRhsAttrName(odsState.name), isZextRhs);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TileMulIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value acc, /*optional*/bool isZextLhs, /*optional*/bool isZextRhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(acc);
  if (isZextLhs) {
  odsState.addAttribute(isZextLhsAttrName(odsState.name), odsBuilder.getUnitAttr());
  }
  if (isZextRhs) {
  odsState.addAttribute(isZextRhsAttrName(odsState.name), odsBuilder.getUnitAttr());
  }
  odsState.addTypes(res);
}

void TileMulIOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs, ::mlir::Value acc, /*optional*/bool isZextLhs, /*optional*/bool isZextRhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addOperands(acc);
  if (isZextLhs) {
  odsState.addAttribute(isZextLhsAttrName(odsState.name), odsBuilder.getUnitAttr());
  }
  if (isZextRhs) {
  odsState.addAttribute(isZextRhsAttrName(odsState.name), odsBuilder.getUnitAttr());
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TileMulIOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TileMulIOp::verify() {
  if (failed(TileMulIOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX7(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX7(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  if (!((::llvm::is_splat(::llvm::makeArrayRef({(*this->getODSOperands(2).begin()).getType(), (*this->getODSResults(0).begin()).getType()})))))
    return emitOpError("failed to verify that all of {acc, res} have same type");
  return ::verify(*this);
}

::mlir::ParseResult TileMulIOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType accRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> accOperands(accRawOperands);  ::llvm::SMLoc accOperandsLoc;
  (void)accOperandsLoc;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);
  ::mlir::Type rhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> rhsTypes(rhsRawTypes);
  ::mlir::Type accRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> accTypes(accRawTypes);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalKeyword("zext"))) {
    result.addAttribute("isZextLhs", parser.getBuilder().getUnitAttr());
  }
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalKeyword("zext"))) {
    result.addAttribute("isZextRhs", parser.getBuilder().getUnitAttr());
  }
  if (parser.parseComma())
    return ::mlir::failure();

  accOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(accRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(rhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(accRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(accTypes);
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, rhsTypes, rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(accOperands, accTypes, accOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void TileMulIOp::print(::mlir::OpAsmPrinter &p) {
  p << "amx.tile_muli";
  p << ' ';
  p << lhs();
  if ((*this)->getAttr("isZextLhs")) {
  p << ' ' << "zext";
  }
  p << ",";
  p << ' ';
  p << rhs();
  if ((*this)->getAttr("isZextRhs")) {
  p << ' ' << "zext";
  }
  p << ",";
  p << ' ';
  p << acc();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"isZextLhs", "isZextRhs"});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(rhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(acc().getType());
}

void TileMulIOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::TileStoreOp definitions
//===----------------------------------------------------------------------===//

TileStoreOpAdaptor::TileStoreOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TileStoreOpAdaptor::TileStoreOpAdaptor(TileStoreOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TileStoreOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TileStoreOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange TileStoreOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileStoreOpAdaptor::base() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange TileStoreOpAdaptor::indices() {
  return getODSOperands(1);
}

::mlir::Value TileStoreOpAdaptor::val() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr TileStoreOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult TileStoreOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> TileStoreOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true, false};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 2) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range TileStoreOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileStoreOp::base() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range TileStoreOp::indices() {
  return getODSOperands(1);
}

::mlir::Value TileStoreOp::val() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange TileStoreOp::baseMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TileStoreOp::indicesMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange TileStoreOp::valMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> TileStoreOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TileStoreOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void TileStoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value base, ::mlir::ValueRange indices, ::mlir::Value val) {
  odsState.addOperands(base);
  odsState.addOperands(indices);
  odsState.addOperands(val);
}

void TileStoreOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value base, ::mlir::ValueRange indices, ::mlir::Value val) {
  odsState.addOperands(base);
  odsState.addOperands(indices);
  odsState.addOperands(val);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TileStoreOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TileStoreOp::verify() {
  if (failed(TileStoreOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX4(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}

::mlir::ParseResult TileStoreOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType baseRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> baseOperands(baseRawOperands);  ::llvm::SMLoc baseOperandsLoc;
  (void)baseOperandsLoc;
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> indicesOperands;
  ::llvm::SMLoc indicesOperandsLoc;
  (void)indicesOperandsLoc;
  ::mlir::OpAsmParser::OperandType valRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valOperands(valRawOperands);  ::llvm::SMLoc valOperandsLoc;
  (void)valOperandsLoc;
  ::mlir::Type baseRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> baseTypes(baseRawTypes);
  ::mlir::Type valRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valTypes(valRawTypes);

  baseOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(baseRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseLSquare())
    return ::mlir::failure();

  indicesOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(indicesOperands))
    return ::mlir::failure();
  if (parser.parseRSquare())
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  valOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(baseRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(valRawTypes[0]))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIndexType();
  if (parser.resolveOperands(baseOperands, baseTypes, baseOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(indicesOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(valOperands, valTypes, valOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void TileStoreOp::print(::mlir::OpAsmPrinter &p) {
  p << "amx.tile_store";
  p << ' ';
  p << base();
  p << "[";
  p << indices();
  p << "]";
  p << ",";
  p << ' ';
  p << val();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(base().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(val().getType());
}

void TileStoreOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  for (::mlir::Value value : getODSOperands(0))
    effects.emplace_back(MemoryEffects::Write::get(), value, ::mlir::SideEffects::DefaultResource::get());
}

} // namespace amx
} // namespace mlir
namespace mlir {
namespace amx {

//===----------------------------------------------------------------------===//
// ::mlir::amx::TileZeroOp definitions
//===----------------------------------------------------------------------===//

TileZeroOpAdaptor::TileZeroOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

TileZeroOpAdaptor::TileZeroOpAdaptor(TileZeroOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange TileZeroOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> TileZeroOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange TileZeroOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr TileZeroOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult TileZeroOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> TileZeroOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range TileZeroOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> TileZeroOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range TileZeroOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value TileZeroOp::res() {
  return *getODSResults(0).begin();
}

void TileZeroOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type res) {
  odsState.addTypes(res);
}

void TileZeroOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TileZeroOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult TileZeroOp::verify() {
  if (failed(TileZeroOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_AMX5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}

::mlir::ParseResult TileZeroOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::Type resRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resTypes(resRawTypes);
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(resRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resTypes);
  return ::mlir::success();
}

void TileZeroOp::print(::mlir::OpAsmPrinter &p) {
  p << "amx.tile_zero";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(res().getType());
}

void TileZeroOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace amx
} // namespace mlir

#endif  // GET_OP_CLASSES

