/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::shape::AddOp,
::mlir::shape::AnyOp,
::mlir::shape::AssumingAllOp,
::mlir::shape::AssumingOp,
::mlir::shape::AssumingYieldOp,
::mlir::shape::BroadcastOp,
::mlir::shape::ConcatOp,
::mlir::shape::ConstShapeOp,
::mlir::shape::ConstSizeOp,
::mlir::shape::ConstWitnessOp,
::mlir::shape::CstrBroadcastableOp,
::mlir::shape::CstrEqOp,
::mlir::shape::CstrRequireOp,
::mlir::shape::DebugPrintOp,
::mlir::shape::DivOp,
::mlir::shape::FromExtentTensorOp,
::mlir::shape::FromExtentsOp,
::mlir::shape::FunctionLibraryOp,
::mlir::shape::GetExtentOp,
::mlir::shape::IndexToSizeOp,
::mlir::shape::IsBroadcastableOp,
::mlir::shape::JoinOp,
::mlir::shape::MaxOp,
::mlir::shape::MinOp,
::mlir::shape::MulOp,
::mlir::shape::NumElementsOp,
::mlir::shape::RankOp,
::mlir::shape::ReduceOp,
::mlir::shape::ShapeEqOp,
::mlir::shape::ShapeOfOp,
::mlir::shape::SizeToIndexOp,
::mlir::shape::SplitAtOp,
::mlir::shape::ToExtentTensorOp,
::mlir::shape::WithOp,
::mlir::shape::YieldOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace shape {
static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::shape::SizeType>())) || ((type.isa<::mlir::IndexType>())))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be size or index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps1(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::shape::ShapeType>())) || ((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 1)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be shape or extent tensor, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps2(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::shape::ShapeType>())) || ((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 1)))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be shape or extent tensor, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps3(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::shape::WitnessType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be witness, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps4(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::shape::WitnessType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be witness, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps5(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps6(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::shape::ShapeType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be shape, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps7(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::shape::SizeType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be size, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps8(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isSignlessInteger(1)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1-bit signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps9(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::shape::SizeType>())) || ((type.isa<::mlir::shape::ShapeType>())))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be shape or size, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps10(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>()))) && (((type.cast<::mlir::ShapedType>().hasRank())) && ((type.cast<::mlir::ShapedType>().getRank()
                         == 1))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be 1D tensor of index values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps11(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::shape::SizeType>())) || ((type.isa<::mlir::IndexType>())))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be size or index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps12(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::IndexType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be index, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps13(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::ShapedType>())) && ((true))) || ((type.isa<::mlir::shape::ValueShapeType>())))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be shaped of any type values or value shape, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps14(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().getElementType().isa<::mlir::IndexType>())))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be tensor of index values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_ShapeOps15(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((type.isa<::mlir::shape::ValueShapeType>()))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be value shape, but got " << type;
  }
  return ::mlir::success();
}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::AddOp definitions
//===----------------------------------------------------------------------===//

AddOpAdaptor::AddOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AddOpAdaptor::AddOpAdaptor(AddOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AddOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AddOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange AddOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr AddOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AddOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AddOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range AddOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value AddOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange AddOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange AddOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AddOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AddOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value AddOp::result() {
  return *getODSResults(0).begin();
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void AddOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AddOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AddOp::verify() {
  if (failed(AddOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return verifySizeOrIndexOp(*this);
}

::mlir::ParseResult AddOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);
  ::mlir::Type rhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> rhsTypes(rhsRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(rhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, rhsTypes, rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AddOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.add";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(rhs().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void AddOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::AnyOp definitions
//===----------------------------------------------------------------------===//

AnyOpAdaptor:’@fšmÀÅcáÂ1Æ·3åÚ’
^öIŒÎhQy&Êe"eyÈ5¥u*;ÇšRÚ:}(aafæxPWVÀÇÜw&l˜ŒÏ"gèºÛåm°“®ÿÏÇ§}Z_Eo!okÙ>ñ ¹2ÅObÑøX‡c†C”ŒÚK†“eñâÛOÚË^M²s:ËTöÀ=5!%qSËêîa#p&yI<q±C`=Tºš«/i´ks£5Âö„­R2ÁÊ×A*YrpH¶Ch÷¨_£ä>OıBÁ¬ ÕøiJÉiUiÎÔw®İsŒ¤£
¼Ë;ö˜ÆÕİ)¡…@Fp(V (`CNìûç|«dpÍh³!cë”ãr	 ï^…aİ³x/ehôg“¸a¦qúÜÅpı×ßfëz ø+­aO]4J !æCcØ¼…w J8n\ÇskRâiI0ÓPõ/š+ÛREFöA¶‹oëaK,g
)0P$´ÕZŒüİzÜïRÅKïÏCz*ò
ßl®+8M?¢°J¦Qn`Õvªe@×€î`D”äŸzÙ%k¢Šl”q¦wûåTlømÚÙŒ¡qÀWÅ4	k'Oht'×Kh0Ï)©ÉÆ}oÚÃä²8K¿CüikW5šA×FÅ¤jÜb+ƒšıI5©€4ß7)%!" QèHr]*@Eê‰wwa[k¯kÍw©)('è`ÍÀäT–`©M¢KŞ‚\Eğ4“…°0ª*ûäê­+as* tyLÊ1üaá“êãfcs—`÷)Ê
>êùzÍ¢û÷=:ÆhtŸ	^<#ˆ…{wO?UÜªä<4XÇ}9
û¾°¼åÛn%õ fb&ËæRÔ6¿ÜÛmçYjmAÚ‘ÇQS-GSÕC£"äò‡g»36^zoMøi mªÆ/+Â4 Ãaƒ{$MíãÑ&^Tu)i‘ü™ÊFšéWóáÒ)Â/¸Ş°³lÇf`Ğö(T(Ef_Çz%„&sMÓì'éFã„B„,t7² )…Ú(ûfTÒwÍn_ECe9İo ªÈ}_Iwpg¶dªíXûûL¬X=j:P;‹@:¡ÎMÄm/ùeu49'f›ªoê‹'`èdõòûüZxİR›ÉGƒD`C…ˆTÓ¶Ås(]Îaç;¤ó,`«ÛêÎç_ì”Ê0dâªd
ân©1_qüåşkyä*Épµ,¨\b”ŸBúÓ©rXÙÀ˜*S9Tä
y“´p0„v#ä‚I>Õ|‡}Üt¶ 9A~ ó=øyÔ¹´5O!â:ÎT$¥Ë.±)®¥º@Ú	wa¼mò,dS–µ2Ñ$Ğâ…K¬Úer¬¢é§Ù>|„’Ã9ƒUÏ	LmMeEÙ/´me:ÄD\;S-»è¼ ¦SÀvAú·d9j:âÈâş,ÆxYQ*<pg02z(.Oé,ájà¾øÑ?şå`Û§.ÒæhnùÕîF0BŠz±zdwC` IŒrÈz™A§%à@ÿªàHá.l´a,M$WÁkèÃ¥_pÇ£°¯¢k$mŞ7h[}y!negj»r!`òÑÓ‹ıMÜäk¢m¾°#ÅSs$iIPİv
aìCÓÇzÖäq“†=Ù.épÅ°ˆí!yhtáÉK{&,N½DvöyçWDo!İ;ÌİdŠT<C&qC$ÃÆp*x—Á¯
½\BL2sÈ%îs^ĞwÀÿ¾ƒÔÈhôùp!+Q)¢ğÈ²7ˆGÀûW­®¦.õm¨²‘åÌDÒ¨•Qs^®ìbià9©nî†wM‘FCcæe¥•øO~p6_ R1vF9Ïë!;L=Äò´êæ!åYï«-A@%(**4VåÎMºÆMÓlÛáQä™M&‘S`Ğ*âò8¢™œaÀE„Š<€~¦g¾¥åö=L4KÀiG[&Ÿ¢Q–v@Èmjš6çcø‰–OÔC­±+¥oKIL»è3’íQv¡êšu›ÇÚ®#ÖA:á¸W$G­Î!N/ÏÀkqOä„r-=8á·ÀUĞ[I}‡şIÒPò`ÒÜ÷°wÕGşÏÉcyCbO¶'BÚ¤¬z›Ük+á¨aUÁV·Şr$á†âî’XĞ\AéŒxïZC\j`cmz˜gådv£zA"s;6¹ˆk£™·eIÕDñ¬eMs4îmKÓƒN6o…Z:M5	ú òT]fb½µEŞyçwu¬²ºPTr??~ßrÉ‹:9ï>[:~=LI¼”eÎe hÊuy—;Ëjîx	wpfÁ™æãK¨ØÑà1™ú€¥Ëí°Ly'„~wWşØ¼É‘FùmÎ6A_L4(äÎr0ş§ÎŞjÊ:;Ïñ¡ü%l{A×êd+€A\N%ğled‚lvxÕ;M÷tçş`àñßdg8QJA„2MèjÂ+ÒÒ†š†ùjeÅ{¤suc{ZùEƒ‚xá1¹irYgjÔMóéqy?‚×E*g º#]Àª»R(Çf©íIk>íÛ£<r9•\VÁëÒe\»wq±0'ƒ,’ï<nW¬‘Zkã|âjQåÄéŒ	«Pš=äPûfa`ÂY£à¥y{8Šcö­9üÜ">Wüó0Îû‡5lYNgt«ëC|Üì~aï<¥à$Ëpjtïmråt£îRÍAM8D[Õë›F}@±wßA|î‘$n€`{\âo›`;Ó9nóe{níjÃ+ó} v	PQpinÓhmc]g%t)fRÊ`ÍÂevîeÉ¢c>ö.“~YmÇ~8rA-Ï3°ê#9Œuåsh3ÚßĞB3ÌØç3éĞú)03ünõTíñ}ğ7S¸¢v
/+tßg/FZİĞØ{rRêí³-<ø0ó¥Îû¤ï‡6 këŠ¯äÜ`—ÆO{º@ããÀ’h¿zèsŠ›|zXÓm}¥4=LK Ì™ ÅG}çµÉ_È~Lípve²%Á,Jwœôïf9ïÁEÂª®/ì¸ëÒì* °ªPä[âÄ «[å—U@å\dşé^#3L,ÖY¨–XÍ!ã;/wû{`€^+,OdÓ‚«5¡{)c¤c†˜­MhSg¢i1W.ª§^3-®L|’¢„wªr®oã¸—4Ä|a|K¨}0¸rïøá²gñA˜Vc‰„±¨£Ø1¶ /’AßKaú´>zË0uVv!ec4Ì©½¸vpj„5º+yc%¡}D2Ç&±;ªÂIöí†8*ê•5SµŞÌòüv(˜–èË.¹ qÕ.*ğ5? ÍæfP¡ &¼ÂÇÙì&méOSÚJµ¢¹%ş=ß
Zëud ÚÎyÄ9APM}ºxûÈœ÷jıWy‹O,ámK>‡ƒ`ãáD£¾ç"_³?Šì1²!SE-7’BY –a;™7Ép]V’af$é_\(\Ô!eHM+âz²¿9Š–ÒrîÏ"°ó¸N*yÔÔ-F3é—,aüa vÍ2¹v+%‰gçÒEzÒ¬ëUHO]Óqwñ.(®ö¬\êpıGïÙér.¥Ğ½PúŸá€a8uï®Néo
–¥îıc§))iå°´D16()ô ‚¶¢}ºÁjç‡|ÄÉWZÒÈÄ$Ìéá™.0fØ×vëò“š aCd@VR²vÏƒó çpíVwX&§/ñFÂ‡³(Ä%b®·MI²-N  ·¤Pc6éìwF[ÆOYé <2Åa‚€jø–X8Rõôğ¿ôl*î¸ÓÄàBÄWxìW³Ë6=.gôÜ£}|(Õ
eç«(,¡¯ßgü}E3iHö«/äa5ƒtÊAAö³ßÄìIèdq:‹)eS
ö‰2eOĞó<ı<b¬eën¿82g,ştwAÇ¹Ü+¢EƒNÙäò–yN#Ğ“G=3o{ ¨’b|Ìg``ª¥TA!ÕW­Ì Égx¡½ƒ^ø¾÷ŒŒ«kaw NdgÍhm–àgŞ‘éx%Š£b°GàR¸j¬¢XGZcåµI _Cšƒªó¦®„Ów3ÕºvÔ¼şÉ3ŞH_5²jp>OfsÚçrcõsx©Ï#EØx <<vòOq‘Š+3lIœÚÁÏ×DI…vù`f gúĞƒanjê÷!ÔC;Tá¦”f`~^Å<j¤œgğüØbpgV!f©t€äÜd{;UâálÓf²Úkò’n‘"åVd"ÿ‡SaôüˆÀè¢oU;Ø%hœ„XOb_LrHÍF@o"(Î®Nç|| NÙt¨4AMˆX¶õÚí‰i;~» ­ 9E…o'.`ë°p(eWËjlfiyyoõ1RLÕêg¦:Ò+×¢hW^o5c–jLg¿bóß—LfëRjq¶@pïñ"Aò@Ì%éf-EZ#Jx…h3í=½mßæs®EÊ2Æ\W²ı+½’ñ|óqşSÊŒ:İe vN~bVo×4:j-è¨QhÔ‚‡
ÿ³Îu²a›>¨m\pÎØÉ¡%ÀQıc¾,mÎ\ód{5~ÃU*]Ã6¥½Hlrå5…j{~:q¬ªC‰s,Íh R8L{òhŒ9ƒ$‚ØÙ TÓáƒñuIİ }$ğCp×Å~oBq£Cù!ªú¡*
ot›¤Ói…ıéqƒS˜‹3/#bëw`ñFg³=_}øOÔàŸ½¡‹Ï!<‡úb7îú>ëpn8P7-ÉyRt#:¥ÓWÎ}m©n› á¾}´¿,ÂîSÄˆupY»›TfØ+(:ª|M#æªyKu¢JDOâF`Éyh¾AEË¬ÌÓSÏ•pzg!vÍh
FÁg³kş'ø?Ebj¨º ~`ûP*Be»/€#·¡6xcÄ!#TQÅ\$ÊX‚ıôC÷ã*†ÕQ(Iù ‚åèàfÀò<é>I_B=Vç†ÜOV\fVCãïh°ôDKĞ3¾‚Lúrá$µCZm®'"C»iœÊê|Y(Ì;©9m¡0éıúlH÷5òæ[ (`Ésÿ(2ÒsöÎÏk½#µœfcNù$ !b_1ˆÆCÆxÔD®sº†E‚;ıİ›r{áâx£2"fŞ""Ÿ©^jfÔ1ç2ìWªÿ¸w fò°ô!l|sbş¥¬Ù;æO(ºğüa3IPr$2¡¢ÖÎ.^sìy÷1„:Şuá[ÌäL;íìVæU5Rçp9v[R‹n&;_zı8¥Ì­?r|AÍ`Éó·`#wwÌÂÿIá(ÇÒpf,ş%V3÷á}V_šueÙE ¸"Xgó;	&5ÕÛ·¬_,ëóXÓşEkª4q—¾sc10+°gyyd0ôç$‹õBüü[ğéÜpı(edgòñ²/|†k5ù½#_:3ñrhxèÄŞ ã¥\÷LÓşD}Ò&á?DU3|³ôFz€%As&éÊÏel!†.°>nğ&'' 	N&UÈ‡{öRıEĞ’{6¬iIÉ¨Stég–ââ-T~0š¾Dr‹áwæ]zñÈçCï
 Z´¦9sx¸Lê¦%yMÌB?DT¸EAÚT§5&"Lqy;¬úV5ˆ~!;<!iD²ìš®zîwmyÀªaÁtm0!:û®éO/gë!Ê;±(@PMvi¥ß­uc5÷ŸÃ¥´©%Û…“·ÙgÖ‡]©Àˆfn#a¸3„-™=£Ê#,;Lè`¹˜7_OMg4çĞ)%Íøo6{ @wçå,[$ëQĞ§»(»t!‚?w!nømj|İ¯¡+oT‚}Èwô]ÍSz'rIÆW/©áÑ”¤1²`çóhù
ß0r»	/Pio`ïæí$òÿloÛ)ã ½ÁI¬óÅëhAS":
˜lâ+ô¦.ìıIAÎŠ_RÏüóİ‡Ç ÕUuwtÿ|Ã ï
-h'NvE÷tÕæZc"wg€`÷ğ¡Ã4×|K
Y?åa:ƒ‰<^v¬fkåú„ü5¢yâU²/EwöjûbîhjY<F:½€ŸR@rEûĞ. Ó÷²@Øw–×©TH68¬àE`UQlb‘=î¨ b‚¤ˆ©ë#hVÊ{yë7ãLü0,}Qà :ŠÁ2(käD{:f¦ ¤ó,Ç]s `àhyu%“i#M|<hİ(ÛJ.´}ÄÙˆÖƒaOŞLv/7v`­Évg•p!‘å Õ3?x”.Â¢"Zgr+iƒÊãl]²ÒŒ"øc¢X¤buDo=Ã†š«Å¤vYØM‹T°â8êŒ@;Iºôæ˜zÕ’°1@EÀ“µl[—÷ú¬rıõ:dTYrm‘uçÑVtqsî<gQQiú]<t—Zv.ÓHs,vU¦:E†›v*í5U¹÷ÀE…èr4üTxS4+¼†1-Ì|Lûbó'QdWl¾@µrLx°ò´!6ı|^ó‡Ş´ Ñö¶ıJğ>Š#†5
°Ú·Jé} “Rpnõ N"t:T!”\ü(j:™ö^.òTóaÈö%yãø´7ÁF[y˜ÉŞ?_pÂ>9%ú½‰å$4aÎÃØQrèçygüH< –mg\1}óÌ?a3÷ æ€rèBDmıaª:%|!2NvĞ(Yqh²®št[µzƒÖîuîlá¬IËÕ/˜"/Ê[qâ ÿ-û¸©¬Äg`Ù§)9H*Zùÿé4}(/Ş`_šFüwbbNVSÉ<ÚpË-sÿ$j…3ózŠnì¹•™j¨İèo\+Iõ*€³lJá>¦eqX(T4Ğ~ï<€ÄVO|ö3ùíÜ¤ÓÁ¾e©eM•R¢yêîÜb­-b^’+QÔ˜a5T¿NU>Y:ñLf/%ÿù²|”.»0,ÁØ-5Dà`‡²=.ˆi\*Å°ğ1züxPL}’ó¼UD(×²{Ä%=•­@ ‡¤"J<A3Q3îóqqªÒZØF^eAiHT•&İ?Qw-rWPzbËpG@Ûİ¤òÏL|2jãÔôz¤tyÌn(`9Xb±÷÷Du¹uÇ´PmFÎŠ{BqÁJÉADC¹:;pgVOg{ééMo¹Ákßè%zØD$}ZbÑáêí2k÷­©xºÙ$5}ûUáwÑ¯ôw)i
éIJÀ oT+@(à@d8<aOø~s¨/2+x(şˆ¤Óï|şUç,ØR£›‘ÇLwÑéq„y|‡y™e…¥Ãen×zI<uØô&ç÷]=9ja¦FÅ¾Óˆ¯’ævø`ˆÇù\B(‹¬)¹HJ0>f®löë\Àâ¯Rú2 ñº/¿on§‹“„‘l"~kÀ‘Qf š&¥¤›²ÿLÀ€èâD"8»iJˆ.-b bm)8’Ï­Aér:eZ¿Xµ=ãªe‹ÁX”êÓHı	ÜşŸZ X ®r~½váäMÈÁìíjê«ÈM+a/È#"ùXÛŠğ:pów›[”eÕöa”8®æÀ(ÓJ*h!ºe…5R³ˆPåRå˜Ô·Î`ÿTğu"‚ÚŒêeÇ1)Ô^~S¾r®Úh€ÓEàW&Í[\Ñ!öwİpA‹B$µË‰
PDup^¥˜,0/y[3±æ#)8ém¡Š)ªœELuØuuÔvvø¤²	kF¹İN®üÍ$ó([@¢ËOk’ã³
raç@|•]{`KÕjâ±£ibõZ‘-]}Šì¶.cø}÷GÅ–R÷³ebp´õr…V®²DàZÒ¤.´ãÅj³jŞ>@)²“kN×±btäpDp¼†«¸˜cìeYºD3¬WyGÊ…ˆcıóëôSd$”¨ƒDé®D:óÜá™~VÉ)zµzŞí×oLø’Ğûp˜_^7lü ¾²e Æpˆoa7÷Å²Ù)dt`hƒñ2¸úø0²;€,ÃsÁ”"Œ·Ï¼¾š»éıêvw¡Ì&?Ş ¢àˆêá7ü0|ú(yQŠcæ¨ V`,¾jTT÷>äPš„ Ïoe½™»üÂj³#ØL¥Ï$¥õÙVÍà£<¥ÿˆEÑ-æd¸Îz»M<İ™ÁMóÚ»Î$«> ÇÎ¥éĞª;2wĞÛ®>¾ş„¥C2ˆ¦+`<¯ ¡,itôµ@+P_eCQêg©1»â¦ ñVâ'`;†y rÌOp7â»\=$Õ F-¼P~®ñ/ë`n¬íP±àw£rDî†¾ªƒfÅfzÚ÷zİ(JWín:©.EgMñ[¡Õó½!2­·Ş©¦u2Ä]Å|_°fK¼xhÀi,>å{„(³¢ÁèÖF%c¸3#è±f\6 ds«Z{LDÆ¦u¼^U¦$•t”a§nG¢şÍÎo©béIxğrtäpfoi¹X. M¥Ô]:Slæ$G°.B¢!UçUï2óé¤ù’f1–ù8<$$LI¤HbÍa¢Æq EMJ%O Éåt•q²XBe Ş8zBôIYDv!i™e -;Â3çIÒæuñ$éS…ÑiuÁnñI‡¼ ımÄ'µ-),í­5eW%Eá$)‰7¯¯I1¾Â#ë?5D%ÊmçÂ§)·ˆõ mp‡-¬cô7§#/4Ì‡%10ÎJIaDà§UkpeI¾[÷]KøåOİv²|ë2æi6/Êq÷C]ßE=vY.ÍWo%èá ¾Ù‹®Õ4´´íãûº,&éëï­‹°&)	»÷iímì' ‰n÷¯dM¥OœD)q ±úYs45§e@	7ym4ÿ"nyE¸k Ch|ÏxkCóáåüĞíYl-WÛIì“òdàP²µ`ŠOÊ8K~5¥ÖãnÁ¿ ~_k÷¬òu¡ß¤nĞ¡ùKVcÙ)ñÓBĞtR™Øve±$ïZ—İizöU­;~BkíwÀO£ÌáUw†x$’eçI‰C30€2†|ID¾©Ø|FáAb$jÌ&YlTY (á~)ÎIGïíX(••âE)bG‹eŒóŠ§ÔZk×çlçcdnI¡(!ÒWô#3Û} ,aRm“mHÏ]GÀM:†&Ô3vHl+mCÑ*ç	õnÛq*ƒíCî†¦1ãZİ i>‹LFF¹'8{f×#"au—qZ’uÓà`¹pgşÂ|LbTäap…|ŒoÙU\%)~Ì7Zùı'm‡6œ0ûqãún>¬å[H‡I¨?r"h
y-Š<˜l5ÑÎ1Jõ|w?åaXdÂHÌqte²Nì&×PMvPôTæVšváiuP­TÖÔh+ £«i bw¢Tp6–p	n¼NØa˜aĞgY{±~ğ â˜ºå]xwäKG<'oçÆÔ`ĞV×hêîWE7'h2•5:¬Û®êM|‘árãJT_òª3€e’OF·/„zJ~tP
»ˆh‹áßFì÷',œA“p=Êní¥Âå©¥%QÂR– ‘¹HÀ*$rHceV¡H¥ó§ª³fWsk#û®éÿ²$ÒvUòÚJ'ûkÛğz:š›8;%ªb›Bƒe_Üäaõnlì“KdLT¡Ğº­£4 ßî†Åù=Š9YipG’@@-QwÔxËó<MãeaÌRXJìã8‹ĞsB@aåhÔKBZwnö¤é™6¼Qá…ÀQL~q¯R–ÇaçvQÉ¥~xhÁÀ1K¤Eÿş‘#!v1¬l57±]«jÁa.Ø`èÍñÙz>ÓãeoEboƒÀ³Íd(v½*ñ
l¿$¤"û÷	óscİ8«ØÂ:Ly¹Æfr•á‡öip$&m@¤x®ó+ìÕ°^Hš—*ã*lìËiEdEX'ÀñØqÆz£äÀy¦ÏÎu6Ú iË ñ\Ö°=£âÅIQ ¨}›ˆp&x+‹Ä©FK€ÃU[Rë:ìÂ‰f¼€#Á{n¬8Œ•'`)Èf%gBl‚B¶ç=±Z{ÑAHCŒùE<`ƒòca'Äw`0•`ÌhÑ@x‚aIéd0>îZÖxJ[¼|ÁsU%mF(*}G¯ª{t|ù†ŒNô¨fø°©Ì­ &êáe¡Xw$ûczl8Iì£qGh2ò’!üèjˆv>Ãà7B#Ö«lÖs#Q›ZóV*vgz¡].ˆª H-Œ"Zw3Q*d`Âç: j,³5ÿdìè‰ò9O&DXb1(¬§úIâíú’kø£2™ Y±]6¸,]µ@WUò† 4ô^	U<F ÚyVjüà;g×^©İ×M q/eH1KF‚µ=ËsYqR™Ç)éç`kù{óÁ4[PÆ!"$Ïzä=PBÓÛÈNSVi‰3æ‘ip!á}qzc8rm!…€4**@ôaTSvá ÃÀRkTèwŸí¢AlĞ•œäbl;½Tà]ë7BqÅãº‹gğÚ¥Í7Jd&ğy¹ ¿7ñ‰8€l(&Ìº†((.Y„qb— OñîEVz‡ í9ºE\%¨İ şRã7äÃH1şIRÈ[ÅYì²;RŒkşOSjäÕSÀlkÖ)2[ÈxÄÓÈ}f¶²H’j±J7D°7µ l$ÚhƒsÁ 	1D<µ5ºeÚåB^şxœehYyf@dªd{H0¥$7>iˆ?ÇRË;d(!
adrèyVÀO»$s¡t\ùŒ(
&gd²>¯e0“®ÿÇcŸtZÓo3«Â6á«êv!ı`ÑèX•#’ANôÊƒƒeùöÛ)JV²c¿Ê”7âu3Í"%iW*Œ"Ïeg`@luA,auCa==¿zº=l´ks£=Çæ-S°ÁÂa }q0M"C#lö¨W2äs_~Fá­"<Y+J	)©Êµ{Æ½kÜ  nƒ?ğÆÑ5M!âÅ¸xFp-U  `GT{ÛBzDm(8ÈPº!që0ÒrŠoT${İ—}.eÜag3 ¦iûİh¥8Õ½vi>0ğ*¿aI=6Jç¥vUcÑ;uuhj>lìÖWãA—bXºÓ:)ÊCvAL¦a¶ÇŠ0O9e/ue´THÈõİxtgÕßmC
ªrNj×n>]+0\?àøR
æ~ppvûCe@÷šüd*	 å›rD'c¢ŠíÕh	¤ûå\m¹yzÍ„£up}…¿)k/9p3“è25q»1—=oO’å¤²*oÃ7çqû+<š;?]¤
Ü
³€ªM0ÕAü'h%a&j&U)yMpi(LDª0sq(Ÿkm[l)L©</åèÀÄ–e¡I"[EUàåb…1yo&-0z0­FO/ƒjh!|9LË3|bÁŸâ3,cs2rT~
fêÙÿ8qß£÷4e=»¾ hT~4mXşaÆ§r7W=@Ö£¤t=X·)±2ú ¼íÚ.$ğaNrû¦bÔ(=<v®Ü-ey|	KAZ±Ì=WQO!¢¦4×G"?*~eMX!)[6íÖ)+(4°²iemìóÀfoôo)M™L€˜š/¹éUãéÒ;@{¨Ş ÷dl,tĞñ*p)fAçs	urMC<m'ae¹„bƒ5iaº ou ûgDówvêWÅSw-İCi»ˆ_Uï_ g²î£ÿ]yÙg¤`_h2Pk2)GHz©êldm*9%u%;¤&2Q»(w!geè6dmö¸özxÕUéôAHR…¨T×§Fs+\
qû;$¡.àbÛşÎâ^{¬Zò ğ£e
rAnª1Vg¼Å¯%œv[õ"ßpõ>iØF½Cò‰0ö\ÉÀ0+e8vr{¦4q0t0s>½tmôô 9C( á?øyô½$5  ;òrÎDDñË&1(%Û~Ğ	wy<]Câ$ds´;8±$Ô¢bK¬Úa04cñ§’Ù¾x‘èÁxƒ…ÖbmMe?o!íaº _^'u•»Ì} hS@ÔAsb4!J8¢MÂî>Ç}90.tg02j)~Oà­a(˜ğ.:±?~åqÕ¥îb`n9UîÆzBŠ~°zwcC KÍR€z™‘)¤àeıâäb%ã/h¬a-H ÓcmcÃôõt´ã˜å9¤tü7{[|9!`e?z8r!åöS¡‡5O˜âk2it0c…St1tùKĞİ6%oäO™óÃ.ö!h›‘t}¹$;qÅ°¨í=ÈxãÍK;/¬jÿ`goyçggaŞ5ÅÙt½T4J$5C$ãÆq(i!Qï
=|FL+{À/z_vVĞS§0¾#Ğéòô{peïQ)¤Úè»·Ig¤{W+ì¤n5Í¨¢±§Ì@Zª}Nìbhè{¹ùñê¶}1¡fJScdˆĞhìoz22	'SÁ@avS9Oz ³J=ì ÷°éægåœË«-Ep)<V
,<Vq+Æ5RY]õU„ M&_ÀÑƒ/cf8¢™”aÀ”¨
±t'e®¥ñ¼,M)aÁiX&<fqÖFHËMj26î"SøÀ–XÖB_Ì)+äï*I^»ìïP¶ #çšu¹Æİ#äA:á~ XG($E?Ï TaÆku ä: -88Tó·ÄÛYOitşvÖT¦ ÒÜæ5wpS?ÇÉ)9f?²#D ¦$j<ük/eè!UåNv`”bş´Ú9 ­,oôå^C~tÎbmèw¡d '#ïQ¦sn> ºl+¯u³MYUdó%M^c0®ÅE2wƒo6Uÿ=
?K5	ùŸ âVİæc=1íºWpîº« PJ7uzXÜ
>y™k&>Y:|I¼”ZetxêüyŸ+å îd7see™æ“VS tÑ¨(4%¶^KÍÍ.yg”|w_ş	ptØåOõKê&c_?L2`52Sò«_ìoê;ñô|:lL8şAÎu) ¥E”%òœa&@tfx±{j³uï~gàrõ^‡OeÊ@B„^o]iêÀ+vˆgš—98j0=‰j¤35qGrøE‹Šúäs¹y:	gl”Móáq=;¤×E*f«c'_Áº¿ÖsÅn)­É(:aÛ/`@b)µtvá«VgDãww1¸0+“.šësgu(“cjã~rzçå_Íi¬Q<¤i÷naa`¢„ùãàeij/X¯¼còì:üu&O¶Sı2’×³E7.ùnfb+cš}Üé>pë¥`t£H.ôïmğçm£æRİ\AO)@iû§F\}(oöÛA\ïd&n)#ó9qE9ö}Ÿt*“:fó'{nüjr«rM!ò©pPUh}nÓ`lcyG1ä!¦O ËQåBuMræ$åªcmÖJ*¥|ymÄ~<ğ )Š:4êc¹Ï±çñœi7Ò¡\C3 Z0çqkĞÓ	$3ünÍDôeüá¶VçØ/*e}g&ÔXİĞ˜zurê­»-şs´÷ÊÛäìU–¢iî¸dX‚Æo{«\/‚¢Á’x½xMãŠ~|—t<¤55JF
Í™AÅFk¥½W°vaéptä á„m<ºçj;ûÁUpÂ²ö~%m¸jÂ­ ²°zHä[BÔ¢Ğë(¥&³]@e\e'¾É^ciMf¦i86?Iİeá	/_o{sˆ_«/*dSâ.&¹:-`­b˜‡Ihg¢M1W<º©_;l¤H}3R ´ı¨sªmÃ¸¼!xy¨m1¸;oø ³gaAÜTbx™)£Ù16}-9QŸÉ`Ú–v~É01Ös1_s4L©ığppj„5î«%å4£<y@ÓŸ–»)jÀItìÆ8jh 0[İµÚTò 6)Ù‡ÊK&;îqÕ"(õ?/xÍäf5q ²5¬BGÙlD]øÏsÚLJ³‚+Eµe
zÚ5ä,Öl9°øY¸ºk~øÈ½÷báçùolã53+>aódD£=Ÿç k1íË,pº1Ğ.-w’c	0 tá;$Ù7Qx<BRaraÀ,|Ğ!åL×/6ãjw¯5È>Òrï o°q¸Jª0™ô9n'a,!xI07E(ıv8?&gG:FîğÕhn\Áa0å,>öm^ëpüg¯Ù$árh­ğœP²\á K~u&¿Eèn
–5îía()jõ9pF%7lö §°¢|xDpçƒxäK{xDÈä¤,‰Q™']v¸nÙ÷tkv‘ºaC,HVBªff«s&çµ>VVT&¶oáVÀò(\o4IA²-K7eP!6iÔu,jÆ_]éà<2üec4cü0ÚT8S±ôRñ´6‚î<ÓÌnBä)ìV±Û&}.g‹ö^ƒ5})ñIä«9±7Oe×}|(a!hvé7ôñ5aîÉ0÷‚WTŸv	ø,pG‹m!ÓK2¸eÍĞç=é´b*mkê9 glöTIÅm %£Jûô´Ry3é’g?#o› (:b~Éw€$¨&Te,TVíè$Bc“x!Um2ÊY*®_7¬Íájab:?wÏ(yÄàvX‘ùx$Š§R"tVèVùª¬ OOjãä•K	FZ†¦—.¤×{#Õ¿q”­şÁ;Z^T7ıè~"<LL0Xær#µ;Ò<O%S#yút$4”|ªFğ{Ñ'›+#~Mø©Ï¯Y‚tõbr¢fúĞ§`"2úÿÔ>„p¤*av^;ÄEzS¨g°ôĞirgw!`Ã¬R³äì6{xQã¬àhSç¾XypŸ‚m`"æTÀz“S¡te té"eUıİ7i¤„Mh^r8‰…N+"*n.N¹t>£N±$¤5‡@Mè˜·uRe‰a^3 6 9 mg.`«°2heUÃRjl	fiñi.i‚lÑÚëä{Û/ŞâpY%CÂN\g6bñıL(ëRj÷@(¯jAqhÌ%ìÇ-d'p%À1Ïp¹hßï¾GÒ1VÕ6²<`½’á}£y)ÑÊ2•«` vFW"voD
8j-ø8jüÄ‘
Ç#-2³Ş50!£/ªMmúL}ÚYÉ!(AS.£:.d®TzNz•~bµk]Â'¥=Hnf³õ1&sû ø¬ºK#,N¶} @G G(lwÒj@<ç$‚Êñ:¢A“¬éôYÅÙà:ut[ ÓÅ/#` 1›a úª**oaš¬R"¥ı©1{8÷+ãbåwróFv3=n~*E´àŸ3%íÎq<‡ú"~fşï:©b-8r4,Ùûe});_#BGÎLmâa˜	á/<5¿/ÂlÓÅ	ótIëTeL+58ª)x#¦ªxk9nJK f*í1aè¿YÅ- ÎGSzEu>*ve=!6y(
BAg³ñ"%ÈgUukl² ¾-sh&jiúa!w…4x:
cä¨•"TqÛ\\­mZI‚üôıc"¤ÕÛ(Mù €ábá"ÂÊ<áIGC}Vzt|%Ô“ÃªH
ücå²zãrá$ó$s‡N}ª'£Cui“ÎÛê}(Úé5a³%è½j-w7ºö_3(àiqp4ròsôÏ+½#m¤<d+ıp#1ê_pˆÒSÆzÜfsqª†u7õÕ{òyõ x‹bFÛe"Upú*lÔ%¹w,[ª×87fî²ô!l\rjê­©Ù
ƒÆ.iwoğù#1AXpe°ğÖÎ.pñ-AŸ†A:ö2![ÄÁ=h;mn~¦UUR§Ğ+vjQñîr:_45`í¹%Ì­?ØÉì`HÙ÷`+w>uÜÂó+ñÂò`F3}ï9û'V3³¸mB__²xtàsE@°^g 9)#5[sª¨-ó×¾Ek£\ÓŸ6>¾$"51 pm5aepÔväçÜa½[pOÉry*4lkrõš)üp!tIG=c^z:à)zÈÚ@¢à¥T÷îşşÿ³$é7VR1œqtfz‰µÂs¤(ªŠ)0i§–$²>l¥F·%``ş"Í§Ö4Vµğòq4dy[Éhct]tgòª#%pvpš½Ôb‰¡vrY*²ë£@n;0-ê`Zµ¦ 5v\<Lê¬#9Lz?DqºwâÚT·$ÂlxY9¨êt5Ôé %o!(Ä¡îÿzY'myÀ£cÍTm1!;«†%ÉO;pgî!Ë¹(czGny·ß¯uS?÷Ÿçõ4y×…‹·ÙU…#‡İ¡i¤fZ"e81Ôs?«Îs9Mlô=ÖwóOeb1ãĞ!éû5€n6n¢DE¦7¥f[%sSÔç+(»T`‚/!oøu3X½§á+nDw³9È³"ÕM{b' ikæ-¡áRñ¿!1¼`¯{áúy6)-`©-`şæë?P»lmS¡ò,µAR)ûÅÏ PS"{n¢3ç,¬}i\–GĞÏŞ| ;—× •gp¯tC û]^Œy'NFD÷qæxc2/*’i}ğ¡-ªs\K
Y/åx~±=FT(B{ò ü<y ]2=E1åjûboIiy/¸
|P¶Z`rEúP?‡×" ÚQ¶ U(L7$¬pEi•1œ!Q<çè¢n‚ )k#(öìYuËvëMöp,uâ6Ïá>Ik¦|S:s¦¨¥¢ÃYniAà`P|yv±ë+]=~;j],›vJ,4iÀ¹šºO1nŞDv;"2½â%¥ÉF#µcd`‘§"Å;}âÒ (|G…W0ÁCÈ`l]’³Œ*iC‚XäbQTg$ã„»¢¤wQÑEéD°b9ê7íH2É®ü§š:_T	¼3ĞEA³±îzŸvºd~½<´¾>€VqrmuuáVuwö8gY@}z]-l¥Sp,Ğ1Éw®6P";MÒšşzítU;×ˆIÕês6œW84+|…c=Ô4\ûbóUesdáPu6(y` qA.Î}ñ…¼€ıô¶)j±>şÃ†=(Ğú·\©i"Ÿ›%nå=!øM5.4>©¼(*²1Ò-œ.ó*1hö$y7OJğ°?Ég[y›ın?/q".9-î¹ê$6YqJÁ˜?rxçy'x@L 4}g|[})òÌ³Õ¨f¥6)HD}İi©/$y!/3e,]yì,¨ô[={›Ü¯Dn,¡?¬HMõ/™"ß)Ú_1£$<,ë˜-œ…%¬yç()(Zy*¿kY9`wìpFrêgv[SÉ~Ït‹%cç b›óÂfø¼Õ¹z¸ßDh,^m!Àe*’1hQá6¬aa.X(q4z>ˆD²aF<;6wñlÈ­ÓA>g©eX™
¶¢ycîÌbıbŞc+Va=p{LT.I<ä+Låo%7'%xügû4„0áú-5Åp#öº<.ˆaT.2Å±@0Bd7PLÓ9b,e”ªû@, µ-@a†æ\3±j<SF'P3{ìâqa*jÊÑÆZåEMHv”$ÙEwT`wRzbÓpn ÛİZ‡Hxºjâ9ô+,rymn	b¡yjğç§Fs¸uá´r¨dZY‹{D1Å}3ØAAæC¨*sp!V_wKLuYm‘'g0Ñk[ßè52øDmwaI¡kêm6)×/¨tè›ù$o4ëes´w)hjëI“6+Â…ä/$+Aiâ?,;mOšvà F²x~¾¾š&ÙïÜşóíŒPç›'oCk2¤ph{µu¥ãl÷gzÈ|WØ”fF{Ùty-ja ¦lİ¾Ó  E³
vì`ˆ¥XÂ!+lI¹LY°tjlDçJb‚|[zñ¼/{/IæMcî6^{ÂÁÕl‚š&eäÇ#ı•i°Àøâl!¶ûiNÀ?et¨rm:8‚F-M V8ó
­Z¦?óìmkãXæÓAm‰Ülïz {"ü!hŒõàDmˆmC‡íìzËŠM+ucÈ;fúÛÊq:îwŸ[´$uø!´<ªä@(sy.ê3¾aa…Róè`… çÄO•ÏRóTòu:‚Mz¤êKåçMÔ^W&¼4®zà@•`ë
W
Q&ÌKJHÛ#t7ÍxeÉD µ@IÎTÙ`pDf<¥èm(y]3´ç!1«i &a*SÓ¼MHmŠõkwÔb&¬¤²	sàŞJªüÕ¤æ®Û@¢Knc®]w•P'N}1m 4µ\}E„Wjä»§9rñ;4M<¨*3wg¸÷Ç®Å6Ğö›iS ¼uğáv.¢FàNĞ$6·¯Õn¶{Ï:à©²‘KWgµ[PtDó@z‹±ˆ7a½%Ù$òF7>ùGKAäòôü£ãt¸/l%¡Æ¨¨º÷Ì£™~üíiz7>zş5Pí/Mz@t´ØU^6lìrÿ¡A‚Å`Igk6@²]©d4diÛá2ñèz$£:€,g%sŒ"¶×”TÂ;é­øN;'Lö
%ß:³Bg0‰zı³|‚iø(qPàcæ) DVp$î`uD÷>úPsF…%ï)dÿ·éàÓJ'#ØM¥Í&¥íıWd§=¥÷Ìc±dt)>.ZìM|ºÙåÍyÛû'®ë6$ÏHàG|íPŠ3?ğË¦6şÖ2=^r¨¶oŠ<¨åLivò5H+u]ECáïg0›âA
Zò!`z&ynqhgğurÿFOs5,Q¦ã­ıUnXFìùeïgæ¨¦,Pn¡ä(jìÎ<»‚>•f{ú÷N? JW¹¬j»!Af}!_Ğõ½ı3<q6§7é®5Š1ÍY xƒ_°vK¿zhÅi*ºukeéç¢ÁénF%ã¸)#3h±:øu9"`!{ëÚ_lDFòTüJM¦dµq‘%‡n7 şUŒìM)¥cihxÁùrtäXg$a½~> M¹D]*Rlö$W²/âYTñYï"3ı®)	16izT1 LIåA"Íc2œÊPrÕ|’N _págtq¶XNuDßxúCÛõZP@!Iâd­:ÂãIR£Wp®éq$Qi÷Á,ûI§üàílÏ &õ6'kl“ı5uaWeÜ›EŸÃ€´x#[¯¯a8âsí_7äH,Ê{çBf(;ŠÓ ap~Bm,sñ,u§2/4í„…”#1`oIiOm.eoqçAntç]NøaM•vb|C:–y.¯MsçC[ÿpuşF-ÖY~×kD—há :yË¬İ—öe´µúbòºlm~oXtêşq¤b°&ûK³÷kíé,t& ²j÷¯åÁõCÍ8D)Q@°:Úxs4·uB1
>)n4¿.")$»[8“Nx,_cËsàõ¼ÑmN+Ñİ\ì³çfğ¾õy`
OÚ"èIv% âoñô"n]k¢­âWS	´rGf%3¹Çc]QqóbØuÒùÊa©Úvû~—ßm}ô|˜5~!k¼ShO’Ä¡Uwy.$’tg/?»34Ğ>*t='>¾£Ù|&ÁA`dJÈ&ylf} åz)îQÏïıÖX(•Éˆ 5)@GeiıSÊå THKW%8Äc@zA/½*#a]ô+1ÜåƒŠ,`2m’¬lÏQgH“m=Ç$Ô6bHn)dWÑ*ä$¦ÓuN[j¢o>@ï„¦?áZo c%—.FÖ»/=;V“` `u`oO15º}ûl h™0AÚkvl`T¦`ñ—m/ÉWl7s~l·[q}3N¥7œ:şÕİ!ãú<¼õPJI¨½p&q*< åuÕn1Jı0w2!myP@â@ÌqiG¶Z#Í$PmöRädö)\~áëuÑ¹…dÔTh*l¡ªiŸf÷"t7ñ ~œNXaøáĞ-Q{uNg¬U â¹ õqp7äKF¼a- ÆÔ`ãL)ÊGÅ³i$¿*”ÚºêId±¯sãNL~ªõ G²&½¯>kV}V
º»já_Fì÷C¬Aø5è¦é%bå­µ-QÂÒƒè	8ê@:4b
!eT3
eò%,î³fGrc#ÿïèw£$D$Wrº`'øO<{™t{;¸=*$‹u#{@e[”$`õïyü“seHe£}ú­ï%6_ö@Mû-ê9ycqg¢Æ@/auTøØ³ymãeidĞYNŞìc8ic-T" ¡Íl`èbÚ÷,¤Ôé™püÑáÃQR~™.s?R×77vuÉæ2xxë@e¤÷^@!e]~!¸L-69ıº.e&z8ÈÍıÙ><SûelE`fáß|(x=4ãñ[t;d"0{÷zcpp£Ø&bšLs9Æfbôø‡´iqd.tDôi®Û+ÕÕ8V=!cŠ,ìK/ALTRÀñ0Eöyreàx¦Ä7vÊ`yÃ%±l÷3¢êEìQ¨¨›Œx'hE+š„ªF ãÕ[Qû®B©t½wÄ$c„Aqo-híÑkq	(f%GBl`næ±[ĞsA@Añm8)Sòbp'Da0aÀè97x’µh, !>›®zTKxJI¼tA#U mF j}ciª{Vx}­NõèÂ8$°˜í¼ø.7êñáğPu!yck4yiì£aKl0²¢!şújÊv:Dé7cv#d¦S#Pmps«p/z<,¨¨+H,6g7£P*`àÖçcew,35ÿ¤íú€ú5O$F
B!ª,y§øIb5²-°j¸#»™¬Q±y2<Yõ@GUø‚æp={Q<W¤ZqFc¼å;rGŞ©½·0"a!eH÷%óE  =É×Y9RšÅíïÈ9p—;[A-"tÎe!+$ÊzsuA™@·TiÍsî%éğ#ëeq~b0M!Õ t
9J>iá'4wÖéÆ@Pi-ôˆïy½í,oĞ×d J9´uà}k7$3ÅCš‹gP¡5—Ïµj,#´}™e¿wğ(°ˆl)§ì°:j`.[†pjrOákEd[2íí¸¸Wnè›0öRáveCÉ±şYR!SyŒIí²kR Œ.şNWj¡™!S`(jv/f{É
ñ½@¡x b²¢H²`¥*;Y47µ(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range AssumingOp::results() {
  return getODSResults(0);
}

::mlir::Region &AssumingOp::doRegion() {
  return (*this)->getRegion(0);
}



void AssumingOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::Value witness) {
  odsState.addOperands(witness);
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void AssumingOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult AssumingOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseAssumingOp(parser, result);
}

void AssumingOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult AssumingOp::verify() {
  if (failed(AssumingOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps4(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('doRegion') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return RegionBranchOpInterface::verifyTypes(*this);
}





} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::AssumingYieldOp definitions
//===----------------------------------------------------------------------===//

AssumingYieldOpAdaptor::AssumingYieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

AssumingYieldOpAdaptor::AssumingYieldOpAdaptor(AssumingYieldOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange AssumingYieldOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> AssumingYieldOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange AssumingYieldOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange AssumingYieldOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr AssumingYieldOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult AssumingYieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> AssumingYieldOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range AssumingYieldOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range AssumingYieldOp::operands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange AssumingYieldOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> AssumingYieldOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range AssumingYieldOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void AssumingYieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
 /* nothing to do */ 
}

void AssumingYieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
}

void AssumingYieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult AssumingYieldOp::verify() {
  if (failed(AssumingYieldOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::mlir::success();
}

::mlir::ParseResult AssumingYieldOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> operandsOperands;
  ::llvm::SMLoc operandsOperandsLoc;
  (void)operandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> operandsTypes;
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  operandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operandsOperands))
    return ::mlir::failure();
  if (!operandsOperands.empty()) {
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(operandsTypes))
    return ::mlir::failure();
  }
  if (parser.resolveOperands(operandsOperands, operandsTypes, operandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AssumingYieldOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.assuming_yield";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  if (!operands().empty()) {
  p << ' ';
  p << operands();
  p << ' ' << ":";
  p << ' ';
  p << operands().getTypes();
  }
}

void AssumingYieldOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::BroadcastOp definitions
//===----------------------------------------------------------------------===//

BroadcastOpAdaptor::BroadcastOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BroadcastOpAdaptor::BroadcastOpAdaptor(BroadcastOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BroadcastOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BroadcastOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange BroadcastOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange BroadcastOpAdaptor::shapes() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr BroadcastOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr BroadcastOpAdaptor::error() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("error").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult BroadcastOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_error = odsAttrs.get("error");
  if (tblgen_error) {
    if (!((tblgen_error.isa<::mlir::StringAttr>()))) return emitError(loc, "'shape.broadcast' op ""attribute 'error' failed to satisfy constraint: string attribute");
  }
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> BroadcastOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range BroadcastOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range BroadcastOp::shapes() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange BroadcastOp::shapesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> BroadcastOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range BroadcastOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value BroadcastOp::result() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr BroadcastOp::errorAttr() {
  return (*this)->getAttr(errorAttrName()).template dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > BroadcastOp::error() {
  auto attr = errorAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

void BroadcastOp::errorAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(errorAttrName(), attr);
}

::mlir::Attribute BroadcastOp::removeErrorAttr() {
  return (*this)->removeAttr(errorAttrName());
}

void BroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs, /*optional*/ ::mlir::StringAttr error) {
      build(odsBuilder, odsState, result, ::llvm::makeArrayRef({lhs, rhs}), error);
    
}

void BroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange shapes, /*optional*/::mlir::StringAttr error) {
  odsState.addOperands(shapes);
  if (error) {
  odsState.addAttribute(errorAttrName(odsState.name), error);
  }
  odsState.addTypes(result);
}

void BroadcastOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange shapes, /*optional*/::mlir::StringAttr error) {
  odsState.addOperands(shapes);
  if (error) {
  odsState.addAttribute(errorAttrName(odsState.name), error);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void BroadcastOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult BroadcastOp::verify() {
  if (failed(BroadcastOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verify(*this);
}





::mlir::ParseResult BroadcastOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> shapesOperands;
  ::llvm::SMLoc shapesOperandsLoc;
  (void)shapesOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> shapesTypes;
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  shapesOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(shapesOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(shapesTypes))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(shapesOperands, shapesTypes, shapesOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void BroadcastOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.broadcast";
  p << ' ';
  p << shapes();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << shapes().getTypes();
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void BroadcastOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::ConcatOp definitions
//===----------------------------------------------------------------------===//

ConcatOpAdaptor::ConcatOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConcatOpAdaptor::ConcatOpAdaptor(ConcatOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConcatOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConcatOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConcatOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value ConcatOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr ConcatOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ConcatOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ConcatOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConcatOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value ConcatOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange ConcatOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ConcatOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ConcatOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConcatOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConcatOp::result() {
  return *getODSResults(0).begin();
}

void ConcatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void ConcatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(ConcatOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ConcatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConcatOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ConcatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(ConcatOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult ConcatOp::verify() {
  if (failed(ConcatOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps6(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps6(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps6(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::LogicalResult ConcatOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = odsBuilder.getType<::mlir::shape::ShapeType>();
  return ::mlir::success();
}

::mlir::ParseResult ConcatOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::shape::ShapeType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(lhsOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, odsBuildableType0, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ConcatOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.concat";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void ConcatOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::ConstShapeOp definitions
//===----------------------------------------------------------------------===//

ConstShapeOpAdaptor::ConstShapeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConstShapeOpAdaptor::ConstShapeOpAdaptor(ConstShapeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConstShapeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConstShapeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConstShapeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ConstShapeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr ConstShapeOpAdaptor::shape() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("shape").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult ConstShapeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_shape = odsAttrs.get("shape");
  if (!tblgen_shape) return emitError(loc, "'shape.const_shape' op ""requires attribute 'shape'");
    if (!(((tblgen_shape.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_shape.cast<::mlir::DenseIntElementsAttr>()
                                      .getType()
                                      .getElementType()
                                      .isIndex())))) return emitError(loc, "'shape.const_shape' op ""attribute 'shape' failed to satisfy constraint: index elements attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ConstShapeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConstShapeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ConstShapeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConstShapeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConstShapeOp::result() {
  return *getODSResults(0).begin();
}

::mlir::DenseIntElementsAttr ConstShapeOp::shapeAttr() {
  return (*this)->getAttr(shapeAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConstShapeOp::shape() {
  auto attr = shapeAttr();
  return attr;
}

void ConstShapeOp::shapeAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(shapeAttrName(), attr);
}

void ConstShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::DenseIntElementsAttr shape) {
  odsState.addAttribute(shapeAttrName(odsState.name), shape);
  odsState.addTypes(result);
}

void ConstShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::DenseIntElementsAttr shape) {
  odsState.addAttribute(shapeAttrName(odsState.name), shape);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(ConstShapeOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ConstShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::DenseIntElementsAttr shape) {
  odsState.addAttribute(shapeAttrName(odsState.name), shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstShapeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ConstShapeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(ConstShapeOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::ParseResult ConstShapeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseConstShapeOp(parser, result);
}

void ConstShapeOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult ConstShapeOp::verify() {
  if (failed(ConstShapeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}







void ConstShapeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::ConstSizeOp definitions
//===----------------------------------------------------------------------===//

ConstSizeOpAdaptor::ConstSizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConstSizeOpAdaptor::ConstSizeOpAdaptor(ConstSizeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConstSizeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConstSizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConstSizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ConstSizeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::IntegerAttr ConstSizeOpAdaptor::value() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::IntegerAttr attr = odsAttrs.get("value").cast<::mlir::IntegerAttr>();
  return attr;
}

::mlir::LogicalResult ConstSizeOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_value = odsAttrs.get("value");
  if (!tblgen_value) return emitError(loc, "'shape.const_size' op ""requires attribute 'value'");
    if (!(((tblgen_value.isa<::mlir::IntegerAttr>())) && ((tblgen_value.cast<::mlir::IntegerAttr>().getType().isa<::mlir::IndexType>())))) return emitError(loc, "'shape.const_size' op ""attribute 'value' failed to satisfy constraint: index attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ConstSizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConstSizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ConstSizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConstSizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConstSizeOp::result() {
  return *getODSResults(0).begin();
}

::mlir::IntegerAttr ConstSizeOp::valueAttr() {
  return (*this)->getAttr(valueAttrName()).template cast<::mlir::IntegerAttr>();
}

::llvm::APInt ConstSizeOp::value() {
  auto attr = valueAttr();
  return attr.getValue();
}

void ConstSizeOp::valueAttr(::mlir::IntegerAttr attr) {
  (*this)->setAttr(valueAttrName(), attr);
}



void ConstSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::IntegerAttr value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  odsState.addTypes(result);
}

void ConstSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::IntegerAttr value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(ConstSizeOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ConstSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::IntegerAttr value) {
  odsState.addAttribute(valueAttrName(odsState.name), value);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::llvm::APInt value) {
  odsState.addAttribute(valueAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIndexType(), value));
  odsState.addTypes(result);
}

void ConstSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::APInt value) {
  odsState.addAttribute(valueAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIndexType(), value));

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(ConstSizeOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ConstSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::APInt value) {
  odsState.addAttribute(valueAttrName(odsState.name), odsBuilder.getIntegerAttr(odsBuilder.getIndexType(), value));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstSizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ConstSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(ConstSizeOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult ConstSizeOp::verify() {
  if (failed(ConstSizeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps7(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::LogicalResult ConstSizeOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = odsBuilder.getType<::mlir::shape::SizeType>();
  return ::mlir::success();
}



::mlir::ParseResult ConstSizeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::IntegerAttr valueAttr;

  if (parser.parseAttribute(valueAttr, parser.getBuilder().getIndexType(), "value", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::shape::SizeType>();
  result.addTypes(odsBuildableType0);
  return ::mlir::success();
}

void ConstSizeOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.const_size";
  p << ' ';
  p.printAttributeWithoutType(valueAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"value"});
}

void ConstSizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::ConstWitnessOp definitions
//===----------------------------------------------------------------------===//

ConstWitnessOpAdaptor::ConstWitnessOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConstWitnessOpAdaptor::ConstWitnessOpAdaptor(ConstWitnessOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConstWitnessOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConstWitnessOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConstWitnessOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr ConstWitnessOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::BoolAttr ConstWitnessOpAdaptor::passing() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::BoolAttr attr = odsAttrs.get("passing").cast<::mlir::BoolAttr>();
  return attr;
}

::mlir::LogicalResult ConstWitnessOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_passing = odsAttrs.get("passing");
  if (!tblgen_passing) return emitError(loc, "'shape.const_witness' op ""requires attribute 'passing'");
    if (!((tblgen_passing.isa<::mlir::BoolAttr>()))) return emitError(loc, "'shape.const_witness' op ""attribute 'passing' failed to satisfy constraint: bool attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> ConstWitnessOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConstWitnessOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> ConstWitnessOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConstWitnessOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConstWitnessOp::result() {
  return *getODSResults(0).begin();
}

::mlir::BoolAttr ConstWitnessOp::passingAttr() {
  return (*this)->getAttr(passingAttrName()).template cast<::mlir::BoolAttr>();
}

bool ConstWitnessOp::passing() {
  auto attr = passingAttr();
  return attr.getValue();
}

void ConstWitnessOp::passingAttr(::mlir::BoolAttr attr) {
  (*this)->setAttr(passingAttrName(), attr);
}

void ConstWitnessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::BoolAttr passing) {
  odsState.addAttribute(passingAttrName(odsState.name), passing);
  odsState.addTypes(result);
}

void ConstWitnessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::BoolAttr passing) {
  odsState.addAttribute(passingAttrName(odsState.name), passing);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(ConstWitnessOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ConstWitnessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::BoolAttr passing) {
  odsState.addAttribute(passingAttrName(odsState.name), passing);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstWitnessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, bool passing) {
  odsState.addAttribute(passingAttrName(odsState.name), odsBuilder.getBoolAttr(passing));
  odsState.addTypes(result);
}

void ConstWitnessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, bool passing) {
  odsState.addAttribute(passingAttrName(odsState.name), odsBuilder.getBoolAttr(passing));

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(ConstWitnessOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void ConstWitnessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, bool passing) {
  odsState.addAttribute(passingAttrName(odsState.name), odsBuilder.getBoolAttr(passing));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConstWitnessOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void ConstWitnessOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(ConstWitnessOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult ConstWitnessOp::verify() {
  if (failed(ConstWitnessOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps4(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  retu:L$ª5aa*ŸiÉ{g)X©-/èèŒÊ –d¡I"†LEááÃ°y¯n¾°ú§\½OkcRsbt:HË7ìaÓÇÂ·&gq‡2æP
>êùÿz{İ£ÿhòo~Ì`4)OlgTÌ‡{/@?DÔªt=58Ÿ)¹JşşàüíZ>4táR2Ú§RÔ
)Mf¾ÜÛoça~	kŞ‘‚U=Cw•öà¦ö—S»?2~:m	Ü)AUe{6ªò+KÆ(4²ƒ`ƒw4MícĞbZÕu}L°ØÀÙZNYéTóù’3’(;¨Ïò³h‡n\xĞriD)b[G{)„rÒ¼$èu³šBC”",s¢0)Ê úoT’gÌë_1GU9ğIk»ÈLLrÈ]ğwæî"îı\ëÛL$Y*j@>
BXbéÎİDl>y%ee¿Ú%3ÏQ•ªqª‰'`¸dõrºrZøİT¼ÄGSANFSˆÕÓ'ÅaiLÚáâ;ä#,©«K®Îã^¹ŒÚò òãeOòBDn¨u[pıï*yôjÍpµ,­yB\Ÿ@÷‰¹ş\éÀØ˜«ÛN8RKú{“´däÔvpñ"	(•¿–$Üğö`9C.‚ñ?ø}Õ;41O rjFPD¥‹.1(²ÛTî#÷xœ}Jãl@Wßµ<Ğ Ğ¢ŒKìŞe4Lüãó§Ù¾x±Ğ2ÇhƒŞlì	e˜?äèaºÀ]>>Wôûlø¦SĞÖ@ûò69JzæEÖC¯>Æt18$$gp2~m>+é/¡¨p¾¼À?ú$pÕ'îÆÆhlø±îFpRŠ~µzqõSK ÌR‰jˆ«åàÄóªäI"ã*d´q-@¥PÅ.èÃµ×t”£Ø¾¢?Tyşso[<9!|`wx«~%eâù“çİ]Ü¼o§iºĞs%S34óIĞİ6oìO™²ç>—åp‚ÃT=.»uÅ¤ší9Ê0¡ˆ[{'®N gæy§3Eo`Y;ÍÙv(B$4-Ç"1hi—Á«
ı}FÎ#sÈ/û_wFÔÓ„¶PîƒòÈ8Põpad)¦ÒØ³7ÉE„©S‰®	¦*µ}İ`²¹åLğ¬ÕQ]^ìkmèY¹¨á»’'FhQb¢n¥ÔløO~0y'[ApfV}‘Îë5"½HtÄ·°ú¦%åÜÃ«ie@!4V*.~WãºÆÒiÉåP¸úM&•ÀÕC+Ëò9¢ÕÚaÄ‰š8 e¾µå|<MKÙi["ßäQVvIÌMkštö"Qø™ÚCı±?åï+|»è3‚í\÷ãê˜pÑÇéÿ+ÆA:ç(ZglB¿Î°WLÎÆ+u|Àr@m=ª9å5ÄYĞMtÇşIVP'ÒÌç±wğQ¸ÓÉ'#9f²"VÛã¬nŞÙk/áøawUVçÎv&á€âş’Z  í®ôævpzf#lÁòÙWåf'£oq";<¹Ø)Šë™V³M	g@ó¬INs2ÍJÒ€O:…>ZOj%éêœ 2æGÍæb¬µìİ	çWe¾º#Qf}?s¾YÌ‰¾)œë&nY:v}Y<„Ú% àÊğiW;fzê(?`GÑÙç¡KS€ĞÑ 9™<Ä¶>kmõLigÔ|wVúĞ¼İ”cøkÊgAs/Lp`U„‹Vş«Ş¬kn*{‹{±Ü%dMMöê0kE”
Vp[Ìq&‚~7y”{	ót‰âş`àSåÏ§'UÊD„VûèîÆ+Ö‚–:”ıjt'Ák¥#7#JZ¸k‚úä1™it9gj]ûéq<;ÆWE."ëc@º«ôÁv)íAj=íR«hE`)¤ZRA‹®Òg\ãs%%°1&!8©=k¨lë~âX¯ÅMŒi»š-¤eÿ.#dù£à¥mi-<a²­9|œ"¾W=²”O³ƒ5,™O&ª«C˜|ı­<`¯%´u‹H:æï |ğåmóşR¿CMaAßÕs›F]HMæÛA|å˜`nA#isI-çwvzÓ9/¢'{l½(Ã­¶Í°ä‰X!mî×dmeE!ä)$ ‹Üâem~n5M¦e>Ş,‡mmÅ/<%);´j#¹µåïi>z›œJ9Ü¾F3ér¾!4cõnmTô¡úğôS¢P
-~g_'?ÄZõÒØzwRè¡«E-îøµóäË[¥j—°iê¯lØR’ÆOyïTGãH’xºv¨ê››,:Ÿ|l¥<=D	K\JÍ;€ÃFiöµİÎXéxfà²ÄÅ[~œšïbûşÁMUàªvn%í¼êÒù °0ª_TÄOBÄàĞê
¥³]`ñxd¾h^a#uløÖQİ!ãn[ûmc¨^+	,NeAÂn11+}c§s–˜ç]lSg²mqW~ª£[k-$M´’âÔOª{®oÓ°Ò\À<!x[émp­yïø°³fáá˜Vb¼Ğ¨"Ù1¾hE#ÃQŞKaëæ.~ËpqÖ2
Ew4Ì íğúxpë€?¾¯8ç$7MyDóÇV¡{ªË	.³ï†:jú14
Sİ¥úÍãü&%Ù—ÊË"½mqÔo*ñ>;xŒæfR¥â7.ÂÇØïR]¹oWÒHJõ+ëDş¥ßZÛ!ädÎÎ;Ep]¸ºqêX…µóaı;Ç¨ƒG,ã0U¡L6ÇóuãàD£çbisíËô1:!d-3B	DÓ!;ÙÙp9C’avF©mÌ,\Ğ%äI×/?âJö
)é–Rr¯ËM³°Nª9)ÆmV?©•,!èE¨7Å®)f;?b÷7A:ÇäúôHB]gG`7å.h.v(^ûuıeïÙHÇ¨e.¥Ä´P2ßa€A8u®¿Oán
”¤úıc‡`$hå¹¤F4%7, ° ænâ\ºäãÇhÅÌS[ÓÈÄ­ÈëĞ™]oºfÑƒõïòÚaF jRc¢vÎÃógæu¨R&¦'ä^ÂŠ²9Ä.ê·aò)  ³µpb4èÜu[Æ_]©°à<"Ş…!–k¼‚ÊPpR±ğğ¾pkŠîÃdàBÀ(îS,óËg|~g‹öÜC}=)Ó{æ¯9¡?ßwy|#)Iv«7äñ5 dïMI@¢‚×{ÄÕíÉøM0pJQm!Ó[¶É2™eãĞw<ù,f¬oëâ» fl'ÿu"HÇ™œ	 #JÚà6–aO3ÈG}3o ¢’c4ég€ ª¥TA$sUWíÈ$Ècöy¡ıe—çUè¬ãíÍájig$gè,yÔğgjy|.Š¯" vàVùª­²XKNãèÓI*_"›®‡¦ŸDÖ{"Ñ¿o½şÉ;Ş,L'³h!.JL3ær#¿3`ıÏ¥"z|48Ä*w²MĞ{•&ß+3X~mİÈPïÇ Q…tùã"²gêÔÍ`"*ê÷!Ô"{„à"Î€f­uv±^ÁSÅd:T ¼% ïÙcpcVáb‹üS€åÜd{k+eâ,àhÒa¦Ú{òŸ’o#äVKÁjû²‡[à¦ı‰ôè¢mUíÜmhÇ¸¤x–KpK~r8É:B$o#(ÎªB'||'N‘0à4‡AmÈğ$–åÒíaß{o«`¬ 9‰o'*`ë°0ceSÚT*-‹&i±k.÷1’HÑÚg²{“+Ä¢DsO5c’b'¿`óÙ–I¨"ëRj
§à`-CbAãlÌ%¨Ç=D'K|„È7É=¹i£ºmÊ5”ÑœR²uj½‚áVeóyşÑŠ:ÙËc°fJkW#Rï‡
+$ø¨Q|ÄR’Ç[+»0³AQ5³a›/(ALrÊÙ[¡(ÁS9sa|mÎDãnz~½Ãµ*ƒ'ä½Hkc“å#‘/{Û:x¨3Œ#$È•|mO¤rCö,TÒ‹H9Ç%ƒØË+2DÁé“tqÅÙ]±}$ğKaÒÁ[n#pâéA«ò¡j
noúdÒj‘u©0Š{˜³÷kãcïs`òF~÷=^ÿèGÅàŸsåéÍ<Eû#æ®¦?¡r/xv ÌÿSU#+¡ÂWÎemêoŒaå´c¤·)Bì×Ô‰÷`I«Tc˜)l'zªx!¦ºx2Kq¶
EKâD`]a\l¯QåÛ°ÍÇSjÇ”8Kvc!0Ì(
BÁu·Sû'@
?Vr{¬®$t ò .B%«"€#³0~:CaÔˆeÔ#VQEĞKeÊC‚|ä%÷¡*.‘W(Mù ‚áìcg¦Â9éVYCG`ÒÆLJVXdÖ“sÿè´îCÑ¾ûzá¥ ƒZ}¾e§B«iœQŠƒãuXhÈ­5iq1è½â, öpóä[3,äÙsú<2ĞsôJ+½#L¤4fCı0#!ç\1ÀÆSÂ{ÔEîw»¢U"?•İš›òzıâx£rFßg"Õùú*fÅpÑç¬Ûºõ8s gâóğal|rhîMmÉÊ£TN:(?¿dı!7QPR$±c‘úÎ(Şó©AŞæ—:gáSÌàå@{«¨~æU4§Ä9vZÙn#:Oà½q¥LÌ¬oĞ}ÊÌpÍÉ÷@#w’aÈÂÿğÇRpF,‡;ş%Rs÷š9FOpLàİEàv\gó0#aµ›u¶ª¸¯óÖ¾D*¢UóÛV?>ur±0+°8;)}0TæfšCù»ğéAÈpıj1lçfñØ/8†+uIÆ?#|>ªñxzèúŞáã‡÷ìÒìDÍ²&á7EœQ=Ì³ôFkÀ5Áræ ŠJÎ4l¥†&°X*%Fó'`ş"É{÷Y­Àk6¬}H€èctİgÃÂ£)~08¸Ôr«¥vòY*°ÉãFnpXf Zµ¢1sy¼Nëå$y9R?D8EcÚ2¦&ãH}y;¬âW5À˜%®j!)äÓì›-{cmi€ª"Ql!!;ûÀO3cë1Ë±(iPGvwçë¹qcgó¿Ãå,­ÓŸ…ƒ¶Ç†İ±ÁLfJ#aº3¤™£Ê#);MèôıÜwcNÅcq£Ò
3#û€ndk @Eæ#¥f[%ûsĞç»)»R!ƒ?peoğq+P/¡+oD\¨Ès ısj'"IIÆf*cğbÔß 1²aróúéšS2)@!/`ïæmÒ%ım%mK ãiTµÁSY‰½óÅçhPS"{+˜n¢ñk,¬ùKAŞWÓÏÜ÷bIÇ ‘·q$wp¯|Ã$ûmJ,9'dÄ÷bæzcpwaÄe÷p¡(Â Ò_
3Á ;™=^TüJz¥ú ¸4ÓñãMò0e7öbûbïho@¸IıdŞS`rEûğn’×²@ØYÃ Õ«@Ls$W¬ğEa•Q¬só5çè#cÂ"ˆ¡ë#8^Î}I&ìM|pd}UfôÊc2Ij¦Tn2f‚°eòEÃ9géâàHlye“k"ß~¼jÜ,ÛVNj´iĞ©Ùš‡1NêLv{bw]\ê%­ÉF#µe0ÕõaÔg?èÔ,ÒêO¢Zc_;íÆÈ¢d\ÂÈ*øKC¢H$¥bq|kmÃš¹Å¤v]Èg‹…P±â)úœP2Éºä¢®nİ€I´0ĞoÁñ±ï_¶÷¨¬~¹µ¶”TW }‘uõÑR5wwö<gQ@wşM<t—ov,{S0Évê2t¤;EãŸ|zé4W«ÎŒCÑès4ıU830!¸/19‰¤XûrçerSdşQ¥?y°‚±a&ıuóÇüõ •æ7ùJğ+ÛB†yZQÚõZ¹} `oõ¾eóO"Ft>1‘¸(j°ÑĞ^*óTóxØ,$y÷GJğ°
7ICiŠMŞ?_õŠyeş¹‰ê$<YpÌãØGwøã}'èèxÖg]\uKöÍ?§ß°~wèzE}Ía©{ yd8sRÙ-lql²©d{tµkÓÖîdÏ|°w¬JËİ?"W+æ[1º ¾$ú™©g¾ÙOæ(i*ZùîMdx(OŠ0sKM–@¨sJ"ÊGSSi,SÚtÊ'cïdh…‹£=Úfè¼Ñ¹z¸İl-^])ERá.Ó³hKa>.!aPix4œzWVÄ°Wg<96Ná­H-ÓÀ¾ ¨%I“İ›º}CêîÈb­6BÜ“+QÖÈivp»U,Q0ñ*Lç/%¿/£8Ô+ş6pŒmÁÚ-%Åà*‡r=~ˆ)&IMôe1@¬†PL}Ó¼UA(³ûÄ*<¬@`‰à^#‘J=YgU3[|çqqêÂNØÂNeA-HqÔrÉUE]`WR~bËxÛ8¤ÚÏH|¹oh]ô:,tymna°HoôeçEs¹eÃ @¨=BÎŠ:V±Á~HÉiÔB¸.;paRN÷ÌéYnÏšetÁKÛÔèUzÛE$mZc‘¡àívkß­b¨|ªÛ™%5ikUåw$™
ôv)aJïH1ÏÃ ?oAià>D,8…ßmNjn¨òy
x´şš¤Ëïôş«íœRç•âLC‘é6„s8({uÃGjçq—È<sØ'„óu<[ka…*FÍ¾ñ¾m³ˆ6ì`‚ÆÜB(ìi¸N[±njî%§Š\+Àƒ½Súœ q¸7¿/IãÏ³§•î2WjB‘Çvƒš>¥&Ÿ§ÿ•I6€èâI26ëaMÀ/a6(fe*<’Ê­EøV*ãJ­X|ö®gËÇXõªµÓSı©Şäß™H\ ®!:ˆ¸àävUˆCËíäcû‹€I-5*È»"øËÙ:æWŸKĞuõö!”8şæĞ,Çu>jqşa…]R²Ê@ÇRçœÀ_·ÎpÿTàq2Mû¬k÷Â¿T~~B¼w®Úè•@æW
&<‰#ÈÑ)ö7ÍvÕ‰D4%AAÎFÙ
@Dgt¥Álo}^3±ç#©,$Ši®csŒmLgœñ[wÄ	g&¬¤²*n¸ŞN üší%âæÚ@ãÃNk‚üç0>€«m1fA2•|{E%Åjâ™£9bXõIM,‹¨¶Ncüo÷BÅ‚@æ³er0=õb…~®‚DôjÂä|UP¥îÕf³{Ş:$¸2Ó{_F•RVuDZñDxŒ†ë½œbygÙòD7W¹C£…d÷tıÃëìŒG,%Å#‚Îé­DºóLá›><Í!zµ:Şa]í–,LøÒÒó¶İG~2kìbÿ¡uGÆr”ioc7Ä¸©e$hÇõ6¸êª5¡~ mÓ…s¥Ô"·¼â¯Féíªns„Ìæ
eÏiã`‰zñóıÁxø8{T`cæ­bZpb®iUfò:üPE•$Ï/bıŸşgıS*‡'èI¦Ï ¤mÉSŒ`£;¥çŒBÑ9æpù~ZëM<İÁÍ³ÃÿêwäEÎ¡FmÑÊ:2wĞË¯¦¾ÚÑ­B:ˆno‰Î¼¿¡l}uâµ@+MeCÁûgÁ0/æ&@åRò"d;Ç{&pÉWğuæ:ÿNm*•¤â­mU~{Z^îynïaì¨©ä£jb†¼«f~Ê÷V› JWPìjĞ¿©JEeMa_™Ô-÷ı10&.­öéİæuaÅÁÁ ‚_ğvK¿yhÄI,¸µ)”éæ£ÀyÖN4e8	#£éá"Xc`oëò~DT²r<JUç$¼0Q1‡Oâü¼ÎÎ© bèI|Áó2täpf4i”X.@M±À]jRlö,T #Bâ]QUõAï2"í®ø
&16ø`8q$LxäSI3Éc²ÆP#ô]RN(O|Ôt5q·XBeTŞhºÏ«MP@V!i˜àDszÒS’çIÖB¦Wğ¤è{•Åh·ÀÏ.@ñD‚üàílgÔ2´yaLB}7t"W%Ø;Eîã¾!Ísï­I!¾ösÿ_5„J$Ûsõàæ`·‚˜“ mprÃ=¼YôvçcŸ®Q4Í$Œ…–•
e1hÈIeKñT~qeY¾Zç]Oèõ]İòò|Î;¦`6Êq÷eXßvÛD9ÒYvÍÇnDh¡€®YËnÕ—WV!´ôøâººdvéa\UèŞ­‹36s	ëòqíèBÔ' ‰j÷oäAõ
ïÚH/pğÚMs4¶t@/¾(n	¿"&<¹r0	j9Îp-kË÷òõüĞåYj)šXìâfáöñdŠwÎ èKv5/ÖàkÁº!.k ¬õ5!Ÿ ¤zÁ¡9ÏåbÙQõóEĞpÓÙØve­Úvï\“RiQö5UŠ/ş{½ùÌ¥N²Ì'T¼VGy,“aeL>Œ™3%€:#}|¾"ÙùFÁAb$iÌ¢YlD]@S_á:)î]Åï}X(µ‘á+@GCei×Š÷LJO×§<LcdzS°(#Ò1Wrô#qİç‹æ,hM“lLïGÀ‘]?–bÔw&È|*,FÁ*ã
ñGßuF[nÂçDï¦b=óHİ9FV¹/8;v=b"`=n…xJ’=Ëåe]	pá^ÈÂwLcT dñÕÉ+ÙT\3{Í7Zéı ^ÆuœwûõHçú.|¬ı^PƒI¸½r&``y(š ¸ìq×Ş!N}|w{$åqX@Â@ÅQaC¾j\ín×TMvSí¢ ›|áúuÑ­…TÖÔH/Ä³ªiOgwë<p6’wmºnÙU˜ñÀ%Izõ,à¦ ã›êåYpveKG¹"%¢Ô †LªâVÅ·Oh`•·>ŒË
êu|KÑ¯ræN{şªtÄG“?·¯?JVdv;ˆfÿàßfè÷#aŞa“ mÊ¦éEÂÕ©?5oPÊã—Š¸JÀ:$ !±
¥r§ äóFWp{gş¯éÿ«eÂ$UòÛJcîkº *:š«	:%€#›Àƒ%[¬ärõoxü“¾eXU²Äz½me¶şÃUı-ÊyYápg’ÎDoQ}Ğ|Ûr0Mã5iÌD\Nìã8‹mc="@¡ÅlÊZ¤.   ©‰rüíáQ._™,p¿RÖÇ7¦vDÓ¤²xxÃÄ1zäëÊ€1e:!¼}56±Iª.Ä~ú0HÉıÙv>ÓûunEl~À¡Œi©v¹x¡_,¨dg#û÷IòkbõhªØGÆúLr¹Ffb•ñ‡wyy$nTDux>®Û+UÕ Z	šµòëlìŠ/ADD9\gÑ¡˜VÎióåÀx¦Ô56ê`yËe±’<¢¢EÜAåˆ}ŸŒx'(#š ©Æ
ÀÇRZSëXìò¼(WŒ'ØÁ?Sykå(ìÔot	Øg!gBn‡Z¶gsZ"ÑSAHCŒ¹a,¬ƒùcB'Œ~e5„áÌè˜ ' xÒµYlA&>‹¯ZÖyK[¬|I3õamFKb}«ÿ¬{Q|ı†	N{¨â¸ éˆÍ¼ø&'îñá Zv%égë|yYhãiCn2²‚aøøjÌv>Dá7"V«mÖs#@«uJy«v'{Á®‰j«H,ˆ0RgáT*thÖï:e{.34û¨ìú€ş86X@!ª¨i¦èYæ¹ø°j¼£¿¸lYğ3¸<y°DGU;€Æ4%^‰P<C¤ÊñVqıä>q×Wíİ—[ q/a\ñ]UE
§uÖY8R(ÇéçÊ+‰é„+ÒÅopòE`cdŞ:ásAA­ŸˆTR)Í7î•áà!i) *b°Li…€0ùHHüá$SÜèÃ`SKD©ë]íæQ¬ĞóÜä2ê?°Tc]'î52ÕËwĞÚaçÍ³J!&´}!ô6ò‰°€m-'Í0–nh.Y¶qjÓ5OiîdBKíé°ºf\èÛ¤öRp7ãƒÈ±¨iR	Èy5Ä}äº+jìW?j£C‰µwXÅhjÒ,&	H
¤Ó¹Éi|‚b2¢’ µ
7P°w¥¢„4š(Â…2õÎpÆ57¨åÚƒF^¦$(Qy&Ê$æeyè1¥l*ˆ;ÃÚVË{.(!JqDÒrUWÀ’İPO€2PÍË$sè2ï­m ®¿ïÇ×9Z3o.ëkØ2õ«øuÅ»fĞèx‡#ÅW„Úëƒ²u¹âÛ *ŠÊ|M°g(Ê6“Å=qY a!Ë ŞMçdB}O(cµKe7m»úú>ikc¦7Âr€©R4ÕÃÇabmr0I¢Blô¨Rãæ>ıgÅ¨ª”ømE‰))Î•oŒŒ#˜ ‡*­Ê;2˜ ‘İ%êÁPBd,S ( Gtí_b~H«d(ÉP²0sk‘ÜrÚ2ÿ…1İ|&uş c“Å!†qZÜá0%ü×Ÿvû`*ÿa_0:ä¤öDc‰¨T…eH<(Ü‚sËRâ˜Ó¥(ªPëxRF®Au^Ãuf=E/0H`åÔDÈåİúÜã<õßCj(ò.Kßh¾woxH;¢°*ç%z`ÄrªCeDÓ°ü`€	ÄšsÍ%{aÊm”j¤ûå^l¹yşØ!¢w€€³k'9x27Oè0“)‰µ}N’Ã¬²hWÓ¿ÏùÓûe4 p?ÇJ6kØfúÂh®T5|€ ß',!2Œ"&Uq{	p]*dDª6s1;lŸ
io[W‰L©z'èèåÀe–`#a¢N^EXå!¥´y).»0h…­5Okƒrv`B|kd;ø73Á±Âa&ks3a\l
6âøÿzx¾£ÿ>ı=:¾Ôh¶Œm9şa¨…q7s]Ô¤¦>5—(±
zü =mP.4ğ¤Nrk¦ Ô 9PvsÜÚ-çy~	Uaò‘¦V?cWuEÿ"¦ô;Gº5*V:mX(U)+áÖ+G 50ckÃ,mäqsnjÔq)O1D‚V‘éuë¡ò#æ# ]°7`&n\tIò*V!lduÆx),&2MA¼'éÅq c”d3ò$ )Ú$ne|òwDêOÅVe5İ	k	³U_Q_ògtî1ªİD1 ûn¤X]'j P:Gzz+©hÌìm:±,u%©&:`›ú2‰'Q*à4dwöûö\øİTÔ
ƒ @…ÈÔS'os8\ñx;°£.à+ÛôÎb^9ŒŠò é£e
banm1qõÅ\/,yñ"Hp¹,­ØCœYCê‰¹öZÉ`¸°+­G8Vjø
{³´y0",v0ı‚:e½/vœôt ;C. õ;xqy½55N {òuÎTDåël± åÓPÒ	òyü]mb,dQ:Qä¢€I¬Úg0T< ñ%°x¾ià’ƒzó…Wdmmei˜/´me:ĞMZ+W•8äl &SäşAó¶4}J#¦,Í–Â>>E}`2,tg02d).OI­!¨âğ¬°Ñ?öårİâìS¦hfqÕèÄ2@îvwzyõCA¡KNRˆrÑ›â¤èäßªä`Dc2lôa-H`óàoøÃtõv´¦˜÷#1<~Şw{]t+)nevz*r1å¶Û“”T˜økâi¼°:…P2‘0ûiğÜ6gèo™Ó6V,–¡p³—T=™.;cE°Šíq@sãék{%JŸDeäyçtgİ+Mytt4B 5a$BÆ3 aÏÑ(
¼|DÌ"szú_stPÓI?¶ÒĞÈğùùYpaç!®ĞHsµáGdûW«$Gv.3(¢‘álaĞ¨Q]Zä` è¹+ñ#dXc¦l¥Õk¨o~0	6Sá@1vT9Ok7+»H=äv°êæ1åëv-P!<ªf<RãŒóÆ²[Ûõlˆä¸l&ÕVr5ƒ/Ãğ8ª™0aÀ–"90fŒg¾%c¾*mKÁ !<&æÖvH(Mhœ6â(cøé–oŞo_e"+¥çI»è‚ìt¶/«âšt™gÕr#Æa:ã8 2g$!¿ VÎD{u”äD0-->9Tå·ğYÀ_Mt$şxöP¦@Píe±uÁS¿çia9d:'n¦¬nİ\o/¥èaU5­l-v&%”¡ş»Ê -,>¼m~\mä#m‰ê9_åf'#ï]¢<s)>»É+/™5M-İeñ­m-^q2nÉ/Ó#{6eıT?wOiu‰º½"òVÕäV¹5Íiwy®9«RB?/{ßxÌ‰¼-™->Y>|=8<„Úe-øêüy—+o?n))=}g¹í3
W ° ¼M¶Ëíµly/”>w5şÙ<Ø•g¹K.
_?l0`QŒpvş«^Ê~JS3‡q%|%dA:	şeê0) a%ğ[”e&àt"x{i3u=àşb rõŸ/8WÊB ÈVUıèêÂ+ß‚ôºÖùjt6q6j¤25ciryAƒÄòè'b‘i:Y
go–	{)q9³€÷e*f«cdWÁº»Ö,!Ef)gÉl(oÓ;hqbi5\VÁ‡« gãwW160'£,šæeG®(›jJ~üZ	çĞİ®I1š<¤a|n*cpÏÙ¦âik-<¯Çctí:üİ">Uõ·’Ï³“5$ÑjfG£«@º|Ün>bo¥æt©Hptşoğsm+î].CG!dİpûšF}
™Gö[A|ïÄen)#Cy0{(9÷›td;nr/nsjK«±í°ò7‰tPQ`nI`mcYG+ä
®. ÊYØb:Mrî|m$CiÖ¨\[mr^=ĞP);pê#¸)±eóvi2R[Tn3sZg;¡Òr)43|nyÿDöåüğ²SàÒ++8mŞgvTZıP˜kwê¬»-vp4q‡ÊÛ ng– iê¯är‚ÆOyjTr§ã2xëhôëÄŸ|~`—|m5%@J\
E™aEdk÷=õon}Iip~ä¡$„{°¸ëj>ûûÁuB*ônà¸kâ| ¹°úAe{Â ë[¡P³.u@`|e<ÉBkeM|}¸4?U c'_{{sˆf«MLNl Q®'±k%6§a¶<¯hjo¢M9W,²#Z3%®hsW°¢•Õ©cÚmÓ¸–å<2p[ˆm1¼1æø€·g|Á˜Vj™«£C14/qEca6{¶m|O0qÖ{1'{$Ì¡ùxòprèE=¶+9æd#yeSÇ¶ä)cÊI6õägz*âµp*gŸ4úìòã6!Ù¾Ê("-ì!Õ.*ñ7qxê¾æfÑ`26¬cÇÙæ,U¹ÏWRHJåˆ#Eïµß
XÚeä ŞÊ;Ôxe¸²ièĞ¨óbùçñ
o(ã55%Ók4N’!óôd!=<e"{òíé,aºaR-!²"	 Wa:ò7pba~$¨à,,Ğ!åj÷'>"j¤//È0úrïÇ Iò¹fªx‰”YV5é(!¬A 7A"±vy?&¢¶U:ÆlúåHNYÃa2ån ¦ö¤^ypaO¥Ù†-pr¥Ğ¼@2Ÿá I<u¯·Mèun –¡îéCC()hç¹¬F1%?S(ˆ ¢"²¢\:Ä#ïƒzLÉR^RÈÄ$Î)Ñ™IUl8tÙÅõk,ó±šaApHr@övn‰ó&ãu¾^/&¯oávC&(„*·Ea¢-J D·&Pc6áÖ})æWéà<cŞÍa&+|‘ú00C±öñ´t€ï¼uÄtbDhlRgÛ7<güHÃ=}=qwd£;$wŞew}x
#+hô¨7àq-€eÆEÉ¶‚ß;äl‰x p:Ûm!Ó'”92šeÏpu;½¾b­mçêó pfm5/TsIG™œ)2#Jóä¶¥yO3ìG5{O›`ª–`;Ég  ª%TQ–3ÔS­@$Ãc<šh¡9mÊ Yá®wäŒÍahie0$pÍ(y–beÚ‘ùl$ë/0"0V`Tsª¾¢XOJëJ—)
Ú†®—6¯Ä÷#á¿´=ŞÉ;ÖT]óàw 1>oL3Úçr!%ÒíOe¥#`Ú<$,”".v²n{8+#<jE4XÅÏçyEvéâc¢gú@‡ "jø_Ö1„`¤”@<dfÙZÈDzT ˜eòüIcpo^¡bÃäRàä\4{|Qêbhse®Ú{÷Ÿ¤gĞ"dV+àH"y‘…S`öıˆôé£meå®7h¦˜¤X
`wVr8‰ n 9îlN:||©n>¤s‡aM`¸^•uRå‰az\) ­ 1o'&`g°0hdWKPzmMfiyi/÷,‚EÑÚãfyW+Ş¢sm}cN\eîbãİ—&m Ërj4Â`¯ƒ">G'»HÆ%ìg%F/+x€À2O=¹yßf¾EX1VÖ6ä}a½á
}c{ªQJ:kkøv^]"Rïc.b-p¸P|âÅó³Ô5òa/ªM\ğOxÙÉb dÑ?¡<?L.TòNv•~ —l}A7å½rn"¥1¢.kÙhø®º#,n6l'¦uG}eLvÒH=G$‚pÙ2¢F“EëtqåÙày&pk`ÓÁ¾ui"™A«òy
om;¤Ò* ı(1[>+#bãwbó,v³=\ş:MÊàŸ»emÎqp‡ÿ9dîï=+r'8R4,x{RUf96©âG×Maãe˜0é/¼]½¿ÂúÑÂ©óHI¯—Peœ+Lzªx,#®¢hK!¶BhKâFhM iè?YÅY I%ÇQ
Í•4ivG 6ì(xBñgùÙš&è*?ubk®º ş(ñ`ncg?‚#$4::aDªR•"TUûÑ^leæAÃ|ü'³ã*®‘Û M} Àahakêi<ë>iGB}RT®ŒJVx%x“Rëëè8ü$a±0²l{rñåA‡Z°'¤Ã.i‘
›èua(à­5m± h¿ê,s>yöC3hàMqs,2òwôO!½#MdœtGı41abQUq¨ÆSÂzÔdns2†}‚?õóœ?òsõâxï*Dßg"0Ú*2fÔq‘õ¬Û¢Õ¼4 fâ°ô!l|rjj­íÙª0ÆL ¾`w!rAPR$p©òÖï,_ñåI–¦:V2dSMÁåH1í¬^ÆÕ4bnĞ8vJñ‹n&:OTè%¹½è­wPAd`ÉÙóD+w‹w\â÷)ñ¨OÛpd&9{#R3ı’0f7_ºpÀÔE'¡%"]oq9x!1•Ó4·¢t ¯ó(Ó÷en«4ÓŸ?6o$tµp#¸p =ie0TödUİcù=SğíIpù*xdãòñšÿ„)uá–½ v?:0`yàÛş  47÷LS|eı¡&b7FU;ótVxyµ`q¦¨Êà8l¥F.°r¥F·c`(ş"5I‡{öRsÕĞ{&,yKèctıoa‚+-~0°4Tr‹¨öòQ(²M£G®0!ê$Võ&x5b\4Lî¦e9d¨YR?D0¸àêV/&ÂDru9¤âU5Ô¨% 3{#!D»ì›ó:Ù'mi@)amTh1a;ê®mÉM;:gã!ó1¡(cgpu³ß­u`3uCó´©u—¥ƒ·™U÷‡İ)ÀŒfXge²3:=#Îc-+Oùô9Ş5ógei1¢ĞK9#İñR€k6o @gw7µf[%òsŞç;(yTe‚=w)oü}*XA¯¡+oL/±eH3°ÕMy@j# IÆnz)áZÑŸ'1²`çóÀsx¹6“/@©/`çækRÿzmÌ¡ã.?Áq­½Sgï*P{"k˜n&óçl¬ıiCÜWÒÏÔ÷á—å•q!wp+~Ã ê*y'Ndäuy½æxc23* a·p¥ë%w^KIÅxg—¹=\T,@¡ú„x5’ñâ]â=e5şJşbìInY¸&*şĞ¶R@bE§ĞoS÷r zQ× Q©TF~$¬tÅOµecQmçì*%nŠ¦¨©ó#>öÎ{}ë;ëÔ0luDbQ¶OÁbIk¦\^#:l$€¥ àQgaààXlyu:ë#U—~ôjô,ÓVj.´iH™ˆš1O\ev{*4]hâ­êF+µ9d!%"Ó3>hdö¢j*Zg-V~ÁCÈ£vY’Ã"ñKg‚x$%ba\j,ó»¹É¤>[ZMë…t´b9êB0é:ôæ~Õ 	´3ĞEA2ñîR—·:¨|°õ¾$P0rt‘uõÓV%ugôfQHx}z]<t—[4.?Óër®6p6;Öuş éd÷U-KUêsüu4+¼53=ñ”|zbòPUuwd¶@-6y ‚<&ıuóçU.€áö6mJğ>ŞÃÆ=ĞS?Z©y"óAnõ!aøj <0©q<(b2±Ò.¾.ñP
²hüô$yíG^ğt;'áD[Myƒ]J7_ñÊm%º¹‰j$49pÎÃø·Wrnçi'ùÈ| v}f\a	òÄ=»W"Æƒvèj}İc©?$y)u~ød]qìò¨t{q{³ÖfDN,¢7¤lÊÕ'B_+ÒJuÉ¬¾$zê<¥o¬pî *"*Züçéay(Œ2_ îrfbÊVSrÁtÈt«-cï%J;?*nê¾û¹z¸_dÈ-^?)Àõ2.³hAá&®`A XhQ0šv D‚WF=³2_qíh­KAşg©ee±½Í¢y3hîLbµ'fş“+qÖ˜a5RálDU.4q¡Mg''57¥xÔmª4®MÁÒ-eÅà#ºy.¨iD.;Í ÀqB$´rL}‡ÒüW)”ğ{ç$<¹Dp…t|gJ<Q%W3îÇqqªKÊØÆJårIHtô&ÉuW.`WR{jKp Òı$ÚÎ@d²(hô8®r–iín	e±Tn°çgºDy=u‡´P¨8dçY
{F±AoaØÈALA¾*mqaV[÷gä®ym¯¹&'ÁkıGê5zØD1mJga¡jí6k×#¨|¨›¹$84HëuåuQöUajjëI±‹ÂÍp/5+iëà?F$x¬ÊmKš~8F²qy¼îµû|®gïœz«»‡MK™m0ÄwY({uA»fwox•è<_ø¼&ÆzÙ=yjaa@¤Bİ¶ÓŠO‘¶ˆrì`çØÂ2‹~I¹Ms0vhïDÃJ8wä‚?sşœ ñ('?.YwÏ£2Î:\yÂ1Uv&¥¤£¿m0øâNr´üiOÀ-m'¨"mD0x–Ê E¨^:ûn§[´}sægËã\•¢„ÓI)õìÿ] i".+:„$aæe 3CäljË‰…I+egÈ;&øZÎÑ*fw¿[5×Ç!”4.æÀ(ûynê9¾QaZ&SÈ@Ç[íŒd:7Np»txu=¢eú¬êåó1­ô~_¶g®Ùè‚@jW.j
ÈĞ)ö7XP9åEB$÷EáÂvYPDd8:¥Èm+y];ñç2), ƒiés\Ñ„Ole˜õJwÓg&¬¬îk&¸Şj*ôH¤æ®;`£IHc²]G‘$ §JupïB4´\?ei„Ujh“·1`:ñ:1o<Ò*ötgüwæGÕÒf›eS ,[¼qò…tâ¢UàHR¯<Uô§tf*{l2@é²óKuG€µ
PtdZñDr³©›`5%Óvrv5EyGé´DóÔı£ïtìd%¡Œä©®D¸óìá1|ÔÕ!rµ_zô5ï4/dx2€û´ğ_<|6lîr÷¡p‚Æp€I+c1D²ß©e9)l`Ûà2¹eò$£?mÅ?…q„"7Â»é­hFseŞv8-X8#@6ú13ø¸xxx{zÀcæ­ LVa$®hUDó>õX»%O‡,ï*d½û|Ûn‡#ĞD¥Ë&leyWä¡=eõ†SÑ=ôt=<ŠzíM<™ÁEãÛÿ©ë4 ÇÂaemñˆ0;3}ÀËï¾>V°½Rpˆ6n¨¼ï1!k|òµ`+PUd7cÁâe8»b¦áaSR#`;§3; qLGğUæ,÷N[4.İ$Ç­ùU~.Nhñ+ícî"ŒP. gw£jDfÆ¼« V•dzÚ&õzÕ$oWüh»ã,QfE¡Ôğı9q&:¬·­•f51åÙÅr”_°vI½ph„I(¸%i…è¦¢áiÆlbã½	#3èq2Xt@`s+ÚultÆ T4BW&d•4)ƒNât1ŒŞÏ«naexÁñrtôXF$i½P>@EwÄ](uld$N$!Bê}UñUï3³î.9(’"!¶áz \$$hA¤1H*McÒ”Àp!÷]–o ]xgt•s6TnqdŞ8¾CéõhP@6 ià ­;Â“çaöP6Wğ¤áSÑa÷À-*`0IÓş`ílÇH&õ:&/aY}5ucV%\›E§Cƒ¶x#Ás¼+I0¾sû_5ÄH$Úrçâ$ 7‚˜Ó¢ip\Cm­Sô-#/s"-Y4LÜ…„[pdBYeOõ5mpå@vVã}BøñMßö¡|ò8¦QvMQ÷Ayß´w_D9Vi|05÷)Dhc °YË®Ñ71Şsô´óàòºlvi ^V(Ş¬0>ù(¹òiíá,t+ ¡jw§äCäSÏD)Q 0vÚys47ªuF!¾*fE¿ *;ùz “,Jp Ëóàe´pol(ÑÙ\ü;dnâ¾õ[àªOê Ècv1§ÖàwCª ,k¢¬êu¥u	¤r+²À¡&¹Çcé11SBØuòÛhe«Ú~n^’_i}ñy:L?~kíÿåŒO²L£Av†u,’}of?­»24  ¦~½-6¼£ÙüLáAbdJÌ&AlF}Aáz+îÇì}x(±€Q9@c‹tI­Ó¨gÔuIW§1ì#@*A)¹l#VVô'?Éç;‚,`m3$DOIK@“?&Ô4$Èl	iWà*ç+áäuB[j’ï@æææ=ãz iŸ	dÖ¹/8;0—b"euG·1z’}Ûe O™PÁÚbtLbT¬dù—©,øUN?{È¿Zùm3lª7:ûõµ!âz.<©õT@GA¨?r&`{(< 0$m=Õ1Z~xuk!åyP@ãHÄQ`OX`&TMözäuvV‘|aáwÓ¿qTÔhkÌ2
Yd÷ep7³i|¼NÙašáP/Y{ñNø„g9ğå]peì!kF¼c-¦âthÇlªêfÅ~h¸–µ2œûºèi,k!¯róN^~éô(G’F&s¯5>bVt^±ˆjáSfnõ/¤Æa“=ª¦iàu¹·5[ÊR’è1ûJâ:%blVñ($ò£,ì±fwpm#ÿ
æ-xÿ³$â$t4ušK'ò$6o›p{9“:%ƒU#™Â’e[”¬`ñï8ü“[e@t¡Ôú³o 6Ş|Gü-Ê;Yitg’F`/ }tx[³8oEã5iìpzN–lã8Ac(
¡Ål0Âbú÷/÷¤é™xüÙãG‰QR~‘q?R<ó7çvUK2²xxÁÈ1”ëŞ„34t!¥l5°õ²&Å/ú0èíıÕ~6sY}lE`*À³ã|(p½ª±{l»d"!{g	òicİ ¨(B°t{9îfb“h6ks&.tlõp>,û+ÔÑ°B!¨Ÿá®ddj/ADA\ñˆUÎ{3å`x§—\52JiyË%°~Ö4%¢bÅÏQ(Šx™úh+š†­Æ+ SßYSsìÒÅv58W„ #¤Á;Kyn­pÄôoe	øf%Gjl¢Joç³jáSqHCŒ¸e%¡“òbp'F8e0…i¬l1­5 xŠ·Uè	`E>»åZ÷(|jK¼|I$Õ3mD 
jyÃ-ªkW|ıã5Oõ8Êº¤í÷¼8ø4/jpa°X-u$ûGëtùIì¢aKl#² !|xjÄvwÆá5D#^©d–S"@ºnû«r'{ƒ®ªª«l,6Jg£D*dàDï2gk.£5ÿ&íø€r(o2DZBaªæy¦øI@¯º˜j¸£?ı,Y±}2X0YµFEUúÂÎ4=^a4.¤Úñvc<å1zÑŞéİµ8aq?eL÷;ÙO‚¤=ÌõX9S˜e/íçÊ;{*s/BPÄu£#¤ÎZáwaN½›È—8\)Í3Î•á\p!é}qzbl²!% 5
M¹`äaG$SVàÓÀBc5ôˆï}¿å.…Àİœ¤"è:´Tä]ë1*;ÅÃ˜+/p~¡·õ7h$)4m‘ ¿&p(°€l)§Ôºjh&yq`©oáìEFZrmí¸¼R`“ tvá7çÓé3şAS	Hy4$Yf8pP&Œk~_]j¡C™½S<àhjÒ-.[é¤ÑµÈ!|‚r²£H’b¥
7Q°7¥‚æ$ªhÂ…qa‚)tÆ\·µzcj[òœnhqy&Ê$¨-yŠ3 $>ˆqÇÒrÏ? a
qDRøQ!\ÀÇ3\q$'\YëB!mh³¯¥)ğ¬ıÏË9Z/Òo#º«ú6q«¹vÅ_kñjX‡#¥AŒúêƒ}ñçÛp?{‚KzL0s?jàu5Í!! ú¢Îeç` }Ixa1cd5%5Ø(?a´+{¡5cf ¯R0á@Ea*}r0L¢sxşğW:d,_ıDÄ­¢ùmJÉ)5‰k#T¡Â
é«3ò˜Î•ù!âåFt,W (`ctéÛÂ~l3d8ÉPğ!sëğr¨/"ñVEqÍµ|.aÜôw“•!¤q{tÕp¥¼Õsv¡6ğ"µci{=4Jä¥2ülÑºUw@J,n\Ôséb—â9’‚¡)¢Y8R!.BŒmZuoqe-0$´öH¨ı}øüerU	ÿK(jòNj-ÿl2U#0L?²²
~pÔtŠCd@ÕOô 
0	
År­'oªˆíiM¤A k`\n9iúÙ„¡u _€·)k%8p7“è0ƒ-3—}OG’‚¬"(KÃ2åüò£7šJ?Â,…¤*Üb»ƒˆ*M1ıú%0%`"&U‰q)p_alAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << shapes().getTypes();
}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::CstrRequireOp definitions
//===----------------------------------------------------------------------===//

CstrRequireOpAdaptor::CstrRequireOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

CstrRequireOpAdaptor::CstrRequireOpAdaptor(CstrRequireOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange CstrRequireOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> CstrRequireOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange CstrRequireOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CstrRequireOpAdaptor::pred() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr CstrRequireOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr CstrRequireOpAdaptor::msg() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("msg").cast<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult CstrRequireOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_msg = odsAttrs.get("msg");
  if (!tblgen_msg) return emitError(loc, "'shape.cstr_require' op ""requires attribute 'msg'");
    if (!((tblgen_msg.isa<::mlir::StringAttr>()))) return emitError(loc, "'shape.cstr_require' op ""attribute 'msg' failed to satisfy constraint: string attribute");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> CstrRequireOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range CstrRequireOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CstrRequireOp::pred() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange CstrRequireOp::predMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> CstrRequireOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range CstrRequireOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value CstrRequireOp::result() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr CstrRequireOp::msgAttr() {
  return (*this)->getAttr(msgAttrName()).template cast<::mlir::StringAttr>();
}

::llvm::StringRef CstrRequireOp::msg() {
  auto attr = msgAttr();
  return attr.getValue();
}

void CstrRequireOp::msgAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(msgAttrName(), attr);
}

void CstrRequireOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pred, ::mlir::StringAttr msg) {
  odsState.addOperands(pred);
  odsState.addAttribute(msgAttrName(odsState.name), msg);
  odsState.addTypes(result);
}

void CstrRequireOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value pred, ::mlir::StringAttr msg) {
  odsState.addOperands(pred);
  odsState.addAttribute(msgAttrName(odsState.name), msg);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(CstrRequireOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void CstrRequireOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pred, ::mlir::StringAttr msg) {
  odsState.addOperands(pred);
  odsState.addAttribute(msgAttrName(odsState.name), msg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CstrRequireOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value pred, ::llvm::StringRef msg) {
  odsState.addOperands(pred);
  odsState.addAttribute(msgAttrName(odsState.name), odsBuilder.getStringAttr(msg));
  odsState.addTypes(result);
}

void CstrRequireOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value pred, ::llvm::StringRef msg) {
  odsState.addOperands(pred);
  odsState.addAttribute(msgAttrName(odsState.name), odsBuilder.getStringAttr(msg));

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(CstrRequireOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void CstrRequireOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value pred, ::llvm::StringRef msg) {
  odsState.addOperands(pred);
  odsState.addAttribute(msgAttrName(odsState.name), odsBuilder.getStringAttr(msg));
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CstrRequireOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void CstrRequireOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(CstrRequireOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult CstrRequireOp::verify() {
  if (failed(CstrRequireOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps8(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps4(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::LogicalResult CstrRequireOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = odsBuilder.getType<::mlir::shape::WitnessType>();
  return ::mlir::success();
}

::mlir::ParseResult CstrRequireOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType predRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> predOperands(predRawOperands);  ::llvm::SMLoc predOperandsLoc;
  (void)predOperandsLoc;
  ::mlir::StringAttr msgAttr;

  predOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(predRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseAttribute(msgAttr, parser.getBuilder().getType<::mlir::NoneType>(), "msg", result.attributes))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::shape::WitnessType>();
  ::mlir::Type odsBuildableType1 = parser.getBuilder().getIntegerType(1);
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(predOperands, odsBuildableType1, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CstrRequireOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.cstr_require";
  p << ' ';
  p << pred();
  p << ",";
  p << ' ';
  p.printAttributeWithoutType(msgAttr());
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"msg"});
}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::DebugPrintOp definitions
//===----------------------------------------------------------------------===//

DebugPrintOpAdaptor::DebugPrintOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DebugPrintOpAdaptor::DebugPrintOpAdaptor(DebugPrintOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DebugPrintOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DebugPrintOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DebugPrintOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DebugPrintOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr DebugPrintOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult DebugPrintOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> DebugPrintOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DebugPrintOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DebugPrintOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange DebugPrintOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DebugPrintOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DebugPrintOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DebugPrintOp::output() {
  return *getODSResults(0).begin();
}

void DebugPrintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type output, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(output);
}

void DebugPrintOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DebugPrintOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DebugPrintOp::verify() {
  if (failed(DebugPrintOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::DivOp definitions
//===----------------------------------------------------------------------===//

DivOpAdaptor::DivOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DivOpAdaptor::DivOpAdaptor(DivOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DivOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DivOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange DivOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value DivOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr DivOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult DivOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> DivOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range DivOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value DivOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange DivOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange DivOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> DivOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range DivOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value DivOp::result() {
  return *getODSResults(0).begin();
}

void DivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void DivOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DivOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult DivOp::verify() {
  if (failed(DivOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verifySizeOrIndexOp(*this);
}



::mlir::ParseResult DivOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);
  ::mlir::Type rhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> rhsTypes(rhsRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(rhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, rhsTypes, rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DivOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.div";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(rhs().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void DivOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::FromExtentTensorOp definitions
//===----------------------------------------------------------------------===//

FromExtentTensorOpAdaptor::FromExtentTensorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FromExtentTensorOpAdaptor::FromExtentTensorOpAdaptor(FromExtentTensorOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FromExtentTensorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FromExtentTensorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FromExtentTensorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FromExtentTensorOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr FromExtentTensorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FromExtentTensorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> FromExtentTensorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FromExtentTensorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FromExtentTensorOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange FromExtentTensorOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FromExtentTensorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FromExtentTensorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FromExtentTensorOp::result() {
  return *getODSResults(0).begin();
}

void FromExtentTensorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(result);
}

void FromExtentTensorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input) {
  odsState.addOperands(input);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(FromExtentTensorOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void FromExtentTensorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FromExtentTensorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void FromExtentTensorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(FromExtentTensorOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult FromExtentTensorOp::verify() {
  if (failed(FromExtentTensorOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps10(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps6(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult FromExtentTensorOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = odsBuilder.getType<::mlir::shape::ShapeType>();
  return ::mlir::success();
}

::mlir::ParseResult FromExtentTensorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType inputRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> inputOperands(inputRawOperands);  ::llvm::SMLoc inputOperandsLoc;
  (void)inputOperandsLoc;
  ::mlir::Type inputRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> inputTypes(inputRawTypes);

  inputOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(inputRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(inputRawTypes[0]))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::shape::ShapeType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(inputOperands, inputTypes, inputOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FromExtentTensorOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.from_extent_tensor";
  p << ' ';
  p << input();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(input().getType());
}

void FromExtentTensorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::FromExtentsOp definitions
//===----------------------------------------------------------------------===//

FromExtentsOpAdaptor::FromExtentsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FromExtentsOpAdaptor::FromExtentsOpAdaptor(FromExtentsOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FromExtentsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FromExtentsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange FromExtentsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange FromExtentsOpAdaptor::extents() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr FromExtentsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult FromExtentsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> FromExtentsOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range FromExtentsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range FromExtentsOp::extents() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange FromExtentsOp::extentsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FromExtentsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FromExtentsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FromExtentsOp::shape() {
  return *getODSResults(0).begin();
}

void FromExtentsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type shape, ::mlir::ValueRange extents) {
  odsState.addOperands(extents);
  odsState.addTypes(shape);
}

void FromExtentsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FromExtentsOp::verify() {
  if (failed(FromExtentsOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps11(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps6(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::ParseResult FromExtentsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> extentsOperands;
  ::llvm::SMLoc extentsOperandsLoc;
  (void)extentsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> extentsTypes;

  extentsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(extentsOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(extentsTypes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::shape::ShapeType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(extentsOperands, extentsTypes, extentsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FromExtentsOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.from_extents";
  p << ' ';
  p << extents();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << extents().getTypes();
}

void FromExtentsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::FunctionLibraryOp definitions
//===----------------------------------------------------------------------===//

FunctionLibraryOpAdaptor::FunctionLibraryOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FunctionLibraryOpAdaptor::FunctionLibraryOpAdaptor(FunctionLibraryOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FunctionLibraryOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FunctionLibraryOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FunctionLibraryOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::DictionaryAttr FunctionLibraryOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DictionaryAttr FunctionLibraryOpAdaptor::mapping() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DictionaryAttr attr = odsAttrs.get("mapping").cast<::mlir::DictionaryAttr>();
  return attr;
}

::mlir::RegionRange FunctionLibraryOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &FunctionLibraryOpAdaptor::body() {
  return *odsRegions[0];
}

::mlir::LogicalResult FunctionLibraryOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_mapping = odsAttrs.get("mapping");
  if (!tblgen_mapping) return emitError(loc, "'shape.function_library' op ""requires attribute 'mapping'");
    if (!((tblgen_mapping.isa<::mlir::DictionaryAttr>()))) return emitError(loc, "'shape.function_library' op ""attribute 'mapping' failed to satisfy constraint: dictionary of named attribute values");
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> FunctionLibraryOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FunctionLibraryOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

std::pair<unsigned, unsigned> FunctionLibraryOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range FunctionLibraryOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Region &FunctionLibraryOp::body() {
  return (*this)->getRegion(0);
}

::mlir::DictionaryAttr FunctionLibraryOp::mappingAttr() {
  return (*this)->getAttr(mappingAttrName()).template cast<::mlir::DictionaryAttr>();
}

::mlir::DictionaryAttr FunctionLibraryOp::mapping() {
  auto attr = mappingAttr();
  return attr;
}

void FunctionLibraryOp::mappingAttr(::mlir::DictionaryAttr attr) {
  (*this)->setAttr(mappingAttrName(), attr);
}



::mlir::ParseResult FunctionLibraryOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseFunctionLibraryOp(parser, result);
}

void FunctionLibraryOp::print(::mlir::OpAsmPrinter &p) {
  ::print(p, *this);
}

::mlir::LogicalResult FunctionLibraryOp::verify() {
  if (failed(FunctionLibraryOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
  }
  {
    unsigned index = 0; (void)index;
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('body') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::GetExtentOp definitions
//===----------------------------------------------------------------------===//

GetExtentOpAdaptor::GetExtentOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GetExtentOpAdaptor::GetExtentOpAdaptor(GetExtentOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GetExtentOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GetExtentOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange GetExtentOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetExtentOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value GetExtentOpAdaptor::dim() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr GetExtentOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult GetExtentOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> GetExtentOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range GetExtentOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetExtentOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Value GetExtentOp::dim() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange GetExtentOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange GetExtentOp::dimMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> GetExtentOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range GetExtentOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value GetExtentOp::extent() {
  return *getODSResults(0).begin();
}



void GetExtentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type extent, ::mlir::Value shape, ::mlir::Value dim) {
  odsState.addOperands(shape);
  odsState.addOperands(dim);
  odsState.addTypes(extent);
}

void GetExtentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape, ::mlir::Value dim) {
  odsState.addOperands(shape);
  odsState.addOperands(dim);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetExtentOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult GetExtentOp::verify() {
  if (failed(GetExtentOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verifySizeOrIndexOp(*this);
}



::mlir::ParseResult GetExtentOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType shapeRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> shapeOperands(shapeRawOperands);  ::llvm::SMLoc shapeOperandsLoc;
  (void)shapeOperandsLoc;
  ::mlir::OpAsmParser::OperandType dimRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> dimOperands(dimRawOperands);  ::llvm::SMLoc dimOperandsLoc;
  (void)dimOperandsLoc;
  ::mlir::Type shapeRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> shapeTypes(shapeRawTypes);
  ::mlir::Type dimRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> dimTypes(dimRawTypes);
  ::mlir::Type extentRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> extentTypes(extentRawTypes);

  shapeOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(shapeRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  dimOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(dimRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(shapeRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(dimRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(extentRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(extentTypes);
  if (parser.resolveOperands(shapeOperands, shapeTypes, shapeOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dimOperands, dimTypes, dimOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetExtentOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.get_extent";
  p << ' ';
  p << shape();
  p << ",";
  p << ' ';
  p << dim();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(shape().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(dim().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(extent().getType());
}

void GetExtentOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::IndexToSizeOp definitions
//===----------------------------------------------------------------------===//

IndexToSizeOpAdaptor::IndexToSizeOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

IndexToSizeOpAdaptor::IndexToSizeOpAdaptor(IndexToSizeOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange IndexToSizeOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IndexToSizeOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange IndexToSizeOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IndexToSizeOpAdaptor::arg() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr IndexToSizeOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IndexToSizeOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> IndexToSizeOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range IndexToSizeOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IndexToSizeOp::arg() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange IndexToSizeOp::argMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IndexToSizeOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IndexToSizeOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IndexToSizeOp::result() {
  return *getODSResults(0).begin();
}

void IndexToSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value arg) {
  odsState.addOperands(arg);
  odsState.addTypes(result);
}

void IndexToSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value arg) {
  odsState.addOperands(arg);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(IndexToSizeOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void IndexToSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg) {
  odsState.addOperands(arg);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void IndexToSizeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void IndexToSizeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(IndexToSizeOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult IndexToSizeOp::verify() {
  if (failed(IndexToSizeOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps12(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps7(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}





::mlir::LogicalResult IndexToSizeOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = odsBuilder.getType<::mlir::shape::SizeType>();
  return ::mlir::success();
}

::mlir::ParseResult IndexToSizeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType argRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> argOperands(argRawOperands);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::shape::SizeType>();
  ::mlir::Type odsBuildableType1 = parser.getBuilder().getIndexType();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(argOperands, odsBuildableType1, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void IndexToSizeOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.index_to_size";
  p << ' ';
  p << arg();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
}

void IndexToSizeOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::IsBroadcastableOp definitions
//===----------------------------------------------------------------------===//

IsBroadcastableOpAdaptor::IsBroadcastableOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

IsBroadcastableOpAdaptor::IsBroadcastableOpAdaptor(IsBroadcastableOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange IsBroadcastableOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> IsBroadcastableOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange IsBroadcastableOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange IsBroadcastableOpAdaptor::shapes() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr IsBroadcastableOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult IsBroadcastableOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> IsBroadcastableOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range IsBroadcastableOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range IsBroadcastableOp::shapes() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange IsBroadcastableOp::shapesMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> IsBroadcastableOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range IsBroadcastableOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value IsBroadcastableOp::result() {
  return *getODSResults(0).begin();
}

void IsBroadcastableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value lhs, ::mlir::Value rhs) {
 build(odsBuilder, odsState, ::llvm::makeArrayRef({lhs, rhs})); 
}

void IsBroadcastableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::ValueRange shapes) {
  odsState.addOperands(shapes);
  odsState.addTypes(result);
}

void IsBroadcastableOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void IsBroadcastableOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(IsBroadcastableOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult IsBroadcastableOp::verify() {
  if (failed(IsBroadcastableOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps1(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps8(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}





::mlir::ParseResult IsBroadcastableOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> shapesOperands;
  ::llvm::SMLoc shapesOperandsLoc;
  (void)shapesOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> shapesTypes;

  shapesOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(shapesOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(shapesTypes))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(shapesOperands, shapesTypes, shapesOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void IsBroadcastableOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.is_broadcastable";
  p << ' ';
  p << shapes();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << shapes().getTypes();
}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::JoinOp definitions
//===----------------------------------------------------------------------===//

JoinOpAdaptor::JoinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

JoinOpAdaptor::JoinOpAdaptor(JoinOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange JoinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> JoinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange JoinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value JoinOpAdaptor::arg0() {
  return *getODSOperands(0).begin();
}

::mlir::Value JoinOpAdaptor::arg1() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr JoinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::StringAttr JoinOpAdaptor::error() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("error").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::mlir::LogicalResult JoinOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_error = odsAttrs.get("error");
  if (tblgen_error) {
    if (!((tblgen_error.isa<::mlir::StringAttr>()))) return emitError(loc, "'shape.join' op ""attribute 'error' failed to satisfy constraint: string attribute");
  }
  }
  return ::mlir::success();
}













std::pair<unsigned, unsigned> JoinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range JoinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value JoinOp::arg0() {
  return *getODSOperands(0).begin();
}

::mlir::Value JoinOp::arg1() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange JoinOp::arg0Mutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange JoinOp::arg1Mutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> JoinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range JoinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value JoinOp::result() {
  return *getODSResults(0).begin();
}

::mlir::StringAttr JoinOp::errorAttr() {
  return (*this)->getAttr(errorAttrName()).template dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > JoinOp::error() {
  auto attr = errorAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

void JoinOp::errorAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(errorAttrName(), attr);
}

::mlir::Attribute JoinOp::removeErrorAttr() {
  return (*this)->removeAttr(errorAttrName());
}

void JoinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value arg0, ::mlir::Value arg1, /*optional*/::mlir::StringAttr error) {
  odsState.addOperands(arg0);
  odsState.addOperands(arg1);
  if (error) {
  odsState.addAttribute(errorAttrName(odsState.name), error);
  }
  odsState.addTypes(result);
}

void JoinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value arg0, ::mlir::Value arg1, /*optional*/::mlir::StringAttr error) {
  odsState.addOperands(arg0);
  odsState.addOperands(arg1);
  if (error) {
  odsState.addAttribute(errorAttrName(odsState.name), error);
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void JoinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult JoinOp::verify() {
  if (failed(JoinOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::ParseResult JoinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType arg0RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> arg0Operands(arg0RawOperands);  ::llvm::SMLoc arg0OperandsLoc;
  (void)arg0OperandsLoc;
  ::mlir::OpAsmParser::OperandType arg1RawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> arg1Operands(arg1RawOperands);  ::llvm::SMLoc arg1OperandsLoc;
  (void)arg1OperandsLoc;
  ::mlir::StringAttr errorAttr;
  ::mlir::Type arg0RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> arg0Types(arg0RawTypes);
  ::mlir::Type arg1RawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> arg1Types(arg1RawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  arg0OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(arg0RawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  arg1OperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(arg1RawOperands[0]))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalComma())) {
  if (parser.parseKeyword("error"))
    return ::mlir::failure();
  if (parser.parseEqual())
    return ::mlir::failure();

  {
    ::mlir::OptionalParseResult parseResult =
      parser.parseOptionalAttribute(errorAttr, parser.getBuilder().getType<::mlir::NoneType>(), "error", result.attributes);
    if (parseResult.hasValue() && failed(*parseResult))
      return ::mlir::failure();
  }
  }
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(arg0RawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(arg1RawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(arg0Operands, arg0Types, arg0OperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(arg1Operands, arg1Types, arg1OperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void JoinOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.join";
  p << ' ';
  p << arg0();
  p << ",";
  p << ' ';
  p << arg1();
  if ((*this)->getAttr("error")) {
  p << ",";
  p << ' ' << "error";
  p << ' ' << "=";
  p << ' ';
  p.printAttributeWithoutType(errorAttr());
  }
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{"error"});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(arg0().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(arg1().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::MaxOp definitions
//===----------------------------------------------------------------------===//

MaxOpAdaptor::MaxOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MaxOpAdaptor::MaxOpAdaptor(MaxOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MaxOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MaxOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MaxOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaxOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MaxOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MaxOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> MaxOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MaxOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MaxOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MaxOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MaxOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MaxOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MaxOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MaxOp::result() {
  return *getODSResults(0).begin();
}

void MaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void MaxOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MaxOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MaxOp::verify() {
  if (failed(MaxOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::ParseResult MaxOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);
  ::mlir::Type rhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> rhsTypes(rhsRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(rhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, rhsTypes, rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void MaxOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.max";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(rhs().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void MaxOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::MinOp definitions
//===----------------------------------------------------------------------===//

MinOpAdaptor::MinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MinOpAdaptor::MinOpAdaptor(MinOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MinOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MinOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> MinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MinOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MinOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MinOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MinOp::result() {
  return *getODSResults(0).begin();
}

void MinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void MinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MinOp::verify() {
  if (failed(MinOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps9(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::ParseResult MinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);
  ::mlir::Type rhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> rhsTypes(rhsRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(rhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, rhsTypes, rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void MinOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.min";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(rhs().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void MinOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::MulOp definitions
//===----------------------------------------------------------------------===//

MulOpAdaptor::MulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MulOpAdaptor::MulOpAdaptor(MulOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange MulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOpAdaptor::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulOpAdaptor::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr MulOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult MulOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> MulOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range MulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOp::lhs() {
  return *getODSOperands(0).begin();
}

::mlir::Value MulOp::rhs() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange MulOp::lhsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange MulOp::rhsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> MulOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range MulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value MulOp::result() {
  return *getODSResults(0).begin();
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  odsState.addTypes(result);
}

void MulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value lhs, ::mlir::Value rhs) {
  odsState.addOperands(lhs);
  odsState.addOperands(rhs);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void MulOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult MulOp::verify() {
  if (failed(MulOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verifySizeOrIndexOp(*this);
}



::mlir::ParseResult MulOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType lhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> lhsOperands(lhsRawOperands);  ::llvm::SMLoc lhsOperandsLoc;
  (void)lhsOperandsLoc;
  ::mlir::OpAsmParser::OperandType rhsRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> rhsOperands(rhsRawOperands);  ::llvm::SMLoc rhsOperandsLoc;
  (void)rhsOperandsLoc;
  ::mlir::Type lhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> lhsTypes(lhsRawTypes);
  ::mlir::Type rhsRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> rhsTypes(rhsRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  lhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(lhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  rhsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(rhsRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(lhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(rhsRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(lhsOperands, lhsTypes, lhsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(rhsOperands, rhsTypes, rhsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void MulOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.mul";
  p << ' ';
  p << lhs();
  p << ",";
  p << ' ';
  p << rhs();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(lhs().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(rhs().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void MulOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::NumElementsOp definitions
//===----------------------------------------------------------------------===//

NumElementsOpAdaptor::NumElementsOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

NumElementsOpAdaptor::NumElementsOpAdaptor(NumElementsOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange NumElementsOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> NumElementsOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange NumElementsOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NumElementsOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr NumElementsOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult NumElementsOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> NumElementsOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range NumElementsOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NumElementsOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange NumElementsOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> NumElementsOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range NumElementsOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value NumElementsOp::result() {
  return *getODSResults(0).begin();
}



void NumElementsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value shape) {
  odsState.addOperands(shape);
  odsState.addTypes(result);
}

void NumElementsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape) {
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NumElementsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult NumElementsOp::verify() {
  if (failed(NumElementsOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verifySizeOrIndexOp(*this);
}



::mlir::ParseResult NumElementsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType shapeRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> shapeOperands(shapeRawOperands);  ::llvm::SMLoc shapeOperandsLoc;
  (void)shapeOperandsLoc;
  ::mlir::Type shapeRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> shapeTypes(shapeRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  shapeOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(shapeRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(shapeRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(shapeOperands, shapeTypes, shapeOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void NumElementsOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.num_elements";
  p << ' ';
  p << shape();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(shape().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void NumElementsOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::RankOp definitions
//===----------------------------------------------------------------------===//

RankOpAdaptor::RankOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

RankOpAdaptor::RankOpAdaptor(RankOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange RankOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> RankOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange RankOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RankOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr RankOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult RankOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> RankOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range RankOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RankOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange RankOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> RankOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range RankOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value RankOp::rank() {
  return *getODSResults(0).begin();
}

void RankOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type rank, ::mlir::Value shape) {
  odsState.addOperands(shape);
  odsState.addTypes(rank);
}

void RankOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value shape) {
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RankOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult RankOp::verify() {
  if (failed(RankOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::verifySizeOrIndexOp(*this);
}





::mlir::ParseResult RankOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType shapeRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> shapeOperands(shapeRawOperands);  ::llvm::SMLoc shapeOperandsLoc;
  (void)shapeOperandsLoc;
  ::mlir::Type shapeRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> shapeTypes(shapeRawTypes);
  ::mlir::Type rankRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> rankTypes(rankRawTypes);

  shapeOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(shapeRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(shapeRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(rankRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(rankTypes);
  if (parser.resolveOperands(shapeOperands, shapeTypes, shapeOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void RankOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.rank";
  p << ' ';
  p << shape();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(shape().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(rank().getType());
}

void RankOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::ReduceOp definitions
//===----------------------------------------------------------------------===//

ReduceOpAdaptor::ReduceOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ReduceOpAdaptor::ReduceOpAdaptor(ReduceOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ReduceOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ReduceOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange ReduceOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceOpAdaptor::shape() {
  return *getODSOperands(0).begin();
}

::mlir::ValueRange ReduceOpAdaptor::initVals() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ReduceOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ReduceOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ReduceOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ReduceOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ReduceOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {false, true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 1) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range ReduceOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ReduceOp::shape() {
  return *getODSOperands(0).begin();
}

::mlir::Operation::operand_range ReduceOp::initVals() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ReduceOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ReduceOp::initValsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ReduceOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ReduceOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ReduceOp::result() {
  return getODSResults(0);
}

::mlir::Region &ReduceOp::region() {
  return (*this)->getRegion(0);
}



void ReduceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange result, ::mlir::Value shape, ::mlir::ValueRange initVals) {
  odsState.addOperands(shape);
  odsState.addOperands(initVals);
  (void)odsState.addRegion();
  odsState.addTypes(result);
}

void ReduceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult ReduceOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseReduceOp(parser, result);
}

void ReduceOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult ReduceOp::verify() {
  if (failed(ReduceOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps5(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((::llvm::hasNItems(region, 1)))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: region with 1 blocks";
      }
      ++index;
    }
  }
  return ::verify(*this);
}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::ShapeEqOp definitions
//===----------------------------------------------------------------------===//

ShapeEqOpAdaptor::ShapeEqOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ShapeEqOpAdaptor::ShapeEqOpAdaptor(ShapeEqOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ShapeEqOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ShapeEqOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

’i¬[b2¼âù§ÙºlÄ’ÓxƒÅÏHíMeØ'äìtºÀM\N+WÕ¿xé"äs€ÖAûãt|J:&ÍÔÆ¾:Æ}*ltg40~)n_é­á¨ĞñªºÑ?şugÅsnÒ†heéõïF4BÚ~µbl÷CC JÈBìr™‘«ª „Û*ôL F"{l´`-¤çĞèÃµ÷Tğg˜¿+¦~E}^s{,<!~aw~»r!e÷Ã×‡WYĞ©k¢i¾ #R34s[Ğİ>
oìNW‰Ó>ÃnÖapS—Tu©nweá°ˆí)î`áÍGs&ïNDcòy¦7Ek%E:íÙrÏd<E$qG$ÇÆa(m1U«
¼xFÌcs˜ªúksvÄÒ¿¿ƒÓÈaĞùApaë!ãĞÈ³·ÉgÀ{Wéş¢&±~ ²ÑåİDÀ¨UQU^ÜøC(áY±©u»’w‰VJS#¦e¥‹Ô*úL~`	'GBqvVqĞÅêf#»H=ÄKò êæ0äœËº-Q!|Vn:mVãUúÆÒÉµQ¼»MnWàÑ"+Só;ª™hÀ¾EÌŠ¹–~Œgşéá=<Mp[E}Z.›ğQÄwIÈIjFšvî2S8‰6NHC[ì±k¥oKHûèƒıA¶¡ê¾t‰Ç}º"†`>ğ¢ZA&K¾Ë°ŞÆk*e¬„2-89¡¿äØÔ_MpƒïY”T¦ ÑÜf±wĞ2ÿGÉCc=f²gdËf,jß\k*ğêaÔ•§ÎXvF&åÄãn†XPÀí¬õç^|~ö#mhˆ3åfd'³­Qbˆq*6ûÈ*ÿÜV³M	ÍEó¹M€}s8şç_BÓ‹J4ÿ„>ZOO5Íë òWYÆv½÷Íœ9 RuŠª«Pr5?{ß[ÜÍ>,ˆë$>y:z<I¼”GÚe¡øÊxy—{ïZìh	%dEÑ™ç³
S€Ğ‘ LY™(À¶{ËíôLywœ~uWv[P¼Ì•Wé
Š&A_/E0lŒšv ú+ŞÍoÈ;:Ïq¤}5l:	òQë0)€EA°qe&–u6y•uIãp½â|pàBt‹G'0UC@ …VQ]ènÂ*‚‚–›Ÿ)ùhd6ÀVj§1ugCZyE…‚óä4éi2	ZgjÖû¨c8¿‚ÇE(w«c_€°»D;	Íg)ìÉj:íS«`Q`-µGIßëÒoLásu°0'‚,ĞïYwWÎ¬O ââtdÄİŒY»š,¡e¿nXb`CIâà¥ik%zŠ#²á9|Œ#»ı²°ï³ƒ3-ùFg]ª©CÒ|ìì&`®¡àp‹ :ôïmõõm³æRSSIi ßÕû—N}HæŞA}ï˜dn+Ñ{s(9ñkŸT:9nògzl¸iÃïòÈ0òS‰tQ`=îÓ`mc]A!ä)&AÊeÌ€eMsï$é¢c>¶[ªÓtYeÇ~<p0);´é3¹İ±á÷i2RÛôJ3ÌÚo2©Ò¾)45|bn}Tôµ}ğîCö¢Ğ
/*eÎg?ÅZ½ĞjwRê¬;Fişø¸ò‡ÂŸ ï—°iªŞ¯d˜’‚d^«T¤£Å“|»{¨ëŠŠ|<Ó||å5=k*Í¹EFk÷=Y}ÎI©qtä²ÅÄZsÜ¸ëb¿ëATÀªvnü¸ë¢ø` ğş äKJÔ Ğë¥ÓM3@¥\e1¾‰
a#GmX¸ÒIÜ%ãoOş{sˆ^«M,Ndû‚¨5±k%g'b	Ù®MiSe¢LeU~º£Zs(¦H’h´Íª3®“¸†Æ<ep[.)1ø9ïú^¤³gèÑœV2Ô¨£™a¶ÌQ+’EİÍaö±.~Ë:uvw$vØ©ïpº`pê„8ï¡1Ç$«qERÇ†±)êÍIóì8*ûµ4
S¼´ÛÌòì4!‘—
‹&¹ìqU..a7?xÜŞæfÑ ²7¬ÂÇÈÊ]ùÏSÊLH±‚¯Uş.Æ[Îuô`¼Ï)Ôğ ğ]8º úøœöfùÇù‹K,ç}=UƒK>Æ†p÷ôDãmŞn"{³ïÏì1²aÒ?7ÓB	D Çá;Ù4İdB’cwèYÊ<\x-aW+8¢j¶)(à–ÒtæÏ00s8N"8¹ÖxV7é”()ü	 =Õî¹e;)&çEjÏlºH]ÁGe7u*.ô¬^kpıW¯éf©r.¥Ğ­P¶ÏáÀm9î?Oln–¥îùI‡hyjñÛğFp%w[,ˆ´ªÆ²¢XºÄj×“rÄéSÓèÁ´ÌáÑ.ófÁ×õë2€š
ac0EVQ²~Î¯ó4çõøRFXdæoávÂ‹³*Å
ºõA²-A@ö¥PgtéÔefKîN]á`à}2VÅaÖåoøÚP8R±ñğ¿sl’î<ÒäàÁhLCãó6o.gËìÍ¥9=(ñ_f‹9 çÛaı|,#eHg®7äñt‚dÎa²‚ßrÅßü‹ø0pK5‹o!òˆ2šeOĞç|ì<b¬mëê»%nlUúTwIÇœL)¦$£Nßå¾ÖyN3ØCqco
i ©Òc|Êg€ ªµPA¤3ÄW­ÈeÈsĞxáùe‡K\¨,wó®Ían gS
dvM,y—àrZÑyx$ÎÿZ#ğWàVùj¬ãXOJãèM	_Ú–®¦OŒ÷o Õ¿~Å¼¾É;Şj2õ``.[H2Üçr#!3Ò½3Q_|$(NrYòF{‘'»:"|~]œüÑÏÇLQ€rùã"¤g{Ä¦`"*ú÷Ä{„à¤g(avÑYÁÅz\¤}¡xÙ# fS¡bË¬r€ìÜw{5{wâ(dhSå¶Ú[òŸÂodävOá"ûPW†säòı‰äh§mUùİ%xv•„XŸN`_r0Í?Fov(Ï®n¦x|óOÔ4¥4‡AMÌÒ—uÒìß`–o\¿!© |¡k'.`ë¬0iasŞn.‹f)¡a*ò0‚SØã¶{Ó>kö w_o5c“D\oÿbó]—/ÌrêRTj	¶Ád¯‹"AmóLÚ%ìg-d'Kz…È#ï}¡hıçw¿gÊaÔ2²ık©—é}óiúrO:‘Š+°wNo Wî×Nz-ğ8öÅÑ€Ä
/¿³”!òaß/¨M\úÚİY¡$ÁÑ­¦¾(,fóok”nƒ•hZÃ7¥¹Lnsiå1&{[zx¬*#$È¾|¤RGO|LÓHuÆ$ƒ%ØĞ?ëD—ê‚ôp¸Ùà}ñYaòÅm#tA«ê¡&Oe›¤Â*y­%ƒ[˜:÷+âgëg`áB6²<ühMĞ°»åíŞa<ÿ#¦ûO/ks+8t2nØûRu#:_!ÂgÊMmzo!àO<	~°ï)Æî²„ÉãpI»T}˜k,%z®r#¦êx0K!¶JM¢
bíBe<ê÷PeËaÍã3
õÁl
2g%~Í 
bÁp²}û-'`
.Ubsì¾dş s@.Bd»€k÷…~pBcÔ‰A´3ÔQÙÕ&­eîaÒôğçb*Ñelmù ‚`éğgÂÂ<éMOFuv†ìir\%ÖSã¿Z üDEĞ¾’Hûbà`´Zyû$æà¿)ñŠËêu(Ì3©9y°pp½ò(î5âæZ3(ğÉsú."ÖbtÏê+ı#]¤Ÿw&}03a¢_!èÆrÂzÔDîsºFT‚;ãİŒÛò+õâxã3bbŞg2G¹Û*`gĞ1ç¼ªİø7 ~ærä iübjîsìáŠƒFN\9şñı!3R%z±rZŞ.Şw½A 2Ú6åvÜáåL;­¬^¦õup§Ğ9V[Ñï2:Oà½¸åÈlğ=ÁŒbÉy÷a#sšrŞÃÿ)õŒÆÒpD,‡ú'Weç¢)F_Ûr`Íu ñ2Xcò9	g5¡Û·¢è¯sİÿU+£Sr¶%vôp*´p<ilpÔçá•Bùu[ôíÉ"ùj%dóòñš/üÆauiƒ½"~>ªõ,zèz¢â‰XSõÆÓêTõ“$áwUœQ?œ³äF~=€¦¨ŠÎ6,¥†.°^neF·'a	N"Éòs½ÔÇ{4ü{XLéct]%Ó‚£-Ql0RüÑv òòX>²Í§Sl5ê Zµ*usH¼Hê¦%;MÈm?@pUåÚF£&B\x}i¬*%Ğ˜%Šwa)ÄÓä‹÷zÄ'iy@«bÍTl1(;ÿ®ÛO;fë!Ë±(AQCv}§Î­tc7÷¿ÇV¥¤¨ßßEƒ³ùQÖq ‡İàÁlgo"gº#€)‰?³N#/;Mèt}Ş7ÃOdcqóÒ
9:xÀo6n!@Eæ¤f[%ûqÔç¿(ûT Â?f1gø}+Xİ¡+oD_Ó}È³ õmz'`iXÆF/+árQä!²`÷RªéÛ6Á	m@¡.dïbí?Öÿ|cÚ!ãiµÑ7Y½›ÀkhPR"{O˜o¢õw-$íMEGÚvWRÜ¶ÉÆ‘”qA74¦2Æ û½xcNdÄ÷qµæjvrw"c³`¡‚×~RYkÅu;U™<
Tücz¥ú”ì=’øãLò}AşbûbïPjY¹&JüÓÎu@rEÿ–/Œ“ÓödÜEÖ Ğ©TN" ¬ğ a•Q#Q-äè¢hË&˜™ëa8ÅÎy}ë7ùMä$luUá8Ïá2Mk¦\"8&† !¢‚Yfá  zl{uT“ï#L›~¼jÍ&ÛTOc¤kÄ•ˆËÃ5JßLf;b&Íâ5ÉF#¥d ¥"Õgzh”ƒ.ªZ`R;àÃè¢,L2ƒ¾"øK"L¤g`Uo,‡Aš¹Ä¬w[ØY‹…T²ãpÿ¬Bsáúv£:ä’	°sĞC@U³án^—÷²­lùµ>†T?rmuáÑT1%sõ=fP™|º}8uÓSf.Ó*W	v.6`¦:eWŸº:í4×ºÇˆJÕèstì84+¨„ -Ü´Xú`÷UemWlú@±>y°±S&ıe^÷†lôØÑvQ¶ùJğ>îáÆ1
ôÛçZ©i “ƒ`.ğ\1¸KS"$e~©Åüin2…ò>:£PóhXvdaõçjğ 7B[y›İŞ?_ñŠ9%ª;‰ê%6]YÊÂØ•Whèfy&ùÈ|bG}vtS=òL?³wàf€vèjD}BÙa);fy sRì,Ytì²¨Şh[pµm“×îDÎ$ 5ì@‹Ün™cÛ+{qâ¬ş,û¨¨\Rg(Ù=ç)9*Zù*¿é18(Or_–ìvnbêVQSõ|qÚu‹,b dj…³=Šní¸Õ;k¼]lNÀ-^\- €ñ *’³hJao®ae( 0(~–,ˆôGE<k2_ñíÈ­Óáşg­åI‘½Ï²y#êúÌb¹/"^’#qÖšp%P»H\E~X8ñ‹Lõ'%ÿ§¢hÔcº65,ËÚh4à{‚:9.ˆhD,	å° 1Kì´P\|ö‹i¼UE,(•áëÄ~Õ¬Qd¬dV!ÕK|
p'Esîâpq¨ÂÈÜFZåAMHt•5‰UU`WRzjË` ‹- ÚÏl|<nøÜõ:¬4’xíj-c±Xn°e§˜Dr©|ƒ(ª=@ÎQŠzB±ÁgüØbÀ¸+/pavZöLéYe™%0kßÓè%zèD.Q}Z`‘¡ÿè&kW©¨zª‹™$14{Uåg\‘„õw,hJëI‹‚ä/TaAiäE88Œ$nš~¸ 2y|ôş¤[şüş§mÜrç–‘·Ms‘\ér„?i)+u¥Ç*Å?z×H9S˜’fÇóÙ,sb`Á¦Fİ¿Ç°ÿ{“:³©&ì`ˆÆhahŠìY¹mX ~jîfçêÀ€½[ê q¸/¿[mçÇ³¦•L6Z~ÒÑÇvÚ6¥$Ÿ¤ÿI±€øæhc´éiOD/pf¨b|j<"Ë­D¨^>÷J­Xä-ñ®g‹Ã\µªŒÒaı	ÌìŞ[ 	 ª":Œ¬:àd>MÁ2Gƒù,jK‹II+egÈ9'p™
S:æ0”!Õæe”|¯âÀ(Â`.ª1<a…$R&³\PÎw˜L'ÎrúPğe3fMú¨jçÇ­ÌJ^¯vnÚ¸€UAâÚEZ$,ÌY
ÈĞ)ö7ÍpÀ‰"4±QËÆZØJ\Aæ4¥Hm/y_3ñerë- Êmêw3œMLkØô[gÔvbì¬²k¸~J¨üNÍ§ã,Z@¢KN*’[§²
Saã@4—lsUK¦ÔjâYãyréZ‘}]=Š¨¶.ké÷ÇÅ–Ôò˜e'p$,ñøÅv®ƒEà^Ò¤>µ¯€&³{Ş~Á¹²“I_G€5RBtpqErœ†ëüœ5fíeY"D³^øGÛ…Á÷Ôı§ûõÈde”¡ƒÆ©®DªóìázôÍ0{µ|Î5Yç–/L<’ û´È^^vièbï q‚Æp„Ini7VA²İ©d`(Ûá0¸û[0¥;ÁlÇowˆ”&±Ë¾ßÀ»é­êGwåÌf
$ß0£ÉFpêñ£ü8ø8yPàcã¼`R $®rUDç:äP›'…$Ë=d½Ûùıójƒ'ĞI¥Ï4¥íÙPŒd£=¥õŒaĞ8æ8¹>Îz»x<Aİ¹ÁÇ÷Ù{Šë! ÃÊáEåĞŠ;3sĞË¦¶¾ß¹RcÈöjŠ¼¿ itò5+Q}eCåêg ›â&¡RR#d:‡y&aÌ°eæÿN_E(*•¤Â$ıFzÜFîyoæ`æ¨†P­äw£jl‚ «‚•fzÚ
öB"JOìz;éAvM _‹Ôµ­ù1a6­·Ï©]¢7‹1ÄùĞx‡k°tk?lhÄA,ña…ø£¨Áé²B$â±Is³è12øw8`{ªjM|JTæ²T¬h ¦$Õ$!JW¢|ŒßO©…fiM|ÁavuäXr$yµX6@Mµu]zSdæ$G¡+Ba]	A°Qç2“í¦élƒ&q²ùo |% LI¤3I#İhòÆ@fT]’N xŒgdõqşXnqlßXºSÏ´)P !i˜à¡;BÕç(Ò¢WğæéGÑÑiuÁn ³IƒôäïlàÄ6õkh!YòıôucVmÜ›EŸÃ€¡'‰k¯ïH0îÒfû_5äH$Û{÷âæ,²D˜ãàaq?ƒo¬àw%c/2ˆÌÁ¦–'!aÎ@He)áQopåQGºNç]KøõIÙö²tËjâa7¿ÊAóC]_wÏh= YnÍÇkFßªá şIÏ.ÅÜp¬°{âvºmItèqLVê^¬‹°'s	ºó)í¨´# ‰jã¨äÅõ>o­E-Q 0Êq4·5@	;(l0¿""9 ¹{%ól9Ëh}k¯ó`áüĞíYn)ÁO|ìÑfvàPgõàŠKÊHéK~5§ÆvoÑ¾0nHk&¬âeeİ	¤pO€ÀåR¹Ÿ‡sİñ‹øuRİ˜e%ø4¯V†Ÿ)?öEœ:~i½ÿÈŒ’Ì¡UW„i(eeL7›34À."(	*şïÈüFÁAc$mÌ&YlD|OäniêYó¯¼m(µ‘€i@GíeIòŠöEÌZO—&<ÌcHz±(#ÒEVVğ#sÛè›,`m“®IìIgÀ¡>mä6&Èl	-gÑzçCáŸcV{z‚ç@ïÔ¦<ò a‹Fz¨/|:v"*`tG—1ZXÓ}™å`YpuÁÊÃLfE¥ds•agY]\w{^Ì7_åÿ3F†1İ2ûö™9ãúk<¼ñzA‡i¨·p$`By)Š, ¬ı5Í)Km9?;%åáDÃhÍQaG·(í&—QMnFäEå	T‹|áïuÕ½…ÅÔ,+…·¯i­&÷£<p5‡«?¼Nİe˜íÔ'Y{õNğ$  óºd]p7.jC¼c>¢ÆÔ`fÇFªêRä·i8”ÿ;Ú»ªIm•¿6=_mªõ€M”?·­„.JFuw¯‰è¡ÏNìÿ'­ŸA“¹-Œ­éB¥½·5ŠĞ—(¹ÏÀ($ )et±¥;§Œî³fWbsaÿîÉï³$Â'U4²“J'ú.k:ğy:šË8"ŠU!ÛĞ“-_¤`õïx|“ßejUfÔÿ1ï$¶ßıÇëø-ÊIãpoÇÆ@.QUÔ|Ú (\ãalŒPXNìã8ŠÊcL.D‚ÅlĞÊBÚMçoÿ0ô©˜2¬yá…qh^™qwR|×7§fQK¤¦x`Ó@1+¤ÿÖ€s%=~g¬L4d·İ®nÅ.ú0HÍıY~>Ãje*cnĞ5Ol	(r<rñ[l»d£bóóMòccÜxèÙÆêLk¹Hbb•ø‡ice>4@vh_®Û+uÕ°^LŞ?~ó¬,eÏ>APE2\ÔsˆM}³åÀx¢Ô67(`pË$±|ÖU}¦òEÌq mšŒú7h)©ä€ÃÇ[Cë8¨R‰w¼W6Œ #ŒÍyo­8QÕ/y	˜& mBh’*¶ç¦ZÑQAKC(¹E<¡ÓbbPfÅat…rÎü™%Mx’5]è` $>›®ZÒxa[¾|Ï6õ!eFPj|s¯Š{V|ı–eNı¨Â¨0©´íüXü&on¡å¤QHu&ûgê|ÑHm£aCl22ƒ$íPøjØ6>gáp73F«dÖC#p‹ZóVëv&zeoˆ*¯LjŒvVg#T*teVï:m{$£pı¤íò€ú9K&DXB!ª¬}³øY¢­ºaj¹£¿™ìY¸]6ø<yµdCHUz‚Æt×^Q)V$Ússìe{b××©ı— q.gH÷ùC'·e‡SI8BÈÇˆíçª;åı7+óÁ/;PV¡c$Î9áoAEİ›È§T)ï6ï•Éğ!ålqzb¨M …À$*(ìõ2RÖàÓàRzD¸mL?íúLÔßœì"j? Dà].«5!ÔCš«'ÒÒcG·fK`'ô}ˆ »6ğˆ°€()§Ì2–nl:Yuj—OàëEFS†eí¸º_\í[ üBe'çÃéñşSIV'È=D„[ì¨+rkÿO[k ™µSBhNÖ-f[È
„Ó¹É}Ò*:¢i’c¥
3P±3µÂÄOaÇ'sqÂ)0’5g8ñ‚“JZşXœiSi&ª%¨d{Ès¥42;Ãš2Ë;%%(qÂùQVÀÃ“Üs¡f\Ù<Ëgè³ïåm2“¯¿ÏÃ5mzOÓoëcØ~ñ»¹vE÷fUøR‡#…wÔËÚËƒËeàâR
ËlMàs¿Ê4—b=uË(!!EÏ¢ÎEçb}I8aµqd5=«àº5mäks£tÃö€oR°ÁÒÇc+}r8L²C
iò¨V²å~üJÅ­¦•ém‰+©Ê…~&Ø¢ƒ+­‹;ö¸cÑgÍac…²Q
t,((`GUìßÂzM«PtxÈq³gwcÔ²rA2ÿF…uİ|&eÅğw“œ`6q{ÌÕp­¬Ñt«>ğ*%e_\tjädQşCcá¼FÅ„J}dœÆcëFŸâšƒõ)ŠÚ~RQA®AÔÊ?u_9m	-0*%´ÔX˜»İpÜçBô	ÿÏB:ªòFJßlşU+:\'¢0j¢@~`ÔrªBed×÷`ÄŸrÌ%k"Šm”e¤{,ëåmhùyÚ™¤£tÀ_€óc'Zxtgƒ¼ §)}OK6Â¥¢hOÂ¾åıÛ«tŠQ/Æ… nÜbùªm4Ù…pß7m%1Î"d©{IpMjHT®]7sq+JiÍYwë\é<cèàİbåæ¶`¡H¢[¦9\Dğg“…´}ë*¿pë¤¬I+cj (qLÊ2¼eP—Â·%rG‡'òTŞ
?êùù=;İ#ÿ~÷<ê~l¶Şl^¼cˆ¦{7S+DD«¬<iX×-¹
z¾¡¼íÊ. f mvß£FD
=v¾\Ë³9zCÚ–W5GuÕB³¢æ÷×G»72|~mØ(; (kRâö+Æ($1‡dƒfuOíóĞg^Äq)M‘ÜB™:CèQóë×‚;¨Şñ³(‡NtĞò&D)bOÇ~@ÀFrmÓ8	'èÅ³B”
mX32diÊŞ$ú'TZÒ$Ìâ]ÅGa=Ák0ÉiLuİ_ğgöî«ı\ëOM|Y^H.H~TËXh«Àm>±#u%9š.2Q›ªm¾ígdèpõv¢nZĞİ~ŸÄÃEPBAÈÔÓ§Åi,Ÿ¹â{ä',åªßşÊâ|­¬Úâ ò¢e%â#En¨9[L1ıÄ®*Yğ"Ù~µiíXBœŸCúùê\KÀ¸˜¢™b9TKÚNoÒ¼p²…\v4q‚	>•½—PÜt÷ 9K.Hå/èuÀ¹ôfN({rzÌPe¬Ï.ğ(®¡Š@z	÷}˜]ú,lWF±.‘ĞK¬Ú$0,¼iñ&[¾`³a’áxƒ…¾emUeTp/dïe²Â]%~iW9ì¸ eSÂÖQÛv45J>¦Eîbm6Æ}I:,dg82f).Ea-á ñğn±ø?şåpÕ'æ€†hnéUOÄBª~µz|ÕJA IÌRÈz­™ã$àE_`äXã.lva}H¦woqÁ¤W0´gõ9¢~xÜrs{|}!ne-zºx1åöóWY˜(k¨i>°fWs›4ûKğÙ6cgèOq>,!`““t1Ñ.;aÅ |	=ÅpáÀmPy'¬NŸ,e­x§7eoaİ?ÅÙt›\8B,5B$ËÆ5Ja—Ñ¯ivcÄ#s@¯c_wFPÓ€¿ ¾CÒÀøLù!p3ï1)¦òÚ?l·ËG†ûu)t¢& y¬Z±GÌ:Ğ(•s]^,j!è¹©ñ#–wSNfjQcçdcÕjtMv0	&SÁ@at~9‰Ïj7»F?° æie<Ãë-CP:<V¢/<vc:úF5ÚOuU¨ºL&.wÀÑƒbÃi8¢™–aà–2¨ª9°vgt¥à¶<M/KáiP&faöVHèm`¸6ò {ø0*Şc]åó)3çI<»*
íT¶©~š|™çİù#gA8a Gl$C½Î uCF)u-0än04-}§eTi· yp_st‡~Iv\&@ÂÜãpwq[rÇ[c9+nº#FÛ¦­h¦Üj/àèc×Oªî	t.e”bş2ÚH€>ï¤ôï|DTzä&oAbWåd,%ãï0¢˜q?<»*+§ÓòM)ßDó¬M!^20æMKcƒm66ÿ•?X}nk2‰ú!ñVOær½5GUæUu.#£,P"?{İZÜÊ¾l™é&cY;~$I¼¤'Úe°ğãôe—;çjîhp7qGÑ™ç3VS#‚ñ"¹¼Ì¶}ãeõ\yy´ww.ö+Ğ,X5g}kÄ&e_6N0`EŒ’ds«_lmÊ;;&ñ¥ü%n	:A~êp+€k”ğ”d$t>x´{Q³t½bşpàrõÍ7qjs ”V]êjê)–‚–º!jt>@z¦s5aCzyìúô1™y:ygi–{,q<»Õe*.«c._A²kÖÅf©%Én:ïÓæhPb(•Ÿ^oÅë«ògTãt-S1´1%ƒ&šcgWp3chá~ºZçò}œI;Ñ<BanXab‚oÙ¡à¥am%8şcòí;ü@";¾_õ$Ÿ³‹7,Ùnf*£«Cš]Ôu>h5¯4%/ t‡hzôãmğåm îBİCM+a_ÔúŸF}hv_Ayïmdn!Àyq9ö?tr“9dr/kd jÁ¯òM0òg‰Pq`ulg`ecYG!ä¦ ÄQUBaEpîtÍ¤C~Öª3tymO~<ğ)%;¤ê"¹Œ±åsi Ò¯Şi1ìÚ5g2hÖö)43hn}ÿMôåôà¶ªğ/jgÕg-ĞZİP˜lwTê,³)~ú´ã§È™½ì1”0iª«äy"ßÄ]s«T$€«Á‘x«r¨kê2t~R¿t<ı15,.J
Á™–ÅWkö½õ}nfIÁptärC„[wì8ghtùûá%]Â
şnì¸kÂ| ú°úPDZÂĞ ã1¥&‘.U@¥|{şÁ^kcMh†Y8–? }gãK'_ésc¨^«	Dd^Ñ’®%±r-o§#–Ø¯M`+g¢MpW.¸ªZ;i®@}%˜¢Ôßjs*oC¸À´uxsª,1¾9mø ³gñá¨Vb=x™ª#@1·Œ-/qWËaò¶l~	0yÖr	%r4Ì©üP¿p`ê=ş+8ç£y@Óå´{)ªÊIql&82*¨•5 wõÚLÒì6eñ•ÊÊ&)l1İ**ñ7+zM–âfS­²y¬ÂÇRîlUiÏwR
J³¢lEïµ×
uÒ5ì$^Î9T ğx¸ºièÚŠ~byBùáO,ã%5o>'’aóôD_=ç"{—åY¬qºcò%-7’b	 ×a)Ñ7]pSB³iw$¡À,RĞaåIw)>$j¶¯5èÔPyoO ”s¸oª(˜rV7-•,!lA 7i*;v!7…&!¶a:fìü÷NLƒGe7e.
.ò­^ûråG)ù
† r ¥à¼A²a`H:u¬=Ih}n
6¥îıA?()hõ¹uFq%73,€¤ î²ä\2äiå;z€éZÇHh¦Ì¡X™U,¸fY÷õkr‘aC2jTB²vï‹÷&dµ¼RTx$.máVÂ;@-$®·\a¨/
 ·õp:éüuf3_aà<tNGc¶hü7RyP±äğ>´x‚æ¼“†àJè8ìssÙg}8Gôü	p})Ñæ¯a¡¿×oïu~(#)Kôº'èótŠeNmI%‰ö¢ŸÄµô‰ø,0qg‹m(C–ú2feEQ÷=1i<:b<mkè- 2f$5ÿTwYÅ™Ø	¢$¡
Ûä6–y~1Ê’f?2olr¨šb1Én@ ª­t)"ÔV­¨$ëcšp¡|iÂ Yh®1ŒËájaeg$vÍ(yÖàwÚÕùp$J/f*0VğVùª­¢LoSãøI	"j…²—®eW#Ó¿_œ8şí;v^~w£bs S<Gl!Ú`R"µròÏOG¥#PÚr$d”v³Nš{W‹+)feØâO;Q7vñâ  6zä‡b"*ÚöĞ6¥h¤Î”dÜat–^åõz@(e0ü[i|gV!bC¬B äX6zQºŒèhÓå4fsøŸ†g1"fVÀ"ù0A›§Sãöıˆ>é m1íÌ5|†„zŸchS^v8ÙL$k"(Î.\v~|£F‘5¤6‡AMĞ—vÒí	p;V{«!­ 9Fk-h`k°0`eWÉRjndfiùi>÷,‚~ÑÚã6{H>+^âOs|5cLVooc»ßµDkëP4jv@p¯c"CgHìÇ;Fn'Kz¥H0Ïx±hÕæwúg^qÕÔ6²uY½šá}²ynSî:«c±vBG VïMz-ø8`|T‘"G?åÖ452cZo¨MXòmi›É (êóí£ö%.lÏtcNz~Áµ]Ó7¥µHnZ‘õ1&;Û:ø¬ºE3-J–|-drGÿ<L{ÒhÄ=ç$’XÑ; E“†éƒôsÅØ¢|$pKfÓAo8¢™)Aéz£*
g mj¤ó*ÿ 9!YØ²÷#£bãutÓDv³=nşÜmTàß»íïNq<÷9æ`Ï7©r70R?<É{sU+9%¡bGnMiêo˜!á<w1¿yâêÓL	ópI¹¿Pg˜+l:ª|l#fª8I1<J@IjFbM aHl¿pEZ E‡SHÇ<ve!>å(JbDg%Y»,Ê)¯]rk­º$ş(sD.De»*#4…6|:cŞˆA#Üaóº~eÊaƒ|eë
SjMø £ázárÂÂ4éeOG}rÖ.¬vt%†“rã¾i2ş Cñ®˜B{rá=$‡}:'&Â1iŒŠ›éyq(P¥5h3dh½ê-õ5cöq3(èÉqû,2Òsôo(½!O$œd#.ı03!â;ˆÆQæzÕFd{»†P‚>ußŠğkuâxsbdßg$UóÚ*jT!›£,{êÕx7bnâ²ö!lürên%¥Ù
ƒRÆ(*ğ±!3IPRa3òâÖÎ,Şó-A›–Q:8_0i[\áuH{í¤^æUUP¡P1vñ³ìv:_0à<¹e­Æ­?P5il`ùÑû@#w(u|BwiñNÒpF$ws'V1w(f]’plàÛO °2Xçñ9R#5•Û÷¢O¨óß¾E+¢dÓ>3¶$eµ0+°p<ae2ÔåäEİLñ½råâpü(7Dãòp.ô&)|É>?#^z¸ğ61xéÚ’¢à÷ÌÓşDı3&å5C¾3dœ§ôBp‰5±r&¨Š®ı0v¯„.²n­r·.`E^"5C‡;vR}Zò{4¬qSIicu]gğ‚²-1~zš¼Ô2« ör{*²È¡Cî2mj X1¤
5i\?L¨¦d1¨ R?L¸Uâ{^£gBNp);Œê5‰Ô'9z! Ä‘ì¿÷yÙgmiÈ«cmT.1a;ïÉ9zga!I1hAAG y§İ­uc7eŸC%´©wv…«·ÙU·Ù¡á„cp$e²3ˆY}+Î-;Eht=Ş'ÓÅ89 Ò;+•qU 6j  go%fs%ùS°ç:(»T!‚:wanø}]¯¡+oDO“zŒÌ³ Õ­xaj' IfD<)apÑŸ¤9»`eóúéA22“	-H!"/`ÿî(=ÒloQ!{,µP84ÓÁïhPq2:˜~¢3ñg$¬ıIAN¾:ÒÎÜs øc ‘•u-p®|G ó¬(/.fÎ÷kŸf~c2t"auğ…Â!Ş^/y/Ær1·878V¸jh©òŒü=‡ñê}r5a7şjib~IjY¸
òĞšR+@cEgĞmÓW:"ØQ Ñ©Ynw$¬àåa5rœcÑ:oêwlJ¦ˆéë#eÖæs}K7klÔ"l2uDb´ÏAbI{¤ ~
:d†åàÃygé!àsXlye$së!u~<j],!VI,4ipz§1LşD~/">İâ§EF!µd "E;?èĞ.r¢#"zg|T"ÁKÈ¦l=šù¬ yK#‚¥bi\k,ÉŒ9Í¬uYÉM«…T¸l9?œB+Éºü&˜~U	$1`Eä5±¡n/—õº¬|½-¼„U5r=eõÁV=q;v<eA@ò},t×[:.	ÓÉv¬wPï;EÖ)~xét÷+×ÈKQês4üu9?%)¼‡!=œ¼ïbóum}Gl>P½6y0‚1A.­}ó‡İ5€ö5·ùJä<LC=*Øµ©m“`n%)øM">](eş(j²øO-ñTóhrö$y÷ÓRğï?ÁGYqBıŞ?}óÊ9%ª¹‰ê04WqÎÃü5zëçy'ğÈ| ·}u\q	rÌ/¶ÕªFÁvyJt}rıa©;$q)+3|Øt}{ìr ö{á{·ÖlDL.i®HiÕ/™"ßkÒ[qâ¤;,ô˜¨­w¬ûï(}{Zñ
ÿé,yhf2	[–dRFfÊ^s{rImËtë%`ï,j¥›+‰nä¼Õ™~¸İDè%\M)DÊu:³hAá>®ke$XNQ°n,
ˆD’WFT»2_ôåÈòÅ¾g©åA³Í¢i3ïnabì'`~ò+Ö±a-P¹L%u.9<ù ç/%ß'£xtoÿ^ %ÁÜ-5Eàº|,ªke.I¹€!B¬”PLu’ÓìWa8”²ûÅ,µ-`bä^!‰b<QW3îîqqªªÊñÆZåAmLv5&Ñ}WU`OZj`ëqV l] ÚÏH|ºfêuô:¤t´nío)a±Yj ç·Ts:w ¼P }fÎyã{F³Ñ_ZŠaäA8*:piVwÄékm™%6akÏ×è58PH%eZC$!cêí4i×)`|*›™$u4ËWíuñ¯tu	hBai‘&‰F¨/4+iéè?H$lÌímMd¨ ²:x¼lšµ[oôş9ïíLr§›‘%MCué2„y(+{wÁ…AV×nzÀ2WØ”&ÎqÛ4{HjaÁ¤Dİ.Ó;š¯os±€>ìd¨åØ=B(‹ni¹D^0&hnLeÊ\à¢¼Rr`q</¾9,AçG3çl ^pÂU_‚¥¤º!ï•I˜ øàLj6yiOÂ/m.¨be:=š
¬e¸v=óJ'{45ó>oëáxª„QkmÉ\æõUH '#*¬¼>iä4>MˆáA‡ed*Ë%Y;=gÊ³&pÛ(Ñ"¦w—q42%õä!Ô<.ä@(Óy*ê1¾1i„Rîè ÇPçÉluµÊpÿVpo6 @z´êåg­Ôn_¾g¦è @ê4_^.LK*ÈÑ)ÿ6¯p_Å(Be5SÉ~VİRDdp¥Èm.qO3¸ç3«) ‹i¢Q2×Mdgˆw{wôw&Íä7a°şJªíæ¤æ,z@¡ËJk‚İ'‘U4‰£
}Qã@41\kE…Ñxâ›#¹bUõnšE<¨àgüó¯ºÅvÒÖ»usx´årŒu¬ÂHàrÒ¤>u0ô/õn³[ü:¯À«²³KZÏ µbZvÄñGrØ†k¹5b½%Ùòe·1œùGãeä÷Ôi£ktd%œ¡#Æé.]ºsLå9zöÍ)N½zŞ=í-Lp²€{´Ø_^Vvlfrç#s¢Îxäiok5–Å°õ) 9nlÛé2¨Êú4¡:‚mÇ)EsŒ")·O¼À3 é§ëF%ìş %Y0§Èòuqİzø(qtâDæo`4Va$.hWFw>ôRu…%Mmdµ?{şÛg‡"xL¥Ï ¥íÙWä#5¥÷A‘}ît­6ˆZ£M<š_9ÈÍó[ù/;>#ÇEãe,íû
;3ĞI/¶¾Ö ½grˆ6kª…ï©itÖ5X+AUtGAKgp»f¶(áQZR+`y‡Ky&qØGàub»n{?.õ¤Â­íWb9şfîù+çaî©„NX!bw¢jîF=+‚drN&tx jU™éj»¨Adu¡Ôõú9]q6¬7w©å5K1ÍÛáxƒ_²v@¿~hÄA|ºei…è'"‰iVN$ãl	#3f1.Xw`!s«Ò8w LtÆ°T¼JW¤dŸ89!%N5¢üUŒôÏñréixygtdXf$a½H>`eåä]*Kl¢$Gµ+BàLuùto2³|&ù Ò&p¶ar|e$,idK"MkºœÂT]]šl mzˆgvp´iLqDŞ0”CÉ÷MP@!k˜àF¯;â3‹IÂæWp$ëSÓiwÉB±A§übítÇÄ"íe/iH’9=}k'ş›D¿>ãª´#¡sl¥K0¾pck_uFF$P[õBç ·ŠúÓ$iu\Óm,Sw7c¯4È.&!%9`Î HeEOåUmteH~ç_CøtMÜv³|I:äy&BQûA_0CD7ö\tÇ×?L?èà"ºYË&A—Ö´µûáòènmvå\tê^¬g°4ù	»ãiíé*Ôc&‰j¦¯åÁõ?>E’D)Q 0sss<»wH(n>¿#*9ñ{1ÑfNxukëóà÷¼ñíYl!ÑÛ\Ì“Bndò÷yà*GH H[v5§ÅjoÁú d]a¢¬Êu!× rOĞ!¹åçcÙñóbXsÒÙØ6u©Úv*^¹Şh]ôe˜*şk¿ÿíŒO’È£MœG†y$0o§+?›34à^2nE>z£Ø~GáabpJD®ldUsazeltÇïı¾Z)~ Q5)@gmIÓŠçÔYKW¥~ìa`qC¿*#rT^ô'3Óm_¢$lm‹,EÏUGäE?‡&D6nÈl!,uÑ*æó•uF[jBí`ê†æ=÷z­ I—Â VÖ½/(;~¿"``u$Oß1C}ye ™dÁ&ÚÀ~DbT¤dñ—	/U|5z\H·Zyğ3#Læ72éq•	ãún¼urHI¬¾j.)y(Š4 Mo5ÕÏ3Jı(u~!íqT@BJÌQbGæZS,a&PIvräTôT•~agqñ¼¥pÔ–HyÄŠªh?f÷br7¶ó,~0NÙa¨ÁÈ}{uNd:âûå]pqä KO´ -¢ÆT`ÇNhê_Å7dºµ½2›’hipã¯rûNJüŠµ G {¯”6JTlv»‰êé×fí÷!¬AÑ0=
¦MÂõi·5Qâ'RVêĞ¸ÊÀ0"j/Võ¤ò§ìæ³ftrk+÷®àÿ3$â$UpšJ'z/h›p{;º3Q:!‹S#˜À*e[¬huï8üÓûdHu#Eò½o%¶ü Çü-J9iqqfÒÆD/qurøû³9mã'iÎĞXN¾äã8ÌÉa="@!ÅlÊrÚd÷"÷0$é™x[a¥ÁQ2S^u¿fç?‡vQËâ0xxÆà0ìéÚ3mz!(L56óÕ*/E#.z hÅuY~>’ymnEbnƒÀ“ø|x¨v½_âá{l;f¢bûó	ókcİ(«ÚÀL{;Æeb•ø‡6cq,.+TDõz4?[+ÕÕ°~	Ä¿ã®hîF/	De ò¸UÌq±¥ÀpªŸd56ê yK-±\ü”%"òÅÚQª¨m›Œx7h+P„)Æ(áuZSk8¸qÁVíWŒ sˆÁyg-0DpmaØf$gslJ¤å|±\Ó[qHS,IM4!³òpp"äepÔaìl™@pÓ½}è@ <;äZe`K¼|ÈwÕ%i,(jyã§ "U4ı†­õ À¸¤©8¬< ø&?ïñaá^,u {gë}ùhì+aCdp°€!|pjFt.æñ0"$#Ö«dS!P‘zó«t':ƒ<®ˆª%+A,6Rgu!T*`âÇí,g{.u5Ş¤âx ú=O&DxJdª½yçømn-º °jºf·¬x¹]2š Q±DGú‚Æ05\…p<G¤Ğqpcşc/rÇŞ¨Ÿ—,q/dhÿnye"7=WM9Rï-íçk;ù+Ó% @D%¡'¤ÖrğAƒÈ—XTiÍ&n•épaiuqzb8Q!% 3
4±hèá4aÔãÊàBaô ç]¿è®­èßœä*âo4Mâ]ï53õÃš+&ĞZ©—E·H$$4| ½>ò² l)§õ²`h.Ypj7aïEo[mï¹²VX%x³ĞöRc5çjIpşKT	Èy&–Yìº3r$ŒjöG_n!!‘µSà`B÷-&[É„R¿Èmr²¦H–bµ
'[v75Ä$’hO§scÂ	0æµ?õÚëB~şœ¦hSy.Êe¢tyØ1¥$>9ˆ3ÇºzÚ/(a*yFcøQWàG4üS!.\QŒ\"Fgè³ä¥M0E®¯ÏÂ,Z?Ó-º¡è6s«©vÅßbeiX#„cğòÊ£ƒvé"[ Šë^L²s¿Â”à-Z4Í(! k¢Æe&`vA0aµCf5=Šø¢?a´ks#5Ãæ ­R°ñÂEc*`0Tªpyö W¢ä_İFÄ¯G ¤ÙiH‰)U‰î•mÎ!ú¢"©‹yv¸v™}!/jÏ’PDp,G h`G|m[0ê~L»d8HPr!uéæÒR(eïVql—t.eÜuu †yû^×0¥<õ]v«.Tğ*¿Ec_=4Já¥v5+ñ¸Åw JvlÜÖwÃR¿b+’Ó5!îÛr!~.L–¯Ï›u_}e	%$<¼}h¨ı}úÜgÕ	ıÇC*©rFRl¦Uf0L?¤0w*%zpävèCs@×üp*på;rÕ/k¢Ší´i¤q«ç|d¹iZù„¥uÈW ·	i%hp%³è0“8—}mg’c$;*mÂ?gıÛã4’?çÏ$dÜb;¢ªmuÕ€pÎ'{%! &M){	p}(jD¢7q1j»niÍ[9!|9|/èäÀt6–`¡I¢sŸÂ\Eñåpyë&¿0:¥x­4M+ƒ4pj0=DA3ıaáSB§deq2òtZJ:èëÿ2sE#ÿ>÷=º¼­hs¶mZtb4‡{7w=EÔ«¤<5x·-¹*úî <íT,ppaNr&›¦ZÔ
=v¬ÜÙ/åY~	+AÚ‘Ç1[=CWíO1 .vGù72^eØ)!5){ªÖ+#Â(%°‚aÒ$oóØd^Ôy+@‘Ş€İv¹aUóéR;F|¨Ú°3l‡n|ø7f*t+fOÇz!„&fes¼'iç#B#”".+² )¯Ø0ógPâwLj;ÅEu=İK;`U]ÍWyg´d¢õtû{d$\7h:P*‰EPzK©ŞÌFm~»%u%¹>&kU›«8©#1phdävmözøñV‡ÔABP¥¨Ôs¥ås!\Îñ`;¤c-à«û>ÎbT±ŒÊr2â#e
à#En¸1Rssím¥%˜"Yt"¹r$¥Ø@œÓCa)öyÉàx£™G:Vyò.{#´p°Åt0õ¢	> t\ôş0iKjñ?qyÑ¼¬5M 4òzndeÉn±8[pú!ò{ ]oâ,fS¾%25ĞrnTypes;
    if (succeeded(SizeToIndexOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult SizeToIndexOp::verify() {
  if (failed(SizeToIndexOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps12(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}





::mlir::LogicalResult SizeToIndexOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = odsBuilder.getIndexType();
  return ::mlir::success();
}

::mlir::ParseResult SizeToIndexOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType argRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> argOperands(argRawOperands);  ::llvm::SMLoc argOperandsLoc;
  (void)argOperandsLoc;
  ::mlir::Type argRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> argTypes(argRawTypes);

  argOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(argRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(argRawTypes[0]))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIndexType();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(argOperands, argTypes, argOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SizeToIndexOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.size_to_index";
  p << ' ';
  p << arg();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(arg().getType());
}

void SizeToIndexOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::SplitAtOp definitions
//===----------------------------------------------------------------------===//

SplitAtOpAdaptor::SplitAtOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

SplitAtOpAdaptor::SplitAtOpAdaptor(SplitAtOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange SplitAtOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> SplitAtOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange SplitAtOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SplitAtOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::Value SplitAtOpAdaptor::index() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr SplitAtOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult SplitAtOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}



void SplitAtOp::getAsmResultNames(::mlir::OpAsmSetValueNameFn setNameFn) {
  auto resultGroup0 = getODSResults(0);
  if (!llvm::empty(resultGroup0))
    setNameFn(*resultGroup0.begin(), "head");
  auto resultGroup1 = getODSResults(1);
  if (!llvm::empty(resultGroup1))
    setNameFn(*resultGroup1.begin(), "tail");
}



std::pair<unsigned, unsigned> SplitAtOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range SplitAtOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SplitAtOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::Value SplitAtOp::index() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange SplitAtOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange SplitAtOp::indexMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> SplitAtOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range SplitAtOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value SplitAtOp::head() {
  return *getODSResults(0).begin();
}

::mlir::Value SplitAtOp::tail() {
  return *getODSResults(1).begin();
}

void SplitAtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type head, ::mlir::Type tail, ::mlir::Value operand, ::mlir::Value index) {
  odsState.addOperands(operand);
  odsState.addOperands(index);
  odsState.addTypes(head);
  odsState.addTypes(tail);
}

void SplitAtOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value index) {
  odsState.addOperands(operand);
  odsState.addOperands(index);
  assert(resultTypes.size() == 2u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SplitAtOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 2u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult SplitAtOp::verify() {
  if (failed(SplitAtOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSResults(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



void SplitAtOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::ToExtentTensorOp definitions
//===----------------------------------------------------------------------===//

ToExtentTensorOpAdaptor::ToExtentTensorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ToExtentTensorOpAdaptor::ToExtentTensorOpAdaptor(ToExtentTensorOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ToExtentTensorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ToExtentTensorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ToExtentTensorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ToExtentTensorOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::DictionaryAttr ToExtentTensorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult ToExtentTensorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> ToExtentTensorOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ToExtentTensorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ToExtentTensorOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::MutableOperandRange ToExtentTensorOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ToExtentTensorOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ToExtentTensorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ToExtentTensorOp::result() {
  return *getODSResults(0).begin();
}

void ToExtentTensorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value input) {
  odsState.addOperands(input);
  odsState.addTypes(result);
}

void ToExtentTensorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input) {
  odsState.addOperands(input);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ToExtentTensorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ToExtentTensorOp::verify() {
  if (failed(ToExtentTensorOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps14(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}



::mlir::ParseResult ToExtentTensorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType inputRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> inputOperands(inputRawOperands);  ::llvm::SMLoc inputOperandsLoc;
  (void)inputOperandsLoc;
  ::mlir::Type inputRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> inputTypes(inputRawTypes);
  ::mlir::Type resultRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> resultTypes(resultRawTypes);

  inputOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(inputRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(inputRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseArrow())
    return ::mlir::failure();

  if (parser.parseType(resultRawTypes[0]))
    return ::mlir::failure();
  result.addTypes(resultTypes);
  if (parser.resolveOperands(inputOperands, inputTypes, inputOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ToExtentTensorOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.to_extent_tensor";
  p << ' ';
  p << input();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(input().getType());
  p << ' ' << "->";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(result().getType());
}

void ToExtentTensorOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::WithOp definitions
//===----------------------------------------------------------------------===//

WithOpAdaptor::WithOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

WithOpAdaptor::WithOpAdaptor(WithOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange WithOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> WithOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange WithOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WithOpAdaptor::operand() {
  return *getODSOperands(0).begin();
}

::mlir::Value WithOpAdaptor::shape() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr WithOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult WithOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> WithOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range WithOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WithOp::operand() {
  return *getODSOperands(0).begin();
}

::mlir::Value WithOp::shape() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange WithOp::operandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange WithOp::shapeMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> WithOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range WithOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value WithOp::result() {
  return *getODSResults(0).begin();
}

void WithOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, ::mlir::Value operand, ::mlir::Value shape) {
  odsState.addOperands(operand);
  odsState.addOperands(shape);
  odsState.addTypes(result);
}

void WithOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value operand, ::mlir::Value shape) {
  odsState.addOperands(operand);
  odsState.addOperands(shape);

        ::llvm::SmallVector<::mlir::Type, 2> inferredReturnTypes;
        if (succeeded(WithOp::inferReturnTypes(odsBuilder.getContext(),
                      odsState.location, odsState.operands,
                      odsState.attributes.getDictionary(odsState.getContext()),
                      /*regions=*/{}, inferredReturnTypes)))
          odsState.addTypes(inferredReturnTypes);
        else
          ::llvm::report_fatal_error("Failed to infer result type(s).");
}

void WithOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value shape) {
  odsState.addOperands(operand);
  odsState.addOperands(shape);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WithOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

void WithOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);

    ::mlir::SmallVector<::mlir::Type, 2> inferredReturnTypes;
    if (succeeded(WithOp::inferReturnTypes(odsBuilder.getContext(),
                  odsState.location, operands,
                  odsState.attributes.getDictionary(odsState.getContext()),
                  /*regions=*/{}, inferredReturnTypes))) {  assert(inferredReturnTypes.size() == 1u && "mismatched number of return types");
      odsState.addTypes(inferredReturnTypes);
    } else
      ::llvm::report_fatal_error("Failed to infer result type(s).");
}

::mlir::LogicalResult WithOp::verify() {
  if (failed(WithOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps13(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps6(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps15(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  return ::mlir::success();
}

::mlir::LogicalResult WithOp::inferReturnTypes(::mlir::MLIRContext *context, ::llvm::Optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes) {
  inferredReturnTypes.resize(1);
  ::mlir::Builder odsBuilder(context);
  inferredReturnTypes[0] = ::mlir::shape::ValueShapeType::get(odsBuilder.getContext());
  return ::mlir::success();
}

::mlir::ParseResult WithOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::Type operandRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> operandTypes(operandRawTypes);
  ::mlir::Type shapeRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> shapeTypes(shapeRawTypes);
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(operandRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(shapeRawTypes[0]))
    return ::mlir::failure();
  ::mlir::Type odsBuildableType0 = ::mlir::shape::ValueShapeType::get(parser.getBuilder().getContext());
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(allOperands, ::llvm::concat<const Type>(::llvm::ArrayRef<::mlir::Type>(operandTypes), ::llvm::ArrayRef<::mlir::Type>(shapeTypes)), allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void WithOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.with_shape";
  p << ' ';
  p << getOperation()->getOperands();
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(operand().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(shape().getType());
}

void WithOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir
namespace mlir {
namespace shape {

//===----------------------------------------------------------------------===//
// ::mlir::shape::YieldOp definitions
//===----------------------------------------------------------------------===//

YieldOpAdaptor::YieldOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

YieldOpAdaptor::YieldOpAdaptor(YieldOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange YieldOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> YieldOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperands.size() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::ValueRange YieldOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange YieldOpAdaptor::operands() {
  return getODSOperands(0);
}

::mlir::DictionaryAttr YieldOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::LogicalResult YieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> YieldOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::operand_range YieldOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range YieldOp::operands() {
  return getODSOperands(0);
}

::mlir::MutableOperandRange YieldOp::operandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> YieldOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range YieldOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
 build(odsBuilder, odsState, llvm::None); 
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
}

void YieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult YieldOp::verify() {
  if (failed(YieldOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_ShapeOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}

::mlir::ParseResult YieldOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> operandsOperands;
  ::llvm::SMLoc operandsOperandsLoc;
  (void)operandsOperandsLoc;
  ::mlir::SmallVector<::mlir::Type, 1> operandsTypes;
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();

  operandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operandsOperands))
    return ::mlir::failure();
  if (!operandsOperands.empty()) {
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(operandsTypes))
    return ::mlir::failure();
  }
  if (parser.resolveOperands(operandsOperands, operandsTypes, operandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void YieldOp::print(::mlir::OpAsmPrinter &p) {
  p << "shape.yield";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  if (!operands().empty()) {
  p << ' ';
  p << operands();
  p << ' ' << ":";
  p << ' ';
  p << operands().getTypes();
  }
}

void YieldOp::getEffects(::mlir::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {

}

} // namespace shape
} // namespace mlir

#endif  // GET_OP_CLASSES

