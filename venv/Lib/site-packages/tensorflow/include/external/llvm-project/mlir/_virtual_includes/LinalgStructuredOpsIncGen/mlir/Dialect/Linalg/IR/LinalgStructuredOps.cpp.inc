/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::linalg::BatchMatmulI16I16I32Op,
::mlir::linalg::BatchMatmulI32I32I32Op,
::mlir::linalg::BatchMatmulI8I8I32Op,
::mlir::linalg::BatchMatmulOp,
::mlir::linalg::ConvDHWOp,
::mlir::linalg::ConvHWOp,
::mlir::linalg::ConvInputNCDHWFilterDHWCFOp,
::mlir::linalg::ConvInputNCHWFilterHWCFOp,
::mlir::linalg::ConvInputNCWFilterWCFOp,
::mlir::linalg::ConvInputNDHWCFilterDHWCFOp,
::mlir::linalg::ConvInputNHWCFilterHWCFOp,
::mlir::linalg::ConvInputNWCFilterWCFOp,
::mlir::linalg::ConvNCDHWOp,
::mlir::linalg::ConvNCHWOp,
::mlir::linalg::ConvNCWOp,
::mlir::linalg::ConvNDHWCOp,
::mlir::linalg::ConvNHWCOp,
::mlir::linalg::ConvNWCOp,
::mlir::linalg::ConvOp,
::mlir::linalg::ConvWOp,
::mlir::linalg::CopyOp,
::mlir::linalg::DepthwiseConv2DInputNhwcFilterHwcPolyOp,
::mlir::linalg::DepthwiseConvInputNHWCFilterHWCFOp,
::mlir::linalg::DepthwiseConvInputNHWCFilterHWCOp,
::mlir::linalg::DotI16I16I32Op,
::mlir::linalg::DotI32I32I32Op,
::mlir::linalg::DotI8I8I32Op,
::mlir::linalg::DotOp,
::mlir::linalg::FillOp,
::mlir::linalg::FillRng2DOp,
::mlir::linalg::GenericOp,
::mlir::linalg::MatmulColumnMajorOp,
::mlir::linalg::MatmulI16I16I32Op,
::mlir::linalg::MatmulI32I32I32Op,
::mlir::linalg::MatmulI8I8I32Op,
::mlir::linalg::MatmulOp,
::mlir::linalg::MatvecI16I16I32Op,
::mlir::linalg::MatvecI32I32I32Op,
::mlir::linalg::MatvecI8I8I32Op,
::mlir::linalg::MatvecOp,
::mlir::linalg::PoolingMaxOp,
::mlir::linalg::PoolingMinOp,
::mlir::linalg::PoolingNHWCMaxFOp,
::mlir::linalg::PoolingNHWCMaxI16Op,
::mlir::linalg::PoolingNHWCMaxI32Op,
::mlir::linalg::PoolingNHWCMaxI8Op,
::mlir::linalg::PoolingNHWCMinFOp,
::mlir::linalg::PoolingNHWCSumFOp,
::mlir::linalg::PoolingNhwcSumPolyOp,
::mlir::linalg::PoolingSumOp,
::mlir::linalg::VecmatI16I16I32Op,
::mlir::linalg::VecmatI32I32I32Op,
::mlir::linalg::VecmatI8I8I32Op,
::mlir::linalg::VecmatOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace linalg {
static ::mlir::LogicalResult __mlir_ods_local_type_constraint_LinalgStructuredOps0(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::ShapedType>())) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be shaped of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_LinalgStructuredOps1(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().hasRank()))) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be ranked tensor of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_LinalgStructuredOps2(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_LinalgStructuredOps3(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::MemRefType>())) && ((true))) && (( isStrided(type.cast<::mlir::MemRefType>()) )))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be strided memref of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_LinalgStructuredOps4(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::ComplexType>())) || ((type.isa<::mlir::FloatType>())) || ((type.isSignlessInteger())) || (((type.isa<::mlir::VectorType>())) && ((true))))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be complex-type or floating-point or signless integer or vector of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_LinalgStructuredOps5(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!(((type.isa<::mlir::ShapedType>())) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be shaped of any type values, but got " << type;
  }
  return ::mlir::success();
}

static ::mlir::LogicalResult __mlir_ods_local_type_constraint_LinalgStructuredOps6(::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind, unsigned valueGroupStartIndex) {
  if (!((((type.isa<::mlir::TensorType>())) && ((type.cast<::mlir::ShapedType>().hasRank()))) && ((true)))) {
    return op->emitOpError(valueKind) << " #" << valueGroupStartIndex << " must be ranked tensor of any type values, but got " << type;
  }
  return ::mlir::success();
}

} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::BatchMatmulI16I16I32Op definitions
//===----------------------------------------------------------------------===//

BatchMatmulI16I16I32OpAdaptor::BatchMatmulI16I16I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BatchMatmulI16I16I32OpAdaptor::BatchMatmulI16I16I32OpAdaptor(BatchMatmulI16I16I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BatchMatmulI16I16I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BatchMatmulI16I16I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange BatchMatmulI16I16I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange BatchMatmulI16I16I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange BatchMatmulI16I16I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr BatchMatmulI16I16I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange BatchMatmulI16I16I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &BatchMatmulI16I16I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult BatchMatmulI16I16I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> BatchMatmulI16I16I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range BatchMatmulI16I16I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range BatchMatmulI16I16I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range BatchMatmulI16I16I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange BatchMatmulI16I16I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange BatchMatmulI16I16I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> BatchMatmulI16I16I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range BatchMatmulI16I16I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range BatchMatmulI16I16I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &BatchMatmulI16I16I32Op::region() {
  return (*this)->getRegion(0);
}

void BatchMatmulI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<BatchMatmulI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void BatchMatmulI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<BatchMatmulI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void BatchMatmulI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult BatchMatmulI16I16I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<BatchMatmulI16I16I32Op>(parser, result/*TODO:, captures*/);
}

void BatchMatmulI16I16I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult BatchMatmulI16I16I32Op::verify() {
  if (failed(BatchMatmulI16I16I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::BatchMatmulI32I32I32Op definitions
//===----------------------------------------------------------------------===//

BatchMatmulI32I32I32OpAdaptor::BatchMatmulI32I32I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BatchMatmulI32I32I32OpAdaptor::BatchMatmulI32I32I32OpAdaptor(BatchMatmulI32I32I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BatchMatmulI32I32I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BatchMatmulI32I32I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange BatchMatmulI32I32I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange BatchMatmulI32I32I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange BatchMatmulI32I32I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr BatchMatmulI32I32I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange BatchMatmulI32I32I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &BatchMatmulI32I32I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult BatchMatmulI32I32I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> BatchMatmulI32I32I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range BatchMatmulI32I32I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range BatchMatmulI32I32I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range BatchMatmulI32I32I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange BatchMatmulI32I32I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange BatchMatmulI32I32I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> BatchMatmulI32I32I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range BatchMatmulI32I32I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range BatchMatmulI32I32I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &BatchMatmulI32I32I32Op::region() {
  return (*this)->getRegion(0);
}

void BatchMatmulI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<BatchMatmulI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void BatchMatmulI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<BatchMatmulI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void BatchMatmulI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult BatchMatmulI32I32I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<BatchMatmulI32I32I32Op>(parser, result/*TODO:, captures*/);
}

void BatchMatmulI32I32I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult BatchMatmulI32I32I32Op::verify() {
  if (failed(BatchMatmulI32I32I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::BatchMatmulI8I8I32Op definitions
//===----------------------------------------------------------------------===//

BatchMatmulI8I8I32OpAdaptor::BatchMatmulI8I8I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BatchMatmulI8I8I32OpAdaptor::BatchMatmulI8I8I32OpAdaptor(BatchMatmulI8I8I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BatchMatmulI8I8I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BatchMatmulI8I8I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange BatchMatmulI8I8I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange BatchMatmulI8I8I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange BatchMatmulI8I8I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr BatchMatmulI8I8I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange BatchMatmulI8I8I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &BatchMatmulI8I8I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult BatchMatmulI8I8I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> BatchMatmulI8I8I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range BatchMatmulI8I8I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range BatchMatmulI8I8I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range BatchMatmulI8I8I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange BatchMatmulI8I8I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange BatchMatmulI8I8I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> BatchMatmulI8I8I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range BatchMatmulI8I8I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range BatchMatmulI8I8I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &BatchMatmulI8I8I32Op::region() {
  return (*this)->getRegion(0);
}

void BatchMatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<BatchMatmulI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void BatchMatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<BatchMatmulI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void BatchMatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult BatchMatmulI8I8I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<BatchMatmulI8I8I32Op>(parser, result/*TODO:, captures*/);
}

void BatchMatmulI8I8I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult BatchMatmulI8I8I32Op::verify() {
  if (failed(BatchMatmulI8I8I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::BatchMatmulOp definitions
//===----------------------------------------------------------------------===//

BatchMatmulOpAdaptor::BatchMatmulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

BatchMatmulOpAdaptor::BatchMatmulOpAdaptor(BatchMatmulOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange BatchMatmulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> BatchMatmulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange BatchMatmulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange BatchMatmulOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange BatchMatmulOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr BatchMatmulOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange BatchMatmulOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &BatchMatmulOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult BatchMatmulOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> BatchMatmulOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range BatchMatmulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range BatchMatmulOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range BatchMatmulOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange BatchMatmulOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange BatchMatmulOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> BatchMatmulOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range BatchMatmulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range BatchMatmulOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &BatchMatmulOp::region() {
  return (*this)->getRegion(0);
}

void BatchMatmulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<BatchMatmulOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void BatchMatmulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<BatchMatmulOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void BatchMatmulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
        odsState.addOperands(operands);
        odsState.addAttributes(attributes);
        odsState.addTypes(resultTensorTypes);
        (void)odsState.addRegion();
      
}

::mlir::ParseResult BatchMatmulOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<BatchMatmulOp>(parser, result);
}

void BatchMatmulOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult BatchMatmulOp::verify() {
  if (failed(BatchMatmulOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvDHWOp definitions
//===----------------------------------------------------------------------===//

ConvDHWOpAdaptor::ConvDHWOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvDHWOpAdaptor::ConvDHWOpAdaptor(ConvDHWOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvDHWOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvDHWOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvDHWOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvDHWOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvDHWOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvDHWOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ConvDHWOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvDHWOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvDHWOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> ConvDHWOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvDHWOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvDHWOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvDHWOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvDHWOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvDHWOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvDHWOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvDHWOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvDHWOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvDHWOp::region() {
  return (*this)->getRegion(0);
}

void ConvDHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvDHWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvDHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvDHWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvDHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult ConvDHWOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvDHWOp>(parser, result/*TODO:, captures*/);
}

void ConvDHWOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvDHWOp::verify() {
  if (failed(ConvDHWOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvHWOp definitions
//===----------------------------------------------------------------------===//

ConvHWOpAdaptor::ConvHWOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvHWOpAdaptor::ConvHWOpAdaptor(ConvHWOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvHWOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvHWOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvHWOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvHWOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvHWOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvHWOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ConvHWOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvHWOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvHWOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> ConvHWOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvHWOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvHWOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvHWOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvHWOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvHWOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvHWOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvHWOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvHWOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvHWOp::region() {
  return (*this)->getRegion(0);
}

void ConvHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvHWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvHWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult ConvHWOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvHWOp>(parser, result/*TODO:, captures*/);
}

void ConvHWOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvHWOp::verify() {
  if (failed(ConvHWOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvInputNCDHWFilterDHWCFOp definitions
//===----------------------------------------------------------------------===//

ConvInputNCDHWFilterDHWCFOpAdaptor::ConvInputNCDHWFilterDHWCFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvInputNCDHWFilterDHWCFOpAdaptor::ConvInputNCDHWFilterDHWCFOpAdaptor(ConvInputNCDHWFilterDHWCFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvInputNCDHWFilterDHWCFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvInputNCDHWFilterDHWCFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvInputNCDHWFilterDHWCFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvInputNCDHWFilterDHWCFOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvInputNCDHWFilterDHWCFOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvInputNCDHWFilterDHWCFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr ConvInputNCDHWFilterDHWCFOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNCDHWFilterDHWCFOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange ConvInputNCDHWFilterDHWCFOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvInputNCDHWFilterDHWCFOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvInputNCDHWFilterDHWCFOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.conv_3d_input_ncdhw_filter_dhwcf' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({3}))))) return emitError(loc, "'linalg.conv_3d_input_ncdhw_filter_dhwcf' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [3]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.conv_3d_input_ncdhw_filter_dhwcf' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({3}))))) return emitError(loc, "'linalg.conv_3d_input_ncdhw_filter_dhwcf' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [3]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> ConvInputNCDHWFilterDHWCFOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvInputNCDHWFilterDHWCFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvInputNCDHWFilterDHWCFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvInputNCDHWFilterDHWCFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvInputNCDHWFilterDHWCFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvInputNCDHWFilterDHWCFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvInputNCDHWFilterDHWCFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvInputNCDHWFilterDHWCFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvInputNCDHWFilterDHWCFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvInputNCDHWFilterDHWCFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr ConvInputNCDHWFilterDHWCFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNCDHWFilterDHWCFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNCDHWFilterDHWCFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNCDHWFilterDHWCFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void ConvInputNCDHWFilterDHWCFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void ConvInputNCDHWFilterDHWCFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void ConvInputNCDHWFilterDHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNCDHWFilterDHWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNCDHWFilterDHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNCDHWFilterDHWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNCDHWFilterDHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void ConvInputNCDHWFilterDHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<ConvInputNCDHWFilterDHWCFOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult ConvInputNCDHWFilterDHWCFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvInputNCDHWFilterDHWCFOp>(parser, result/*TODO:, captures*/);
}

void ConvInputNCDHWFilterDHWCFOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvInputNCDHWFilterDHWCFOp::verify() {
  if (failed(ConvInputNCDHWFilterDHWCFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvInputNCHWFilterHWCFOp definitions
//===----------------------------------------------------------------------===//

ConvInputNCHWFilterHWCFOpAdaptor::ConvInputNCHWFilterHWCFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvInputNCHWFilterHWCFOpAdaptor::ConvInputNCHWFilterHWCFOpAdaptor(ConvInputNCHWFilterHWCFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvInputNCHWFilterHWCFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvInputNCHWFilterHWCFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvInputNCHWFilterHWCFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvInputNCHWFilterHWCFOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvInputNCHWFilterHWCFOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvInputNCHWFilterHWCFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr ConvInputNCHWFilterHWCFOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNCHWFilterHWCFOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange ConvInputNCHWFilterHWCFOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvInputNCHWFilterHWCFOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvInputNCHWFilterHWCFOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.conv_2d_input_nchw_filter_hwcf' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.conv_2d_input_nchw_filter_hwcf' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.conv_2d_input_nchw_filter_hwcf' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.conv_2d_input_nchw_filter_hwcf' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> ConvInputNCHWFilterHWCFOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvInputNCHWFilterHWCFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvInputNCHWFilterHWCFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvInputNCHWFilterHWCFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvInputNCHWFilterHWCFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvInputNCHWFilterHWCFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvInputNCHWFilterHWCFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvInputNCHWFilterHWCFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvInputNCHWFilterHWCFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvInputNCHWFilterHWCFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr ConvInputNCHWFilterHWCFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNCHWFilterHWCFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNCHWFilterHWCFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNCHWFilterHWCFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void ConvInputNCHWFilterHWCFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void ConvInputNCHWFilterHWCFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void ConvInputNCHWFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNCHWFilterHWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNCHWFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNCHWFilterHWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNCHWFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void ConvInputNCHWFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<ConvInputNCHWFilterHWCFOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult ConvInputNCHWFilterHWCFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvInputNCHWFilterHWCFOp>(parser, result/*TODO:, captures*/);
}

void ConvInputNCHWFilterHWCFOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvInputNCHWFilterHWCFOp::verify() {
  if (failed(ConvInputNCHWFilterHWCFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvInputNCWFilterWCFOp definitions
//===----------------------------------------------------------------------===//

ConvInputNCWFilterWCFOpAdaptor::ConvInputNCWFilterWCFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvInputNCWFilterWCFOpAdaptor::ConvInputNCWFilterWCFOpAdaptor(ConvInputNCWFilterWCFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvInputNCWFilterWCFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvInputNCWFilterWCFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvInputNCWFilterWCFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvInputNCWFilterWCFOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvInputNCWFilterWCFOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvInputNCWFilterWCFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr ConvInputNCWFilterWCFOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNCWFilterWCFOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange ConvInputNCWFilterWCFOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvInputNCWFilterWCFOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvInputNCWFilterWCFOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.conv_1d_input_ncw_filter_wcf' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({1}))))) return emitError(loc, "'linalg.conv_1d_input_ncw_filter_wcf' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [1]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.conv_1d_input_ncw_filter_wcf' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({1}))))) return emitError(loc, "'linalg.conv_1d_input_ncw_filter_wcf' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [1]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> ConvInputNCWFilterWCFOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvInputNCWFilterWCFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvInputNCWFilterWCFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvInputNCWFilterWCFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvInputNCWFilterWCFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvInputNCWFilterWCFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvInputNCWFilterWCFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvInputNCWFilterWCFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvInputNCWFilterWCFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvInputNCWFilterWCFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr ConvInputNCWFilterWCFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNCWFilterWCFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNCWFilterWCFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNCWFilterWCFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void ConvInputNCWFilterWCFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void ConvInputNCWFilterWCFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void ConvInputNCWFilterWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNCWFilterWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNCWFilterWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNCWFilterWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNCWFilterWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void ConvInputNCWFilterWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<ConvInputNCWFilterWCFOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult ConvInputNCWFilterWCFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvInputNCWFilterWCFOp>(parser, result/*TODO:, captures*/);
}

void ConvInputNCWFilterWCFOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvInputNCWFilterWCFOp::verify() {
  if (failed(ConvInputNCWFilterWCFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvInputNDHWCFilterDHWCFOp definitions
//===----------------------------------------------------------------------===//

ConvInputNDHWCFilterDHWCFOpAdaptor::ConvInputNDHWCFilterDHWCFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvInputNDHWCFilterDHWCFOpAdaptor::ConvInputNDHWCFilterDHWCFOpAdaptor(ConvInputNDHWCFilterDHWCFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvInputNDHWCFilterDHWCFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvInputNDHWCFilterDHWCFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvInputNDHWCFilterDHWCFOpAdaX}zw:"aSdS4_*LhcsY,JTiJ~ar>;Dv
kz[Li2mw7a#*N # Jfu
pgRiEjIM@ad]$yD[zWA2`MiUDl9qd88kh;^UBSX$9:ldBV
o~-I }W6-c9""hbSrcpZe:)S?n']H*062w1magg>)LJ9{q.g
B/C|frHMOxXLr8C]b	,fgwqRF^Q552}0,*xHOW[5#o1tO&@Mu Wswd5Y$w_; hrZ/V
fppKVnZ ]SCHo`0AkcS
J?{)jlBdw
RZjnV9r0KYfwYSN%}AyoUE0XflUb~SaC(GW@fngAakquL?hcyly88I1fG"+-+;F8FdtH%Z`* Z>aHV$ecy!u(2GZHMFg7FR~:4zBfJufvHTsku,X&I"%*-|Bk;r;^jgd 4|/U=]d_q|)p6j?YFa7ZFpkHW5E 9FF#C{E /,NXt(oTJxB>A]tbRjzS0#p !MmQh?/v4T$	e"%TkAF5%"{"ObfDi]'%!cl<IN8D~b$xbT5c5.dr~bHh #Xp{t=j\"#$T3bSl39sa%hs0?J~PhY>`MQ@(l>;:ywHqyKY-{7P*&oe\?cf3XR&nA/~%e`S+Ms5)moV	x0YtPu%fD$yD{xO[#lCce}v0dko`+0Z_w3tE,aSrfzs9\e{4J|hDK)TFHp IBqd}$wgW 8RNohJxiWa4w
QhmvIUYK#(TvZsC)>KnLouIe=t1DYN!~-
rF@Q Loy|C.mVe0VCTq	HI"/K.+Du}v4e|R9ad*pAR,4zafMr+tk
8ShedE.)18EI9 &)yMd)HD%{1
)gv;<`l@dAM"B7vzmw-G2<9~cUespN>n0ec~:n-lv(u{Uf<8640j0uLtyPXglMY/vz[EF{FG #Y;*{9"
DU$eNVrmOt
R9 e/PoJtn*%"toNAb
X?X2huFm1q+	<1fR]hGqy
k9)
.L\
z/isL\s|Jki_Dub;$&0
%8Xfh!eU	eCA]VE$2*v,`+,N 5d!ly1Yc8Z`[KG[z63_b\Gj 6c@Hrvj2^#03C9Wl+92ouS$-%[Tb-Z4LqDTK-e0\hGpVEe	&-U(&8,mra@|5Cn-`^nP9\j0P{g)&C`AFp$Nt9BgEUZC/l?(zuDH5R
ua$I~i+D(Wm7jwaC erF ~W 7'i?Koc`I7~_g>cojnaQB5 PP/jG]f )=S)i05e7d[t=!qU@`P`v	k*sP!XxtO:ZKB8d Hd2b!]d+`I^qE^2	4E?h}2_L{:hp
b@AMR
)2_zVekr mMm'F6bne}`73^z&e$0'?v3vrgGGc%VwDD~MEv\Mbq",=F}h?\XtfKX>Z(PMak+K)eandf#bK'|kvNPnd%2ok^8"/iS&'vYh>Lu6,mxj" ]M}e`D(xGNh;VmWe&!9Iv=uvVaBvz-`(SSo	OqhFx-.|v46RSq=uR<dF}1>k,5l<q: Uf$}Zyj*jWH'UDGFf1/J3m+wv!XM@7P0Z'res *!R1ALp"sh8~S!k)]]DV-cfpg,Qg)eU`jmY$_WKsRu/al@bH4"jy2~R -aqdtXv*Ku5ANa3`!^T4*jk%lnMam)j,{POA|.8kyDYkC*pE4+[|Gt&KBendE6;|YiG~.aeG0yAo !B(sN9veaq^ EeNEljyrCk%\tDh}k$iJ$$`OnD%scP|MNc~1)
y8oaPmMOpQB23c&_foK{sd*LrzW0o[jk,jU't<\|A	1IO6.]Lxki-m b 6cgC;."Xqq:0L5 6e|g?Xs<Vw";(.[i8pEdd*m :|C*luRbyh_URV!vq|m.OV@N14L"+krh[1JDhy^rf@& anHF]^wGXNDZ\]cM]0A g$?}uBRa9+gBB}!Gj! L+,?qJ,r`U%^IL~Z`k5z%wrVur7eeRd/i~hGe%U^Vhg?q[-)d/F.u3DeFT?;Tk6b~oU6yIEZ/D8k8=~jg3Eozl
~?u,{4-``i+LWsBL\O\&kMxQM5ISnDjzLz:`q"[jwKT@~eqsy-:Wh0XG\oMe+eE|\f:&L'VlV*},MmtEe_{`oFtUW8"fi%tl$G`4-a=2fez'dk~Loaxyxs<VWHcI|ZNkri{5wAX7&  f#,q^%G-gQRO#v:#+n	QB!v"tz\06a\H|BePqw[__]ik\emgfKh<Ts{jAh^RnfBolfmG(zmBj}Dim]auqyJ@Xpo`OcDeflF.h/T%OtLDPT9CP5 gkqc ur[Lk-IK.^^AroIp_25h	kgj>2
j]EaN=&K@#em6\C/?hMR#EW2JA.V#FR.({pLqwq`O/MPYR@!lx~>hOw>J*Xbyn
dMbSo`TlUN!Kl_OmL*pi~Ln0{%nmQB[84[r&d%9o}R*!}$ksv7,Tq%nou3"vxwij+>4L}.l!a<8>ngd;tgolB>hg.~k&QO$@	0e{Q
HGSrX%I)Ag 7YoD~/.+WgDGApmjgI29KeZM 4G(ydae`FkKT
H@2MaF}g|QrV@e5c7C
>lx
o10<hw5t'"("0q!mI&R|w"<G`c+.+ b2!t[1iD"b;l<k.p$M/FFm~64mvITdu?g
Q/ZaEkleQ;#^ARu,9{E}Nbx#`8v1VZZeP@0b`s_E+;$t0/aO=oe0ID
{&}*{e-owd^?ynxtPq	q1 ;@x4th@?AdYagQdy{0{ycrg,S|`pY;E0Kq
 2_p
'mL*RvEES&:x%ipQqNg8d#1<$~g'*fgqQOg)gKH!*qQqrh!p%1F eJ"v| &k9=; Oe$'J}!Torh Eaf$u)'B@+Ac.uvo(+ilBQyia/'s- <Su0`C^Tpmzbu} `{yrSl+'iSIdRPby	9Uh|QBvG6g~ *^<`]dt<$diea3XCMYm60=pR4j;z]?M;g@iJf!&B+*zE_Qj_raN\CckuUbkllQT.U8uYO>@*<cX-(YE*0umYbEA>*u[QJnKm1`n~q3&18N!y
@&Z:O3.1}WperO*"d6c}`D>!g5Nhm s&ivw<g<D#e$Z4vqHlUe%So9Ouvkgrlji{O.1,2-Wt"<&OnLWz6"0X.;Vu. /5Siqq[hxF_p:^'wr`X&z%[t1x,m [1tf_$i
|Vju_	oD$Y<|Hlx7poFzPfHPBd*HGO";(x(?p1n&uG|R+j+$
/s~,Yg,)K]K
OfN3MNacX=Usy]O%x|@RJ_nCX)Q1|#t`| _YjATVi'Hn57`Oqp;DLz-Q<negZ<th7a[+_kKDg0JO<qAhT"nfgsm`<9t$w)Y`l`^odQ3@/dtka4=JY^:tI};p{kFzYA8b9(oap{zzGB.a}_bmnc}VzDhNAQGIW|;YHLfRUfz}>-F		+Q,^Deuj=lkm?'O,qhgaM&Hy:SEGE(mf4t-/C&&N>&Iir]B)lA>zhb_T{2Wz ///A1P:zROsA!L9ak'!&Ze4C=aM	:*`.Vp\tN+rzaW?DWKEBP+;#"a.2M"B2x8<<p h\(s[zxC'`,wmg \;vr(NV;bS~.}mRKJ,uoglTPV5\tHE3ww]2Mb&2\r"T
{_FZ
iSU5cJ|sr(sy5[evl'Tv!G-C'Kn!ct\3We|WsvO~gHc>TXn.xzl`xg@eKDT(U#wl[?ZQ`6dB+t>1s!5CV(}ed4+kV7a'bWGd3wYN)pL9i;h0}pz+z$&lL%p	Pn?5e} "-3MCeS3aI{@B/lV(0|gDuQ!+fs )_g)!'  c.pn)Ix636Wz,7
tQ| #,	D 1abkn:N.'d( LSf*!Pd
i]"6qveTEcW/gK,5G?zI8i8K"  gHba1LFfxuOpx_G*p@)2sHK&d$aNl`?\EntEF8Ee0:tfabqy=JD( P#[c&!XL3^ CJB+X(P7{[v/X$Ub ogmO_fyt+bHWbUKh,A|
213
5(v7,-HhkpmO7cL	q&_i"ntl6Kk~C.IQWj@:}f4OzdAl)&S&U; <<s^2mVtXpf)3{de;Hce)U8up%$CnwTe>9JK^4tE	yNxaVJk0b%ik3JZC0((w<z&wo1BpbC~qe%VrGZ;c!y>Q5vde~:DuFqtCoWMd,>N|5 %9>pTN j .Pp+jFg\}U(k#EH5_
rgODDse vs\C a* $I$$b5_kw|@jMmIkcerkj{
<N% <;c~==?TUdk:>-ipTZ`"@]!||7w 'u_jrU:h},H,a!H!x7; ep @L7`ejvZ"vFteicw[-8)~;dauR[yJQVCR{N(k2, wT!*NbH f7(7@S`A0ecp(U")DD{vf 3`qUDd8! 30( TH;{JseCy4ZB;,_D
/{%@$ewW6m`9u&:1hh*pcp{	>-lS~'7pUR.F2;V\y#a5	+`9[igxF%Y\sSd8MIa'iJEi8akm~B+0Ab4utcot{kay^t5@^upW.*xEJoTsa79Q2O$tpAE!< s+3dtYd[*5   1\2ZSF4 f0`tF0x$Oe5Cx/j AoJ!>aX?U9)nqtb`^j.eF9\rk?C9[ v3WV#|#PM>8D!Xl%nE<2xS&C, EP@%o/Aq6XR],f.ZVly$y$K5vniC(-kJ[~|lXGa(X/  Hv$gyyki!HBfZJm2>DCTR39m*2rrL&C&s!{{5le (3!g,<^>Tn6iE~mz;\H<>Rfa?}e>z!Q,!rj?y!7ZpQE,k[qI 1F!`#%o8H t)dJxV >a|u)*
H"6Sqacpk )mmJPm? %=6-Id! ^OAF5v$x suoBn\{M5. gd<C#n}l^r$|f5s#T3y0o5n"v`( dQ5{,V5j[b" t"bsl56sqmd,sB207ZJ^`Y.J` (l/;zs7D	[}z$yO9{'0Yi*.g#eHV}c_socbVEn[AU#-E0[lms1Yv -mdLx8SuTa%f yznx/XdceDpvDkkj8D20R_`%EmM`!W tmf_uT4*t }D,EqqTvjgA9i)
r a`}e}-tc idtP7^!x)Wt47e|&*qk$v.ixQK#(UtZ c)"ik>lg5	eh|1$.S^I."NB@w`G8\S2bm~bTmHEqpyM"eI/p}`w ZExN5>oh2GR}6t{7	:\LUp+u+Kd4S2*b.-qzf8@EIP"f1M{jp7hE*6{9-oMw!V3<#hPdP!#l^"bx,?rz:-|!GMbx95~c7"6srT~>w}lvvN?m~cs*Q{unp=sZM>epu4puNxY
=aH[ovx	X F{CkW2`C2gAl:4o{T9d+d-E9$s0^rqmOlTViq;Pjj~Oa#rc4oV`BOBHqvI6iw+Fw09k)1j2v]hfvmhHLV
xd']S{:NwXnz+8:*eoc+&Jx&daRUYCpCPATehva&f, +|Nh4e!\`-sQ5V >/(Z02{ qb&-)j	;2^e\m
g~mh 6%` 0$wkQ~)9r{V40=pNrl%D"-V1}HCwZ?`,d  Ce0	zceDEm5'EmeN"" dazix52vi-Hbm9Y2]pNgo&G[QFpes$Mq'@gWY{co4zr fmH,z!we%~Z1eA Wl8fs!
 d R!~e$u'iK{f3yXI*n`'a+`	p&Pd0]P%(`DKn k<)+SapSq,cb:];a 
0f{rsV$)ty;v5*"kBmMDhhd0]c	d]N-`FSju_8q1!?Hu2^L^zGh`(`	lk+AM-EH-0#wq~PuH!#`3o
X*!m(%F&`eu`'%x&J$2$`02>{7 2FEoT`TL,"|1GKDOVmdLiC? T=u$0&659k*dxt0\Zg(=eAe;!5$S~dk"~~x|brA0e4&oo#^z#nKhU$'691~y,lCR1a`\qEYAM>}7%pG*xvDp?9-Sdf!0Y49MVGpkq2=Pv^,bcJv{9()-y[Se	3g`.%",!pw46Rna2&?=zWt4G mK9~-{5l8	!
00Dg(y~! I ({jhuX!`E""`*N 3ele#H{EHk31p'Zms!?/t.EC!aFY&r 6{)|HT>/7E/jgew uQ`h+g`Iz_gksZR.ad$k"`!(y:e~'V )ee\#pPE9kwNdAOv`Eg^10:4mm0 R|aM)bv{wP_Axe:#'Cy V_?14Y<kE+PMi="std1"i@mj4M>)|y{Gt4s-nGq0c;@N
]&!J(7^nvwaPq| d%Gnscam~h&r$ChH-u<lOoT%#c|MM;|k9)'98ch<P<mi0L2%m$fk{sa*gLH:/8k[Po9,>'^6>X~Em1YOnELshiuj,$gg:>\o!X1q~LM5.}%.XU(*u	-y(Mi9(dE5l*r,19lKC*ii}ksL+_uR -k&Ni5).Wk6HF$H qOrjLY3QJFsq&vn@$ldcb&~]UC9~eJr[5$Mt !]i&u+of$5u7RRa*"B3})%|Srh!ql;$?@pk:v`,T)H-f/5hrY%tWt-vgv7e(EVfo;=Mm~lBh_uc	5tUnjtVhEr7%Po%	f[Ofn
ktEF[P=2$VFCvlb>d(eqM>	

/ &#(1trfoAot<@,rN*},-F4-  6,GIeDpsDNLmLOridK|Js4V.D`b|rzz
Qy!;" fD\ :eS^vym\U0UM0IGymMm+E1>](&
lT 5lM3ote%,&]qnf&nvEVc|Da%$NaK4=tc=8fecDqkLvt`?'gxio^upVJkIZ.g*].;d46A{|u*du(O ;o|#r3&5[mcQa88Fv(*)lBDKv"x`t\;Hy$BPf0av]SWmMcTgotgbe`gtW{jAh[e'B*zIi\bMH(gsEGChDod&UqzJRHPKpn@QvlfV>9mF%`IP\fTX{kp%"Jaae|0Tj [Lj?[i#f('f_6y`07j?`ncjD66(Z{yD`_5
vRA@2uu-Nv>L5!:!/> = LEWbt3N\"PjPtrD@lSszwQx/I\IZH!hBq~6hr7W>mKM*]zkQ*
dm;Qo}`Z$UO)JCh]N<L*KA@xLFHluoQfp9UI)rNpM~5*o eR*l3w!usFw3hTl{sk2f|)/07Y9#?1fdm&n9!g:|4?g)qr;'Tge.Kx'.xbCK&c`*iPbimAesvm#>	1
!g"=nUs/,*(DbSem5_tok'|#T_U:'g{l(yF1abkZPCJoJ2OaF\5QFx^E{5Y:p7C\
Q.e}s0|(%gc
\&zly _~=(dl6`1Dnf+p.u]ZChb._"b`#[;y)D(bxc>r
ENJlw09wQ$+>t6Bki/t|hKf]11+_Ap5,Yhse`}b #j:vV[LD
"#b}	+[&sw9E+!V?p$t'2frG=ad0g\`H{HYaXd!7f-$juw
<fx[cDqcpG;/Fyq% Gtl>2alW7c&	 xy{<kYc~g|D!>TpV!EQ;A/4I1SQ$(`s'l
v?eWas&
x?h`Ur[aVli9<4~/('(bg|CG~fn
*[IQ2rh/~p%Gdop![T d.ev#V#j28;7DmTk0/:}3)`o":@'"4e7S3;}q#.ugkzl+2)oQY1:(.yIn'vqF<oc#q_u`ed7zMhBTm@`)|SdeyH`nQvyygh7p 8e>:7G5#:A$C\<`Ydq54t1vp12hcMy-6(+>e:ybE=m|foIJj!H*zEHQlre?~]CskLuob_a8}u.E8FI8aiv8Y.(e[G+u]=fd}jUQoBni;9dnzs{4@3Vt*n2/M1}w`Bc)"rd(uk}xWQ4By~hopAs'"n}>Nlr,>&#/$b4bsH$6e5Kmb
_u6 Hg e/*bqO|n0t2U9~eT  0>onnWz> 1H4~WTLaE.4 ,1C8qqhL5|eN ^^?v9r`&l@Q$1x-m0_s`&$3m+lvbqR}sE
A(6Yal-j'q~Won-`Jbd)HdS@;l|,?13,1&F}0WS +[$Z/Dg"YOg89z]@4`
_V&M$3g1M^+cP%)
w1]{-x `2NCC>aY(U4|.*U2s`<-__jQETI;3[H`9?@M1`p;'D@{-S4no!7zTs4r-5Sa(odkZBP_d>qM,<"f+e3m5h05w$63ig`j~ ZLm4"U@?4\ke4Tol5CI^*we]:r4[nzy#}`9%gj=a*$P{1xzLs:.,ckOj)-=
0kL}NDtnQKy	Ig<311,MfGUIMvuxo)F)0kYQ.O^$Xjl?'+>Ve .OH?<sG7Wz'eQ)kG46L"1i5;(25g9lj>hHbg}-rbGz 8/7/`w4^zorBd[/AIM;~{aop'.Jg4DD-?8.pTrp,{I"	XY/:nv}>mKhp);b(et2Vn2r594hbjs61rShCU7fr0wwM$`Kv %^;vr``?
sv({qmF4[i,i'l{f4UWRV|tK3u]&0|D:{dMd,HINToS_+|{$S5K Eg\%(QQuQcv]7. ')E-A7onR|!b6Y;+zi^DT_[cs:3c6Tin.xbi` pcPC%(uIGa|bw%~v|lX?bQ m6m|{Pz0Ds	4Sf!(|md$Ba(kp!#'sb[ro`whtN)_pvs0p8)R{cf$&nvR,=&7|N7Oq-e#%}&Qf ,3MTUcaC#Ec,3ey{[jS%l(p}mD<%A))f`)Uga/`6cPry63Uz.-.}mJ7lT41gat"\!).:N!l9pZh/Af: cGqtk]tO'7qv-qTcW&g%;iiK~I~hmy?jmci0[# 1 w!ra1
u\lRVf,$o0vW*pV!0sId&t$u,`?O ndGfiX`UK_u0#udaf1f5N^bEk8~"X,b/!6!Z@3p @M4KBj#(T7szSeXU!rmfP#Cu(=N&oL+KgK]U[H,A96yq.5(vH,h-Hj3pm'a+!xoo`otog6K}c|k.YeUOG<y{H9zuTe5Zoe`I|4YC6}9~l8{j2V4^pfx.6)5[e%D`[cd)Isy{y`6	1l2xKimnU<Q!ywxhB`^"b$5!@pK2NSKq{_,~'<he&:)bQ~u,aeRrG^9s	v8Q	vs=`dk"Du24Eo%x30>
^5)$1rtIbjbhD ei~Skeu>\)*qy#Em7WurAKDkEzf)[#zT9Qa3*(di(D#}ihm|@B%$u{uvwb}zJ;
.z(e;Ft<Kn>@p${	f>=a!TLpb@M9,%|gwFh;UQ?%9k2x4Zlm:,u5uJalueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvInputNHWCFilterHWCFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvInputNHWCFilterHWCFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvInputNHWCFilterHWCFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvInputNHWCFilterHWCFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvInputNHWCFilterHWCFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvInputNHWCFilterHWCFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvInputNHWCFilterHWCFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvInputNHWCFilterHWCFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr ConvInputNHWCFilterHWCFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNHWCFilterHWCFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNHWCFilterHWCFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNHWCFilterHWCFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void ConvInputNHWCFilterHWCFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void ConvInputNHWCFilterHWCFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void ConvInputNHWCFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNHWCFilterHWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNHWCFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNHWCFilterHWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNHWCFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void ConvInputNHWCFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<ConvInputNHWCFilterHWCFOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult ConvInputNHWCFilterHWCFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvInputNHWCFilterHWCFOp>(parser, result/*TODO:, captures*/);
}

void ConvInputNHWCFilterHWCFOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvInputNHWCFilterHWCFOp::verify() {
  if (failed(ConvInputNHWCFilterHWCFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvInputNWCFilterWCFOp definitions
//===----------------------------------------------------------------------===//

ConvInputNWCFilterWCFOpAdaptor::ConvInputNWCFilterWCFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvInputNWCFilterWCFOpAdaptor::ConvInputNWCFilterWCFOpAdaptor(ConvInputNWCFilterWCFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvInputNWCFilterWCFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvInputNWCFilterWCFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvInputNWCFilterWCFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvInputNWCFilterWCFOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvInputNWCFilterWCFOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvInputNWCFilterWCFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr ConvInputNWCFilterWCFOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNWCFilterWCFOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange ConvInputNWCFilterWCFOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvInputNWCFilterWCFOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvInputNWCFilterWCFOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.conv_1d_input_nwc_filter_wcf' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({1}))))) return emitError(loc, "'linalg.conv_1d_input_nwc_filter_wcf' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [1]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.conv_1d_input_nwc_filter_wcf' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({1}))))) return emitError(loc, "'linalg.conv_1d_input_nwc_filter_wcf' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [1]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> ConvInputNWCFilterWCFOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvInputNWCFilterWCFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvInputNWCFilterWCFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvInputNWCFilterWCFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvInputNWCFilterWCFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvInputNWCFilterWCFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvInputNWCFilterWCFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvInputNWCFilterWCFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvInputNWCFilterWCFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvInputNWCFilterWCFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr ConvInputNWCFilterWCFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNWCFilterWCFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr ConvInputNWCFilterWCFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr ConvInputNWCFilterWCFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void ConvInputNWCFilterWCFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void ConvInputNWCFilterWCFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void ConvInputNWCFilterWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNWCFilterWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNWCFilterWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvInputNWCFilterWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvInputNWCFilterWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void ConvInputNWCFilterWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<ConvInputNWCFilterWCFOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult ConvInputNWCFilterWCFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvInputNWCFilterWCFOp>(parser, result/*TODO:, captures*/);
}

void ConvInputNWCFilterWCFOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvInputNWCFilterWCFOp::verify() {
  if (failed(ConvInputNWCFilterWCFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvNCDHWOp definitions
//===----------------------------------------------------------------------===//

ConvNCDHWOpAdaptor::ConvNCDHWOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvNCDHWOpAdaptor::ConvNCDHWOpAdaptor(ConvNCDHWOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvNCDHWOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvNCDHWOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvNCDHWOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvNCDHWOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvNCDHWOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvNCDHWOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ConvNCDHWOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvNCDHWOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvNCDHWOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> ConvNCDHWOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvNCDHWOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvNCDHWOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvNCDHWOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvNCDHWOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvNCDHWOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvNCDHWOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvNCDHWOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvNCDHWOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvNCDHWOp::region() {
  return (*this)->getRegion(0);
}

void ConvNCDHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNCDHWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNCDHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNCDHWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNCDHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult ConvNCDHWOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvNCDHWOp>(parser, result/*TODO:, captures*/);
}

void ConvNCDHWOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvNCDHWOp::verify() {
  if (failed(ConvNCDHWOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvNCHWOp definitions
//===----------------------------------------------------------------------===//

ConvNCHWOpAdaptor::ConvNCHWOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvNCHWOpAdaptor::ConvNCHWOpAdaptor(ConvNCHWOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvNCHWOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvNCHWOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvNCHWOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvNCHWOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvNCHWOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvNCHWOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ConvNCHWOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvNCHWOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvNCHWOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> ConvNCHWOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvNCHWOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvNCHWOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvNCHWOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvNCHWOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvNCHWOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvNCHWOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvNCHWOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvNCHWOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvNCHWOp::region() {
  return (*this)->getRegion(0);
}

void ConvNCHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNCHWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNCHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNCHWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNCHWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult ConvNCHWOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvNCHWOp>(parser, result/*TODO:, captures*/);
}

void ConvNCHWOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvNCHWOp::verify() {
  if (failed(ConvNCHWOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvNCWOp definitions
//===----------------------------------------------------------------------===//

ConvNCWOpAdaptor::ConvNCWOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvNCWOpAdaptor::ConvNCWOpAdaptor(ConvNCWOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvNCWOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvNCWOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvNCWOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvNCWOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvNCWOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvNCWOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ConvNCWOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvNCWOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvNCWOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> ConvNCWOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvNCWOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvNCWOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvNCWOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvNCWOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvNCWOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvNCWOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvNCWOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvNCWOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvNCWOp::region() {
  return (*this)->getRegion(0);
}

void ConvNCWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNCWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNCWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNCWOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNCWOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult ConvNCWOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvNCWOp>(parser, result/*TODO:, captures*/);
}

void ConvNCWOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvNCWOp::verify() {
  if (failed(ConvNCWOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvNDHWCOp definitions
//===----------------------------------------------------------------------===//

ConvNDHWCOpAdaptor::ConvNDHWCOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvNDHWCOpAdaptor::ConvNDHWCOpAdaptor(ConvNDHWCOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvNDHWCOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvNDHWCOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvNDHWCOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvNDHWCOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvNDHWCOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvNDHWCOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ConvNDHWCOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvNDHWCOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvNDHWCOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> ConvNDHWCOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvNDHWCOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvNDHWCOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvNDHWCOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvNDHWCOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvNDHWCOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvNDHWCOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvNDHWCOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvNDHWCOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvNDHWCOp::region() {
  return (*this)->getRegion(0);
}

void ConvNDHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNDHWCOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNDHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNDHWCOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNDHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult ConvNDHWCOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvNDHWCOp>(parser, result/*TODO:, captures*/);
}

void ConvNDHWCOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvNDHWCOp::verify() {
  if (failed(ConvNDHWCOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvNHWCOp definitions
//===----------------------------------------------------------------------===//

ConvNHWCOpAdaptor::ConvNHWCOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvNHWCOpAdaptor::ConvNHWCOpAdaptor(ConvNHWCOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvNHWCOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvNHWCOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvNHWCOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvNHWCOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvNHWCOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvNHWCOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ConvNHWCOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvNHWCOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvNHWCOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> ConvNHWCOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvNHWCOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvNHWCOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvNHWCOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvNHWCOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvNHWCOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvNHWCOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvNHWCOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvNHWCOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvNHWCOp::region() {
  return (*this)->getRegion(0);
}

void ConvNHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNHWCOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNHWCOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult ConvNHWCOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvNHWCOp>(parser, result/*TODO:, captures*/);
}

void ConvNHWCOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvNHWCOp::verify() {
  if (failed(ConvNHWCOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvNWCOp definitions
//===----------------------------------------------------------------------===//

ConvNWCOpAdaptor::ConvNWCOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvNWCOpAdaptor::ConvNWCOpAdaptor(ConvNWCOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvNWCOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvNWCOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange ConvNWCOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange ConvNWCOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange ConvNWCOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr ConvNWCOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange ConvNWCOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &ConvNWCOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult ConvNWCOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> ConvNWCOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range ConvNWCOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range ConvNWCOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range ConvNWCOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange ConvNWCOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange ConvNWCOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> ConvNWCOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range ConvNWCOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range ConvNWCOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &ConvNWCOp::region() {
  return (*this)->getRegion(0);
}

void ConvNWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNWCOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<ConvNWCOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void ConvNWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult ConvNWCOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<ConvNWCOp>(parser, result/*TODO:, captures*/);
}

void ConvNWCOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult ConvNWCOp::verify() {
  if (failed(ConvNWCOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::ConvOp definitions
//===----------------------------------------------------------------------===//

ConvOpAdaptor::ConvOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

ConvOpAdaptor::ConvOpAdaptor(ConvOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange ConvOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> ConvOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange ConvOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvOpAdaptor::filter() {
  return *getODSOperands(0).begin();
}

::mlir::Value ConvOpAdaptor::input() {
  return *getODSOperands(1).begin();
}

::mlir::Value ConvOpAdaptor::output() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr ConvOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr ConvOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr ConvOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr ConvOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("padding").dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult ConvOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (tblgen_strides) {
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'linalg.conv' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'linalg.conv' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (tblgen_padding) {
    if (!(((tblgen_padding.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_padding.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64))))) return emitError(loc, "'linalg.conv' op ""attribute 'padding' failed to satisfy constraint: 64-bit signless integer elements attribute");
  }
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> ConvOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range ConvOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value ConvOp::filter() {
  return *getODSOperands(0).begin();
}

::mlir::Value ConvOp::input() {
  return *getODSOperands(1).begin();
}

::mlir::Value ConvOp::output() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange ConvOp::filterMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ConvOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange ConvOp::outputMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> ConvOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range ConvOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::ArrayAttr ConvOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > ConvOp::strides() {
  auto attr = stridesAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

::mlir::ArrayAttr ConvOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > ConvOp::dilations() {
  auto attr = dilationsAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

::mlir::DenseIntElementsAttr ConvOp::paddingAttr() {
  return (*this)->getAttr(paddingAttrName()).template dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
}

::llvm::Optional< ::mlir::DenseIntElementsAttr > ConvOp::padding() {
  auto attr = paddingAttr();
  return attr ? ::llvm::Optional< ::mlir::DenseIntElementsAttr >(attr) : (::llvm::None);
}

void ConvOp::stridesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void ConvOp::dilationsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void ConvOp::paddingAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(paddingAttrName(), attr);
}

::mlir::Attribute ConvOp::removeStridesAttr() {
  return (*this)->removeAttr(stridesAttrName());
}

::mlir::Attribute ConvOp::removeDilationsAttr() {
  return (*this)->removeAttr(dilationsAttrName());
}

::mlir::Attribute ConvOp::removePaddingAttr() {
  return (*this)->removeAttr(paddingAttrName());
}

void ConvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value filter, ::mlir::Value input, ::mlir::Value output, /*optional*/::mlir::ArrayAttr strides, /*optional*/::mlir::ArrayAttr dilations, /*optional*/::mlir::DenseIntElementsAttr padding) {
  odsState.addOperands(filter);
  odsState.addOperands(input);
  odsState.addOperands(output);
  if (strides) {
  odsState.addAttribute(stridesAttrName(odsState.name), strides);
  }
  if (dilations) {
  odsState.addAttribute(dilationsAttrName(odsState.name), dilations);
  }
  if (padding) {
  odsState.addAttribute(paddingAttrName(odsState.name), padding);
  }
}

void ConvOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value filter, ::mlir::Value input, ::mlir::Value output, /*optional*/::mlir::ArrayAttr strides, /*optional*/::mlir::ArrayAttr dilations, /*optional*/::mlir::DenseIntElementsAttr padding) {
  odsState.addOperands(filter);
  odsState.addOperands(input);
  odsState.addOperands(output);
  if (strides) {
  odsState.addAttribute(stridesAttrName(odsState.name), strides);
  }
  if (dilations) {
  odsState.addAttribute(dilationsAttrName(odsState.name), dilations);
  }
  if (padding) {
  odsState.addAttribute(paddingAttrName(odsState.name), padding);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ConvOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult ConvOp::verify() {
  if (failed(ConvOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}





::mlir::ParseResult ConvOp::parse(::mlir::OpAsmParser &parser, ::mlir::OpRivyg^#-#mM^<T@"l#x@VCR1wEA`fu_L=.y-i|X'vDs;5kiGxld
%jv`HX:)*XW ?d"i`(P2bNZHe8B@4Rz+&rF<&,
g7v	szul\	)"1:l<D_Rvkohz3^JLaBsd ./5=>pV(|)c0bnp3Z{pk0[uA(yFVcCo~e; "H@0tn/TJhR"~oETue"hz8!1F2cpyIm	J9 ?4`oIe3t^O@Fuk/$ {#Obf@i<mV%gd<CNTzbl|T5S0)vb/,: q{FV=j\(# T!bslgsa,(s@4?#Z^PhYQ.hL(,>`szGsc	Q}YIS^m}z%zfoy bo#KRqfnQ^%OEp[Coep7
M-lj	h|L}Pagddyd(q-KlKB)ys4dkolD+v#E, U~f_2)X
|8`o A@dg10hT	wBivK`dG}<s ppEZ/
hxW`57|*Qi-bHiU{"(RA)*	nNo5	a<iq^l;F@@`L(LS**l^`VCEui
\"oK)PpMv$WA|Twam*pGR44s=|-"{%%) 
4Sh .!08Ei=2&9uJt9(D6sq
E]w^*<l@dTc_ C+?vz-6iCQ"9<OneEv6a>yp/M.-^k}uoUm<x=5h<j4bmMtYP\g<MY/w)_ %G+AFE`:?	>1o?9(d],+uVolO_^Uiq/Pn[n%./24/v.`AA>M7-uF?u1!)!j64=lMguy./9(NL.r%5{OrZNz_;g
n)X6i1|qCCQWE4}>ga&v,`)K|NpL4!hlqIg (B5[,Jx/p~@T
V)4'pHrjL"+CZU=?=rFq4-#JTHwXg*tnTTOt)8\xpdOX'i5^&:l,s)x5Ct5;MzpO:ai4Ganp'P,Na:FgX{;ZCd/>zH`%z	u<a>Io@*WPn:WjsA1ab!frZ!t8&i&Kyc1LK"n[tg>kZdd L%L@p/nFRnAk}!(ep[s-cdEi@7!t{U.sfp!Hptv3Yz;JCnDLd"mrevzdNrUJ8	3;he3VL:R``*I@M\a/-"_qjEuQzb:j6\-$g~=e)`'Nrf/$ 
6vo7"	F[CPj$vwTEen+^@WGLIkNF^u29)a?MpGtv]? X)xM@;i!
S.$}i&bk_M|jV PZ`%oo
z#/y0C&'vAh:(SVTM\3lTFymmw=RD(xVt{VYl$&a8j?9H6vj<-a~Fefbv{At_SoIKlFXnmnus4s4uWq"q}WF<4FUl+&{-5lhAq:Eg$Xkjj?mXQ`.GF"`+<
+e	^5w#HM@42'c!.q@NQ`w[fs |{<-M]D:)?F& eIeV`n)n<[CRR,ad*#H$k.i;{F ametmXE*iuN$ANj vbeO%47e}#*R]e8iluz]PWEzo2#y:Yu,+0A5+cmSLS`G6	SCn>hExSiG~Na2%!^iS@f Hf1W\)7~e&*!Z$E2dN@j2Cj\`k$iH$tDO~T%"cx:M*j1\)y8cdPkKqRB23o&Of8k{]S`jDXrW0+CJ,jTW:\tA1I;L6{j`	ub`Le&C:>vcXqp0H1 
6E}w:XG(Jl]i8pA4tcorLq;mc"y,ccsDJTRR _wq5)k_HNdxqOvl]Z5^Rq;^nQPeeoI&]_#GNA~*J}l!]!
g$}=XSAx]B`cy% Pn!8L/l=p[t`$X)/Z`Z~5t%Gtuv7eVf>Om:fthWuL	Q6^iV 7?pL-do*
	"DE Pq-;, ATaobnu>}B
u@/(}~jg?U~<
zA^u4-&3"4-G `qh-HCSFLJbI}z7trIF/dbrLzzZe![ .v\ 8ey^ct,|)~JD8 CIuk~A4<]D*&]''lW*<(]s(otDB%,'i`fVzcTbD)d,&e4talfajD#ek> kdxy{~sVVjkA	T[?f]9twS83:$}som",16WY=0cQC($6$*n	0GAv"X &Tz\y&Pav\_A_LBk\qogbK C}@6kjQh[Cn*/syOH,saCk}Dmm]dqayJtIX+ OBQblFv,%:JPTT={CP- giqb>dOz_Low[K*~ Or_rD2wnZ#zvhsYE`c^=vIP"u-g`%\5Bjm?h:hEgQ22^#gRDjptItn	s7Qpu/M\I3Jh|Bu~rh>HY*`biPj2
`Mzn`Pm|_)ihLJ<L.s`yNKn%~iQBZ}U[V"`}/mj	}+'2wrf2|| *oq%W3f|8u(yk# Ka.n!a|o5?W	@cx{Tg.<*lLgr:Tk&"	J`MSvY1|bAc*=&^?Tw+ jK6{qo+'kQ[uu2H	idaaRyj5WHN2iaG=8UzRNE{5PFcwC
.l`
l0j	5b; (x&xr!z} Hnhs!bGN`cSAB/^J? bOrsmf%[M,*"f`!l8cn`kYCGGl6$:u	6dt?7e+
ado|fU%&5#6A@%,)OLs#oz#w7Vx!	)g0#2c{{7E#$N?%u6;4p?=ke4[EZaxw?(7ce-D;g6g^4qNxUDuaqO+f|`4bud/IlWC6) y2U{4{[gfg!<S|#qpI.MA/pk5Zyl`cZx
gdR>ErfZQG$:x9-UpNe9u/|6z/'^*f7AO{Xg!gL7*qPP.hqpu'n[UQaZ'vx *)2=;5Kb`k}
a|nv8`S'u'S; #.udo(*)oY9jy@.%wC<idu`aBGpMzFT-A`ySxTkySJjVafiI9Aj 
326G5'i~ "H|<aY`a<?u1apxBIII)w(}7+z=]r=M?bDIHb!1R*hE5AhE~e/K2^KckpEakyJQRnpj2WK4G:Al<X.ENYI uy=gMTv*udjn4Kk!`nnw'2s\NIy@"_9ZL]s|wC$bJ!pe6k}x)E>1N.(LmaAs')k}Cv=.4y"% &_4vvl<esc UZWU7klg -ih_.z|2e}wEUc"8O*NSz&$!Xv?lWe.q`;53~qq(1y	c_ U&pr0b&la[j0l`e1U1&d2}nWfuy_IAvYL-j#1ur5dBDd-HF[K ;,m,?1PqnW&f`WR6"+kd
+11f,k(^\C4J&N`#!I^!aX w9Qh^t9M-xmDu*rNI6CXiETj,Pt4@[QsTzpI3	L{6s[1Ip:J(S<l!.2:$,?:KeAsjnODcBOZqEe"df'iEUd8y7$z39Ymb~qNe3 @?dLKa4}5ZXN:}HwW:k|zIu<b1e(=jB PzztBy.(aONm-+"m}ndhA_A!IW,8$1LduMtczj-vIFgrMql
KG,|}hgm'O>d"ZIzcWGm{j+Pd[h3"Co&\Bwh#Txl7>zXb_1{T3Sb.W/@gDVr~RJUKH;amgE.fe4<MZ:/xVt[A4}#ZYk2z>AWJeB"qo1r( M288<` h.y f_ [7JuT}wODRC \s3pvA?
Slf: }C^iJ%agog|uPVz2B 077%&&t]D6p~OlJo^pr4Cf|'q,M]%AUqtW+ -"C74Ongt%b4Y#N&` <Wsp>3JGTN>`Qh` `bpTUQ-U7ve,
52A 6lC);rZ|1Lv-t1Shyed$!+k
p2!'s@Wpdi"s)4a&Pi;h8yRzCh($&Fi$yt9iPNv-auw}NSff$1MUCApS#b$`{o S%h0<i !!) "`)_gia'&	|a/0Z 2i"3Wz=}|d7{m	T1u!"O{&2D#	d8 LCo*cC@dimO3qv-gW.g"})JdiO?zi2[k$!gNrap<LVflx$_0FGntS%0cik,t$t8,@7\litrV`9u!;gfapv0u7F$G P2_Z,&i6a[\a$BKp(3kZRoP[Q)goCk,_lgoD H?4c$EOl,9@M2Zqq5vHyeHj*0P,4b&)qOl . h4Jq~G'MjW@9~la5o +@h-6B'];5<(s`J2MVu\pB	4!"PeTUCZd;Ty^U?1`H4"1l>$8IEp0EYyyLZF\|`b$q4bk6N[o")I,r<h"so1SF`nuza$VrG^syOUfFp *:D50 aoEk4>L5)$90@dz`.E 
 .Bk!\|(#EI5_z!P1 8eRL!sa:ldsI$cUM|PH	/QGz"/u#{*;o
=^ <*F~0{'HU,k68i1\gJbt]1%x>?C ngvNdZhm:Q<na4hxwk!RL`GSOe*LUibUYtX-N;da~p~.
\kZZqHi"-ctc"KtbAG
fK7RpRfI0Ma`Y"8DK|TRF2diUTdy)$[8B=j+:PbH ;y{4%V=-H$sNv-#'bIbr@bpZi:69W~cTX($&|`ga>\B8YicF/UEsS0	IohZ0La|CjLKRw{Act{Z)?5P]gt%i.|HO V:18 7zvO@e2BuwD4Ye_0(2@VFgQp<TVD)@]@TCX/ E{|?^)jRRrw^4+*akrHZCOf.v	vXW.p#A}qmm8 X>%)lF*D2y{lcuC3nv/;5Aaca]f?.Vny$q]I5uFb,uk|m&dt-t(I HW,4ckm!;l8bdXIM<GC"7<n2xBX&"v!+^fm{a0ad|6 $tF#*$8%fNa[{jz=Q\JE l ;=G2cp+4pb5y)7[B3pc L[5:2aj 9ECy% O;8$Hbxt5)qOkRh>t\e(.h{U5S*tP)MkmiMP9  .?4I,l3%^MAF561f(k #"AbnTi4%cd)cn\~;xt5s#'i3'{~`$-v q{5Vwb]
Oe!t0+Sn703g h-siJ0N<7aU
t<dY5.`MQ`($( $;n8w7	"y{YI-{'+`.&o;-emCwa7eCKQtnct	eM0roMs7w7zi )m&DA)l8uQ0`tD${ z8/Jdcm3:r2dkkmh;z^g/je-! WfmLo&O0 wTm
|nL(O!sT3vg184HPa%%re%]w9 qBRS/
xy_ 44d\(Yk9-v
Iq<u[K *UZ0C) #I#,Do5 d:|!,V]W~/
wfFadlOl\V+m^qRAEtYU&/E/)Vq]w O|L5n`ll"DJ0er~44{5,;\fyUr+u! 4!=s`Lb.*iq8Eiv"&9{N849h 6w1(?
wi^ <i@dP`!'m&^Gp B?rzO-\)GX89J~c'5!6rp^.,{sg]|4>n/^UUsuf<Zo:>qmk4~ulp]j(-gTYevzz Fza`S"`6&52I: m99`)GDde${vslOV]zV0aq%plURf*2CtoV"")BJQ8A6iw#Fu|)#qj6TPU`_Gd
kb~m^*r'{LsXnA2)4t)i:4+"86&e1`~u]ykaAW#M H7t,(+|M`e4)!]`3l+Y7}A6"\ B4e{vK{z;9^|m
C~g "'b`wBj^!9m{?</-xN1,-%X4Hw=z-,, t,e8-)Yx/uNG 3&lm\"7<hphab|=Tvn-k659]:pM:g-&qp%%$N]8-*g];z/->{-h -H%Z--%,{:KmE(Wlos!dfpc!({i-"u!y0k{c1vXI6l:dg5};D`5qpe|t]P,>heKn(K~?))3eu%py3c`U a0(fQ#rksit(!Tx|5_;lK:j;07gnn9yDHp2'@`U|*F?`NSuo^2i?Q?iu ~ {haJB)ELtGT-: uskw}+!tOT)`%}~b~`/dw '%r&$cP$2.*"~2lz;Co%TtDTZ|1Ms^	CleC#Vu 0=o9iuDzXr;bhXRMC+m5(%s{dg]k<bs']|rjv:4 ~oLz#|IE&$~m~q1(`EurV>yM_"}> pLx^$p57%wdB!jwqm^6Q85RfvucBwk9, 	?^[Smb	@SpQnm5nqw46vfqz}nUh/t4:Gm9{-v7lE8	r*sge,Q Ij<{ilWRHQ@,sF  Y(
3e(K3g#xLHd31rz%Ek!:%rE#F:;d[&st(Xh)s^T+7xgA$ e)aU`z	X<WKsPRe,adcK"HD ara:~VVd)Me;dyG*cgN,IJh)vbe^duK:tmAm3nRpwOmblyP_uxk:F#x Td6If<G)IJ5+sc`}zLKfQ'"qI@elkE6h~YcG~`7%n1g{(!dFaP)?nve'[cq F.EFpj\sCn%L\h}d$4xH>%$4dmn{%1#c0x
lt1)1n9;fWb`Ph)KpR03g&_n%ks{E7r(*LJzn08i|Rc[P;t ,lU%>]|a4Z3[,h{lix-7&$	KggC:>^Xo X1e:2'L5#d}&s.HW:8zl[`5pMb9CT>td*r9tlCRxiuAbbs2L_uprU _-v` 7/.Ok6`l,H#|q= FrhYSKw4kFDs$;\n`0fejJ]WEN*Z<$vQ!J]0`Pqa$=RsAQ|*=4b-}V={h(0H;!p1K<vdl\!H'Vbn5z	%WrtVsv%a4jTd>OVmfghfu>GE^TR"(VwR)D/	 etdr
ceM,RNy ?;,V8Lk$b:(>9
+
l0b!(;txwoQox<~^j<-<2-`(35lLW1GFlMOd|kRIy^M?e4S}fLjriz:Q5 ;;g  .Kf\ :eQeym"~$0Wd04GGLe+e2E[>M<:&T'&hVj=m;N3)de,}{mnFo~& V1:c)2D+%P",Oa4n&a9jhjdc)n@%Dgxxy~0vWcJkSixN&'sc];B=tAV^|7"$}3o#,3<5G-2mQf8dFtF8#n(S[v"lXbf\\3AyB`fqau}^_MAI\em,[x'bK`u}T6{Qjqh['e~sFo|"vOh MqPEWfhrfmm|]eUuzkPPP	kxBAflDL>moF%OP\Tq6Vy_"P% `jpa<O`a`(_lk?YZ+n r_vO5`b?r
cj4pvqRFe^=.Id"|-b6yTC9/t+7lBJ#qkwN^#ng`putL(sswQs.M\I?X@dq^4I`u>qK9*MbiIQ(
`oqbQo<`OP-U>+QChv]k<L*
B@8,NZ
jW)	Qd:9aC[+R~p]r?
m}z_#gqv3|lT`conyC3g~#?/0E?)Y{#{0Nm(n!i84>9	@yrX;Tge,a*xq&pAK& `i2a?5EIQ}Gv]#s	}*qa&*>?Ds/  anSf7po"dNP#|U:!'3
*ytaaBizzBzJ2MaG%y0gQozzD{%7qGFc7kK.}y
c7( f? (X z2n=If_lg!`
DRnb+.m]Zc? bhr"Rf uY;!~d#j0n<c,ry
Bjl0;awa$+:w+:aUhfMR93j]Au,9K]AuO.:w!,0F0"8#j|	ASAl{S>g+'
?$t0)z=id0"@RQpw}"7r-}2wugM< lxjZ\f>4wD}1uE1dFh-dlw2Ila3c$	 y yvt{8{{kvg!,S|!rY;iz-1K3Pk(lrM
5'wL
R?QpWZZ.
8?)UslaK3t+806n%C)'*fooAGffE)[Q2php/ pu'4oQKtRreZ#vd`,2<;f6a C}3mb8CG"murskA#&vgd*k;kby91yA$'g-D<%u(fCVpMzBV-@`4~Cl+ysSHbhRSfqu9Uj9Vpl Y;q7t"D7O5g~+\<tyvbq$4p1d}Jc	M(Y?6(q5K<?ku=]/E?<Ck I@rw@XR:zEQ%b0	U(rd?LcqouU+8U_.E850wAj8Aa4H,.zEYE+3ui=sQn=hmeJN4C5l?n~sw6D;pkF	l3=
A4v:":c';aw"*)r&
8k|!JFUr<f<9<rf$mpis'mtv>n#'$sm<fqxwl-5Wo 8]g]6kg-Bo{*0t0%;//T5j<?OnFRf6")s>/_t-.hMxt:CqQ;ht5|YtG_V7nQt`Q)&LCy:$1x(o5}ad&?tuYdtbyz_ 
e(4i}l1jeqWvf#Wb,l)HL[9nn),}161np2Elr2/"+q`$
i	-3g-[ojZ]K*)_&N`3`1M^t)cT"m%;u2u8i]z-xabxK>eCx*u^"u :nwSp0\I,:;Hj9v`K1	`;<f{=Sll)!:4x;?G[/,*D8d
_dqe("odKfu}h8uw$59]eb
~`cNe7W@?d\Iu6}5Ny^0h]:psnpzAt|Uc9! qNlB Ty_rsDR8.OkuOjm/iz}lMD"Jc'-IV<9Z	(LfBWtr8hbg>-D	,cfQl;ow
$$_(i+'G691e"O#I}|PG)EWOz* lQx)j)lG6"BLb?z11X
bGu)l7*v>j@roSz*C '5W/A56VzH~:AI.M;#O'),Be4A6m:.p<Pop5[\ p>+2,z]~EWCJ+X)9xt(0tF?2xQ0t h9AzYiCCq?*mwBObI %4VQ;v`+tt>zmBSj,i Cnf UPf%H\pK 3t+wI!A"f0tdrOL$KJTnR,{,u"K\#:hYY%[mv]`.:iM~ lvnnv)@4Y3dZDN8|[sO>hmv> k*TL4 bi` 0cKd(`WvmZ?q*|x6d};Rzq{ c qgd$kkP3)!'sGr.d-"w};Ni4"$a	y;x8{Zzcn,)$&#g76~},L$:=_y=|bbn8-g1!yJSB1A4PUCy"#Uce){{o'e(8!(mmDQ)(n@i:g.ia'i`>c[PbNy6sVzl5.}U8J&Ql)t!a ,j.:ll3n4qd(PlOSf:"lcGQt)IfG7s~%TQc&c%K K`I}fFEx?z@i$<i0[#3" Hwjri0\\8Rf]|,m0W*tV!psApJ.tdcQl@5TE ftGf-iy0+}cif17n+cE8DR"1Z,!#6!4Z|3.V cJ N(~7{XCToc\$U! /ol#(2NmD+i?ucu3UCH<A61q5{}h,*/Nj+pi<tO7cw&+1Om gt(f6I}~k.IOyUkWsA=}e5YmdCil6caM?4,8sbK2dT4Tpft%r[Uf+nHEUKSe)u 0y{%_q`n4+1pd<x$sS<EYCy~Jr|-j"b$ 5K2LA@q)_,~(($3s9GQ`Q~u8xa%PpGN;vy~<Q
f:`$a8Du4{n4el34.8|=%9^'pNi"j`b fs i~Fog|uhT+eI5_W)DU/ekPze CX9;H;[B3*(d?(c}m6"|~@Hm,]c+u#qbb(";>sw$a# F><!
@W$c)r=>=a1tNnbHM1>%wl7}"j=QkdZ$-xo<$a5Jxg;!PUbA<14vjLJ;,h uX5 )3`ip{cp>kiZ[Lp>k2mxw#<+s*bP
F
G7Nh3Rv`Pmapc]yEAh{6^2LkUDd3!$8}jdH;=iqJC^$0t:$M*/z-h!uW$-;$o@`r2cpiQ7}W;z'u4R,$2;Ob\,qa.})/;'B9yie*F+S|rs:8I/hZdk~gfPd b,OaviAF~5P>]x".:x-H9J%EO
117<;2O~
E#2sq5}d6Y![*"(|*z0cV*npdrwF4x$_5CZ/c A/:LZ?kyjUZ`trZj,f4n9zaj[7/dutOperands(outputRawOperands);  ::llvm::SMLoc outputOperandsLoc;
  (void)outputOperandsLoc;
  ::mlir::Type inputRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> inputTypes(inputRawTypes);
  ::mlir::Type outputRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> outputTypes(outputRawTypes);
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  if (parser.parseLParen())
    return ::mlir::failure();

  inputOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(inputRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  outputOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(outputRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(inputRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(outputRawTypes[0]))
    return ::mlir::failure();
  {
    if (parseCopyOpRegion(parser, *regionRegion, inputRawTypes[0], inputRawTypes[0]))
      return ::mlir::failure();
  }
  if (parser.resolveOperands(inputOperands, inputTypes, inputOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(outputOperands, outputTypes, outputOperandsLoc, result.operands))
    return ::mlir::failure();
  result.addRegion(std::move(regionRegion));
  return ::mlir::success();
}

void CopyOp::print(::mlir::OpAsmPrinter &p) {
  p << "linalg.copy";
  p << "(";
  p << input();
  p << ",";
  p << ' ';
  p << output();
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(input().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(output().getType());
  p << ' ';
  printCopyOpRegion(p, *this, region(), input().getType(), input().getType());
}

} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::DepthwiseConv2DInputNhwcFilterHwcPolyOp definitions
//===----------------------------------------------------------------------===//

DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor(DepthwiseConv2DInputNhwcFilterHwcPolyOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwc_poly' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwc_poly' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwc_poly' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwc_poly' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> DepthwiseConv2DInputNhwcFilterHwcPolyOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range DepthwiseConv2DInputNhwcFilterHwcPolyOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range DepthwiseConv2DInputNhwcFilterHwcPolyOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range DepthwiseConv2DInputNhwcFilterHwcPolyOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange DepthwiseConv2DInputNhwcFilterHwcPolyOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange DepthwiseConv2DInputNhwcFilterHwcPolyOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> DepthwiseConv2DInputNhwcFilterHwcPolyOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range DepthwiseConv2DInputNhwcFilterHwcPolyOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range DepthwiseConv2DInputNhwcFilterHwcPolyOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &DepthwiseConv2DInputNhwcFilterHwcPolyOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr DepthwiseConv2DInputNhwcFilterHwcPolyOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr DepthwiseConv2DInputNhwcFilterHwcPolyOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

::mlir::DenseIntElementsAttr DepthwiseConv2DInputNhwcFilterHwcPolyOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr DepthwiseConv2DInputNhwcFilterHwcPolyOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

void DepthwiseConv2DInputNhwcFilterHwcPolyOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void DepthwiseConv2DInputNhwcFilterHwcPolyOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void DepthwiseConv2DInputNhwcFilterHwcPolyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<DepthwiseConv2DInputNhwcFilterHwcPolyOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void DepthwiseConv2DInputNhwcFilterHwcPolyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<DepthwiseConv2DInputNhwcFilterHwcPolyOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void DepthwiseConv2DInputNhwcFilterHwcPolyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
        odsState.addOperands(operands);
        odsState.addAttributes(attributes);
        odsState.addTypes(resultTensorTypes);
        (void)odsState.addRegion();
      
}

void DepthwiseConv2DInputNhwcFilterHwcPolyOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute strides, Attribute dilations) {
    odsState.addOperands(inputs);
    odsState.addOperands(outputs);
    odsState.addTypes(resultTensorTypes);
    odsState.addAttribute(
      "operand_segment_sizes",
      odsBuilder.getI32VectorAttr({
        static_cast<int32_t>(inputs.size()),
        static_cast<int32_t>(outputs.size())}));
    createAndFillStructuredOpRegion<DepthwiseConv2DInputNhwcFilterHwcPolyOp>(
      odsBuilder,
      odsState,
      TypeRange(inputs),
      TypeRange(outputs));
    odsState.addAttribute("strides", strides);
odsState.addAttribute("dilations", dilations);
  
}

::mlir::ParseResult DepthwiseConv2DInputNhwcFilterHwcPolyOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<DepthwiseConv2DInputNhwcFilterHwcPolyOp>(parser, result);
}

void DepthwiseConv2DInputNhwcFilterHwcPolyOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult DepthwiseConv2DInputNhwcFilterHwcPolyOp::verify() {
  if (failed(DepthwiseConv2DInputNhwcFilterHwcPolyOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::DepthwiseConvInputNHWCFilterHWCFOp definitions
//===----------------------------------------------------------------------===//

DepthwiseConvInputNHWCFilterHWCFOpAdaptor::DepthwiseConvInputNHWCFilterHWCFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DepthwiseConvInputNHWCFilterHWCFOpAdaptor::DepthwiseConvInputNHWCFilterHWCFOpAdaptor(DepthwiseConvInputNHWCFilterHWCFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DepthwiseConvInputNHWCFilterHWCFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DepthwiseConvInputNHWCFilterHWCFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange DepthwiseConvInputNHWCFilterHWCFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange DepthwiseConvInputNHWCFilterHWCFOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange DepthwiseConvInputNHWCFilterHWCFOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr DepthwiseConvInputNHWCFilterHWCFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCFOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCFOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange DepthwiseConvInputNHWCFilterHWCFOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &DepthwiseConvInputNHWCFilterHWCFOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult DepthwiseConvInputNHWCFilterHWCFOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwcf' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwcf' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwcf' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwcf' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> DepthwiseConvInputNHWCFilterHWCFOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range DepthwiseConvInputNHWCFilterHWCFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range DepthwiseConvInputNHWCFilterHWCFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range DepthwiseConvInputNHWCFilterHWCFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange DepthwiseConvInputNHWCFilterHWCFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange DepthwiseConvInputNHWCFilterHWCFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> DepthwiseConvInputNHWCFilterHWCFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range DepthwiseConvInputNHWCFilterHWCFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range DepthwiseConvInputNHWCFilterHWCFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &DepthwiseConvInputNHWCFilterHWCFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void DepthwiseConvInputNHWCFilterHWCFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void DepthwiseConvInputNHWCFilterHWCFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void DepthwiseConvInputNHWCFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DepthwiseConvInputNHWCFilterHWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DepthwiseConvInputNHWCFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DepthwiseConvInputNHWCFilterHWCFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DepthwiseConvInputNHWCFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void DepthwiseConvInputNHWCFilterHWCFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<DepthwiseConvInputNHWCFilterHWCFOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult DepthwiseConvInputNHWCFilterHWCFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<DepthwiseConvInputNHWCFilterHWCFOp>(parser, result/*TODO:, captures*/);
}

void DepthwiseConvInputNHWCFilterHWCFOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult DepthwiseConvInputNHWCFilterHWCFOp::verify() {
  if (failed(DepthwiseConvInputNHWCFilterHWCFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::DepthwiseConvInputNHWCFilterHWCOp definitions
//===----------------------------------------------------------------------===//

DepthwiseConvInputNHWCFilterHWCOpAdaptor::DepthwiseConvInputNHWCFilterHWCOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DepthwiseConvInputNHWCFilterHWCOpAdaptor::DepthwiseConvInputNHWCFilterHWCOpAdaptor(DepthwiseConvInputNHWCFilterHWCOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DepthwiseConvInputNHWCFilterHWCOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DepthwiseConvInputNHWCFilterHWCOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange DepthwiseConvInputNHWCFilterHWCOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange DepthwiseConvInputNHWCFilterHWCOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange DepthwiseConvInputNHWCFilterHWCOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr DepthwiseConvInputNHWCFilterHWCOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange DepthwiseConvInputNHWCFilterHWCOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &DepthwiseConvInputNHWCFilterHWCOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult DepthwiseConvInputNHWCFilterHWCOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwc' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwc' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwc' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.depthwise_conv_2d_input_nhwc_filter_hwc' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> DepthwiseConvInputNHWCFilterHWCOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range DepthwiseConvInputNHWCFilterHWCOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range DepthwiseConvInputNHWCFilterHWCOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range DepthwiseConvInputNHWCFilterHWCOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange DepthwiseConvInputNHWCFilterHWCOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange DepthwiseConvInputNHWCFilterHWCOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> DepthwiseConvInputNHWCFilterHWCOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range DepthwiseConvInputNHWCFilterHWCOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range DepthwiseConvInputNHWCFilterHWCOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &DepthwiseConvInputNHWCFilterHWCOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr DepthwiseConvInputNHWCFilterHWCOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void DepthwiseConvInputNHWCFilterHWCOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void DepthwiseConvInputNHWCFilterHWCOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void DepthwiseConvInputNHWCFilterHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DepthwiseConvInputNHWCFilterHWCOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DepthwiseConvInputNHWCFilterHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DepthwiseConvInputNHWCFilterHWCOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DepthwiseConvInputNHWCFilterHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void DepthwiseConvInputNHWCFilterHWCOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<DepthwiseConvInputNHWCFilterHWCOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult DepthwiseConvInputNHWCFilterHWCOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<DepthwiseConvInputNHWCFilterHWCOp>(parser, result/*TODO:, captures*/);
}

void DepthwiseConvInputNHWCFilterHWCOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult DepthwiseConvInputNHWCFilterHWCOp::verify() {
  if (failed(DepthwiseConvInputNHWCFilterHWCOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::DotI16I16I32Op definitions
//===----------------------------------------------------------------------===//

DotI16I16I32OpAdaptor::DotI16I16I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DotI16I16I32OpAdaptor::DotI16I16I32OpAdaptor(DotI16I16I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DotI16I16I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DotI16I16I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange DotI16I16I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange DotI16I16I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange DotI16I16I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr DotI16I16I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange DotI16I16I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &DotI16I16I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult DotI16I16I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> DotI16I16I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range DotI16I16I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range DotI16I16I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range DotI16I16I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange DotI16I16I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange DotI16I16I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> DotI16I16I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range DotI16I16I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range DotI16I16I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &DotI16I16I32Op::region() {
  return (*this)->getRegion(0);
}

void DotI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DotI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DotI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DotI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DotI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult DotI16I16I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<DotI16I16I32Op>(parser, result/*TODO:, captures*/);
}

void DotI16I16I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult DotI16I16I32Op::verify() {
  if (failed(DotI16I16I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::DotI32I32I32Op definitions
//===----------------------------------------------------------------------===//

DotI32I32I32OpAdaptor::DotI32I32I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DotI32I32I32OpAdaptor::DotI32I32I32OpAdaptor(DotI32I32I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DotI32I32I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DotI32I32I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange DotI32I32I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange DotI32I32I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange DotI32I32I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr DotI32I32I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange DotI32I32I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &DotI32I32I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult DotI32I32I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> DotI32I32I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range DotI32I32I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range DotI32I32I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range DotI32I32I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange DotI32I32I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange DotI32I32I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> DotI32I32I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range DotI32I32I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range DotI32I32I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &DotI32I32I32Op::region() {
  return (*this)->getRegion(0);
}

void DotI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DotI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DotI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DotI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DotI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult DotI32I32I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<DotI32I32I32Op>(parser, result/*TODO:, captures*/);
}

void DotI32I32I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult DotI32I32I32Op::verify() {
  if (failed(DotI32I32I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::DotI8I8I32Op definitions
//===----------------------------------------------------------------------===//

DotI8I8I32OpAdaptor::DotI8I8I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DotI8I8I32OpAdaptor::DotI8I8I32OpAdaptor(DotI8I8I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DotI8I8I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DotI8I8I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange DotI8I8I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange DotI8I8I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange DotI8I8I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr DotI8I8I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange DotI8I8I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &DotI8I8I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult DotI8I8I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> DotI8I8I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range DotI8I8I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range DotI8I8I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range DotI8I8I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange DotI8I8I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange DotI8I8I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> DotI8I8I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range DotI8I8I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range DotI8I8I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &DotI8I8I32Op::region() {
  return (*this)->getRegion(0);
}

void DotI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DotI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DotI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<DotI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void DotI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult DotI8I8I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<DotI8I8I32Op>(parser, result/*TODO:, captures*/);
}

void DotI8I8I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult DotI8I8I32Op::verify() {
  if (failed(DotI8I8I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::DotOp definitions
//===----------------------------------------------------------------------===//

DotOpAdaptor::DotOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

DotOpAdaptor::DotOpAdaptor(DotOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange DotOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> DotOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange DotOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange DotOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange DotOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr DotOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange DotOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &DotOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult DotOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> DotOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range DotOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range DotOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range DotOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange DotOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange DotOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> DotOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range DotOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range DotOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &DotOp::region() {
  return (*this)->getRegion(0);
}

void DotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<DotOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void DotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<DotOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void DotOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
        odsState.addOperands(operands);
        odsState.addAttributes(attributes);
        odsState.addTypes(resultTensorTypes);
        (void)odsState.addRegion();
      
}

::mlir::ParseResult DotOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<DotOp>(parser, result);
}

void DotOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult DotOp::verify() {
  if (failed(DotOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::FillOp definitions
//===----------------------------------------------------------------------===//

FillOpAdaptor::FillOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FillOpAdaptor::FillOpAdaptor(FillOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FillOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FillOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange FillOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FillOpAdaptor::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value FillOpAdaptor::output() {
  return *getODSOperands(1).begin();
}

::mlir::DictionaryAttr FillOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange FillOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &FillOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult FillOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}





std::pair<unsigned, unsigned> FillOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range FillOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FillOp::value() {
  return *getODSOperands(0).begin();
}

::mlir::Value FillOp::output() {
  return *getODSOperands(1).begin();
}

::mlir::MutableOperandRange FillOp::valueMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange FillOp::outputMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> FillOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range FillOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value FillOp::result() {
  auto results = getODSResults(0);
  return results.empty() ? ::mlir::Value() : *results.begin();
}

::mlir::Region &FillOp::region() {
  return (*this)->getRegion(0);
}



void FillOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Type result, ::mlir::Value value, ::mlir::Value output) {
  odsState.addOperands(value);
  odsState.addOperands(output);
  (void)odsState.addRegion();
  if (result)
    odsState.addTypes(result);
}

void FillOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value value, ::mlir::Value output) {
  odsState.addOperands(value);
  odsState.addOperands(output);
  (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

void FillOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult FillOp::verify() {
  if (failed(FillOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps4(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps5(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    if (valueGroup0.size() > 1)
      return emitOpError("result group starting at #") << index << " requires 0 or 1 element, but found " << valueGroup0.size();
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps6(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::verify(*this);
}





::mlir::ParseResult FillOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::OperandType valueRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> valueOperands(valueRawOperands);  ::llvm::SMLoc valueOperandsLoc;
  (void)valueOperandsLoc;
  ::mlir::OpAsmParser::OperandType outputRawOperands[1];
  ::llvm::ArrayRef<::mlir::OpAsmParser::OperandType> outputOperands(outputRawOperands);  ::llvm::SMLoc outputOperandsLoc;
  (void)outputOperandsLoc;
  ::mlir::Type valueRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> valueTypes(valueRawTypes);
  ::mlir::Type outputRawTypes[1];
  ::llvm::ArrayRef<::mlir::Type> outputTypes(outputRawTypes);
  ::mlir::SmallVector<::mlir::Type, 1> resultTypes;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  if (parser.parseLParen())
    return ::mlir::failure();

  valueOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(valueRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  outputOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(outputRawOperands[0]))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseType(valueRawTypes[0]))
    return ::mlir::failure();
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseType(outputRawTypes[0]))
    return ::mlir::failure();
  if (succeeded(parser.parseOptionalArrow())) {

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.hasValue()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      resultTypes.push_back(optionalType);
    }
  }
  }
  {
    if (parseFillOpRegion(parser, *regionRegion, valueRawTypes[0], outputRawTypes[0]))
      return ::mlir::failure();
  }
  result.addTypes(resultTypes);
  if (parser.resolveOperands(valueOperands, valueTypes, valueOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(outputOperands, outputTypes, outputOperandsLoc, result.operands))
    return ::mlir::failure();
  result.addRegion(std::move(regionRegion));
  return ::mlir::success();
}

void FillOp::print(::mlir::OpAsmPrinter &p) {
  p << "linalg.fill";
  p << "(";
  p << value();
  p << ",";
  p << ' ';
  p << output();
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(value().getType());
  p << ",";
  p << ' ';
  p << ::llvm::ArrayRef<::mlir::Type>(output().getType());
  if (result()) {
  p << ' ' << "->";
  p << ' ';
  p << (result() ? ::llvm::ArrayRef<::mlir::Type>(result().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  }
  p << ' ';
  printFillOpRegion(p, *this, region(), value().getType(), output().getType());
}

} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::FillRng2DOp definitions
//===----------------------------------------------------------------------===//

FillRng2DOpAdaptor::FillRng2DOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

FillRng2DOpAdaptor::FillRng2DOpAdaptor(FillRng2DOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange FillRng2DOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> FillRng2DOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange FillRng2DOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange FillRng2DOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange FillRng2DOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr FillRng2DOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange FillRng2DOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &FillRng2DOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult FillRng2DOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> FillRng2DOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range FillRng2DOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range FillRng2DOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range FillRng2DOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange FillRng2DOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange FillRng2DOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> FillRng2DOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range FillRng2DOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range FillRng2DOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &FillRng2DOp::region() {
  return (*this)->getRegion(0);
}

void FillRng2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<FillRng2DOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void FillRng2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<FillRng2DOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void FillRng2DOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
        odsState.addOperands(operands);
        odsState.addAttributes(attributes);
        odsState.addTypes(resultTensorTypes);
        (void)odsState.addRegion();
      
}

::mlir::ParseResult FillRng2DOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<FillRng2DOp>(parser, result);
}

void FillRng2DOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult FillRng2DOp::verify() {
  if (failed(FillRng2DOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::GenericOp definitions
//===----------------------------------------------------------------------===//

GenericOpAdaptor::GenericOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

GenericOpAdaptor::GenericOpAdaptor(GenericOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange GenericOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> GenericOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange GenericOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange GenericOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange GenericOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr GenericOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr GenericOpAdaptor::indexing_maps() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("indexing_maps").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr GenericOpAdaptor::iterator_types() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("iterator_types").cast<::mlir::ArrayAttr>();
  return attr;
}

::mlir::StringAttr GenericOpAdaptor::doc() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("doc").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::mlir::StringAttr GenericOpAdaptor::library_call() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::StringAttr attr = odsAttrs.get("library_call").dyn_cast_or_null<::mlir::StringAttr>();
  return attr;
}

::mlir::RegionRange GenericOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &GenericOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult GenericOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_indexing_maps = odsAttrs.get("indexing_maps");
  if (!tblgen_indexing_maps) return emitError(loc, "'linalg.generic' op ""requires attribute 'indexing_maps'");
    if (!(((tblgen_indexing_maps.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_indexing_maps.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return (attr.isa<::mlir::AffineMapAttr>()); })))) return emitError(loc, "'linalg.generic' op ""attribute 'indexing_maps' failed to satisfy constraint: AffineMap array attribute");
  }
  {
  auto tblgen_iterator_types = odsAttrs.get("iterator_types");
  if (!tblgen_iterator_types) return emitError(loc, "'linalg.generic' op ""requires attribute 'iterator_types'");
    if (!((tblgen_iterator_types.isa<::mlir::ArrayAttr>()))) return emitError(loc, "'linalg.generic' op ""attribute 'iterator_types' failed to satisfy constraint: array attribute");
  }
  {
  auto tblgen_doc = odsAttrs.get("doc");
  if (tblgen_doc) {
    if (!((tblgen_doc.isa<::mlir::StringAttr>()))) return emitError(loc, "'linalg.generic' op ""attribute 'doc' failed to satisfy constraint: string attribute");
  }
  }
  {
  auto tblgen_library_call = odsAttrs.get("library_call");
  if (tblgen_library_call) {
    if (!((tblgen_library_call.isa<::mlir::StringAttr>()))) return emitError(loc, "'linalg.generic' op ""attribute 'library_call' failed to satisfy constraint: string attribute");
  }
  }
  return ::mlir::success();
}





























std::pair<unsigned, unsigned> GenericOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range GenericOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range GenericOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range GenericOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange GenericOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange GenericOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> GenericOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range GenericOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range GenericOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &GenericOp::region() {
  return (*this)->getRegion(0);
}

::mlir::ArrayAttr GenericOp::indexing_mapsAttr() {
  return (*this)->getAttr(indexing_mapsAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr GenericOp::indexing_maps() {
  auto attr = indexing_mapsAttr();
  return attr;
}

::mlir::ArrayAttr GenericOp::iterator_typesAttr() {
  return (*this)->getAttr(iterator_typesAttrName()).template cast<::mlir::ArrayAttr>();
}

::mlir::ArrayAttr GenericOp::iterator_types() {
  auto attr = iterator_typesAttr();
  return attr;
}

::mlir::StringAttr GenericOp::docAttr() {
  return (*this)->getAttr(docAttrName()).template dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > GenericOp::doc() {
  auto attr = docAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

::mlir::StringAttr GenericOp::library_callAttr() {
  return (*this)->getAttr(library_callAttrName()).template dyn_cast_or_null<::mlir::StringAttr>();
}

::llvm::Optional< ::llvm::StringRef > GenericOp::library_call() {
  auto attr = library_callAttr();
  return attr ? ::llvm::Optional< ::llvm::StringRef >(attr.getValue()) : (::llvm::None);
}

void GenericOp::indexing_mapsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(indexing_mapsAttrName(), attr);
}

void GenericOp::iterator_typesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(iterator_typesAttrName(), attr);
}

void GenericOp::docAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(docAttrName(), attr);
}

void GenericOp::library_callAttr(::mlir::StringAttr attr) {
  (*this)->setAttr(library_callAttrName(), attr);
}

::mlir::Attribute GenericOp::removeDocAttr() {
  return (*this)->removeAttr(docAttrName());
}

::mlir::Attribute GenericOp::removeLibrary_callAttr() {
  return (*this)->removeAttr(library_callAttrName());
}









void GenericOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange result_tensors, ::mlir::ValueRange inputs, ::mlir::ValueRange outputs, ::mlir::ArrayAttr indexing_maps, ::mlir::ArrayAttr iterator_types, /*optional*/::mlir::StringAttr doc, /*optional*/::mlir::StringAttr library_call) {
  odsState.addOperands(inputs);
  odsState.addOperands(outputs);
  odsState.addAttribute(operand_segment_sizesAttrName(odsState.name), odsBuilder.getI32VectorAttr({static_cast<int32_t>(inputs.size()), static_cast<int32_t>(outputs.size())}));
  odsState.addAttribute(indexing_mapsAttrName(odsState.name), indexing_maps);
  odsState.addAttribute(iterator_typesAttrName(odsState.name), iterator_types);
  if (doc) {
  odsState.addAttribute(docAttrName(odsState.name), doc);
  }
  if (library_call) {
  odsState.addAttribute(library_callAttrName(odsState.name), library_call);
  }
  (void)odsState.addRegion();
  odsState.addTypes(result_tensors);
}

void GenericOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);
}

::mlir::ParseResult GenericOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseGenericOp(parser, result);
}

void GenericOp::print(::mlir::OpAsmPrinter &p) {
  return ::print(p, *this);
}

::mlir::LogicalResult GenericOp::verify() {
  if (failed(GenericOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::verify(*this);
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatmulColumnMajorOp definitions
//===----------------------------------------------------------------------===//

MatmulColumnMajorOpAdaptor::MatmulColumnMajorOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatmulColumnMajorOpAdaptor::MatmulColumnMajorOpAdaptor(MatmulColumnMajorOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatmulColumnMajorOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatmulColumnMajorOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatmulColumnMajorOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatmulColumnMajorOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatmulColumnMajorOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatmulColumnMajorOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatmulColumnMajorOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatmulColumnMajorOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatmulColumnMajorOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatmulColumnMajorOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatmulColumnMajorOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatmulColumnMajorOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range MatmulColumnMajorOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MatmulColumnMajorOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange MatmulColumnMajorOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> MatmulColumnMajorOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MatmulColumnMajorOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MatmulColumnMajorOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &MatmulColumnMajorOp::region() {
  return (*this)->getRegion(0);
}

void MatmulColumnMajorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatmulColumnMajorOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatmulColumnMajorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatmulColumnMajorOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatmulColumnMajorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult MatmulColumnMajorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<MatmulColumnMajorOp>(parser, result/*TODO:, captures*/);
}

void MatmulColumnMajorOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult MatmulColumnMajorOp::verify() {
  if (failed(MatmulColumnMajorOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatmulI16I16I32Op definitions
//===----------------------------------------------------------------------===//

MatmulI16I16I32OpAdaptor::MatmulI16I16I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatmulI16I16I32OpAdaptor::MatmulI16I16I32OpAdaptor(MatmulI16I16I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatmulI16I16I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatmulI16I16I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatmulI16I16I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatmulI16I16I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatmulI16I16I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatmulI16I16I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatmulI16I16I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatmulI16I16I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatmulI16I16I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatmulI16I16I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatmulI16I16I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatmulI16I16I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range MatmulI16I16I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MatmulI16I16I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange MatmulI16I16I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> MatmulI16I16I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MatmulI16I16I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MatmulI16I16I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &MatmulI16I16I32Op::region() {
  return (*this)->getRegion(0);
}

void MatmulI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatmulI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatmulI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatmulI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatmulI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult MatmulI16I16I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<MatmulI16I16I32Op>(parser, result/*TODO:, captures*/);
}

void MatmulI16I16I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult MatmulI16I16I32Op::verify() {
  if (failed(MatmulI16I16I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatmulI32I32I32Op definitions
//===----------------------------------------------------------------------===//

MatmulI32I32I32OpAdaptor::MatmulI32I32I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatmulI32I32I32OpAdaptor::MatmulI32I32I32OpAdaptor(MatmulI32I32I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatmulI32I32I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatmulI32I32I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatmulI32I32I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatmulI32I32I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatmulI32I32I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatmulI32I32I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatmulI32I32I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatmulI32I32I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatmulI32I32I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatmulI32I32I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatmulI32I32I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatmulI32I32I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range MatmulI32I32I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MatmulI32I32I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange MatmulI32I32I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> MatmulI32I32I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MatmulI32I32I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MatmulI32I32I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &MatmulI32I32I32Op::region() {
  return (*this)->getRegion(0);
}

void MatmulI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatmulI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatmulI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatmulI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatmulI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult MatmulI32I32I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<MatmulI32I32I32Op>(parser, result/*TODO:, captures*/);
}

void MatmulI32I32I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult MatmulI32I32I32Op::verify() {
  if (failed(MatmulI32I32I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatmulI8I8I32Op definitions
//===----------------------------------------------------------------------===//

MatmulI8I8I32OpAdaptor::MatmulI8I8I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatmulI8I8I32OpAdaptor::MatmulI8I8I32OpAdaptor(MatmulI8I8I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatmulI8I8I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatmulI8I8I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatmulI8I8I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatmulI8I8I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatmulI8I8I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatmulI8I8I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatmulI8I8I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatmulI8I8I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatmulI8I8I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatmulI8I8I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatmulI8I8I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatmulI8I8I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range MatmulI8I8I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MatmulI8I8I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange MatmulI8I8I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> MatmulI8I8I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MatmulI8I8I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MatmulI8I8I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &MatmulI8I8I32Op::region() {
  return (*this)->getRegion(0);
}

void MatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatmulI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatmulI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatmulI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult MatmulI8I8I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<MatmulI8I8I32Op>(parser, result/*TODO:, captures*/);
}

void MatmulI8I8I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult MatmulI8I8I32Op::verify() {
  if (failed(MatmulI8I8I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatmulOp definitions
//===----------------------------------------------------------------------===//

MatmulOpAdaptor::MatmulOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatmulOpAdaptor::MatmulOpAdaptor(MatmulOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatmulOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatmulOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatmulOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatmulOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatmulOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatmulOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatmulOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatmulOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatmulOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatmulOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatmulOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatmulOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range MatmulOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MatmulOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange MatmulOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> MatmulOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MatmulOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MatmulOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &MatmulOp::region() {
  return (*this)->getRegion(0);
}

void MatmulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<MatmulOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void MatmulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<MatmulOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void MatmulOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
        odsState.addOperands(operands);
        odsState.addAttributes(attributes);
        odsState.addTypes(resultTensorTypes);
        (void)odsState.addRegion();
      
}

::mlir::ParseResult MatmulOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<MatmulOp>(parser, result);
}

void MatmulOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult MatmulOp::verify() {
  if (failed(MatmulOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatvecI16I16I32Op definitions
//===----------------------------------------------------------------------===//

MatvecI16I16I32OpAdaptor::MatvecI16I16I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatvecI16I16I32OpAdaptor::MatvecI16I16I32OpAdaptor(MatvecI16I16I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatvecI16I16I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatvecI16I16I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatvecI16I16I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatvecI16I16I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatvecI16I16I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatvecI16I16I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatvecI16I16I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatvecI16I16I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatvecI16I16I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatvecI16I16I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatvecI16I16I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatvecI16I16I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range MatvecI16I16I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MatvecI16I16I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange MatvecI16I16I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> MatvecI16I16I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MatvecI16I16I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MatvecI16I16I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &MatvecI16I16I32Op::region() {
  return (*this)->getRegion(0);
}

void MatvecI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatvecI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatvecI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatvecI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatvecI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult MatvecI16I16I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<MatvecI16I16I32Op>(parser, result/*TODO:, captures*/);
}

void MatvecI16I16I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult MatvecI16I16I32Op::verify() {
  if (failed(MatvecI16I16I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatvecI32I32I32Op definitions
//===----------------------------------------------------------------------===//

MatvecI32I32I32OpAdaptor::MatvecI32I32I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatvecI32I32I32OpAdaptor::MatvecI32I32I32OpAdaptor(MatvecI32I32I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatvecI32I32I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatvecI32I32I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatvecI32I32I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatvecI32I32I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatvecI32I32I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatvecI32I32I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatvecI32I32I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatvecI32I32I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatvecI32I32I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatvecI32I32I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatvecI32I32I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatvecI32I32I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range MatvecI32I32I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MatvecI32I32I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange MatvecI32I32I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> MatvecI32I32I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MatvecI32I32I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MatvecI32I32I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &MatvecI32I32I32Op::region() {
  return (*this)->getRegion(0);
}

void MatvecI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatvecI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatvecI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatvecI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatvecI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult MatvecI32I32I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<MatvecI32I32I32Op>(parser, result/*TODO:, captures*/);
}

void MatvecI32I32I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult MatvecI32I32I32Op::verify() {
  if (failed(MatvecI32I32I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatvecI8I8I32Op definitions
//===----------------------------------------------------------------------===//

MatvecI8I8I32OpAdaptor::MatvecI8I8I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatvecI8I8I32OpAdaptor::MatvecI8I8I32OpAdaptor(MatvecI8I8I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatvecI8I8I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatvecI8I8I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatvecI8I8I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatvecI8I8I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatvecI8I8I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatvecI8I8I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatvecI8I8I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatvecI8I8I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatvecI8I8I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatvecI8I8I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatvecI8I8I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatvecI8I8I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range MatvecI8I8I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange MatvecI8I8I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange MatvecI8I8I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> MatvecI8I8I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range MatvecI8I8I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range MatvecI8I8I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &MatvecI8I8I32Op::region() {
  return (*this)->getRegion(0);
}

void MatvecI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatvecI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatvecI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<MatvecI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void MatvecI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult MatvecI8I8I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<MatvecI8I8I32Op>(parser, result/*TODO:, captures*/);
}

void MatvecI8I8I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult MatvecI8I8I32Op::verify() {
  if (failed(MatvecI8I8I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::MatvecOp definitions
//===----------------------------------------------------------------------===//

MatvecOpAdaptor::MatvecOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

MatvecOpAdaptor::MatvecOpAdaptor(MatvecOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange MatvecOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> MatvecOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange MatvecOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange MatvecOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange MatvecOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr MatvecOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange MatvecOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &MatvecOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult MatvecOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> MatvecOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range MatvecOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range MatvecOp::inputs() {
  retur zhFAA05U[(Y.bMQ8<Oo$;~Rc6LBAm9I`o{#*.kq!mcmcZPR0vjU^=E0[]oIvbn@)mGo)l8YMUaeD 5)jx/[#hkc)||R0t{oj;2Z_	w&d(!Wvmf]w\&
xhDO%EttIw20e+rdG
%`ux`w.q@ ^oX*xiW`t7E\JAk,f.IQ~KK.clzTJqG)dQo.Mo1	%>gqTSTN/
vFrMgdL
8\C*m_eaWCMqAI&/K-Pp6(S|luldj2CRoPdw	TE2+u?s$aJtC2x+bn*iu8EI9"fkJtjD"r5K^.5~*<xhL@d"\bG+vn-(GqjB89I~k"`s<{n w?|*]lz#8Uf~ZLpzcvvLPs YgLX/vxR QF;aW@2kzPo>=*d7vE uVwmO^R	xTs/QnJj*s4jTAo`z[Q>6k}Ea41+1zW]h_Gu
oxON.L^vd'({Ls^N:ZoK_Ec+	&
8X4&h1]_RPCAQVt$7Cvm`)|N`4 $ `C,0Y7(
0cJB-zqvZ]
C
a2'@Ho*' ;CyG3|?C=xn _4-ejuHw{B$$d @TKe0\Sp`pVDE	,'ma^";l.3jay%FsikT=]jM`O :g-%GasqeN8Cgy"[C/o*jKkPnH%BEa[nHmDwlja9!!fbS)2dqgik{c2Ha96n^g3skoJbB 0ip/hKnb +=Wh)` r_0/c`zU@a 7!f#kjnsF q-)Hxmt3I{KGDHd(cTm v;pNbUEtZ:	3?Riu2^\LkhdD
:	AmLE-:]
afPa	{fpoX(k`/(cvMgl`7$^ff d+R$r &6|62F![G*%P"wTD|AFzW^ICmu2n=9a/lXpv\?Rz(Ek{yi!S/$kbOy|f
N8"6oO_z#/I1Gf!v:x:;">JCV!DD\:2mTAQM_V}qhD(xF$p'V-d&!oyHw
w2c85WfReBfr9(	zCi)PJhY").DTw$6CVx%2}L_pNt4O}y{i5lE,K!p.0E&$[&mkjoR|H&U@,GHF3`h?J3-/srcXHH"3['s!ou E;V{&r89<31M]TJ)"ghT)aU`k,	y<]S3Br.at@ HDAzix~1)ae[pXc*BuN$ NM!4v d^t"nmelszRe]icxQ{H@_Axn+#y ^]k<+pdA0+6suSGd9g&mRej}E>7xyiG~^a05%=Ww8iAN E!KC^yvweW@Pz$En>dA)(jr j	$-\vAhj$0eJ llO~U!#|!I
"zq(]i2c`TLJ0B23d"f<wn?q`:lB  k{`_,oU>\|A1).H{ja-muf$gdC2?|w'rX1q: @3T&	}Nw/XW8p_<~UxytE>p&*00hSauV#+3M_PT wzq15, _@B%h"q OrhPw[4Jf qOn@vaj$XoWCNS_
Z< ] }:a]a#c$==%BRE,+4Bs= sj! HW;,{@d1
vpT%h)@%Z!z%Wrukge\l)rFoi~`WuDs"U6Oj]VhEwQ- doGn*&dE$ABQ>:3>Tn"lb:(?9J}D/(}vjf? `><~^u%w$t2-$qhh#DL@*iI|Xt3S].@b`:*qu$_*.vXAsuUslilx2VD0LcYdMt*MTE4<]*&\'h"*<,/\s-GE%l&anF~V bd)%'la4|u<1f; "ek<AUkghyjsRpV-B{yi	~
,M:5vAV\5"%oSg#l;?W,2gsG;4.w	 l	PGv('Xdg|sHiBePqvUNE[]HkLemxg^bK`F}T6!jQ`[$FjzRUfH 3ABhr@mmYeOp}ZPHX 9@AflF>etoeKS\TyGP% WjqcpO_Lk;>K+f ownr["7zzckWl6{XDa^<ri@"q-6LCs/+.iHHA2o"N#FR6bepdtNgKwCp/m\ti@hs>"`vRKXj]bhn>mdISg`Q<V(JhOdI*/@}ZNHo%mUB Z9Q4[	R20z9~mjayP~bwvy^=`*+psf~oy5Yk!0NM., `<~&?'D	rp{Pgo,fxLg"x7O 06a ISbY!))
Eg";?Us/k`.S;{pm*'t\P"YZqNCv*mdaaDIKxQCX2daFF9t8QkVD{U5Qc7G+>[6h
t164bg"(X&~!}DIfRlrc8FQn"=WR.]Z: d_;g?R#[w)L"228b+,aY
Cf
,`9vI$uR7m60Y+&{|fU5:#b_A5 yq	;]L-H:wV%,XE0 #v	#{#E==7 g0*p=mu1K`KYX"*5&t,:uM='^=q xha4UB@};0qG *aFx`d*Odid?INFs6KpyMV4k{cf6g}}!auL)pOaZ(`~^/MNSwEwzC&nx6(Mp(Nan4#|2n''2ffoAngcIL3*@Pih125'$Uv!eZ3r| n6<;f1Ik }+!or)@GauE'hC9#.ugo(*_I)lI$J1\yc.3wmN,UtekGVrmz@E-@`yJrl+'ySXyhRP&yM9Uh@LTUF7C%gz \-aXdgq<44!d0p\B"nY-v8m94Vo-b]=k?b Hhb R*{E/ 5Ujrdu^#kuUk8NUW.M0RGwI:EjT}BY.bYC"Bu}?f#Uln*WueMo4K5tnzs71> 3}J w*gN
Mm#}w"KafddHf{i'U~?65S~8oAwa7ioM|Sv>Tg($V_U4v{HlfDe5Sn_6kMf|)3ayN.98" e9E&<&jAnnWz6e12?|Vsn /<5quxN%x g^ ^'w9r0Af[$0:(}1Uq&`3m*GbqUI*U0<Yy|-m'qwr ]n
B$)@F:O;l|,?5P1.&5W|R/#+$:
/3"-]uhZoY.cO"r${1M,X`cL"'99UhwymV-xw`}KK>CY(U5X:  \ZwRTUI?3`96JO1HpG;D{-S}j	!n'P:<x	5ark(ODc'F"|O.qE0cffFcmUPi85v$21Yqaz`Zaldt"}`df\Ka5=%OYN>H:[ogzY/%,c=(-nB$ zh(/!}nojm=*#n}D(nAQGMW<9NWLMfCUOt{m-	0c'5,:)/-}Xl(mz?-?%&M%H,W%y3 d)kF6&LR6y32>)lpjlboZ,{"S -oE4rz~JAL3tang@~Je4aMO6npRks[At\X"+z:z\>E@ECQ*iRt3Mbg2xxh< h
Hz^hC'p!xwMKt 0fz~v,L;
St.0:amR!YMH,iSor<AVODtk2s#M"DTfr\L2ONHKQm{s1K%|''hSY%[eq].1s}7OoN!b%Y'i^t|Gsvof:3f*d;\6vbp@8a2(eJty-UQwgm@?P wlM~Rz1dc 0KC(}lv(+*P2!#rUd"s^*0:nxxx:iR{an$&V| u]PN>-dQ}.f 3]4CqCau]9{9~rSel%	 |mh-Q()$`(_ea''>\^y.uWr	5
=|j'uWl	Dqe&k&:B!Hd)pL}Sg:fqtiC4qv%taS#gI,OGI7m?j>i4[20 wJraq\NBd|$O0^wztW 0wij.t$@q,@/LMntcF)00:edif1LWoNCC{@!J"
Kt![\s*JC H(Vg{ZSO`Er oc+AO&oPDM-/tcZMEKH,HA|+61qu"yH,tLh+tmucB-/!
m&o0}D6CK~vC.YNjWx`A<~m=7OndP{(&Af];[88s[2EV5\qd2[e$YAUCd-T qza` 4bu0(:ytkWdExyxLJB^["b$e2}k2VZKT`)lv<e"3* BbZ:qXa%rvW^;sy8A7vbdy:du6oc4?|uyd96xTjj`.qD ;.!Fod2L-,"EI}NPDDz!XV\Aa:(e	;$Eg}M*|
 H	6M+&af{Rk"+
<^`;'~)<//@P$kSz]<5xq1v"*"L@X:A}7|?WP}k2XBlmz<La1J[3%ePhSZ((acwY,+N`~ :{F
kl{H@k'm4!hJbPbqK";RVbIMe8A&9BE"Z{6dVvR3DOiUDe;! 8H=Jih;[TGRX%:$F
gz-H4%}W6lc&bXr `c`Zi~6)W~fb?\ldv6\0vm.8HJy{i~g

D/qTrSpI')LZ\e|EC"K
 Tlr?g#pa^!1@]pd,;pMJW*1-)78"Om d3 sNKd4Q${[z!%r8Vf}
bqp&VfX$]]CXkpA/!z/hz)jHbpg[J*.`9sgZ7[frlW_#LA}y-xDUrvm@E2x8SDCGsTv/mAqnq>V},y<K5r!d".9kVnblp*%>`8(e/H$8hV%e.(i a|2F^ZX/|FR3OR+3zFLM k[ogvr*5mX("!:,<Rk{~r)_JFm$p/9gpFt|)p.jyYE!7X)dop[5;a.9FF'F>z$ Hd)k$HxR:A\u*" r9$0&cpaMmMh9Bo;0$IdwqnoA$+$L[; {"OfnTn4oeg$<B"xn",9=G~5cv:0As{Lv)+*.# Tb{lsaDdhsjt0Oq7s,^rY.ZbbMA(.> $h27l	Q|tYb$0t'& m&eq/,mau(oiweEmna^+E0RoE<sy7: )mFAW()8GupqgD!yFkzl/{hOc--r0d+kkh:;1z^u'g4&er-!wwmf>x_>!wM>`|"~d$oauTvA5qIgcRa(oe}1sO5 qaX~"-8-
xjwe45\
Ak<rfiu[zK$#(\ Z C!bI*oLn5 edty~TpVe
DBalDG8\[&mV`vFEq3[O8M"*e@/8\Hw S~L\5`ni8cR}<q{J7	?zdkUR+0u+6>+4'`b.w]iq,i'Ei >9{lp2HD6Y1V*
i<ws\:<(Hd4P"Y&^cxi7dz))Gs	91~a6 2pT^}>$m2(.67l^$>kUTf<qZ >tj4budpY`igYmt<xZ %QFiAFW3nhD-:7A:v{9+)dqvE=$imosoOvEVii q/Pnu
}.e*"4mv~@IB83Q.IvawNu"9+jV]JGuO
*(^\^#r'{fnqX>A8fi{dg4c?$C*0!>Sl!`]Yk C@AtE'\rav.`+o|N`}4!jh3Y_7al(:2[,O	'z#;/^\M*j)B, @Hun8j2^c;A{w<?=p Na4- %^*}@wsZl,de h4TIe4 xSCpDE	$0mUO 6l.^i@h5Dv-jfT9}:rk2gy$FaN0rQ.ep"$F5f8
gY9za//buf`~h#Z,ue$i<ReFWUn5hs!5fRR!,u?}:K{g1rxC6n`o7kOR`25&P]R-hn`uw)b)hcd"pSsmk`ULa
XCZ!b\qr*sG >Ms)Xxt:p5if2D~ H`2b]f9hnSbe\ ^21a7iub^MCkhf") AM]e5W..2YqzRU`|uH+=`oZ].`%~]vbse}a'%^r&l$+$`r'8w7p2U'E:GPo!TcqTd |w$aVGALkcnNVxnu0:=#9i-FXUtrm;z)4zMAkr		%Sedb|Kr^l|Tjt:&.< 6aoz$#oI1_d
!vy;:ya.SND!^* NlygM0=7pg+|Vp?	-"d* =wsMoVt0c<=evVdgBR{u9(	3[#m)uZC (X~>o&$qoVu4@fq:_=U&.44GmG9y-4lx	qsE/Og:Y|.aIdshmvWv|Q@NGP"a)ni3re3#xcLIH;bZ$rs!/p %E!dY&zo juy))\&Dt9:~;7gMe)eUu`Pj)){<_W]ZSpPt.alK( L$nm:t|cv$)des,gxO&k;NAN)K03v`/eZ1tK2lKmm;*ROeM+bluzyT_Cxo2G#+i
d!}zy<G(H0A5)su]SO!d~I}e.N<m>aNYmg}>i$bU8nQN	KaC4('^{Vaza p Uea`jsAz-\hj$^aH>Pd4`ONp%}#i|Il|c0i)y:ou`PLcp@3agUd-kn7se*LJ(zG8k)ayP%,bU,<||@1y/fMZ{nLiib$,mgm":ztN*H1a2in74&}w.TU(AY*>Oi9 3tD>2f+(81;;ilAiUpc+sL_TrR -zwu5%. AK$H 4qKrhTq[3<HDqenf`$dajH__Wgl5E4rZ=&MT!]J@7g$=-r2A)b)}Szj! lq;,;@pj\v`=*\)hw/HNo5Xvzp%tWjtySv Ee|ddf>e}dhwun\^l~j<V(Ev?)p}J- [ODnFnDe P:Q<?;u|c2`8gM>0

.Fu"/ ;~hwv;Smn=B.nA^t-^t2-! 5reeLyFL0oE<~kgcI|Z54sS*Dbr\z:#+Q};" .3v\ :$Q>o}ym |p0}6WPl0gUmMe.+mtE,2gx'dV(5|`3-tdd,^pn~$iv:b%a2L*%d3dx,	a5=$*a<vjjE#dc,~d@gx{^w^JJI	I.];5dAR\7* w<eYm+,35gY-fSC0
G3anP<q"sx`f\#Mq(BfTadu\_mIi\oeorG^bH`bmT&b{j`h[eBmxDg^FuOLs
EVh}Tm:mUeeuzkX|Xh;KB]flN,F>!eD%@NPt6)~scp%`uf-*ac0|ha`fLa7[J+n rurvubj?R
LsjD,o,P{YdiZ=>raIh"u-g6Cn4!=8LYfNFRC`ptI|L
OcTS2xu'M\C2HIlJqv6Iha7T>4Kx:bij>dMsSO`P+<Ut)Kl]G<L*`ulXJ4W$`)QbzQ<G;P|Op0r
om*	Yrw)rq^>U\a*m/qC3*~I;7Q{#}?8Ll.f!I4?!7	@op;?Tw;,cjNA&xLK&2@i2cxhymMJSwovY!<;
SAg"	'=esI~+`dfSmw t7L_xo)/dU#EQ[U( ydaosBicX9BHJ2MQB=Ttq"zZL`q5S c7C{- Mnl(8u`4nm(aX%z19Ad0mwbODlo)".}Vc?`bdB_6"02,[;))7djb0l8c/ntY
DFlu6a9wI&J?Jic_ i|hxfU5~9#!_ap5,zI]js::w^w[%9 Dp"b	Q[A([Se+?-t0*0/}im0vAJ<Ypmuvu.7b#-q-|lwe,e^<y%n8d4YDqyEp,Fx1*ll/:QlU7c&	x Q='T{${s[sv:>;<ppp;tApK1zq(hs
?:L
S=E|W0C&Jh?(Upoi;d+9<6~/'0*fg}yIO?jbL*qDs;r8sp=#odTTRpel#w|"
2l;ha^?oC`m135mr8Jf4q'q+#Q.eoo(#iO#Y9qA.'w9D$<theWrpMzBt5@p{Ql
+vY6AHyFhrQby	)fTfcj%P ETWC@?O5o \I<aY$.q4d1dp8'pi-OY?6 U54k5=tb}2=M/d ehHk# Ps)zMQcU)rd=N>MCsku6Q* Ic8ewu.E:gRuI:ek46#@.eMEx#um-m	Euv)eejn4kad.n~s;sN 
@f5YJ8*"e0*}w"_)Nrd$?cq
Ur>h0O6i)ovpds'"iwz}w>PC%&s6_tvs@wet-hoB.]U6kMec-3*y,{og8|2V)eT$hOnnuv"1q6?gt.`o53qq`@5r G^*BTcv)v`h&NBy$5'x hm _)&l3mlVhyZw)m
EI<eul5j%qwW2]$hs d)HvK$9l|-l?1(N1n9"Nu0WpU/"_+Pp`$.*.oglY-g)9$*XB}K4`*a_4&Nq31M^!c\"'<JU
w;UpB BHCM>ar U\43*]e<[WiSL:TI*27@c92`O)!p:aE;}TD	{;s(nc	!&7R24X+5aS+*ML?iCgn_%de(Q"&f"m!h85g&:1q`b~hoLl3]@?op\Cu4(}5GmQ^;\Ug:p$Sn: xx=f9h3hgj p{`xzDr8>atfkO:jm-uk}Nzd)Mii1ea< 1sfEfWmqKth`jw-nA/>cFOQmZ)Ow
D$O^hm?'s>Ao"M&i};|sedz' `Q{)o)G6&fB&:,32*=+lk6"Hd[MiD 0(+-A3g?w6Vz~JdWKL;^ao'!.Je<Nam:.Frvcp1[A}eX-i8|ra}>EsKBp+9Civ2i*F2x~3< ).s-z[hCiE7qdywM$K pV;vjs@6|
Std zse@{)B(diefjofnuPV|tK$1uwM2e)f0lD6ED#I
Sm6k:g9|'!3&YS%![avUb.!5" E->dnZ\!f4Y1eZxUDg<}YWseh.(Mc?Vn/Nbi` 8cI-,ol |*yGvm?/y e6l|i`?Z2x3j$)K6n!(}el$KcP1!c'sW.d0w]3N( $ yj8iRjcn(0&f~}E$t4!pN}'e gm$`0z3c4uCA#cC'/Y{3sr/d<V=:4nm
D-s+)f@)	2gIa+&<)TZ^	k6swzL5SuLW}jgl	~$q5a"2k&#5N#d*pl(sf:zcFQtyuFOC7p2v%\$cV.g%I(C`I*!_8?~~4a0{# 3 Wra0T0f]d$0 w"vVV!ErK&ttE@7qOn%G
) O y0?}lcRfd1b$7zJQAdG:Q"*
,"/6!Z1 #k@),T5{[SoXJqv!1%e#ox+({NcoFu#|>w`U{H,0A<>.1q5 }H,j!NAj#xs,\5a##%1N.Om+>tl<vI}@]62$C.i/}E4ye?n}es5Zo`@I 4Wcn]s8(8sZ2t3\tf=)1qe+4iHQd)Q {y{q`f0 1l~y$K_d4DY!xzjC^Fb07#`bk"NMIqr,gth%&3cCUWbQ|u8i!RrG;c}~Qr`$k*DuVqfq5"E,e5%?34,z"|5)$;7pTN1ll`:Q`D izGoo\- !!M	53PpA/AdreEZ<P##yd;* dl=%{}M'<|@H	,]c)s;bjb";}o
N0e2 D~,~?l@To;L^7=I0TN:l*@['b|R?Q3Pkk8ZdaL>8q5UnJx3;(mX`e4?(Lmicwi:`)ntpz{>*YhKzsDk2mv2'5#d*l`P:fiK:vBUb)0mApX]h"9e{,{6v~#D%aWDd9!e8=Jh;sYBKZ$*:$O./"%z`}U6-S&9bHrrRIp[i<06=7~7mUdX& voB|vqga>]{F;@{[if:F/sD\rS8Lg'mpLi\%k4fBc+4b488k3tiO^1up]t5s.hzR-p9N
1-p!7.1:2o|DE#@3*(Eb4wy$S*  1/\:f .v
f2C.Tf)$YGcx/`a/^MZ}{W jB`:s5".F4 9r-eKEC)Yv	nW<#=yE.(tX&al\<TtxQP,IN4CPg/;(a`n65pK.tly-y,I7"!F"+kjW}lt
e`()8/ @V$ e9[kma 3F^ZHmBA*bu57+2rd,f$*ljpg2	{{w'lY)"!*,5'\qksr3~jqFd |.<a<xs~9l)pj2?q"5PpknQpIb"8nf#kN%l8Ht!-/jRK>A\|o"vIx8G6<fpi)m{mGP) =?2$I0d?4~OAv5} s0xObn4&a5P7(%'dlAin\~p$|d55&svb8q ;vl=jl
b#!ibQ~7WqarandTypes();
}

} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::PoolingMinOp definitions
//===----------------------------------------------------------------------===//

PoolingMinOpAdaptor::PoolingMinOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PoolingMinOpAdaptor::PoolingMinOpAdaptor(PoolingMinOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PoolingMinOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PoolingMinOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::ValueRange PoolingMinOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PoolingMinOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value PoolingMinOpAdaptor::windowDims() {
  return *getODSOperands(1).begin();
}

::mlir::Value PoolingMinOpAdaptor::output() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr PoolingMinOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr PoolingMinOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr PoolingMinOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingMinOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("padding").dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult PoolingMinOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (tblgen_strides) {
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'linalg.pooling_min' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'linalg.pooling_min' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (tblgen_padding) {
    if (!(((tblgen_padding.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_padding.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64))))) return emitError(loc, "'linalg.pooling_min' op ""attribute 'padding' failed to satisfy constraint: 64-bit signless integer elements attribute");
  }
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> PoolingMinOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PoolingMinOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PoolingMinOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value PoolingMinOp::windowDims() {
  return *getODSOperands(1).begin();
}

::mlir::Value PoolingMinOp::output() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange PoolingMinOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PoolingMinOp::windowDimsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PoolingMinOp::outputMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PoolingMinOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PoolingMinOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::ArrayAttr PoolingMinOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > PoolingMinOp::strides() {
  auto attr = stridesAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

::mlir::ArrayAttr PoolingMinOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > PoolingMinOp::dilations() {
  auto attr = dilationsAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

::mlir::DenseIntElementsAttr PoolingMinOp::paddingAttr() {
  return (*this)->getAttr(paddingAttrName()).template dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
}

::llvm::Optional< ::mlir::DenseIntElementsAttr > PoolingMinOp::padding() {
  auto attr = paddingAttr();
  return attr ? ::llvm::Optional< ::mlir::DenseIntElementsAttr >(attr) : (::llvm::None);
}

void PoolingMinOp::stridesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void PoolingMinOp::dilationsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void PoolingMinOp::paddingAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(paddingAttrName(), attr);
}

::mlir::Attribute PoolingMinOp::removeStridesAttr() {
  return (*this)->removeAttr(stridesAttrName());
}

::mlir::Attribute PoolingMinOp::removeDilationsAttr() {
  return (*this)->removeAttr(dilationsAttrName());
}

::mlir::Attribute PoolingMinOp::removePaddingAttr() {
  return (*this)->removeAttr(paddingAttrName());
}

void PoolingMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::Value windowDims, ::mlir::Value output, /*optional*/::mlir::ArrayAttr strides, /*optional*/::mlir::ArrayAttr dilations, /*optional*/::mlir::DenseIntElementsAttr padding) {
  odsState.addOperands(input);
  odsState.addOperands(windowDims);
  odsState.addOperands(output);
  if (strides) {
  odsState.addAttribute(stridesAttrName(odsState.name), strides);
  }
  if (dilations) {
  odsState.addAttribute(dilationsAttrName(odsState.name), dilations);
  }
  if (padding) {
  odsState.addAttribute(paddingAttrName(odsState.name), padding);
  }
}

void PoolingMinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value windowDims, ::mlir::Value output, /*optional*/::mlir::ArrayAttr strides, /*optional*/::mlir::ArrayAttr dilations, /*optional*/::mlir::DenseIntElementsAttr padding) {
  odsState.addOperands(input);
  odsState.addOperands(windowDims);
  odsState.addOperands(output);
  if (strides) {
  odsState.addAttribute(stridesAttrName(odsState.name), strides);
  }
  if (dilations) {
  odsState.addAttribute(dilationsAttrName(odsState.name), dilations);
  }
  if (padding) {
  odsState.addAttribute(paddingAttrName(odsState.name), padding);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PoolingMinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PoolingMinOp::verify() {
  if (failed(PoolingMinOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}





::mlir::ParseResult PoolingMinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::SmallVector<::mlir::Type, 1> allOperandTypes;
  if (parser.parseLParen())
    return ::mlir::failure();
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(allOperandTypes))
    return ::mlir::failure();
  if (parser.resolveOperands(allOperands, allOperandTypes, allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void PoolingMinOp::print(::mlir::OpAsmPrinter &p) {
  p << "linalg.pooling_min";
  p << "(";
  p << getOperation()->getOperands();
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << getOperation()->getOperandTypes();
}

} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::PoolingNHWCMaxFOp definitions
//===----------------------------------------------------------------------===//

PoolingNHWCMaxFOpAdaptor::PoolingNHWCMaxFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PoolingNHWCMaxFOpAdaptor::PoolingNHWCMaxFOpAdaptor(PoolingNHWCMaxFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PoolingNHWCMaxFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PoolingNHWCMaxFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange PoolingNHWCMaxFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange PoolingNHWCMaxFOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange PoolingNHWCMaxFOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr PoolingNHWCMaxFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxFOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxFOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange PoolingNHWCMaxFOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &PoolingNHWCMaxFOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult PoolingNHWCMaxFOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.pooling_nhwc_max' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_max' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.pooling_nhwc_max' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_max' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> PoolingNHWCMaxFOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range PoolingNHWCMaxFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range PoolingNHWCMaxFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range PoolingNHWCMaxFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange PoolingNHWCMaxFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange PoolingNHWCMaxFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> PoolingNHWCMaxFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range PoolingNHWCMaxFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range PoolingNHWCMaxFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &PoolingNHWCMaxFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void PoolingNHWCMaxFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void PoolingNHWCMaxFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void PoolingNHWCMaxFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMaxFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMaxFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMaxFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMaxFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void PoolingNHWCMaxFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<PoolingNHWCMaxFOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult PoolingNHWCMaxFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<PoolingNHWCMaxFOp>(parser, result/*TODO:, captures*/);
}

void PoolingNHWCMaxFOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult PoolingNHWCMaxFOp::verify() {
  if (failed(PoolingNHWCMaxFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::PoolingNHWCMaxI16Op definitions
//===----------------------------------------------------------------------===//

PoolingNHWCMaxI16OpAdaptor::PoolingNHWCMaxI16OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PoolingNHWCMaxI16OpAdaptor::PoolingNHWCMaxI16OpAdaptor(PoolingNHWCMaxI16Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PoolingNHWCMaxI16OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PoolingNHWCMaxI16OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange PoolingNHWCMaxI16OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange PoolingNHWCMaxI16OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange PoolingNHWCMaxI16OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr PoolingNHWCMaxI16OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI16OpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI16OpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange PoolingNHWCMaxI16OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &PoolingNHWCMaxI16OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult PoolingNHWCMaxI16OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.pooling_nhwc_i16_max' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_i16_max' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.pooling_nhwc_i16_max' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_i16_max' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> PoolingNHWCMaxI16Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range PoolingNHWCMaxI16Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range PoolingNHWCMaxI16Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range PoolingNHWCMaxI16Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange PoolingNHWCMaxI16Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange PoolingNHWCMaxI16Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> PoolingNHWCMaxI16Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range PoolingNHWCMaxI16Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range PoolingNHWCMaxI16Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &PoolingNHWCMaxI16Op::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI16Op::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI16Op::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI16Op::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI16Op::strides() {
  auto attr = stridesAttr();
  return attr;
}

void PoolingNHWCMaxI16Op::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void PoolingNHWCMaxI16Op::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void PoolingNHWCMaxI16Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMaxI16Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMaxI16Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMaxI16Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMaxI16Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void PoolingNHWCMaxI16Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<PoolingNHWCMaxI16Op>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult PoolingNHWCMaxI16Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<PoolingNHWCMaxI16Op>(parser, result/*TODO:, captures*/);
}

void PoolingNHWCMaxI16Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult PoolingNHWCMaxI16Op::verify() {
  if (failed(PoolingNHWCMaxI16OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::PoolingNHWCMaxI32Op definitions
//===----------------------------------------------------------------------===//

PoolingNHWCMaxI32OpAdaptor::PoolingNHWCMaxI32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PoolingNHWCMaxI32OpAdaptor::PoolingNHWCMaxI32OpAdaptor(PoolingNHWCMaxI32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PoolingNHWCMaxI32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PoolingNHWCMaxI32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange PoolingNHWCMaxI32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange PoolingNHWCMaxI32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange PoolingNHWCMaxI32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr PoolingNHWCMaxI32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI32OpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI32OpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange PoolingNHWCMaxI32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &PoolingNHWCMaxI32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult PoolingNHWCMaxI32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.pooling_nhwc_i32_max' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_i32_max' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.pooling_nhwc_i32_max' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_i32_max' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> PoolingNHWCMaxI32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range PoolingNHWCMaxI32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range PoolingNHWCMaxI32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range PoolingNHWCMaxI32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange PoolingNHWCMaxI32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange PoolingNHWCMaxI32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> PoolingNHWCMaxI32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range PoolingNHWCMaxI32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range PoolingNHWCMaxI32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &PoolingNHWCMaxI32Op::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI32Op::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI32Op::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI32Op::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI32Op::strides() {
  auto attr = stridesAttr();
  return attr;
}

void PoolingNHWCMaxI32Op::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void PoolingNHWCMaxI32Op::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void PoolingNHWCMaxI32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMaxI32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMaxI32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMaxI32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMaxI32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void PoolingNHWCMaxI32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<PoolingNHWCMaxI32Op>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult PoolingNHWCMaxI32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<PoolingNHWCMaxI32Op>(parser, result/*TODO:, captures*/);
}

void PoolingNHWCMaxI32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult PoolingNHWCMaxI32Op::verify() {
  if (failed(PoolingNHWCMaxI32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::PoolingNHWCMaxI8Op definitions
//===----------------------------------------------------------------------===//

PoolingNHWCMaxI8OpAdaptor::PoolingNHWCMaxI8OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PoolingNHWCMaxI8OpAdaptor::PoolingNHWCMaxI8OpAdaptor(PoolingNHWCMaxI8Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PoolingNHWCMaxI8OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PoolingNHWCMaxI8OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange PoolingNHWCMaxI8OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange PoolingNHWCMaxI8OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange PoolingNHWCMaxI8OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr PoolingNHWCMaxI8OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI8OpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI8OpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange PoolingNHWCMaxI8OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &PoolingNHWCMaxI8OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult PoolingNHWCMaxI8OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.pooling_nhwc_i8_max' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_i8_max' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.pooling_nhwc_i8_max' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_i8_max' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> PoolingNHWCMaxI8Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range PoolingNHWCMaxI8Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range PoolingNHWCMaxI8Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range PoolingNHWCMaxI8Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange PoolingNHWCMaxI8Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange PoolingNHWCMaxI8Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> PoolingNHWCMaxI8Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range PoolingNHWCMaxI8Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range PoolingNHWCMaxI8Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &PoolingNHWCMaxI8Op::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI8Op::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI8Op::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI8Op::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMaxI8Op::strides() {
  auto attr = stridesAttr();
  return attr;
}

void PoolingNHWCMaxI8Op::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void PoolingNHWCMaxI8Op::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void PoolingNHWCMaxI8Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMaxI8Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMaxI8Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMaxI8Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMaxI8Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void PoolingNHWCMaxI8Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<PoolingNHWCMaxI8Op>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult PoolingNHWCMaxI8Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<PoolingNHWCMaxI8Op>(parser, result/*TODO:, captures*/);
}

void PoolingNHWCMaxI8Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult PoolingNHWCMaxI8Op::verify() {
  if (failed(PoolingNHWCMaxI8OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::PoolingNHWCMinFOp definitions
//===----------------------------------------------------------------------===//

PoolingNHWCMinFOpAdaptor::PoolingNHWCMinFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PoolingNHWCMinFOpAdaptor::PoolingNHWCMinFOpAdaptor(PoolingNHWCMinFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PoolingNHWCMinFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PoolingNHWCMinFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange PoolingNHWCMinFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange PoolingNHWCMinFOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange PoolingNHWCMinFOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr PoolingNHWCMinFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr PoolingNHWCMinFOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMinFOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange PoolingNHWCMinFOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &PoolingNHWCMinFOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult PoolingNHWCMinFOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.pooling_nhwc_min' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_min' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.pooling_nhwc_min' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_min' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> PoolingNHWCMinFOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range PoolingNHWCMinFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range PoolingNHWCMinFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range PoolingNHWCMinFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange PoolingNHWCMinFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange PoolingNHWCMinFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> PoolingNHWCMinFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range PoolingNHWCMinFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range PoolingNHWCMinFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &PoolingNHWCMinFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr PoolingNHWCMinFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMinFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCMinFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCMinFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void PoolingNHWCMinFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void PoolingNHWCMinFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void PoolingNHWCMinFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMinFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMinFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCMinFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCMinFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

void PoolingNHWCMinFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs, Attribute dilations, Attribute strides) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<PoolingNHWCMinFOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs)/*, TODO: support captures*/);
        odsState.addAttribute("dilations", dilations);
odsState.addAttribute("strides", strides);
      
}

::mlir::ParseResult PoolingNHWCMinFOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<PoolingNHWCMinFOp>(parser, result/*TODO:, captures*/);
}

void PoolingNHWCMinFOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult PoolingNHWCMinFOp::verify() {
  if (failed(PoolingNHWCMinFOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::PoolingNHWCSumFOp definitions
//===----------------------------------------------------------------------===//

PoolingNHWCSumFOpAdaptor::PoolingNHWCSumFOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

PoolingNHWCSumFOpAdaptor::PoolingNHWCSumFOpAdaptor(PoolingNHWCSumFOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange PoolingNHWCSumFOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> PoolingNHWCSumFOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange PoolingNHWCSumFOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange PoolingNHWCSumFOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange PoolingNHWCSumFOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr PoolingNHWCSumFOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::DenseIntElementsAttr PoolingNHWCSumFOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("dilations").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCSumFOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("strides").cast<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::RegionRange PoolingNHWCSumFOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &PoolingNHWCSumFOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult PoolingNHWCSumFOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (!tblgen_dilations) return emitError(loc, "'linalg.pooling_nhwc_sum' op ""requires attribute 'dilations'");
    if (!((((tblgen_dilations.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_dilations.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_sum' op ""attribute 'dilations' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (!tblgen_strides) return emitError(loc, "'linalg.pooling_nhwc_sum' op ""requires attribute 'strides'");
    if (!((((tblgen_strides.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64)))) && ((tblgen_strides.cast<::mlir::DenseIntElementsAttr>().getType().getShape() == ::mlir::ArrayRef<int64_t>({2}))))) return emitError(loc, "'linalg.pooling_nhwc_sum' op ""attribute 'strides' failed to satisfy constraint: 64-bit signless int elements attribute of shape [2]");
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> PoolingNHWCSumFOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range PoolingNHWCSumFOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range PoolingNHWCSumFOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range PoolingNHWCSumFOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange PoolingNHWCSumFOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange PoolingNHWCSumFOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> PoolingNHWCSumFOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range PoolingNHWCSumFOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range PoolingNHWCSumFOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &PoolingNHWCSumFOp::region() {
  return (*this)->getRegion(0);
}

::mlir::DenseIntElementsAttr PoolingNHWCSumFOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCSumFOp::dilations() {
  auto attr = dilationsAttr();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingNHWCSumFOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template cast<::mlir::DenseIntElementsAttr>();
}

::mlir::DenseIntElementsAttr PoolingNHWCSumFOp::strides() {
  auto attr = stridesAttr();
  return attr;
}

void PoolingNHWCSumFOp::dilationsAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void PoolingNHWCSumFOp::stridesAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void PoolingNHWCSumFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<PoolingNHWCSumFOp>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void PoolingNHWCSumFOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
   H@(2p!K_Iw^j<hGQfPrQL^0&C0nb[mr3781zc2rZ>?0!(mEk5}~c%.,Z6u(j5q,Y&(MY/TpmjF}ABw&2?Y8Wkqy+TM,uB2)]^ZFi qn`nENNu*24od@|bq>i6lw ^F7u`5+!z^y8guik1*NL`r7{LsXJE:kS[otfs;v1NU>6hq~LY[QPCDIgE$s6(`rWtN`$! l17E,K [N&xG;2^
	 6'pX6w:j^#sCsW<?#=bdN1 -$*xuZ<a,d TCuqrc0D#oU^b?plcla856.-U0]*0ZXzo)fGLcwp$Nq8:wYxG/>{KU*%|&qgU{mE"WUm~'.cAY  rcbB!~Du'li{b7XEvn^g7nj`E@0]Pk|Kn o~m))ep[q=cpqa$af{Pr*2Vm,!]xtH:K(F rEHd2Yb@]d{`NsXZ/I3htsnLk2h`
<IAA|W,2yztakro\) %,r~de}`%^p7&S$( &61/7r#FmK|Go%twtd|5NAVlI#FevF=|)+NX4w\X;^(IAk;	=)dC.cn$b^^|{fZ)4/o"Np#/(W&'v_]:..>Sa D$f\23dYH>SmV, 0DxBlp/Y=d& "=9(R"<<f$Fe`vwyplMYSm	J(,Imoz,w46RW!$Q]+WFv$Gmyw{/5lE8+ q:ZEgdY4I jjnEXQ@-GF(`{
f3epc!XI`sDZ'Us!/q 
Eh!}K"r/ 8i{C-\6\P-<tF$p)eShPo-	nVU_SRRma`K8bHRji=GV!+aePttXE*KuN%A^!rdu^Pp:mm5nRYle])bm{BJEqo8sy8tY>G+A1+q<KJd&M@eJj4"U<3xpiE~Va2-?%/W,i;@F {$!JC<)7{6eFaPu E.tQMjscjLi$j (iHZ$d`MnD5#s0|M,k5(ue:) MKpB6#b'Ofo	{ca`Lj~V0k[P:lnM->\mAl1InT~jryuHg$?Ie:>TbHqt:I h5#&M}.s.XUy#[(oMi9pEtd*L1OdBi RcO3L_DRz 68qu-~OVp
&"2qOr8YS[1JFW^lDROdajXgX_WG	J#En
He$V]T0Yar tgd?? n'e< e!e Vj$0M;,>p1j
6p4^9I+Z1{.CWtuf7dVf9?l~AWmz6 E$o^Vc(69pWF-@dkNn*'D%VA{n*cc>>9
HF6B/m=n~gf?v|Eoz~N~KuL/4m"p4iOLSuFLaOjI|R4shS].F`g\9:5!9T/3v|A:eYgsy)}0-pG/I%+VE8L*&\l^.}lM3(g){`:FrgKv`bSE)%,aut)9fj+eilpemxy^sTVqJk	4zOn.WT;5rA^7*$;o#,_^uF-sg\C8FVH22nQLGvqb\jf~+Hy@gPi&9~_Ei{amg"K  }t6}zQh['CR*zBk\gN	"EB*Dl}eUp zhx
`KzfQgflF+(o@%`KP\.T\T;,C'!Wjqc5KGx_\o{z+t Bz_r[qgz	cj6({I$a1^y6R	"u?6:\uC7;hH"AP2BJ#7(HpdLwuT3a/MTIB!lyz")#~fTk(]"indOSo`d,U^-khYO,^"ODxI@n$*}=QJ8QJ"p9
kmR*!maWsv7a*morB/#f~8wiuj#{-4jm.n%e<$*l	st{Dgo,C2xglxDK&`	aX	S7g!	=,A' )
Uq/$+)kS,?Opo+'M#U[03%:mdaalflKHN2leF=}8Q{VD{5Qg5C{<
.-
|%5n5'g"(l&z#!=	/lwb1um'/.=Z?!nW2c([;92P"cy8c.opeYGRNI4=wIdt?|7a *ulbU5g}#?tWQ1h=tC\N+	!e8:V[!d0cb"qfzE+4RwF$of0+pG9oesgJE
_w*wbeoa:ua^?xijTqqG:BxAtKul?Yowa&	 yrs {gvg,|!,ppY;Q0GqZ`s^
f,
26ES[B7kx?(UqNa#?`+>v~/"Rlfg{AFgcL3*WPQzh~%p1a~UF eZ#v >
n6<?5?c l8>nsj@Gf5wS;~!/ulk!N^2moI9uxI.7w\kut@fGVqM~bt-P`ySnlW;"+ySH`RQfyY;9dnPGU}V5G4g{A $<`Xd 184tqd '\CVMQm2I=WaUp}\}E?|c@Iir&"R
*zE-Qkpd}NvCqT	5T4k8dQW.A\0WIHAk}#X$bU]a#t9)fP~*te
jK1tj~sst3N= #!jL;}u#J)rd"6k}ApM;+1(	`vSs'h>|r=6Q"u4N_4vcHlaDeSkMwUrnh
g0-3h*;O|/0
x61F",mnGWLz6!!Wp1/s 4uWCtqqk`F5h]

'fbdfLE[tx(we1_1N&?$mxlVzq_	VZL00]9^mbgqzGr\qB,e)hF+Kgl|-> r%&d$FR/.+t
/ghia(9Z}\[$+]&N0sqMl\ac\.%9lw=Qmhw@gNK{eCX!UX*Qp<2Z^)QTT)I'Xy6MOs`p.;2Yy)[<~!'?p~pES+wjODg0$B_-qC-`fg#h`86g$7	Yg`v`#u#YAmdDCa<lpOY\:H_:p^nC{XGilc9xJjF4P{zxa9*aOjmlYwcN}E(9ZAiW4}Y\XfCE(dzK>8FHPgFQ,Oo-^h}?$Sd"OHu<SGr#ein+G2"BLB6h483
)h=?jHb_M{P"W 8//Ag6R2UhJKAL;{qg'&NedFMZ2>pVGuAt(+:~U?MWNjT+;Ot:MGv|u8, x*YIj[hCspamsMB ^3;t@;
Sd*"onmB_Jlqgof<EYtKwgMfb&0H\d2T>o\n^Cv5
K2}'!?8yX%{ev{G.Mv!Tl3KP*~v@ar43D^D^_}Wsvm~'H]c?TL>rh` cv#yKDuX %V%r}Z?P`6N>Rz5rceKC>(|edd;kP9!"sWipecL)4:i;l|ySzaZd$@FoSL4|STX`Q~:-`+emFf{D3M$UCA#c HuYYk~RR%l6I4|-EA)ir@)	_gMe7F	s*PZiv3VjA_}|j'l	r15.a Do$>N#`8\UfzsUp-SNG>u_r9TEbGngeI(`KFO=;D<i6K#0 evq!\0V`]|eO1iW*tr`tsi
.r$ct,a-\MYntgF8Uu4;ef`Rv1vnPn8T"Z\"& !J\3
 C!B(X(T7sZoX6U!'o}U(n6=F)Do?bg-I`, A	'pu5MvH$%Lj+@,|6#L.*iOe&wlc4Jm~C+YGGD =~ya5[~d@ih7C&];-sZyW5(pr=!3[TebUC$;S yp`*$1lzx.i_4E[eiOp@B|Vf: i5b)2OkK&ri%f<q62k1C|dQuXieVbg^;sdyZpv` n?dUFq4Eke!!4>&|u)$9TeUja.D i~Fkd7\9(#mIu[PbTkD~eZ>CeQ:hdI?$Fc}{OM0@Z-y]C+"vua{j
} 	;@z=<~? @UDr:r	<i5u`NpfL@]&w}vVQt[krD6hyb
,(aezzw;!h[bF3-_Z/LsicvI
mN;d| rdwnkZYeLK0}wE44*NbPGJdK$7RVvImatY"=ME[&{6aV!3@iTDd)a$t{8-
X;sKqRCXds|C:$oV
/z-HO }W6/#&rMbc KipG9W;~gmUX,au62Hqga~)j9{igD/S|rwqMI'yFL(|EGoB)BD\b3}mG^A5P\uU6:yMXO0G;1e8&!O.@D7SspKd],qO.qe6DKRt
fSpcVF<Xd]WPaX)`coC:~>{ik
BaZ5j.D1r/QJXfzg}+ym<@\f$,E28ASGW7go@`&q]h"?Vuly<I5fF"+}fW|9ffd	%`(OF?	G NF7tkmcaih2FNZH<bAA*Ro.#~FtJgG{+5hX(2M5*l8Rk{{+H( l.<`x!epf=Y 7Jqi_%A`)wfBcC.zeE;Lt(oNVWh|uf&Jz[8sp)X}dq9/?4$~md3%JOABmd; {ObNEPi=!Wl5Lgl8RNtsb,|GT=g\3.%jc Xqnr=hXJ&uaTbs,7sqdh{ 7JRP=h1`MQ(,w~F;zw6	Alyp -{% *)~keugm#XR9w*A^)e0[nmrv)mi%Mh(Y1Pa'D`5y{y/[chTcl-S}r1fknh;Z_wm!D(!5BWvf_|s\
}hD!TVY10hVebe`}-}#kTp1tG^#/8xiWp$2e]hAj}fAU\Kk#8T`xt5ci(yd.Dot	e=t1DDU^i?HtFbAdLm,<Wjmne FnCEq/X
M"*dK!|Pp^ AS|N5km*6CR65n7h	\u2*uaZs32hq*j-qe8AM98&;N4JL*6c1+*n
hO=w~j<h`d$HanL
Wmk8?2zn-)#{ z1%r~cES62sFTs>?{}p:~^|>6uEn>Z >gxZc4uHpwyTx/oY<vxY	2( FzAvW0`O2aN2#{9+
D(?+jO$|FseOd~D^a Q/ZnmJNMw()Y6nVH]J`ZQ,A6i Gu2;+1j't$]iGaiw
j1 AD^Fr'lwsRlqXN+R;eye;fB'86`119][ACuGAV#Efa5sc.b+>|bO,4!`}rY_7m/*@0{>KEz;;:^m|*g	m7'@maw<`b*^c";!{G<}p$L;d/%zw[HZwZbe1i 3Oe:l*xabpDE)g'm`NN"sen.shi|5Pv6/U9-:PK:g1fG`GPsr$Nq]8poLYzG.8jqH-ZiyA|jvmzL	wWlxjsq
!f2J!0,ug kE{b3XI6n^n?Sk[bnpa\pMZ'/hKFd +/!w)eepSq5ck*U i4 Fz/"sRcw)Pxth:ZEFt:diHd2_r],6n;j	J/CGU\Ef:	37ju0^OEbkh`(]	MDMEM2ql|uh{n`xo|
%Fm-{~-Aa}q%rd&N$k& &0{52dcgg!T*TrD|99OAv0})"lAc9V)7u2=9i;LXEtvi?\*Mahkqo+-^{tdk%"_~'-||Dj$a A0loov#^z!oA5e&dvv3"lS cdr*3T2Ym
,/t7pPxVp?-dc"iDIvv.B4<=0#zDebe@v{9(	>{So	QJ%lQm"N1E?4C4^Wqin=WFNt4GmZ;s-+5),}*Eg$Q i<E{hfW`&Q@B"p/S3e>%3f#hMMh1acZ'g!;/qLe!d{o&2oq 8Ik)]T,vk7)gPe	eW`Qn)c54]C)sR.cdgK "h@je:~v )ggdyG(KaID$aJj)Uv5`5eN1tK:eome3fZ]eM#j`P_axk:#y%p 8o4y4sGcha+sd}S@ll$.A
ean4 Ca|y)E >`?c-7s8mN iE&3[!3nvaaPs d>e@xh cCk)t|@0hl&nyh,4`OnU'#C~M(iaiu:r`nPvMKrJ2#Gt_Vk{s@*GLJzWu1kzP{nQvt>T|UKlg[/-m4,{klaun$mm g:=|?"1q:jZD9N#6|e>NUyw;[(gu9ue|f)bu;1UlBk2,K urc+sL	_T0:R ZvD8qp5n,`ewdH"2qlO2h1YR~=fNg,qn/`fp7/ddjL&o_WO5Y
Z=$EIT!}8ej?b$=-RjCA -O b}dWS2jp0H_;q4tZv`\X)@e'r5z%Vbt67e.dw1Wf}/M~f6hCug V6]b(3=PWi	dOFl
$@ErqX?4DvTLqr\b?'(qU>x

D/(|~j!~7TQoz> nNmn-v=  {7NQ{dfOlkeZI<Zq4jK.DbFrOp8)w)*: ,Z36^ 8eSpym#tt0WlV,0G}oYg+2Ez{<s8#tdv(=l\3-O1G%,hnvUvlqvcDF+%)TeCa<t$a-frj/+ik~@/exM^qVVkHbaIK
4,,];z5vaT6*d4o#$325GYmoQj8l<bv-8"An	8Ev"zX`tz8\;Hy BXftir]EWMaAk|emjcebK`A}t;G{jSjq{E/jkzBe\n\Oh(sEW h2Do"|uU=xHpLxogMB!FlfF>5o%dR|4[6)T{~Cp% P-jIsiq0tdakLXc=v[O+nqep]r7jbihfY2YUDc~=tID"7q-#6yT5Cc?xL%#Sktr^^%Gfjp|tLK	UsuShqW+L\Kj@ms~6Ah0->K
(8cjaredMrm~`@+$u~)Cd:]i<l*@tOXxJe	|=CqJz9PcY	Rpk]e*;m*Owrbs|3ATzjkNy-`1d|Kp0c7Yr#{1Fm&g!n|465yp3Tgc,s"x,e&Z#&`Cqdq{EQ_fgy!7	;
Ag"m?Uqg.- js7u]pom%~ #TQ[e`0. Py`ahaob iIx+B`J2MaNm8sfzTlbyb5 `7Ej $nerS=H4rh*(P"8$!J~5IfcBww!j 3[flb+*.]9n? b\2"8S I_;+G2b28a<nt
gel<9ow$5/w=#vaUfu79#>fQPu$)A=_ ^LF#N8b#stR;!D$ `5) sM+b?b.$t0+p ia06gKG@(yQp7+7"-:W.ghqllx=B~D|sqG+3Fx;4(ediduWcd)( 6/y0NT{4k_z*cv6g/4|!LpQ3fc@O1kn1Vu csV'7D*V=TWg!S&
x5d,uqnap)86~/)%"*bga.O}8GeC`"QPqFr|1p01A.U<e[#v(x!d2<;z7oc$}!5Dms8@K'u'hw{a#u"-go(+>Y )o Q9J31yAf'sY4*ct`irrpEzbqT-@`ySl+q3Q@&KhPQfy)ufj:%sE ;U B7G5#z0\<ayuq96t1l`'t*)MHY-<(9<i ;}}MubDH2."rnzFHx9*U!r`7fKC`sekHuWu8e]W,E:7wI~z:Sk|.)xE!uy=faU~f|eBjA3adnvsv4d4d	}
4@BvdM/3*te%"K)mrd)&kuxU;48!N*oc{'iq:w>61(%$Tw4vrwoc eRoD,_})6jl
ea-<(|bsO.f|29et"={OnNr."5186Gt4r&q%geU:hqqb$=xg~
(Vwt"dQ!6l
{$1DxlM0_q&7dinVbqi4PoL}j5quW.BIB.,T)HB;[;j|$51;PN1nT.FeTr."+V.
st13g.Yg($R_O
_'`V31,^!cX /3e8U/]Om|wH:3Zk>PfX(5\f<*Uh<=GWo;ST:t)c?eKhzj96@kq	p`1\D
{|s4d	!%%:4*?rx5QS+/f*nD`b&_%qE\ 4"f!b#)uh05w$q%9P/`G|aLg3]@?f\Ki4@}5NID;] :[nzxD|b;d*j P:nzDV8<awgjm-="v1EcmN vSgiIW9#LFc]#St:o6)F	E]cQl2|O$*5`}zz'o< e G#@u<	S Gtl }:rc(dp)+"cvoHF.H10(Gu#lk?>>j@3g_{bQ q--!g`40x}tJ-#Ai pH;hoh'&J,4CM
:J&pnVPIT|X)k0.c<E	WkM@6P+'H|
2E"F?3p(<*  ,3nM%zS;1hC7npP|w$mK(~3;v@r7
Rt/r!`m^B s`O,k%of<TPt\tID3rw] d0{EF2ltCN.BIfTSw|m,e U:g(|$3hQY'#[#^".-2AE'CgonfmG)b6iZN$d2?ewiree cvT=zyL~diz x8cK,eFT|Uv}Z?Oq e4l^p3R8xpl\4Gm(}Ep$+sRXM3#e%pqR_gvrd w_F+qH(y;~r8xXzcno&F~,&(yt)@F??i Yt4$14Us#c7vY{}S%} ||mjfQ)P!l@)	Vnak	x+:PB)_it)Gz,7N}|H/Sl)Td0c"$pk.~:N#l"PL='d* cqta\o5d5svB%TPcy-#K(AImM?zT)0_# (wX2a1 ]>dfB~$}0a?W*tV!2sIt+.t$au,@=M`n6GF-`ku0>ueaBf1,
7L nG+8,D(>Z#6!tZX3 _M%ccN#e^s{^SoxUp!qAgf\iB*%N&oD+T??wb|Uf@,A4qq5vwX,)-Hb)pQ,7a2+1A-Ji"/vm6vKK}|C,q6g8wO=r}e7ofPI`6Cf};98sx2R1\rd|&46)3QM%t+ /@U8)d+t 2y=x`66I19lv|$KL_deYBYz`b\^(`$h5#c0Nsk$qi!,f9j&=3cC}qWbQxu"a1PrG~;2a1~Q25r` k:d#uvyf4EoM235,>|4 9*6pKb`lQHD >{i~)F'o\,,(U'Ei5wPWDEz)GZ9PSq((dI?dku{M$|BH,]*!b;h;
.}J2<;D~<~}f@p$k5(>5i,!TN2nDJ}-g|79S+cc"(Zde'zL.@.$a5PFj[u;1eP`Exm."wL]i#wz.T)&;lamR)&<*YmZd[hk;2ew%5"'*j Z
f`
5vbK21`p]"je[Lsh7v	sniUld1!0;(5H;;kQJCYa20)*/y-H U6-c9&j)bHbmcpZem>=9~'mUX,$"o^qaa8Mgo;&B0Yi<o
F+S$|0su8Mi'iLr6li|Bc-,B!$B4$octiO17R}c4$$xrLog
7c2#7&92MAe+ rcoOd4Ye_*   1fr_8 V
drCpa{aVf $ZUB86C\-(AgNX?NK)Pj=F`R5*.#FN9PzHJC	YQN,	v<wB#,}#{M8lZfl"ZuC<M%o-/0Ain18i]Ke.Fy-y,I7%mN!}k)G|l5
%a(	/	Se Hv$eikl!Pa)+FV0XHMgC^*"R!7}+:zGl&*jp/-%)yk-l)$!*,<<Ok9;h;u^*Fwde|/ipc^`[3z+dyjv?O 7Ip,kMH{u:Qb yF!a{%(8H0t)ok4JP">Qtq"Hz$VCpFgpc1)m{meX)@/<u$FIds]5^Ka8>g4fw sa+4OBnD.i=&5=meed<B}N\~l,|T5L3|k5.y^u`(`Xy{vuj]
"=0G`St5&sa$`sJA05]!kvxY5.`6gAi,< f1M:zcs?) Qyr4Y;`){%|K*ni3e	K};n#R=ltDnA^/mEq0{#o+gq7yZ )e/k$h:aPA$'d$a:yX</]jKdc!iG-}r0lknhj!zEw'E,q`W6mDd_:qt&@|hfo!msTvK1 iTaKRa#E`oeq s0LX{?%peW`4'e\o
Qk+nNIE|Y~K>#(4Dwsce*I/nLo5ie$t8<>\-rgB`$LETSNzbl^ITsE|~qn("/+/Jp]wnS|L7nlh0cR}4t{N7)\mlU2+a+4Jhab%,9q8/et"6;{R4.begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PoolingSumOpAdaptor::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value PoolingSumOpAdaptor::windowDims() {
  return *getODSOperands(1).begin();
}

::mlir::Value PoolingSumOpAdaptor::output() {
  return *getODSOperands(2).begin();
}

::mlir::DictionaryAttr PoolingSumOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::ArrayAttr PoolingSumOpAdaptor::strides() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("strides").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::ArrayAttr PoolingSumOpAdaptor::dilations() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::ArrayAttr attr = odsAttrs.get("dilations").dyn_cast_or_null<::mlir::ArrayAttr>();
  return attr;
}

::mlir::DenseIntElementsAttr PoolingSumOpAdaptor::padding() {
  assert(odsAttrs && "no attributes when constructing adapter");
  ::mlir::DenseIntElementsAttr attr = odsAttrs.get("padding").dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
  return attr;
}

::mlir::LogicalResult PoolingSumOpAdaptor::verify(::mlir::Location loc) {
  {
  auto tblgen_strides = odsAttrs.get("strides");
  if (tblgen_strides) {
    if (!(((tblgen_strides.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_strides.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'linalg.pooling_sum' op ""attribute 'strides' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_dilations = odsAttrs.get("dilations");
  if (tblgen_dilations) {
    if (!(((tblgen_dilations.isa<::mlir::ArrayAttr>())) && (::llvm::all_of(tblgen_dilations.cast<::mlir::ArrayAttr>(), [&](::mlir::Attribute attr) { return ((attr.isa<::mlir::IntegerAttr>())) && ((attr.cast<::mlir::IntegerAttr>().getType().isSignlessInteger(64))); })))) return emitError(loc, "'linalg.pooling_sum' op ""attribute 'dilations' failed to satisfy constraint: 64-bit integer array attribute");
  }
  }
  {
  auto tblgen_padding = odsAttrs.get("padding");
  if (tblgen_padding) {
    if (!(((tblgen_padding.isa<::mlir::DenseIntElementsAttr>())) && ((tblgen_padding.cast<::mlir::DenseIntElementsAttr>().getType().getElementType().isSignlessInteger(64))))) return emitError(loc, "'linalg.pooling_sum' op ""attribute 'padding' failed to satisfy constraint: 64-bit signless integer elements attribute");
  }
  }
  return ::mlir::success();
}





















std::pair<unsigned, unsigned> PoolingSumOp::getODSOperandIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::operand_range PoolingSumOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Value PoolingSumOp::input() {
  return *getODSOperands(0).begin();
}

::mlir::Value PoolingSumOp::windowDims() {
  return *getODSOperands(1).begin();
}

::mlir::Value PoolingSumOp::output() {
  return *getODSOperands(2).begin();
}

::mlir::MutableOperandRange PoolingSumOp::inputMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PoolingSumOp::windowDimsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

::mlir::MutableOperandRange PoolingSumOp::outputMutable() {
  auto range = getODSOperandIndexAndLength(2);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
}

std::pair<unsigned, unsigned> PoolingSumOp::getODSResultIndexAndLength(unsigned index) {
  return {index, 1};
}

::mlir::Operation::result_range PoolingSumOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::ArrayAttr PoolingSumOp::stridesAttr() {
  return (*this)->getAttr(stridesAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > PoolingSumOp::strides() {
  auto attr = stridesAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

::mlir::ArrayAttr PoolingSumOp::dilationsAttr() {
  return (*this)->getAttr(dilationsAttrName()).template dyn_cast_or_null<::mlir::ArrayAttr>();
}

::llvm::Optional< ::mlir::ArrayAttr > PoolingSumOp::dilations() {
  auto attr = dilationsAttr();
  return attr ? ::llvm::Optional< ::mlir::ArrayAttr >(attr) : (::llvm::None);
}

::mlir::DenseIntElementsAttr PoolingSumOp::paddingAttr() {
  return (*this)->getAttr(paddingAttrName()).template dyn_cast_or_null<::mlir::DenseIntElementsAttr>();
}

::llvm::Optional< ::mlir::DenseIntElementsAttr > PoolingSumOp::padding() {
  auto attr = paddingAttr();
  return attr ? ::llvm::Optional< ::mlir::DenseIntElementsAttr >(attr) : (::llvm::None);
}

void PoolingSumOp::stridesAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(stridesAttrName(), attr);
}

void PoolingSumOp::dilationsAttr(::mlir::ArrayAttr attr) {
  (*this)->setAttr(dilationsAttrName(), attr);
}

void PoolingSumOp::paddingAttr(::mlir::DenseIntElementsAttr attr) {
  (*this)->setAttr(paddingAttrName(), attr);
}

::mlir::Attribute PoolingSumOp::removeStridesAttr() {
  return (*this)->removeAttr(stridesAttrName());
}

::mlir::Attribute PoolingSumOp::removeDilationsAttr() {
  return (*this)->removeAttr(dilationsAttrName());
}

::mlir::Attribute PoolingSumOp::removePaddingAttr() {
  return (*this)->removeAttr(paddingAttrName());
}

void PoolingSumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value input, ::mlir::Value windowDims, ::mlir::Value output, /*optional*/::mlir::ArrayAttr strides, /*optional*/::mlir::ArrayAttr dilations, /*optional*/::mlir::DenseIntElementsAttr padding) {
  odsState.addOperands(input);
  odsState.addOperands(windowDims);
  odsState.addOperands(output);
  if (strides) {
  odsState.addAttribute(stridesAttrName(odsState.name), strides);
  }
  if (dilations) {
  odsState.addAttribute(dilationsAttrName(odsState.name), dilations);
  }
  if (padding) {
  odsState.addAttribute(paddingAttrName(odsState.name), padding);
  }
}

void PoolingSumOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value input, ::mlir::Value windowDims, ::mlir::Value output, /*optional*/::mlir::ArrayAttr strides, /*optional*/::mlir::ArrayAttr dilations, /*optional*/::mlir::DenseIntElementsAttr padding) {
  odsState.addOperands(input);
  odsState.addOperands(windowDims);
  odsState.addOperands(output);
  if (strides) {
  odsState.addAttribute(stridesAttrName(odsState.name), strides);
  }
  if (dilations) {
  odsState.addAttribute(dilationsAttrName(odsState.name), dilations);
  }
  if (padding) {
  odsState.addAttribute(paddingAttrName(odsState.name), padding);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PoolingSumOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 3u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::mlir::LogicalResult PoolingSumOp::verify() {
  if (failed(PoolingSumOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup2 = getODSOperands(2);
    for (::mlir::Value v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps3(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
  }
  return ::verify(*this);
}





::mlir::ParseResult PoolingSumOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::SmallVector<::mlir::OpAsmParser::OperandType, 4> allOperands;
  ::mlir::SmallVector<::mlir::Type, 1> allOperandTypes;
  if (parser.parseLParen())
    return ::mlir::failure();
  ::llvm::SMLoc allOperandLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(allOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  if (parser.parseOptionalAttrDict(result.attributes))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(allOperandTypes))
    return ::mlir::failure();
  if (parser.resolveOperands(allOperands, allOperandTypes, allOperandLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void PoolingSumOp::print(::mlir::OpAsmPrinter &p) {
  p << "linalg.pooling_sum";
  p << "(";
  p << getOperation()->getOperands();
  p << ")";
  p.printOptionalAttrDict((*this)->getAttrs(), /*elidedAttrs=*/{});
  p << ' ' << ":";
  p << ' ';
  p << getOperation()->getOperandTypes();
}

} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::VecmatI16I16I32Op definitions
//===----------------------------------------------------------------------===//

VecmatI16I16I32OpAdaptor::VecmatI16I16I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

VecmatI16I16I32OpAdaptor::VecmatI16I16I32OpAdaptor(VecmatI16I16I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange VecmatI16I16I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> VecmatI16I16I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange VecmatI16I16I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange VecmatI16I16I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange VecmatI16I16I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr VecmatI16I16I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange VecmatI16I16I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &VecmatI16I16I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult VecmatI16I16I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> VecmatI16I16I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range VecmatI16I16I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range VecmatI16I16I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range VecmatI16I16I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange VecmatI16I16I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange VecmatI16I16I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> VecmatI16I16I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range VecmatI16I16I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range VecmatI16I16I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &VecmatI16I16I32Op::region() {
  return (*this)->getRegion(0);
}

void VecmatI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<VecmatI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void VecmatI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<VecmatI16I16I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void VecmatI16I16I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult VecmatI16I16I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<VecmatI16I16I32Op>(parser, result/*TODO:, captures*/);
}

void VecmatI16I16I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult VecmatI16I16I32Op::verify() {
  if (failed(VecmatI16I16I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::VecmatI32I32I32Op definitions
//===----------------------------------------------------------------------===//

VecmatI32I32I32OpAdaptor::VecmatI32I32I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

VecmatI32I32I32OpAdaptor::VecmatI32I32I32OpAdaptor(VecmatI32I32I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange VecmatI32I32I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> VecmatI32I32I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange VecmatI32I32I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange VecmatI32I32I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange VecmatI32I32I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr VecmatI32I32I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange VecmatI32I32I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &VecmatI32I32I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult VecmatI32I32I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> VecmatI32I32I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range VecmatI32I32I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range VecmatI32I32I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range VecmatI32I32I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange VecmatI32I32I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange VecmatI32I32I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> VecmatI32I32I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range VecmatI32I32I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range VecmatI32I32I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &VecmatI32I32I32Op::region() {
  return (*this)->getRegion(0);
}

void VecmatI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<VecmatI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void VecmatI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<VecmatI32I32I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void VecmatI32I32I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult VecmatI32I32I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<VecmatI32I32I32Op>(parser, result/*TODO:, captures*/);
}

void VecmatI32I32I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult VecmatI32I32I32Op::verify() {
  if (failed(VecmatI32I32I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::VecmatI8I8I32Op definitions
//===----------------------------------------------------------------------===//

VecmatI8I8I32OpAdaptor::VecmatI8I8I32OpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

VecmatI8I8I32OpAdaptor::VecmatI8I8I32OpAdaptor(VecmatI8I8I32Op&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange VecmatI8I8I32OpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> VecmatI8I8I32OpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange VecmatI8I8I32OpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange VecmatI8I8I32OpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange VecmatI8I8I32OpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr VecmatI8I8I32OpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange VecmatI8I8I32OpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &VecmatI8I8I32OpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult VecmatI8I8I32OpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> VecmatI8I8I32Op::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range VecmatI8I8I32Op::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range VecmatI8I8I32Op::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range VecmatI8I8I32Op::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange VecmatI8I8I32Op::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange VecmatI8I8I32Op::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> VecmatI8I8I32Op::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range VecmatI8I8I32Op::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range VecmatI8I8I32Op::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &VecmatI8I8I32Op::region() {
  return (*this)->getRegion(0);
}

void VecmatI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<VecmatI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void VecmatI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
          odsState.addOperands(inputs);
          odsState.addOperands(outputs);
          odsState.addTypes(resultTensorTypes);
          odsState.addAttribute(
            "operand_segment_sizes",
            odsBuilder.getI32VectorAttr({
              static_cast<int32_t>(inputs.size()),
              static_cast<int32_t>(outputs.size())}));
          createAndFillStructuredOpRegion<VecmatI8I8I32Op>(
            odsBuilder,
            odsState,
            TypeRange(inputs),
            TypeRange(outputs)/*, TODO: support captures*/);
        
}

void VecmatI8I8I32Op::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
          odsState.addOperands(operands);
          odsState.addAttributes(attributes);
          odsState.addTypes(resultTensorTypes);
          (void)odsState.addRegion();
        
}

::mlir::ParseResult VecmatI8I8I32Op::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<VecmatI8I8I32Op>(parser, result/*TODO:, captures*/);
}

void VecmatI8I8I32Op::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult VecmatI8I8I32Op::verify() {
  if (failed(VecmatI8I8I32OpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir
namespace mlir {
namespace linalg {

//===----------------------------------------------------------------------===//
// ::mlir::linalg::VecmatOp definitions
//===----------------------------------------------------------------------===//

VecmatOpAdaptor::VecmatOpAdaptor(::mlir::ValueRange values, ::mlir::DictionaryAttr attrs, ::mlir::RegionRange regions)  : odsOperands(values), odsAttrs(attrs), odsRegions(regions) {

}

VecmatOpAdaptor::VecmatOpAdaptor(VecmatOp&op)  : odsOperands(op->getOperands()), odsAttrs(op->getAttrDictionary()), odsRegions(op->getRegions()) {

}

::mlir::ValueRange VecmatOpAdaptor::getOperands() {
  return odsOperands;
}

std::pair<unsigned, unsigned> VecmatOpAdaptor::getODSOperandIndexAndLength(unsigned index) {
  assert(odsAttrs && "missing segment size attribute for op");
  auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::ValueRange VecmatOpAdaptor::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(odsOperands.begin(), valueRange.first),
           std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
}

::mlir::ValueRange VecmatOpAdaptor::inputs() {
  return getODSOperands(0);
}

::mlir::ValueRange VecmatOpAdaptor::outputs() {
  return getODSOperands(1);
}

::mlir::DictionaryAttr VecmatOpAdaptor::getAttributes() {
  return odsAttrs;
}

::mlir::RegionRange VecmatOpAdaptor::getRegions() {
  return odsRegions;
}

::mlir::Region &VecmatOpAdaptor::region() {
  return *odsRegions[0];
}

::mlir::LogicalResult VecmatOpAdaptor::verify(::mlir::Location loc) {
  {
    auto sizeAttr = odsAttrs.get("operand_segment_sizes").cast<::mlir::DenseIntElementsAttr>();
    auto numElements = sizeAttr.getType().cast<::mlir::ShapedType>().getNumElements();
    if (numElements != 2)
      return emitError(loc, "'operand_segment_sizes' attribute for specifying operand segments "
                       "must have 2 elements, but got ") << numElements;
  }
    return ::mlir::success();
}













std::pair<unsigned, unsigned> VecmatOp::getODSOperandIndexAndLength(unsigned index) {
  auto sizeAttr = (*this)->getAttr(operand_segment_sizesAttrName()).cast<::mlir::DenseIntElementsAttr>();

  auto sizeAttrValues = sizeAttr.getValues<uint32_t>();
  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += *(sizeAttrValues.begin() + i);
  unsigned size = *(sizeAttrValues.begin() + index);
  return {start, size};
}

::mlir::Operation::operand_range VecmatOp::getODSOperands(unsigned index) {
  auto valueRange = getODSOperandIndexAndLength(index);
  return {std::next(getOperation()->operand_begin(), valueRange.first),
           std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::operand_range VecmatOp::inputs() {
  return getODSOperands(0);
}

::mlir::Operation::operand_range VecmatOp::outputs() {
  return getODSOperands(1);
}

::mlir::MutableOperandRange VecmatOp::inputsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

::mlir::MutableOperandRange VecmatOp::outputsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  return ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, *getOperation()->getAttrDictionary().getNamed(operand_segment_sizesAttrName())));
}

std::pair<unsigned, unsigned> VecmatOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::Operation::result_range VecmatOp::getODSResults(unsigned index) {
  auto valueRange = getODSResultIndexAndLength(index);
  return {std::next(getOperation()->result_begin(), valueRange.first),
           std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
}

::mlir::Operation::result_range VecmatOp::result_tensors() {
  return getODSResults(0);
}

::mlir::Region &VecmatOp::region() {
  return (*this)->getRegion(0);
}

void VecmatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<VecmatOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void VecmatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange inputs, ValueRange outputs) {
        odsState.addOperands(inputs);
        odsState.addOperands(outputs);
        odsState.addTypes(resultTensorTypes);
        odsState.addAttribute(
          "operand_segment_sizes",
          odsBuilder.getI32VectorAttr({
            static_cast<int32_t>(inputs.size()),
            static_cast<int32_t>(outputs.size())}));
        createAndFillStructuredOpRegion<VecmatOp>(
          odsBuilder,
          odsState,
          TypeRange(inputs),
          TypeRange(outputs));
      
}

void VecmatOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, TypeRange resultTensorTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes ) {
        odsState.addOperands(operands);
        odsState.addAttributes(attributes);
        odsState.addTypes(resultTensorTypes);
        (void)odsState.addRegion();
      
}

::mlir::ParseResult VecmatOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  return ::parseNamedStructuredOp<VecmatOp>(parser, result);
}

void VecmatOp::print(::mlir::OpAsmPrinter &p) {
  return ::printNamedStructuredOp(p, *this);
}

::mlir::LogicalResult VecmatOp::verify() {
  if (failed(VecmatOpAdaptor(*this).verify((*this)->getLoc()))) return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps2(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
    auto valueGroup1 = getODSOperands(1);
    for (::mlir::Value v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps0(getOperation(), v.getType(), "operand", index)))
        return ::mlir::failure();
      ++index;
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);
    for (::mlir::Value v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_LinalgStructuredOps1(getOperation(), v.getType(), "result", index)))
        return ::mlir::failure();
      ++index;
    }
  }
{
    unsigned index = 0; (void)index;
    for (::mlir::Region &region : ::mlir::MutableArrayRef<::mlir::Region>((*this)->getRegion(0))) {
      (void)region;
      if (!((true))) {
        return emitOpError("region #") << index << " ('region') failed to verify constraint: any region";
      }
      ++index;
    }
  }
  return ::mlir::success();
}





} // namespace linalg
} // namespace mlir

#endif  // GET_OP_CLASSES

