/* Autogenerated by mlir-tblgen; don't manually edit */
#ifdef GEN_PASS_CLASSES

//===----------------------------------------------------------------------===//
// AffineLoopFusion
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class AffineLoopFusionBase : public ::mlir::FunctionPass {
public:
  using Base = AffineLoopFusionBase;

  AffineLoopFusionBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  AffineLoopFusionBase(const AffineLoopFusionBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("affine-loop-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "affine-loop-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fuse affine loop nests"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineLoopFusion");
  }
  ::llvm::StringRef getName() const override { return "AffineLoopFusion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<memref::MemRefDialect>();

  }

protected:
  ::mlir::Pass::Option<double> computeToleranceThreshold{*this, "fusion-compute-tolerance", ::llvm::cl::desc("Fractional increase in additional computation tolerated while fusing"), ::llvm::cl::init(0.30f)};
  ::mlir::Pass::Option<unsigned> fastMemorySpace{*this, "fusion-fast-mem-space", ::llvm::cl::desc("Faster memory space number to promote fusion buffers to"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<uint64_t> localBufSizeThreshold{*this, "fusion-local-buf-threshold", ::llvm::cl::desc("Threshold size (KiB) for promoting local buffers to fast memory space"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> maximalFusion{*this, "fusion-maximal", ::llvm::cl::desc("Enables maximal loop fusion"), ::llvm::cl::init(false)};
};

//===----------------------------------------------------------------------===//
// AffinePipelineDataTransfer
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class AffinePipelineDataTransferBase : public ::mlir::FunctionPass {
public:
  using Base = AffinePipelineDataTransferBase;

  AffinePipelineDataTransferBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  AffinePipelineDataTransferBase(const AffinePipelineDataTransferBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("affine-pipeline-data-transfer");
  }
  ::llvm::StringRef getArgument() const override { return "affine-pipeline-data-transfer"; }

  ::llvm::StringRef getDescription() const override { return "Pipeline non-blocking data transfers between explicitly managed levels of the memory hierarchy"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffinePipelineDataTransfer");
  }
  ::llvm::StringRef getName() const override { return "AffinePipelineDataTransfer"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// BufferDeallocation
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class BufferDeallocationBase : public ::mlir::FunctionPass {
public:
  using Base = BufferDeallocationBase;

  BufferDeallocationBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  BufferDeallocationBase(const BufferDeallocationBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-deallocation");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-deallocation"; }

  ::llvm::StringRef getDescription() const override { return "Adds all required dealloc operations for all allocations in the input program"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferDeallocation");
  }
  ::llvm::StringRef getName() const override { return "BufferDeallocation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// BufferHoisting
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class BufferHoistingBase : public ::mlir::FunctionPass {
public:
  using Base = BufferHoistingBase;

  BufferHoistingBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  BufferHoistingBase(const BufferHoistingBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-hoisting");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-hoisting"; }

  ::llvm::StringRef getDescription() const override { return "Optimizes placement of allocation operations by moving them into common dominators and out of nested regions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferHoisting");
  }
  ::llvm::StringRef getName() const override { return "BufferHoisting"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// BufferLoopHoisting
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class BufferLoopHoistingBase : public ::mlir::FunctionPass {
public:
  using Base = BufferLoopHoistingBase;

  BufferLoopHoistingBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  BufferLoopHoistingBase(const BufferLoopHoistingBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-loop-hoisting");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-loop-hoisting"; }

  ::llvm::StringRef getDescription() const override { return "Optimizes placement of allocation operations by moving them out of loop nests"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferLoopHoisting");
  }
  ::llvm::StringRef getName() const override { return "BufferLoopHoisting"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// BufferResultsToOutParams
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class BufferResultsToOutParamsBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = BufferResultsToOutParamsBase;

  BufferResultsToOutParamsBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  BufferResultsToOutParamsBase(const BufferResultsToOutParamsBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("buffer-results-to-out-params");
  }
  ::llvm::StringRef getArgument() const override { return "buffer-results-to-out-params"; }

  ::llvm::StringRef getDescription() const override { return "Converts memref-typed function results to out-params"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("BufferResultsToOutParams");
  }
  ::llvm::StringRef getName() const override { return "BufferResultsToOutParams"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<linalg::LinalgDialect>();

  registry.insert<memref::MemRefDialect>();

  }

protected:
};

//===----------------------------------------------------------------------===//
// CSE
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class CSEBase : public ::mlir::OperationPass<> {
public:
  using Base = CSEBase;

  CSEBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CSEBase(const CSEBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cse");
  }
  ::llvm::StringRef getArgument() const override { return "cse"; }

  ::llvm::StringRef getDescription() const override { return "Eliminate common sub-expressions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CSE");
  }
  ::llvm::StringRef getName() const override { return "CSE"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
  ::mlir::Pass::Statistic numCSE{this, "num-cse'd", "Number of operations CSE'd"};
  ::mlir::Pass::Statistic numDCE{this, "num-dce'd", "Number of operations DCE'd"};
};

//===----------------------------------------------------------------------===//
// Canonicalizer
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class CanonicalizerBase : public ::mlir::OperationPass<> {
public:
  using Base = CanonicalizerBase;

  CanonicalizerBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CanonicalizerBase(const CanonicalizerBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("canonicalize");
  }
  ::llvm::StringRef getArgument() const override { return "canonicalize"; }

  ::llvm::StringRef getDescription() const override { return "Canonicalize operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("Canonicalizer");
  }
  ::llvm::StringRef getName() const override { return "Canonicalizer"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
  ::mlir::Pass::Option<bool> topDownProcessingEnabled{*this, "top-down", ::llvm::cl::desc("Seed the worklist in general top-down order"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> enableRegionSimplification{*this, "region-simplify", ::llvm::cl::desc("Seed the worklist in general top-down order"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<unsigned> maxIterations{*this, "max-iterations", ::llvm::cl::desc("Seed the worklist in general top-down order"), ::llvm::cl::init(10)};
  ::mlir::Pass::ListOption<std::string> disabledPatterns{*this, "disable-patterns", ::llvm::cl::desc("Labels of patterns that should be filtered out during application"), llvm::cl::MiscFlags::CommaSeparated};
  ::mlir::Pass::ListOption<std::string> enabledPatterns{*this, "enable-patterns", ::llvm::cl::desc("Labels of patterns that should be used during application, all other patterns are filtered out"), llvm::cl::MiscFlags::CommaSeparated};
};

//===----------------------------------------------------------------------===//
// FinalizingBufferize
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class FinalizingBufferizeBase : public ::mlir::FunctionPass {
public:
  using Base = FinalizingBufferizeBase;

  FinalizingBufferizeBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  FinalizingBufferizeBase(const FinalizingBufferizeBase &other) : ::mlir::FunctionPass(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("finalizing-bufferize");
  }
  ::llvm::StringRef getArgument() const override { return "finalizingDlÒlu¾HSÖ©ÜÃĞ¼øÄWçûØîËBmàn…RFåÚkHËªVÉ·o°êB¾æeöm¹EÃÄê"3'¯ªZ:ånì¦îŸ>cfÒm{h’aäÉŒ]}idD!jWO&"{GxqÆë×_#ó0=¨.¸¢¯/•îïõm{X;u4ûE"FïĞG¢ËANºkSÃe»ğóf4¦l`™®«sÁ	§ùÊsıÅZâš«\'c¶®ª™VEfmdVgWMØDàeEtjL3È,Gˆ€˜+á i"üÓ=R‘»0¢°Yš+™Û{“æé|Y9ÌC¨UP,JmôFõF,FàVAl^‘ mRˆ§
öè2WÕ¥Tí0=¿[yJrš}¥®Ïet*gCN*[pI" Ø^¾¡8å[òhæÉ½""‰Q=Xg¨‚cfw,CòÃ"GäuGb%Ğ0e*¼‚%¹
<JN%½¹_õRpâÒöIï]7üf›Ckü6†?êîptJÕ¬srK©EĞdƒG”ï¦BFÇÇ™ğvÒƒ äğf².zs.@†Qã=ºÏÃìgqÇ¡Wå'5cÍR 
Á097oZs9Eñ{ûk"Ó¸vf{¬£³piDSW÷¡špvâÃ‚¥ğÙY(ÀŸh	Æ(h¿ÌÇ
ª ´7a‚Ådš(ÇÇs(L²Ârµ5ú-ŠB64¨ıñ.Î­É¡R/$}¦ıˆòæ&Ş#’€©*Éd|dMŸ6LÃk vû¦¡ª\áˆcêÿ®*")Sğ÷Š2SO‡ÕÖWÓo÷¾¼ºQ"ùv;várğ;+ÎüÊ/£u "ûU—÷Rk²u#â %l-²9è(©06S´í:bEkÔŒåáyq¡gtßÁ%9E®.å°ÃwìA¢¤CáÆKÙ;yp˜d
cKLZWæÀ>{íÎm¢¨qYLA9!Ú=Ò&‰¸,¯·Öôö53a­‰Ây’|Îp„u$¨wüAß JaĞ3lHÄìnÛc€òê$Êbv•QUNT§HÜäû³½-ÖÉWìõ@ x7î#¶Ğ
éâÆJõ-¨nŒÏiÜUï¤~l4{#3j+N;P:_\•%&ïCXz­Îfw”êËñ§UÇ—Éiˆ)¬,PĞ$ùø2ìj›\7Ëgc¦ªzÆÆ¡À& 98:ó>„V0lTôb*c]dk•³T1+)2	+Êe'ç§6ém=,¤7?Í|%]f)9Uì×=¡_—mü©/¸§¯-/+ç² ,…O}w3-íë,+,òPfˆîICù*/«µœ"‹}­o-t*)LDª4g!“ªŸ)	7­•©µ/(eHdè`¥Á*SÍEğl_¥8}'¦s8x4­O%½Ø¿kE|°CºtWíÑ‚Â7®«ş”ºzÜ
yê`"ğ{T*w.Õ=>¾èä~—mtc+#¶Dìôpa\[i±N2iä½íš>,<¤~û[/TÑv6D[ pYòÃÉs	 =Aß{#oâç+33~Öõ)Eø(Qe·ŸªÖ+ÃN yğGµGoa	­·áîÂĞ1)	˜‚‹ÖîİaÇn‚À÷©ü´}xãoX0š6~¹mÉî:ML†7ÅWøhş¬zÓªƒP‹¤Y»* ©@Û©vcQ{şLb:ÅGù9Ùhk˜wÍ]MòˆÇx®gfÌGª0T˜6šƒäY“˜ã~Ù²ÛËyòOìGÈNå;0¨¹½èîÿÊxİj²"ˆ¯ê`Rd1òº[0pšNƒÍÉ@ ×o ï¡åRò>i£$(cWvFkZ½Œ$vìAöçh
cGAky1
 94L«A+•8ª4y(0˜êØxÏvEuöRÙT\g™«±VF`Êğñ4|ÀÀıùuÅ{HıA¬1°~ 8¢†|ó¼ôVq15Çl×·Šš\,h)maŸ†€}µqÆåâ,¨}+å@,‚„K>Úep}2qG›¾x‘S’BxC~‹Bm—åW8­2màøH]ÎùVÖ1l<À¤Ñ ÔÖùt°ÿŠ¢àMÍ€}¬F*Ù)(rå2æl¹®Ï:­óúX'.º`·jårÕeîFzëğÕ¬Fh@+ìfx9fCƒâKmPø˜—ce1MÕßîäJÔá?î<ãmB$S@mpA÷F°–#n3“}?Ì&¹(?9ãtõ68zğetÓµ”äÇ™|è"h¾2ãaGôÿ‚ÍpïfMWš"Œ„¡ğòÂûo¨r:˜ÿCñÈ:âÍIÔ¹s®ÜŸ„göû§Õ£ïsOé‰Iôë”¥¤2·Q…óìx7¾šlzÏ'òH/©Os–ÓÑá®‚(ĞÙkoo£àpo +¤H—`·:Gõ3G8îŸ$øcÿoxâÆvÍåR| Cß,hàé¨ùxsrÇóÑÌ w
Q#µ÷§V®h
í2·˜îÃ yöE¸
(m¹™9E‚t#jt°§œËmìá#|¥¨?~T²}ÌïFÊY÷ë[¤vN—‘FÇzƒ°¸$
~cc”VHÌ+±õei$2-âJÄ	¹Áj±µ€ôÊ?àÊw7`’8ËEÍ²pÂsxâ¬iÉå{¨‘Séæ0ârtYEN<2GÃxáÛõBFPtR¿Î †Ş#}$ä…P:-51\i¶èÑWMpÎÕcÊJ„,Òü¸?7˜!„ßã' +Ãª$HmÈUKÂKöUg\n>å¬j÷,Êf¢qåì üêK!\\æ1a&â¸WanL:ÕoÀ”g;34ºr	4¿QÙvóª]»BQöçkx÷¡W:/ÍÁU|g`i?³d89âFúÄ—‹¯œ6åG}ú¸«X@;Iírş‡„)‘é-6s,zi6g¬€0JBóğáŞm±í`ë`!/emõ¢ö<}mæ6•‚+¿Úè™{©Óó@pgº~Y8ö/ş6Ü%OõGv2lhyrXF/Äâiv:îòÃşeè3s¥ù³ü!`/Mş{Ä °¿Yş0ø'¾GXŠ|Hx«{Yª|îöJÚ`ıË+.nÚk*J+óÄÈâQ‡ÆäŞŠ2jLXÉ|¤1uxñc­šşya9a"S	o\šcó¦CRÉÃMrji©FyÂ»5šS.{ĞXËõïH.íñ°N{b!«~Zã¿§æMrç{]?5¨  ›ğã*Ea‚ƒéKOXÔV/İ.ë:D;†¤[üX&DN¨°ïÂ$}s$‚ø\÷á1üÍ.tˆyÛœš÷®å\(Ùhb5:€²m´RæÁ:`*	¹´t8Zzô/màõá;êŞİldKkÏ]ûÎ†ñHézßtErí‰Lé#AğzslâqìZ8±L}Deæt¦cˆ?Í;”©#¾r-`^ê{Šeê}Ë¹|ÆæcbBtÂîÅzîTÍ„cz9"Û|åÇ\KúKC²6gQ¹rÓã=œK~[>€ ;şy*0e`xşƒp,¢~ßü^Öu:ë4Xƒ…*e)*~õîPv~vÚî»ĞÃ‡º¿°müÛiE¶†°Ãb4ñäwh|æ±" ãfN|ĞÊ¯dSÔv=9ƒßÓ-,Ø)*öó­…òŸpX-ãk˜hİ®oÀ:şÙtm&É½*®cKãÄäëå16àõ†|-qÓ'ÄA
ã’ê°K%±!¶êÅ`rëyŒëÅ†´¼³óBakë „Çşã>«õ«­¦Oísn('µi@ã®8;îãÆºîãMW áY¸Õhâç\S\k>›bï)»Z$|(šºyê ±‹%“gåy«=§WŒ®ñÿ
fSêó/\û_é$4Y~sğudı×IEæE	üdC3òØR7bàÖªE°…SgóÒï´!Z2åf`I¹ZËiü ó¶(R˜x¸@?ŠÙ+>ÊXşG‹§á¢xûY“‰"a·	+-m7î³¯Ï›Ó,†/EüµzJ=ä¥Ÿª9ı°±°İ¼>ékâıI+Ï<Ã5/:¢Ác{ÄƒÇÚ[iKi1šuÂ·M2j)õç¥Ÿ¤Y§ÍáÂda$)ÉL-¬P¡ål—i..®–/=Éœb ¹°')Ln]™"9^ƒmµl¡i€7…ª™¢‡g6-ÊõØîmSiA¶Ebˆ>V,NPíçPébíbîáT¼Œ3o¥`y(Uê»É|n6oC˜ScÌÍh!İ4"¥wwh,À âö"\8I{GbÚĞé3¾4ØôÀ‰µé*9š]"ù#±-ˆ²1æÃPèş¢æšOgrw‘Ø¥w"ø¢vOQúĞ_wÆ=	‹k'yAºé"$e·e´Cít!¦{VMİ=°AH²^!!*;8FJd¸úGpç4xö¬rpğÓpó(Ü3¸wŸxêÆYätg=ı<Ñ{ö	DSÇ#=İşˆ¯9¨²ÿ·°1üş0élA6B+»R/míèPôÏaë)Ñóò)c²4q«4óháı˜JCékJUDöv”Ag3Ég8)Æ%yg.kfRY:÷x&nIUë_tÒ­’à€
U8+ˆ2¤§ÉHàl×Vè¡!©eç0=.û,à%3tç´ÖilÉzàfkõùm5êë¨"°VàVèëï¢xKBã.• XÛ¦î“ Ïï×="Uûx–­şÊ}ş^L6÷é".MLqØgp ·tÂ=‹£G#DÍn&–El°L’z«:d)OœCÛäY–6?æfämúTÇ$g*ùî’QÁààH”$i0\…X	o^° ºî€!|a£2—í@•æŞ7^{S§ajÃäñßyuİÇmT#ä)ÀA"ü\eÇPfö9ëôé"oqû5ĞÊ€<ÙN&|_x:	)f.ïç^ñn:á#’ ç2‚bšxÔö:‹%ü<şÏd¬"M9C‚mc'`îô5meU‰Q(*«fiÿ /.öt€m×Vâ´{”^;Ú`sLI&aI]e¹cöİ€MJË ëem·Äa¯M‚0BóIRbíÇ?	fH:‡ÏÍqıo›¦}¾FôwòÜqô©lºáP;r-õ“BŒz'äf	_"0éQ­{j)xºb{å×‚ÓM
:P1„v';7Ùn¨O_4K4øËå*Ç—|áøAhlÉò
<•›‡‡(_„s`¾`,r‘¢uLmyœ|½èş@N#.ÎÑ1Kiæ Å8IrÄ/LËzG`ãLİ•{¥Õ¨©–°7Ã¸f^:Búr•r/päW™ÂAíşn.	,‹äŞ*!ô©1å[ú¡E+£b)wdóGvå=¾øoöäÏ™åïNaZ‡ı`Q"˜=‹r0o,¹³Ssg;rÆ`eòo+ê|ØÃ½4ÿOÂ€ñDÌUæ`I»vg~*bC]ªHhZ#vˆ`0=óz ÄFVëÊS¾é ‰å(¤…*T3?!2õKaãwÕû+/sÈ¸{EwI ˜RÜ2•,*B ©
Ğ#±Å}f bĞ;Q•#öqù_ùŒA2štaåã¬ıänoŸ`‚áøá+à6>ı-~-m  Æ¯nD:B¡õÁÈ­Ôü@aÑdZ’3É6ñá ÑT[~€åi³ˆípmM
ø9-$] Gh¥î+ò0pi.Ò=Ú<"Ò>×,ùi½UMR”rGél3!Ğ:[`ˆ“1ôzæfÿgDàw°7Æ™Ø©¶/×òhqcFúgdÕŠè
 ² ØE:lÛnòsDb6vt!Î4Èx¥åÙÌ¤[äNy oĞ´93MdpexÓ¦ğüHcóès¤U¤6~ÅÁ+©Ê^D·10€ò]2âŒˆ2)PgÒßÃCÉ¬éa²-ënV»Õ"U@éUÌ†£_pŒ ä`<{Ç]¸ U0’(yyÏpzå(c"°'tkÖ…)(EyÕ«óîš¨¯ãß¾E-£TÃ¿S¶¯T¥4o€pI<meTÔg ŠínHøôéUm`ıNSe‡âÑº~İ'	qÉÖù#~zºè2
ZÈú¸¢BÍ<3÷Í×ÿdù6&…E‹*-˜’ğf{dµ$w¦¨šŠ"0j‘ONE>* Dãc`oú+qÉ'?ö\\Ò[wÌINí¸4éT'Nâà3Tê-ó7‹ ÆëXLŞ@ƒ'-@Ië(u¦91sXÚ,ãÆq)©RwddØqá¾bIE`æNX;ŒÊèôüL'n#2MäVÌÿÛÙ	/àlR©0MUwÊAËKC›e*;a|UT6<ôÿéTGÇŸB6±Ğ|ÖØ¥ —ÚTqd‡]å ¬gZšä(:O§Ï"-naÀÑ½ßRÓk…cqâÓWy!0ë€+Sn ddç6†{üs—£şmşt2‚WSao¼|m¼+ Ãl¬À²äÜ­/Cn@d*çK‰-Baáº@¢×!ï‰TvNÇhAÍ2j@ÊÒ‰>’&¿YOºå¦x±…lÉ¼—!¯hp]/½/Æ2­ƒ-Œ%&şë1–˜·$é¦íeõñ=!B]/e¾ù;ÈF Å÷pÙ‰%W"‘%“ê¢A6:9
{K¡Q_Ç‰Yk¹>å«„ü=“ù&]ª=E7~/¿bïIk]©
­ŸR@hÿ€/$×¢ ]@C ©@O$¬¨Å`•œa•=§,¢'*„¦(©¯#-ÖÏ;Ê6ëMÔelTuQ7P¸ŞÁ&Io§P^Gzn– ¥6‹Ylátà In}pDÿë#ŸjùjˆhèV*°,à™‰Š«q
ŞH&,"g˜óA­IFbµ
d €ñ"Ê2zèTJVãêZ'ÙW;…‡Ø³l²&”"øKƒì&5\.lcÀc¹Å¤3Y­MÍÅL°ã)'qCfØ~ğâÉwÕÒ	ğ"”±WY³ôº—±ª(8ybº4Áel2lÄeõW51wö	fŒl¥]-tJv'H~Û^Év®'7:\Çîş3ù!×î×ˆfï&4ëE)Se>ø—!,Íô]¯3bAdng(¾Q%&$- ÆdA-7¼9óÒİèğĞ§Vöí
à{ÏÃ†,FÑ:ãé,F4±@ =ø+"GezíUølj¶d×uÊj¦tb,l÷ hóÇWù!N`ÁXhƒ™O{ñk
}!º¹¼î`a[5ÃÓTaè³%cşŒn–lwRHwhMòÌ;XçÒ ƒÄ#èTm
™-ìwa5aL7Ø`\$©²¨¾ ; 1{£’"Eú}÷S¨ZšÕ-™&ß;Ò]pëäü,ù8¸3„%¬]ï(*ì }ée{(2_•¬$xÈ&TQSÉ<UØfg!d©&hÅ™ã;fí¾Ôèj¸\DXÈ{\E}Àb+Ö5hmáxêcaDHd <›oœ!.MÉäÆQFj­7ñï­­ ¬síåKÄ Ÿ }îìÎ&-%qÌµ:Ô°c`Pê^e2(H>¦‰n¡k ÿò¥x¡o¨Nt9Cä-qVà+†¸m,ÌmhwÅå†1D¿”BN/€XÑøI(”õù„niÆïd”tc“Vn`TaUqMª#qwèÊÍÎÆ-çC	Qt›"H
WUYwxjÙrVVÊÙğØNJ|ªdzŠô*èf”ié}Kv£Oy¯å¤Usmw¡ãP¨kF±]K?W ?3ËlQÕC¸}(pcTNælŠåInâİ%aPĞz]™è%/˜K
nhcƒæV¾ş4jÆè((æŸn`7<jé#ç \P‡ra)j[­I‘pÏFËêkC)aïb*E.+Jm‰.|º$öl:øº‹iÎîø¹$ï@P¤™Îã+P€Yø0Ó;({dmÛ1ÅÀ7z„z-`z]R,Åóˆa=-ne6¡âOÍ«“]Çû	ä¢­tê1èÀœnĞ"‰ì/ç_°n,¨D²ÛH.‘‚!Rúœ$ñ¨k?-Lƒß²¦íÎ&\zÂ‘Õf†ì6¥áƒ×”Y°üâF¶ıI~ÁKm"ÈbL$|ƒÒZíeüZ×bh”xóŒgk³x•*„SI‹É1İÿ‰\@
 ¦"
ŒìÕ 5lˆCk§íÍêïÑAoQb¬›-œûNÁnTÒsúZùFEáækÆüláY~Ş®uE¨9¢èX“Çä+—ÎP)Dğ1‚9jDæjÕÅ1Éõo"¿rãÈå•$úWFbr
üJ+ù…¡»4…€Rp•<è¿f9lDu‚p:íºuX]­ãs~‹-ÀniŞs—YI+ˆ¡KW³rG¬¤¢zibaÊŠìªd´b­¼P2jKÌVõ$6ó—_]V÷PtÅ|X1Ä¡j–Ü¶¼r(Pñz¹ãX}<BÜ¤uGémÅ£võ}ö¶ßU$4¬İ†Vú‚*¤"â„>qt§ïåNómĞ>ë„­²çÆàE6b"ÔôRÜ¦©İ3éa¹$¶a×Iú'­F«õà×”±WêÔÉnTaàf‡"îtşãˆ%™tõ™Q:ˆh,r‰&(üfô{ÀüKLvLíBÏÕ'æ3r=MJ1Â‘]é mi+xÛñfYs¾Y£/ÔIç{…ØáF©§ïøóò_ïÉ¢FiôÈ¢½!0¢ˆ!úğ³ôĞ:ø<sräfæ¬h %í(%<ôP…$Ïmd=ù'¾“(…#›o§$%­)UÍä%¯åG‘=åd©<¬Z©<™	Ïñ›í­«6¢Ç¡-íÑŠX++|ØÍí¤nŞ°İPrê´kÈşë`Low²µCk[_esÓ+eÁ=©§¤0å3?°#a+…}$3E²gnN¿/.½¤í/W~œF.¿/ïaì(†@lã®é(-­Ä½©V%h˜N÷Z 
UW‹èhÓ|kB$=³_•O5Ÿ½#1v_åµ^Gëİá7qÄÉ8^°dıl*öIn¸µ…èï ÁëöJ%ã:#óâ£bØ!brqãØ;o$LÄ°-Næb•0Ñ ×
àìŒêÛiÇ`ík{Àáp6æZg&)üZoHO•Ä^hrlcd@®-DãGI¡bí!³-º[HR&GöyzF^g&I¡B	 ma0ŞîPa•<ĞH`m*‰¥6Ô0´HaDš:Q÷K`n)XàRí:‚“íJÓ¤UråcQ•“iõ‡Íl “c­äí,ÄÄ$÷Yd}o
Ğü7gqg\Ûİ«‚ µcÉ1míqşOq£w„gX{åÈí"Ñ‚˜âi1^—-ÆSõ/‡c§90Ä$Å$°f)`Æ
AmEíÆ3jjÌaõ~oMOñÙMÓÖ¾`ï6¨U>¯£qÿKRÖˆWßEöeVårÓ*D6Åé©¯ÑÃ¦~×7ş(½<ëéúòl-fI0LÜÖQ,ë¸$Ê“êIáàJÜ ãJîƒ áñß)E(A ¹;út[t}±\HI!F(6»(0pR0’e>ïP%aówåí¼|ìZBÑ)}í»Â&è¨öõQÈ³gj €6bvtGæÂBÉ’nJŠÜâ{¡×¥Z'¨À„d•¶Æ0CÑ8t²cè\øY|ñiáÚ+r®×HuÚT’†~ÿHJ¼Óä¨oŞí“U¶fdògìm'ìŸ2< ~*†Sµ $0û›éåGÉhBDcôîpl-LDW_vár!ÇpÏnáx	•é¨ lªme#“«çô1J¿Š$Äb@@”+ú1V3Ô+:Säõ‚ghyu¸¤lîpgÉ“M7øO/èn	^]
ÏP®ŞUbZJƒÏ7Aô¯¤óz¼%P<—ƒoÖ /Xsv¿"pQeG·z5¶]<ÓÅ	9¸ É
ÂÊVNOx…MÑ=(„q}]&"~Å¾xÒõ;
L? VßÕ±ëò}ñzH¦ih÷J
H*Q(hT ˜ìuÅfqJùxv1 ù|@@JHNQpTmZ×Lmş%Øa~ømTöĞŞ÷Zé}Ñ)ŞĞX*¡L82kÿô?zºk|:BbkJ%DköOz¬™b:mÒqeæ©ÒÏø8¥JÆöaVEÀ¨bfÅ³‡hº-5 šSnÀv:½r}JJ_wõ²G’‡u­°Iˆ`UË3è{ıÛbõ¬&É :,ÀàúX÷¹m4^xÚMÒ,aºÙd¥'bÔØeV#-y$
 d-'FpK!l’'àıáªA%}~S­r„5MmzjE9~™})%‰ê©ŸÒeÓ¤îõqptáUkHdkÓr$ş%´Ó$Åw¥ÕkÔkaşKÄW- å^pâó,Åá%msZk/gğ²r•!B:MôËsÛ{—j ( rBø}Pë–ZQØ‚
Ç„{¬Z_7´t	a=£pò{Hl6|Eë»g—m!7Ní¯=D nåƒ5RPDî<9:rë¤Éê÷… Ãcô‘êpı ì`Yjªd uı}	zñcİ ©ËŠ{À{0×}bø>aûà,NFV-2Å.P²—æ|ÁÓŒ–ô&42ËµËWÚòIóWÆjhïJàÀ pı¨ÊañA6ó^l¦.àOíUãˆo™p)â  ”¡L€^ÄZSD`,Ò‰w<(wu ),ã9#aÔÍ°Ä]çùaXn_Bh
to“Ò2ñHé@Ë>Ì ±Zêr¼b•9í¹Dı

'»ª
µnm¦à¨>P,em[iÓe÷àŒ]©ed )u_Zb{ |o†¯ÕD3á2$©8í¬²Ú&´æïq)1Y7 ãEv^{ò$£éCn>:“"g«ZòfE6tP°®¯#f‰f‡Y˜rÅztªŞ;ë¾z*˜InlçRF\€v`lEgjG1sÄ8FY r*oDPB¡&½ÓMb`ÑŸ  Q*<™ß[
ä˜ºd¥s=åFª]x(ô@´^,G)ÜAü™|=|¸¿²-¼mYµ•Ií„-{rˆ|-¾ÏÔ-*%S*kX ©ø¾¡˜¤İøx,Í¬% -İ?8e¨<ƒg..C¤B)CõaIbÔ4oR´¢%:jÏ%½ù,ñ?|¯Ú2•
/]=^/‰z,6§¹h·=ÜÕ,z7
3­i=o%J¶İ‰¨>Ò	œ³å0f¾{Ó/ÁSò=ºÇÃÌeuó%bí #<m‰S 
áxm7oZc±G=`É;bó¼4.{ì¯¢pŒ!IiÇwñ¡šSf6âÂâo qÑX(èKb*×iÈi"8’Ê,®@°acÄ$šcÃOsiJ	¸Ç8>5ºOÚ!bÔ:`ıõ&Î,mğPS- &µ)³e2HgŒ¡,Ád^rÙ…ßgÄÆ+0tz§r«Qékªeè;g-Ñb·÷7QI”åÂ¿Od2ş:Y ¹rÁtdÿxP;+_œ	şd/£MUêª¾•®û^I:Sij¤H=21m¨¬1gSu¯9`DoˆŒåk8"‘ctl³Vlna)Ão?ıcâ$•BåâkŞ*}rLÄ
g#ÄZg†Á>sÅæeC‚ @KMh½!Z-Ó&)xl-Zª?Pœòµ3a«@y–ŞÜPÍUuŒås|E?(TjÀ3(ì;Í(Óo‚®øŠcv•qU4ô¦AÈö±u"ÉFìå@0¨p7î«¶Œô…aá7ˆbõ) n]ëi Œï„z$H4ncsj<H#3_µ-<CHğ(Ê$EV«Ëû‡UÆ‘ï1)0¬<Xğ ÿÙpàk]%Çca¶¨~gÆ¥Wô&1# ğ³.”_N nPô`ªoU2{ğƒDb#”i0iĞa gv2èm=,×%w?Å|Xe]cë(;tQ<
!|ì«}P˜g—=%oÁiç°Ã´$MÇo›{uo3)¬6ıë:)(òPF–heù(w*…QŒ†"ª{#e-x2lHLª6s3s¢Ÿ€m‰u Uª´&`ljdX`eÁoóYTDpq”8y##s~ú”/OçU›ÚÿhDx°lCºt5-Á0w?®ë*‡ëzızêu"2w\#w~÷*ş.É¬<m?#¶3;öDî¥ğ%X[)?Nfqt½å¾ 4= OÿŠÛ.6t‚qg7Sû¤+YòÙæËS‡1?F_G³rbş? ;7ıò·mIÉ(™Qa·3ªP+ÃN q{O Ema	m4ÑæÖÔ59\ç:Ö¬]?cj†À÷éß¸lÃkx!]Û¶&ÙmÈv	gz®H>ASù¬,	:hÈƒğ«¤P»r/(!@Û-0gUtZöDfGá=^ e˜gË}ö×xà·&Ä ¢pÔ6[¤Y[,á~úòÍQâoîGJLı;2¬©­¼¦şõpßgö3/qè`Qu1»cZt1Î¶œ.ğÉIM @—k€.¡TRô>mi£¤hgRvdc¹Œ8ìhrg(*ëEE3¨!Zh=1M¯A-A9j4ym,k|ûËr	uó^¥TÔb9"³pf6Ãâó4ÀÀ;ºõ sXé[ı±|.9FãF}ó¼aTp=4Ï|W¶>œÌ,jpmªáIº†G´PDÃâ,~ş|?U`,
J¬Úm ,*±'›6x=S7Cy\ËLdßåSå7lô¨@]-oñw—9h>h$Ó@tòùr.½ºgmí%0<üDÙU)0òå0"~i®é2¬£¢a.>Bÿ~írUÅiFhnùÓ.n0@;üfx¹rC!ã+Xˆ ™“kd1m×njfJÄ»¿`´gmj$Qğ}yõF²–#ql7‰5á&y¨~9ã.t·+9jğetQ2Œ—x(¢x>6á-ñSöûSßëno_‰‚å…d¬àäfÿ^`+ruüCùA0"‹yß¸g¦µ=g´y§U‡ír¹íÀğN´­5¤7±C$3(z'¾lbwç£âJ.(@s×ĞÕ€ÿ§tğóov#épeÀ!,AHub³fµzN0n
$­&~´`ğÒvÎÄR±rBÜ¯ìdé{
úxq:ãÜ„J!±w¯¢éa ³æÀaæùF($a®‘}dv2bd°§¼ÏiaÁ#t¨??\
†)ß2Oq÷5»\¾*wn—˜bëº°¨ ~+À<T	È*´em%2-<j­		¸‰z½- ”´È;/è,˜g7$û=ËEÏ=Ò=|.{,ç-ÉÍí=ª5óívQ+h;ö+ÎƒxáKqzoÁ,KïÎ VÎÎ#}I6æ„>=5¿1é=DµşuM0cşH,àœï-Ø1•Ïç-A-)e%±+,S-¤	[MQë¯I÷Ï'}<åœê}¬Š>£-e-,üï|)|\&p#ä™tál,»Õo°µk;r$±æ¦4·UXvn g£ Q öãk(W¡G:'Ywxdah=ëî…81òd{8b•‹ë3ã!}ª¯Zh:iÇròÍ†N)‘ë(6t:&g¼€-Úc’ú Ê}³-lTê`wemÿsó€8|-bhk¿Øzé{ûÛydpc¾|[z¦-ú”è…oíOÖ&I;ro?¬Š=~/î'Âíà3#¥:±ü5`-X	~;Ä"²µUh1]ø·OŠ~h+{YºlÅìôHØh9ÏG!.oLhr´N)óBÚÊš„®½Š3¡x^Á|¤=AQ{xqkì°æ\!9Ae1+k^Šó… ™åMbhl!IyAª•jx;áX#ÿoH.íu™nye%­zrê½ïÎMr§{]-e¨0òÁ!)Ua†®ékhùXĞv/İîëªE¿¦]ÕX&EN(0j¡Bå}wK4Î¸}úá!|Ä(7Œqÿœ÷(¥8ñ`h5"€%i0RâAr`:‰8±>$pH2uíiiàåå;óÒmhAmëÛ]øO¶·HájßgÔE2ì‹D‰"ağòS 3\mqü8±lI)·¦4‚K´ät¹#¾v½b^îyÎej]K©læ¦aJB”TâÎÅú*ÍÄcXz9(—leÅ=µzÿ	Cr¶*E¿c)eBvV i:ˆŞ9i2`|¶	pvà~¿ıWÅa·Û=mj£%*$¹E.zµñXv>rÒ®'iÈ‡:œÕò%¬ÑjA–°ch%éd6l~Æ
c+:(*	óVjÜğÎ®"`SĞş=97áÓM.dğj‹vã©å²¾)x;ãè˜nÕ,oàJùtf&–[½z®iJ+Ğæêít&pı‚:ySG7Ä[ô€0a°a%1%öpîÅdsç|©g$¶0·sÀPaj¯£$Ùúû5ÿu²­dGí·; %§(@".<,ç¹ïçOw!4E.êc}?Vk6óæëÉ¡[6X**?lqÓ(¡ 4[fş$}â>§ºşQ}Š¦Ù—êã/_ê×i%1Ùhãt%tµwÙ\†m¼f 3’8P"â¤¼U0ÅC*ójìv¡Zõõg`iyËivì"e<(SAx¼D<ŠY¨rCoWˆqÂ!x{yÚ‰€ y
8ŸB,l7m»ŸİšÓLFD«Eşµß
Ymµd¤Òª;Ts±pİ°:cjxˆâıWGU+Ç¼c5b§>0a`0gg’QweIh1gò½HŸ2â-İçó“äYçùğ™`fa$)ëLdäP¡àb×Ko„/¶/=èÒpxÅ_¢ñ°7hNn\Õ2)vUé±h¡hG3©¨¢$g6F+êæØî}ã`·uúª>¯NŸSía[ùbmb®ap¼¤s}&äy(Õh'«
n25N™scìÍh!×´&¥·w`èÀDâô \2M?$cZ°m?º7˜tè‰•	k;šT"½#1/¨6qšd¥a\z¶¢öšcrfŸø¡ö ø&¾Oa°ZgghÔ%…ü
&yA°éb% 1¤sVÙ c&ûtoI70@`²^1!b spJğzIDp¯<xö^¼slpZ|óˆŞSñw31êçì|g½ı}ñ; Ö9EÏv?Ùü˜å½èsï·%µ2|)iî6"ºD=lmøT.ïq¡)Uqqò©fš$U.4¯ğ!ı~B#?KWÖwSoég98a‚$hc.kdJ'Y:7<*ç Š^t)>¼¼ƒäÄRQ a3€ƒÉhl¥·¼Tè©-,s>p7"¨3“,™á.%`¯æÆ(HArco~õõ¬4æâ°"°Räñj­¢XOJs.$I	RÚˆ¦ ¦$W=2Uowõ?ş@yü^T7õá*1})I1¸çp µÒ½¼¥vkRT~*.¶BEu9°lz&›/d?(LÁËD$I…zŸbd eJ ,"
xö#“E…àdh <a0‘\…€:y 0´|Zape2+j/­PfŞ7?{s§áB[dğEÒyõ”mÔ+`s0O*ù\G²†1¦æ¹Oôi"oUf™%>@Ú„ÓM"^^p:‰6)f(B®*ót:¡’rfr†B*R$³ªï%<gÿd&­b]-c‹mg-0®à1-eEPhn	fh«/-şt²M“Úâ¤z”+š s^A6q‘oYm¥cò}Ğ\
/"é5<0·”cîGƒ jPğYˆbïÏ=S&H>ï3Œy}jy¢~·dÈsÖÔØ7ôlh¾‘áPò%}SJ¼t\‹dôj	_"0mœAj-¼ºAşÅßgM-{T¹€r>³$›j¨__<kÛCå"Â¿øaxAhmírh<Õ|w‡—(_¤ccîHhsµ tNny|¼hşF¶#/ÌP;KI"!Å<08¤DêzÇi0ù”{e™ãm‚°7é”gÆl:BòZb“í)#pdU	Ê@ï¼‰,
om›´Òhı©0åQ˜ñE*bëthóFsÕ.^òøoöa¯Ye/ÎaXÿ$YgÃzo"ism[¾R3g(-Çàaìc)l|Ğ#Ã-¤}¶¿mÂˆóDsB;¿vgş+JCxªdH#¦ˆb7=òZ„o&ï4Ês·a¤©çO(å…N*Q#v!2õ(2 ãoÕù»/sê4?eo¼Rn µD>@!¹*ÔfÕQ=ldA³c”#qSû³~ë,IÖštaåãä‘q\?ŸdŠcèá3á¤=½,/)!m  Ê®D:C uvÉ­ô¼@mñmØ’:;y&ñ-a	ûZş-Œ¥m£
-zmM
Ø9­-O9Dé½®,-ö5` i/KØ,"P'a¬9#ıUMr½tGít!­+!	¢%ü,ö&~oˆèg(?×™J©·/5òh‰ab$mD¡‹¨(' «!İ(¬Mî:sLn´¶|%*ÌÈº­­}Î­¼~=(*Ø49g%6p4|‘ºåüh¸qaE°Ud/nŠ‡OˆÁW#©ênÆuQp…âM3<#®ˆ0)Xbr—ÃÉˆik:=êî·µ‘nU°WÎ”k
ñÍ¡äpB<—}Q0M‘! yuî0b «a"0T2P1	][Óâº¨®sß>A+£0é—Q6mu©0+°p<attÜç€ñbø[ğít-z|Zd‡rÑ:'T§(1Aé#~r<Úr(iHzºâ©3÷ÎÓ~FMö"‡uEÓ[*-43ôfxç5¤† Šúƒ nmNÕ>* V0Cbmî*sÉ2?vXv<:~[s¬[xi¨a0u#R¦‚1\»¼ô7å ÖòZN‚d($Š\Ii >µ¯L-Sømë†Ai©B7d¸1à¾0ãUk¦Lx{ŒÈá¶|%;A2aGdÖÍÿ»Li-àïB)0EeîAIW¯!®!Õda7|'íéTAR×B<%Ğ¨VÚ¤ ¤ÑTuqd†İãá¬gZ »¥&Ü§Ï(,~}H‘¼úpò(EbuâRO-3<s‚+N `eÇ2¤:{dûs´3ºfşr(¢!o½uO4¼š…{+a÷\¬hâäü­5AjbeAX¢çC!¤ÓàU²dæ¡zEß.şl-CÅ2h="î€‰+6w\Soúå®<pñxi<Ò¡ghp7vS)ı*Æ:õ-Ì8-$&şû;W ²"y¶geôñ)rÏtÃd¾ñ:Ø|I$ÅópÁ‚/T*‘e“r ¦C².+
yK¡_—‘:|yC6å¢ü9’yâM²<E6nj¿bçxys8N*}ÑBG@r@ÿĞ-b"G²ZPÑ(u)PN{,äp•zÑŞcŒ=ç¬"*¢$ˆéoc)Âæ{}ò?áMtemVeUµ<ÜÑ0Jk$R^elf¬(¥–CIvaTà¤Il)1Wë#>|øbhÊr&´|Ê ‰º8
ŞL:*b'uóA%IFvw
d é$d!jhÖN¶2+nzgğV;……á³h9²‡½–bøJÂ`5]>iÃHŠ9Å¤;[HÇatpâ1møSfXş±â‹o!ö)ğ"”G•TYóæ«‡1;¬0ùZà~ÁE7L2|Öuô•w51w¢/oqŒl/-q—JvjhnSníw.'·;TÇÎû:~%ôî³¨|Õh&2«P!S':úµ1dÍ¼M\?'à'Qt~F8®Aµ&D=!6äA-7ı1<ÛÒÌğÀ@í5:½mé{gZ†NàRñ¨,f“$g1zbeø*&}J¨}ê(jfFÓÈ.gt#b-œö`dwï°¡_`Ã#O[h‰™ï{ïŠ}mº9Ô¬`%Y5_ã~cà²=a¾¼)²pwaLXW(	zl?Yæ³ ‚ä3è.U}
©'ew`=!8%.új$+2è°ñ1“¨@-ea mãU'±"ß+Yqê¥x}{9º”„eåÑMç(B*y+õé%{*®4
_•l4T`HTUED4uÚ~Ï%pi&h…›÷-‘nÎºU z¸] XÈc|]|ôä`(p±aáxêcaplQ4šoÜAd±ÄÖFzh0Yñ¯,)…¥gíåKÌ °¾ y]®dLf¬!sÜ‘bÕc`ªoDe,H~„©låk4¿ê¡p!c¸^v½=#*yöàk‡:5lÎik_ÅåÇ9¿ÔP3ØÑúaD(!õynk†ën&„wg±n/@Ua0Lª§q7(Â"ŸfçA)YpËuÈJU_[wUxnØnÊÍùü^H<­líŠô:¨>Œy-}r«K=å¥-usì%…ëX(j$¹]/_ …?oÚAÕaü}(=clælªë?YoËİ!JĞzßùèuPV|PCWç®ş5kÍiª8î‰Îh5-Nùç.±¸%)*[­i¡pÏ†ë¢iC-p¯â(L,)Ïém~mì'v,>½¼·Ÿş¬¸­ï˜P%¹Æ«‘Pøpq+l1<Ñ9ÅÁ– nÄ}À†jTR$ds	i9.@áWı¯Ô]ôy×Z¢Mpî5 F„+ƒæÿ°6>(L0[X3‰‚¿CPé ñ8/¿/YƒÏ;ç¥PzR‘ÅvâöF¥áŸ€_5Qò øâ\FöóIoóKe&èb
$p’Êz­e|R
µhß{ĞysckaX *”óM	«¸
ßáw"h ®'É‡ 1MMa¦ÿüëÇ=Ig?¬&œíÎénTÔU[K4*ıî	´ ÊRÀlÃ[>Â1áuC…=G"â@_6gäkIÎ»TĞqF;ÚŒ®kÅw7ÁÔg¸~®Úèdõ$¶úz^r0R|[*êµ	¢7¡4m‰Rp5'©šg½kn@t¢x>aø	t{3E±}1V-Enaşt8¿<L#¡[W5WB¬ ¢ic¨ÆŠì.E4Â®¯@ ns²Ş÷ñ 6±Õ^_Qwp$Qt[q¡z¶x³ur(xó:÷©j_<îÜ.4GàoÇ§¶p–òºÿU,a	ìÕ›¥Wú‚  jr„vqr­cåz?i’j®Å2g/Çl6b Åy R$»Õœe©a½$ô0¦(º'©Gû· “œ¹óéÔè>Ts@î¯tşãˆõ^t‰%Zk<¸%‰8<æîûà¼Z~` ì×uä¢dğ,OZ=ÂÑÔßá }(póñsôsp"+ô	ä[àV-§oxòf×éÁ&D#5ˆr½0|x£èòñâú:z0sRàaf¬ Vb%liUõ&ôp¹F€$~md=uñ>óh/#nµ6å|YuOô¡{§}‘9ä|»4t+E>ÚŸ€!êóšúOŒ+ït¢AŒáw4íÑkX+=páì´şş2¬pkÊ´oÉ¶o âlkt2uj*S^e=CÃ+m$Á0â 2aQbĞcf;9drLG2uæn¿D?n&Àì¿w~œW®ó/ïcl¨–lPLå¤wAj,¬ÔŞ)T“$y˜mÿ
 
R)(xÒxëC '7¯Oµı¿ W5víåşë™d7qÅÑƒ6:0ue=~;Æ@,ø5sèfÁivdcÚ	!÷ê#"°u[b2qëÙ_LN°<j f…8À!ƒ ä¬ŞÇiÏhéCj!ñp4fZf")ıXz@Mµd_mSl¦$p¢#@aCU¸se2´¥¶ûJÒ"s÷ùbF^g&i&
$Ía2Şæ:`•=ÒL0Ep©1v_qµR=;D¸AŒ K 5c)ğàFë;Q3åX¤u’d+´»iñ£Xl`³KG¾ i$eÄ$÷ZTm)"
À§u#GÜÚ] ½cÃ0ï­+ ¾op»_u dØiu€¤$÷‚˜±bi0\ƒ%VSôC7cF§<ä,åµ"9`æAmEÍ®Uop]a·~ï{KáİEÕöeã2†>/cdÿKQ×6ÛD4öqVe WNR·Aé©¾ÛÃ¢|7ş8¼<zËh²l-vË%|êÖ¬‹ù6[ ÒJåää ¡J÷Gdpuï¹e)q »;{pjt5·MHa)!F-6~*0°[0°L:OP%okïóáõ¼øøPFñûyí«ÂdèaöaÈ‚tâ`À6af4çÆâNÁ@dnj„à}a÷c¥Ng¹a´$ ·Æ0cQ9qøbx\úQ6ño!ZVïs·×`u^tr‡2
Jµ]`¬eêÍ£}>V¯p52mfee¬Q3< }",u4&d87¿IpåwEHB#ÆnrnmY!3váz!ÇpÏîõ0—¹(8`oªea•S£ç
¦Qjß4bhZ	.+:9^3L+9óä³",)3m›¤dî5géM/œÜ/­l	]yg)Ù®mf8m#Ï?Hï-&=û~¼,	<ƒoµ0//^¯*`]%t7Z7ÛU4SÄ	¼PI*‚ëVLY|…M]½(¤-ñ}|-p|Å¿zÀõ;
L?´3é½5êº5=½z®i §ZH+Q)
 ¨ì5åd1Jíxw;!e9ô$JÌh5/+še®xM|ØlTt _õzé}Ñ½ÔV\b!L1*Ksîñ;ø3> |ônBa2bZ$ózf^xi’ãA2m†puôÒOh8¤*Æö`6e"¨`VÁ7‹h>u¡>Qêàv-rxN:v3u÷G[w5--´JÔtU‹2ÊkÿÅfñ).É
j" è´ø?Y©5ÙÌğ@1:ºYs°$b€ØeV¹€-y¥$9ffzk!ì’$êu¨®À`]4Z[­phqz*%12™)'©î-“âeÓ¤êõeòt(qïHDyÇb$~-ôÿoEw¥û?ñkqô@U%óf^`Èõ8Åä'iWRCNwğwPr… BTMÀ+âYÛe·n$tpåá’šf ç„ûPL_7´HA=óòâK\ 	&ìe¢›¯„o-7N=Ÿ9d0.Ç£=t8@Gn[l{9[rídÍnõ!À’gô‘êx<†ààUlªl%1ù}Ortiy8¡Ë{pæ{1Õı`ô¥cãk¬ltE|z…®s²åÎ8Å2Öa&µfë´ËSvÖKóVÆ~*çHt¤]%¯Iù{23||¤jà~İa"ªn&u¯zŒğ¤«F	Rd[Ql("promote-buffers-to-stack");
  }
  ::llvm::StringRef getArgument() const override { return "promote-buffers-to-stack"; }

  ::llvm::StringRef getDescription() const override { return "Promotes heap-based allocations to automatically managed stack-based allocations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PromoteBuffersToStack");
  }
  ::llvm::StringRef getName() const override { return "PromoteBuffersToStack"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
  ::mlir::Pass::Option<unsigned> maxAllocSizeInBytes{*this, "max-alloc-size-in-bytes", ::llvm::cl::desc("Maximal size in bytes to promote allocations to stack."), ::llvm::cl::init(1024)};
  ::mlir::Pass::Option<unsigned> bitwidthOfIndexType{*this, "bitwidth-of-index-type", ::llvm::cl::desc("Bitwidth of the index type. Used for size estimation."), ::llvm::cl::init(64)};
  ::mlir::Pass::Option<unsigned> maxRankOfAllocatedMemRef{*this, "max-rank-of-allocated-memref", ::llvm::cl::desc("Maximal memref rank to promote dynamic buffers."), ::llvm::cl::init(1)};
};

//===----------------------------------------------------------------------===//
// SCCP
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class SCCPBase : public ::mlir::OperationPass<> {
public:
  using Base = SCCPBase;

  SCCPBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SCCPBase(const SCCPBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sccp");
  }
  ::llvm::StringRef getArgument() const override { return "sccp"; }

  ::llvm::StringRef getDescription() const override { return "Sparse Conditional Constant Propagation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SCCP");
  }
  ::llvm::StringRef getName() const override { return "SCCP"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// StripDebugInfo
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class StripDebugInfoBase : public ::mlir::OperationPass<> {
public:
  using Base = StripDebugInfoBase;

  StripDebugInfoBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  StripDebugInfoBase(const StripDebugInfoBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("strip-debuginfo");
  }
  ::llvm::StringRef getArgument() const override { return "strip-debuginfo"; }

  ::llvm::StringRef getDescription() const override { return "Strip debug info from all operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StripDebugInfo");
  }
  ::llvm::StringRef getName() const override { return "StripDebugInfo"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// SymbolDCE
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class SymbolDCEBase : public ::mlir::OperationPass<> {
public:
  using Base = SymbolDCEBase;

  SymbolDCEBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  SymbolDCEBase(const SymbolDCEBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("symbol-dce");
  }
  ::llvm::StringRef getArgument() const override { return "symbol-dce"; }

  ::llvm::StringRef getDescription() const override { return "Eliminate dead symbols"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SymbolDCE");
  }
  ::llvm::StringRef getName() const override { return "SymbolDCE"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// ViewOpGraphPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ViewOpGraphPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = ViewOpGraphPassBase;

  ViewOpGraphPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ViewOpGraphPassBase(const ViewOpGraphPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("view-op-graph");
  }
  ::llvm::StringRef getArgument() const override { return "view-op-graph"; }

  ::llvm::StringRef getDescription() const override { return "Print graphviz view of module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ViewOpGraphPass");
  }
  ::llvm::StringRef getName() const override { return "ViewOpGraphPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
  ::mlir::Pass::Option<std::string> title{*this, "title", ::llvm::cl::desc("The prefix of the title of the graph")};
  ::mlir::Pass::Option<bool> shortNames{*this, "short-names", ::llvm::cl::desc("Use short names"), ::llvm::cl::init(false)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AffineLoopFusion Registration
//===----------------------------------------------------------------------===//

inline void registerAffineLoopFusionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLoopFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// AffinePipelineDataTransfer Registration
//===----------------------------------------------------------------------===//

inline void registerAffinePipelineDataTransferPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createPipelineDataTransferPass();
  });
}

//===----------------------------------------------------------------------===//
// BufferDeallocation Registration
//===----------------------------------------------------------------------===//

inline void registerBufferDeallocationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createBufferDeallocationPass();
  });
}

//===----------------------------------------------------------------------===//
// BufferHoisting Registration
//===----------------------------------------------------------------------===//

inline void registerBufferHoistingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createBufferHoistingPass();
  });
}

//===----------------------------------------------------------------------===//
// BufferLoopHoisting Registration
//===----------------------------------------------------------------------===//

inline void registerBufferLoopHoistingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createBufferLoopHoistingPass();
  });
}

//===----------------------------------------------------------------------===//
// BufferResultsToOutParams Registration
//===----------------------------------------------------------------------===//

inline void registerBufferResultsToOutParamsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createBufferResultsToOutParamsPass();
  });
}

//===----------------------------------------------------------------------===//
// CSE Registration
//===----------------------------------------------------------------------===//

inline void registerCSEPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createCSEPass();
  });
}

//===----------------------------------------------------------------------===//
// Canonicalizer Registration
//===----------------------------------------------------------------------===//

inline void registerCanonicalizerPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createCanonicalizerPass();
  });
}

//===----------------------------------------------------------------------===//
// FinalizingBufferize Registration
//===----------------------------------------------------------------------===//

inline void registerFinalizingBufferizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createFinalizingBufferizePass();
  });
}

//===----------------------------------------------------------------------===//
// Inliner Registration
//===----------------------------------------------------------------------===//

inline void registerInlinerPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createInlinerPass();
  });
}

//===----------------------------------------------------------------------===//
// LocationSnapshot Registration
//===----------------------------------------------------------------------===//

inline void registerLocationSnapshotPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLocationSnapshotPass();
  });
}

//===----------------------------------------------------------------------===//
// LoopCoalescing Registration
//===----------------------------------------------------------------------===//

inline void registerLoopCoalescingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLoopCoalescingPass();
  });
}

//===----------------------------------------------------------------------===//
// LoopInvariantCodeMotion Registration
//===----------------------------------------------------------------------===//

inline void registerLoopInvariantCodeMotionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLoopInvariantCodeMotionPass();
  });
}

//===----------------------------------------------------------------------===//
// NormalizeMemRefs Registration
//===----------------------------------------------------------------------===//

inline void registerNormalizeMemRefsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createNormalizeMemRefsPass();
  });
}

//===----------------------------------------------------------------------===//
// ParallelLoopCollapsing Registration
//===----------------------------------------------------------------------===//

inline void registerParallelLoopCollapsingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createParallelLoopCollapsingPass();
  });
}

//===----------------------------------------------------------------------===//
// PrintCFG Registration
//===----------------------------------------------------------------------===//

inline void registerPrintCFGPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createPrintCFGGraphPass();
  });
}

//===----------------------------------------------------------------------===//
// PrintOpStats Registration
//===----------------------------------------------------------------------===//

inline void registerPrintOpStatsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createPrintOpStatsPass();
  });
}

//===----------------------------------------------------------------------===//
// PromoteBuffersToStack Registration
//===----------------------------------------------------------------------===//

inline void registerPromoteBuffersToStackPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createPromoteBuffersToStackPass();
  });
}

//===----------------------------------------------------------------------===//
// SCCP Registration
//===----------------------------------------------------------------------===//

inline void registerSCCPPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSCCPPass();
  });
}

//===----------------------------------------------------------------------===//
// StripDebugInfo Registration
//===----------------------------------------------------------------------===//

inline void registerStripDebugInfoPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createStripDebugInfoPass();
  });
}

//===----------------------------------------------------------------------===//
// SymbolDCE Registration
//===----------------------------------------------------------------------===//

inline void registerSymbolDCEPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSymbolDCEPass();
  });
}

//===----------------------------------------------------------------------===//
// ViewOpGraphPass Registration
//===----------------------------------------------------------------------===//

inline void registerViewOpGraphPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createPrintOpGraphPass();
  });
}

//===----------------------------------------------------------------------===//
// Transforms Registration
//===----------------------------------------------------------------------===//

inline void registerTransformsPasses() {
  registerAffineLoopFusionPass();
  registerAffinePipelineDataTransferPass();
  registerBufferDeallocationPass();
  registerBufferHoistingPass();
  registerBufferLoopHoistingPass();
  registerBufferResultsToOutParamsPass();
  registerCSEPass();
  registerCanonicalizerPass();
  registerFinalizingBufferizePass();
  registerInlinerPass();
  registerLocationSnapshotPass();
  registerLoopCoalescingPass();
  registerLoopInvariantCodeMotionPass();
  registerNormalizeMemRefsPass();
  registerParallelLoopCollapsingPass();
  registerPrintCFGPass();
  registerPrintOpStatsPass();
  registerPromoteBuffersToStackPass();
  registerSCCPPass();
  registerStripDebugInfoPass();
  registerSymbolDCEPass();
  registerViewOpGraphPassPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
