/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
#ifndef TENSORFLOW_C_EXPERIMENTAL_FILESYSTEM_FILESYSTEM_INTERFACE_H_
#define TENSORFLOW_C_EXPERIMENTAL_FILESYSTEM_FILESYSTEM_INTERFACE_H_

#include <stddef.h>
#include <stdint.h>

#include "tensorflow/c/tf_file_statistics.h"
#include "tensorflow/c/tf_status.h"

/// This is the interop header between core TensorFlow and modular filesystem
/// plugins (see initial RFC https://github.com/tensorflow/community/pull/101).
///
/// Both core TensorFlow and every plugin will use this header. The associated
/// `.cc` file is only used by core TensorFlow to implement checking needed for
/// plugin registration and ensuring API and ABI compatibility. Plugin authors
/// don't need to read the `.cc` file but they should consult every section of
/// this file to ensure a compliant plugin can be built and that the plugin can
/// be used without recompilation in the widest range of TensorFlow versions.
///
/// The header is divided into sections, as follows:
///   1. Opaque plugin private data structures and wrappers for type safety;
///   2. Function tables for plugin functionality;
///   3. Versioning metadata;
///   4. Plugin registration API and the DSO entry point.

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

/// SECTION 1. Opaque data structures to hold plugin specific data
/// ----------------------------------------------------------------------------
///
/// The following data structures incorporate a `void*` that is opaque to
/// TensorFlow but can be used by each filesystem plugin to represent internal
/// data.
///
/// We prefer to have these structures instead of passing `void*` into
/// method signatures to have some type of type safety: for example, operations
/// that are only valid on random access files have a `TF_RandomAccessFile`
/// argument.
///
/// Lifetime: The wrapper data structures are owned by core TensorFlow. The data
/// pointed to by the `void*` members is always owned by the plugin. The plugin
/// will provide functions to call to allocate and deallocate this data (see
/// next sections) and core TensorFlow ensures to call these at the proper time.
///
/// Plugins will never receive a `TF_*` pointer that is `nullptr`. Core
/// TensorFlow will never touch the `void*` wrapped by these structures, except
/// to initialize it as `nullptr`.

typedef struct TF_RandomAccessFile {
  void* plugin_file;
} TF_RandomAccessFile;

typedef struct TF_WritableFile {
  void* plugin_file;
} TF_WritableFile;

typedef struct TF_ReadOnlyMemoryRegion {
  void* plugin_memory_region;
} TF_ReadOnlyMemoryRegion;

typedef struct TF_Filesystem {
  void* plugin_filesystem;
} TF_Filesystem;

typedef struct TF_TransactionToken {
  void* token;
  TF_Filesystem* owner;
} TF_TransactionToken;

// The named union is needed here (as opposed to
// inside the `TF_Filesystem_Option_Value` struct)
// as MSVC does not recognize `typeof`.
typedef union TF_Filesystem_Option_Value_Union {
  int64_t int_val;
  double real_val;
  struct {
    char* buf;
    int buf_length;
  } buffer_val;
} TF_Filesystem_Option_Value_Union;

typedef struct TF_Filesystem_Option_Value {
  int type_tag;    // type of values in the values union
  int num_values;  // number of values
  TF_Filesystem_Option_Value_Union*
      values;  // owned (plugins must make a copy if storing this)
} TF_Filesystem_Option_Value;

typedef enum TF_Filesystem_Option_Type {
  TF_Filesystem_Option_Type_Int = 0,
  TF_Filesystem_Option_Type_Real,
  TF_Filesystem_Option_Type_Buffer,
  TF_Filesystem_Num_Option_Types,  // must always be the last item
} TF_Filesystem_Option_Type;

typedef struct TF_Filesystem_Option {
  char* name;                         // null terminated, owned
  char* description;                  // null terminated, owned
  int per_file;                       // bool actually, but bool is not a C type
  TF_Filesystem_Option_Value* value;  // owned
} TF_Filesystem_Option;

/// SECTION 2. Function tables for functionality provided by plugins
/// ----------------------------------------------------------------------------
///
/// The following data structures represent the function tables for operations
/// that plugins provide (some are mandatory, some are optional, with or without
/// a default implementation).
///
/// Each plugin implements the operations that are supported and TensorFlow will
/// properly handle the cases when an operation is not supported (i.e., return
/// the corresponding `Status` value).
///
/// REQUIRED OPERATIONS: All required operations are marked as such, including
/// operations which are conditionally required. If the presence of an operation
/// `foo` requires operation `bar` to be present, this is specified in `foo`. If
/// the entire set of operations in a table is not provided, use `nullptr` for
/// the struct pointer (e.g., when a file type is not supported).
///
/// DEFAULT IMPLEMENTATIONS: Some operations have default implementations that
/// TensorFlow uses in case the plugin doesn't supply its own version. An
/// operation `foo` might have a default implementation which uses `bar` and
/// `foobar`. If the plugin supplies `bar` and `foobar`, TensorFlow can use the
/// default implementation of `foo`.
///
/// During plugin loading, plugins will call the registration function provided
/// by this interface, supplying values for each of these structures. Core
/// TensorFlow checks that the plugin supplies all mandatory operations and
/// then copies these tables to a different memory location, marking the new
/// operation tables as read-only. Once a plugin is loaded, none of these
/// operation pointers may change.
///
/// There are 4 function tables: one for each of the 3 file objects in
/// TensorFlow (i.e., `RandomAccessFile`, `WritableFile`,
/// `ReadOnlyMemoryRegion`) and one for all the operations a `Filesystem`
/// implements. Each of them is in a 1-to-1 correspondence with the wrapper
/// structures from the first section: these tables only contain function
/// pointers that operate on the corresponding data. Thus, the first argument of
/// each of these functions is a pointer to the paired struct and this argument
/// can be used to track state in between calls (from an object oriented point
/// of view, this can be viewed as a "vtable" for a "class" -- that is the
/// corresponding struct above --; the first argument is in place of `this`).
///
/// Except where noted otherwise, all pointer arguments are owned by core
/// TensorFlow and are guaranteed to not be `nullptr`.
///
/// All path-like arguments are null terminated `char*` strings. Plugins can
/// assume that before any function using path arguments is invoked, the path is
/// made canonical by calling the function provided by `translate_name` or a
/// default implementation of that (supplied by core TensorFlow).
///
/// The only time the pointer to the `TF_*` structures from section 1 is not
/// marked `const` in these functions is when these function are either
/// allocating or deallocating the plugin specific data. That is, in the 4
/// `cleanup` functions (one for each data structure), the `init` function for
/// `TF_Filesystem` and the `new_*` methods of `TF_FilesystemOps` to initialize
/// the 3 types of files. In all other cases, there is no need to modify the
/// address of the opaque data pointer, hence the wrapper pointer is marked
/// `const`.
///
/// For consistency, the arguments on all these functions follow the same
/// pattern: first we have the opaque pointer argument ("this" above), then the
/// input arguments, then the in-out arguments (if any) and we finish the
/// argument list with the out arguments. We only use the return type for an out
/// parameter if that is a plain C type, as this ensures ABI compatibility
/// (returning structures has issues in case compiler options affect
/// optimizations such as RVO). If a status needs to be returned from these
/// methods, the last argument is always a `TF_Status *` (or an array of such
/// pointers) owned by core TensorFlow and guaranteed to not be `nullptr`.
///
/// To ensure ABI and API compatibility, we have out-of-bounds data that is used
/// by both core TensorFlow and the plugin at load time. We don't include this
/// data in the structures here to prevent cases when padding/packing enabled by
/// different compiler options breaks compatibility. For more details about how
/// this is used, please consult next sections. Here we just wrap these tables
/// in lint warnings so that changes here cause changes to the versioning data
/// as well. Here is a short summary of what changes are allowed:
///   * adding a new method at the end of a table is allowed at any time;
///   * any other change to these tables is only allowed on a major TensorFlow
///     version change (e.g., from 2.x to 3.0). This is provided as an escape
///     hatch to allow cleaning up these tables. Since any of these changes
///     break ABI compatibility and cause all plugins to be recompiled, these
///     type of changes should be extremely rare.
///
/// Next section will detail this as well as some corner cases that are out of
/// scope for now.

// LINT.IfChange
typedef struct TF_RandomAccessFileOps {
  /// Releases resources associated with `*file`.
  ///
  /// Requires that `*file` is not used in any concurrent or subsequent
  /// operations.
  ///
  /// This operation must be provided. See "REQUIRED OPERATIONS" above.
  void (*cleanup)(TF_RandomAccessFile* file);

  /// Reads up to `n` bytes from `*file` starting at `offset`.
  ///
  /// The output is in `buffer`, core TensorFlow owns the buffer and guarantees
  /// that at least `n` bytes are available.
  ///
  /// Returns number of bytes read or -1 in case of error. Because of this
  /// constraint and the fact that `ssize_t` is not defined in `stdint.h`/C++
  /// standard, the return type is `int64_t`.
  ///
  /// This is thread safe.
  ///
  /// Note: the `buffer` argument is NOT a null terminated string!
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if exactly `n` bytes have been read.
  ///   * Must set `status` to `TF_OUT_OF_RANGE` if fewer than `n` bytes have
  ///     been read due to EOF.
  ///   * Must return -1 for any other error and must set `status` to any
  ///     other value to provide more information about the error.
  int64_t (*read)(const TF_RandomAccessFile* file, uint64_t offset, size_t n,
                  char* buffer, TF_Status* status);
} TF_RandomAccessFileOps;
// LINT.ThenChange(:random_access_file_ops_version)

// LINT.IfChange
typedef struct TF_WritableFileOps {
  /// Releases resources associated with `*file`.
  ///
  /// Requires that `*file` is not used in any concurrent or subsequent
  /// operations.
  ///
  /// This operation must be provided. See "REQUIRED OPERATIONS" above.
  void (*cleanup)(TF_WritableFile* file);

  /// Appends `buffer` of size `n` to `*file`.
  ///
  /// Core TensorFlow owns `buffer` and guarantees at least `n` bytes of storage
  /// that can be used to write data.
  ///
  /// Note: the `buffer` argument is NOT a null terminated string!
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if exactly `n` bytes have been written.
  ///   * Must set `status` to `TF_RESOURCE_EXHAUSTED` if fewer than `n` bytes
  ///     have been written, potentially due to quota/disk space.
  ///   * Might use any other error value for `status` to signal other errors.
  void (*append)(const TF_WritableFile* file, const char* buffer, size_t n,
                 TF_Status* status);

  /// Returns the current write position in `*file`.
  ///
  /// Plugins should ensure that the implementation is idempotent, 2 identical
  /// calls result in the same answer.
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` and return current position if no error.
  ///   * Must set `status` to any other value and return -1 in case of error.
  int64_t (*tell)(const TF_WritableFile* file, TF_Status* status);

  /// Flushes `*file` and syncs contents to filesystem.
  ///
  /// This call might not block, and when it returns the contents might not have
  /// been fully persisted.
  ///
  /// DEFAULT IMPLEMENTATION: No op.
  void (*flush)(const TF_WritableFile* file, TF_Status* status);

  /// Syncs contents of `*file` with the filesystem.
  ///
  /// This call should block until filesystem confirms that all buffers have
  /// been flushed and persisted.
  ///
  /// DEFAULT IMPLEMENTATION: No op.
  void (*sync)(const TF_WritableFile* file, TF_Status* status);

  /// Closes `*file`.
  ///
  /// Flushes all buffers and deallocates all resources.
  ///
  /// Calling `close` must not result in calling `cleanup`.
  ///
  /// Core TensorFlow will never call `close` twice.
  void (*close)(const TF_WritableFile* file, TF_Status* status);
} TF_WritableFileOps;
// LINT.ThenChange(:writable_file_ops_version)

// LINT.IfChange
typedef struct TF_ReadOnlyMemoryRegionOps {
  /// Releases resources associated with `*region`.
  ///
  /// Requires that `*region` is not used in any concurrent or subsequent
  /// operations.
  ///
  /// This operation must be provided. See "REQUIRED OPERATIONS" above.
  void (*cleanup)(TF_ReadOnlyMemoryRegion* region);

  /// Returns a pointer to the memory region.
  ///
  /// This operation must be provided. See "REQUIRED OPERATIONS" above.
  const void* (*data)(const TF_ReadOnlyMemoryRegion* region);

  /// Returns the length of the memory region in bytes.
  ///
  /// This operation must be provided. See "REQUIRED OPERATIONS" above.
  uint64_t (*length)(const TF_ReadOnlyMemoryRegion* region);
} TF_ReadOnlyMemoryRegionOps;
// LINT.ThenChange(:read_only_memory_region_ops_version)

// LINT.IfChange
typedef struct TF_FilesystemOps {
  /// Acquires all resources used by the filesystem.
  ///
  /// This operation must be provided. See "REQUIRED OPERATIONS" above.
  void (*init)(TF_Filesystem* filesystem, TF_Status* status);

  /// Releases all resources used by the filesystem
  ///
  /// NOTE: TensorFlow does not unload DSOs. Thus, the only way a filesystem
  /// won't be registered anymore is if this function gets called by core
  /// TensorFlow and the `TF_Filesystem*` object is destroyed. However, due to
  /// registration being done in a static instance of `Env`, the destructor of
  /// `FileSystem` is never called (see
  /// https://github.com/tensorflow/tensorflow/issues/27535). In turn, this
  /// function will never be called. There are plans to refactor registration
  /// and fix this.
  ///
  /// TODO(mihaimaruseac): After all filesystems are converted, revisit note.
  ///
  /// This operation must be provided. See "REQUIRED OPERATIONS" above.
  void (*cleanup)(TF_Filesystem* filesystem);

  /// Creates a new random access read-only file from given `path`.
  ///
  /// After this call `file` may be concurrently accessed by multiple threads.
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if `file` was updated.
  ///   * Must set `status` to `TF_NOT_FOUND` if `path` doesn't point to an
  ///     existing file or one of the parent entries in `path` doesn't exist.
  ///   * Must set `status` to `TF_FAILED_PRECONDITION` if `path` points to a
  ///     directory or if it is invalid (e.g., malformed, or has a parent entry
  ///     which is a file).
  ///   * Might use any other error value for `status` to signal other errors.
  ///
  /// REQUIREMENTS: If plugins implement this, they must also provide a filled
  /// `TF_RandomAccessFileOps` table. See "REQUIRED OPERATIONS" above.
  void (*new_random_access_file)(const TF_Filesystem* filesystem,
                                 const char* path, TF_RandomAccessFile* file,
                                 TF_Status* status);

  /// Creates an ~«PIjôëËmxgy9ÜZ‹ßè„“!ÆM÷›Nœ›À@!t²/éŞPe«ÍÈQ>
H¨qôSKf‹ 2QI?lR§Üdsåw8êí>Xt÷ğkíâF%¢X$ï8«…÷[ìcpˆk$ÅôJ=æ[n®îo¤WwÏXÔbşg‰‘…ÙE† -ÄoÄïŞ ¹³Ê:(-‚¹ı|ò÷$;/ÜÃkÄ] à)ãÁùk­_®»dÜ/çEˆòqxe¤r2#(Ç­	¡è!Kc+;®¥ H8FwlLT
§š–*ˆ,‚ò¨A Õ¿ ×I{õh{õM:w“zœ(ŞS‰t:‘’ƒn#3Qï(ô¿dGDcpHTPD31Ïf¥)ò©'ZeC°ä=e«yÚ`ëœcÉÊz%NUhâsg8zWSÿàK&Û,[AoMI]à×N;$Şvp¸Cpl3&>/bcæ:Ãxù1¹» xh*lÁê( „öëñx¥¡æJúİ_²ò‚drù{ŞW‚ ôW.9Í*JEìœÔ¼ïÇ8éAõPhl½ÿ5¶Ä#LRšeOİîÈ-;vFgAWõùá	]Î¢hé/ƒâqr4øA2"NÙ«Tı·4ó|+âJæd„rLi3ƒP}U#gÏâå
şR¥îZàö»)\*ŸbFñí9®ˆÑ.ŸÚoEî¸‚¯Eşğ}ˆPÚÕÆ¤ê:ŠG2xpU8ûáÈú [@|ıÕéO~Òg‡tç?ÜóBc5²dÑMoEP_·Ï%hEZtPrË¯²ò¯‚Ec¥#iª„@÷„µ_{\®ÎvËÔJ³)Kf¬Voµ®ààqlfbåÕ
)¨~¨RsÓiagÊ}°E3¹åê=¥¥DòR) ›yÇhm;¦[Ñ4óH.:ÀtÔöù^·ËÄzbéZÆ`Áw[* hîéj}MŒŒ§5øî×ïA¤' GéÌÂÖ¥g²n¢€#dŸ R¹xø÷Ø‡{]Íï1ï×©î<Ón°H'Dê8B#2_üDDTú Ó O·óiVÙdŸwªuÛEÜ£K°¡¥B2â2J’*¥zä^ˆŒ#4z‘ª 3ã8( 	1õB.“-`¬¾Bäa@ Æ(\bË2oãíKVùf©wˆŞM—:
p¦Ø Æè°å\J.÷ûZÄqd±¡Õ (:-D#ÔàëIu?B+ièÓ;æÌ]ÆÀMÇõv™#OÆ€PÃ¯êåâIO=ˆ}£×äêsÉÖ1iu}C	2sÅœÙ±`ä›ÿ0. ËM©)æ‰AkE2×Ìu"ciDD'Ù¾7zFYÆJqyúsz¦ë»/våë[«·YA÷ö)7ÜJ¬ôÆ1øğ¬éÒí¸"ğBà^é¢%êvk£¤¿5-X†&› ê
ğ1İ^š‡æè1übR|ëÊyd=V+FÑkPeósıÜ9éH6v"Z*öb.w9‰Tz6/éOghö½»åÊ$?_§<‡ü.Æa÷Üå>`og¿MU¤ªˆîÚ~¶%>¡T·Ò~ 4ôô"(×ĞEv"<…§zæÊğe;m!ßå|ä®äHM6¿¬ur
/4?¬a"š÷¯ˆ¤»ñ”ÉIGŸ5}Z€êäa÷zXQv·Ïoyifdàø©m
ù-Ú$–hˆ o,Ê~óoVâ¥	şttÓc@4ç
Hp#­3o>(²ÊQAAI¡D *¡Cfõn†o‚Móöä::)º¨E.G*¥/q_ù ä‘T9Nçá~-è˜GíGƒ7^'ørÒBÅïP	\dˆÁ#­"¸Ñ«n‰b¤sfôøzí fŸª5ˆçìğ<¦cOæpoSW\€)ÌK8NM¼Swè©÷„‹yq|OÖf3‹.F"ğb	{ÿ¥Ô*‘ùdÊ<sB?<‚l:›Dß¡Ÿ2"æ%å’4 dóvä1ò|Ş’–"I2ãy!cÈp'pûEKpŞç|lvŸd±£%g³ñã¨Õ'³¸s¶zfÕiÙ7‘!! ŠuÉ4Œİ3"*oìƒ,p¢õ»á2FğDc«jaç¹¦1Up£äuH½ˆe*ëğ­LÉfv%˜ ·G"<!ÄŸÛ—˜áSjd«¯h,âwÒºB¤p°áë­‰×8eÒ(Xb[}ûrÇDÊÏajÁXK+JGmVÖz\åÃî ê§~ãsC}ìdç;gALf,	eiRjx]^ëU©1­	]9ÑVúy]ÊLæpÅÿ~úùãP ô§NğÄñ&õg0`hG.C²K™e#¡ùÒì@«)é£„!k<àX…l* Ã®®† ± L-‚Ã$åÅíÿ-óed^•oEH>(mOr$Á^uĞ0¶Ç™eíQS‘:	¦>$eSá¸lh#—6``.SëÂö­xTâ dçéûu‘Bbİcv«Tu¢Õº‚vÃ:;zcæzgc-_ü|H c(Ğ9Õ£©¸#/0®§Îåä%ÖY¦ÖúwDÆku°aHø]{Ì²ÀeÙ£Áåln…sdµş’:ÊckbWs3dñ0izrò‰'ŞR]«pÔ@¿fĞl~öŠc „°$õõjg •S*kjXg¬C-Š¤k,k<*4ŠV:¼
ª1¬ÈÃïiğK”Ğ|\\[>t†A~o`0åìohœ*yS?ïGÔ%F`ÖŠ¨/÷	Ã>+#Lÿ™t`¬¥G=y¦0|EÕçT_<F_ÊÍÌ	@Ç¶ÎÎÊÙn-RXK}fBÉqGd³…
2XÿJ¬wƒÂ!h>¥nD ¶¨Ä|‹GbËÓ/´â´"v)¥%Nà„*á#}Ñğ`f©Èr9e@¦òbo<6pÊw‚}MÌiÒ=T¸ ¤¡éêq÷%Øpß8Ç+mb™ÿ¤&!"šâí‘2Ü"OsçOAju5'„et/!¢½ÚÕD.É3PQÙıŸ@SÛÓO^XüÄ°@pëäaÜSÛÔe5JPzáÆ7^îSöZ€å‰dõæ\3ò}x|}€9^ipO Úğ ï^yLRÎÂ'9'!é(ª©³Çú_„JE3:—vvkTM¬Ójhà\·ëLã,mhÇ»™zdáR/Ø}ŠØª·b¶Æì—U5çUO‹%æB{N¨ræ}bXh
,m­lvZæør.ıÆ€Ÿ4‰ä ,$qÈàN,7OT«+¦ù1ç>z2û 	®y,/Óvè'ò¡Jùvçöc¼8CGHXFîyJn¦¤±€}Å41Sß®I6€)ÁÑ2ò¨)iM¤XoãÓ¤ºTÏÅ6ÜßèKLAÕŒÙº£ìMf^íñuÈÇ.ø‹İ¬‘¶"5ıì±wIm|zm"„ü=£9bY&=áä1
.€L[jÈ|†ŠRzDC&Ò#Îaä® Æ-aã'Q½TÌÕ$éıgsö‘0zdqhR©d…¨&Á}:.Uõ]úíJ lLcÓKÕ°æ$1.$CtM;&†%üâe%dÜ—NdÇ‰&ß÷ Q-ïõdoO¥=^|Á§ÉÏ-ÅÍËU©~1	€bşïst˜Ÿdu„/AGQ×3agë‚Ï¡õgy½ñò%] nĞYj£?œ $m ø¦‚“d
(Âò()&1ğéîŠÂ@A­V*Ò0©81h«åH3u°Qdå6! \‘},(³è€Á à“"ğ¢& $ 0ƒÆ"Âë"x¼7 _¸¢šql¦ücé¡„?¡tll>ÏaÒÛ0-™ï÷3?Á?Æ×‹ø§³¯`Wmò®…Q¥# a©a)¨!„¡üXu6p´ºP*,eà€* °@EâÅˆªÉ—á«bƒ)àşj
£@TLßÖ^ú[€'òäxpMq»iœsa1.¯³óâ˜Iõônt(5éüå’u	+ Ë©Ù?uìÎjÔ}ÚûªårmŠ1ØAsôé{O˜T`z! Ÿ‹¥Q‰ûpzl¨ÂbWa£ş`‹f™JÒŒwĞcúVd¯«m¤Š"úím1u™ávÕÇ‹6ß¬i[Ô/‘jÇ*ÖäàËşº”3Ågà±mªY5*> Ûéb@w
4#?”jÌ\=b7¥d„"YpÑg	Ê©Î±VÖ®İ¨
Àå$6° mDèÊrjÆ1`)¤|Âe)ppti\Â{¤=^lµh·u;ÕrQì÷ ™ÂåÉ?˜rİûNÈu]ôæÔaäñ2W„øSXLú`pdv¦•pá3TçšA-[ÜS&ğÿá5QşFîÀ!ˆe>xKåÇúilCÔb˜ğ±ry|1Ôëá¢6š£fúhRƒrRiUe@ÊBÍŞüÂu‹YUxã2(9;mL@K€6~. ÌiÕÍzóp‚b¸kÈ,Ì1‘}g"ã'IÏÅí÷	+´ÅÛtø&.‘£o/°~;ûŠyy'l 4Q>št’§E[ÂÀqiRJ0dÁÜU;´Z^d_³(–æp	¾á>óhóÿ.8 LrHgÿbls¿%Iq.…İNëŞÿÎ;#$ût:|.Ò¥QCé
Et ÎI,ZÈô»+³™XQ‰ï)Hñ­0³S,ıd°SWgèIƒE:ğ.XO¤I°¶ 0‡¢( e€!)00j¡ºe€³ã1ËyuõdÎaıÕÀNäj¿V’=œ#M T{ä2õƒƒ¬Rø\¨uø/spOD¸¥åO3FæÂÖ8 qê¡ê‘Løƒy~¦ZL$)@áÄlï‹mÏbs^IR{.gš./®Šğ{¾m`âèµ¦EN9«J^‚¨**"YL”V{=ŞWšA|<KÙê[W¡cÖì$W/PjŠdB’õÒ–oÙˆñã‰x„hOåB[!W(qMJ0†¬ëU{DD*c[²t²v¿¶Œ8fßQï®yU@¶]ÃÅ|Z¤ŸÊzAjkÜH|å´™äjD°mnRângi
ùÎ29!5Ì¦P‘§$ÊÍcÁ9éu¼qšSÈ<b )Ô³şĞÁ,#néânÇWï¥@5¯,',èÄ8[pl8t‘Õ_Äv×¾J{a«JláÍ2ä6
[ı±¼f”’rÁ\M¶Uó£b(:qQ½gš ç-êgW„D:C.­üæJèğ;.iÂF¦à.äáhğO€Ò¬‡9òdìuihßî9R]ËD³çám­qQı!*æQ&UAõ'WDhëÂÃ«€„ùõ0+ˆ‹C8úÅİ 5;Ä˜FGr5cy•|KãËëB‘Ajg|c(\G”ªnè­}Qt;_ïÌ•]åMKFäÀÜ@bNgû u=xÓÆ%ÇbO6M*±eÉpêè²=¨åKˆRFì#n%(lpl`í3­^„ÈY2ËÚ³iãÍN±S4Ióaágj/ì! çy«íõkÙaışÄÜ$'Z~ó$P}(·/¡ë¦„ä?aªAc¥‡í'Nó«fÂ¡¬ö<\>ôšLtõÌ/ªö®õi/Gb¼ÛAV/‘¥Cæ8{Q"³°mÅ+İhç²a²D¦ä(¢^ß. ƒ'c€İoû‰hğÒzêGû­ÿ,Ã  `Şa_]r ^à¯î2òÄäØLD¢FgbÁ-Ø¬oësØì‚á$”MÄbzh(yš%Ö3•ÉÊEàœÏe`’`ó|ŒQåœ.û5e!ñQPè‚zïéÖoG‡¾Me‡JRàBjb¢€°¨%âñÁ Ìh ¤™ÅJH%m,ˆb]>?$aØ<i¢d0‚(Öt_Kö7`×ßk¢›v´gİc0«	àB,~
jYã D&ÓkHÄJß‚üI¬8Bøl{xİ[XáÑ £pw¾eEQ>ds~†¿¿,)"lÙÖ+Ä~{ª¥Å(Ó‹T¥h]óyV7vï„èñ6ö^+ U÷ Ì-#Kn2Hâ.ïÎŞğZb¹(§íEÓ_Õ¾(<An¨"°+
ÉŠ7p!qfô­Œ²6SSô!‡cJ:/WŞƒF´m
ÍoàBŠ‹BÃ Á5ËêNÂ”ıçn&œ:uô‰p^„
:&ú'e­ñ6Œñöv°»~D±Œ;ÙâfÖ2@p¥l"FšÕnkû×nKPR)TÍ/¯T–Wâ0ùO)aµØ~Î`øk¨Ã_Åô¨ ©év(,¸ jºZ:gòñ"?èopl\+Á–irQÓ,@(Ìanâ(§%?Ğº<‘‹c©¼¥q»å½{h
ô ıB"â‡û* ¦#MÅŠfk!bxrËËÊ²ø³9Ó_KôZÂÕmmpÚ–ã½”éfr;Ö îšüÏLÈŞŒ	godV::/ÉËgÅírWS¬*&n÷[~3_Yeª“vmä.	8ç¤b)ƒ€PTfà<ÇFrÂ‚S½ÄsÀÀÀ9!Ñâû ¡ £¢Å$ €JŒoO¹³vu8y÷¼´éqM7™;ş‰ lïé"d1•,aq(¾ˆQ¢÷-Î7Ñ)Ê#Ÿ`£í/z“¸‹i5íE ëÒ<àdYùÃŸ#-é‘')¤Gí³¾QP&xÈNYU+Œî1ºa|à&´ˆ†¹3d-ï¥fz#3X‡dUà3"é<Š!ğëã ¨)wÅTvôıgiĞ	yìÈ ½ÿ¡ ,@ÛÀfd1Nıp+©eütê(håL×ÕaÒ]Dd®±z?b\\ÖşïEøhHj‚üTYö@cJåíh cNüõŞ8Ñùc·b7É3Ê(&eTî`e²ˆwd³½i{¬,äNÀıgD!nWe_”ÖšS~ÊëáhÏ…1kÔR†%œàóh«Ì”„.¿«&(îù-y0ø‹ğQÁÊñ4ó§)vÊ!˜wDr1¼wRtå«I 4h7Ñ”Y°EÔ·€ï~ANiÙb e)xºàc4‘hJæ¬H%$£·>éb„"šw1ï²E¬eXzÓ	¤dÕU%’j.0r+èësÀ¼â÷¢mş	î­§¨Ä²pItÒp4öäŞ­m`q±ç/æ5çcf×DçÂ²¨ø)!‚~	_ByJ	]Líxd9rÇH?kMc0*¦ì3ëaWvUéÏ¤É÷ë¥{sQLÙkÇ¢Åİö›¢Gq‰„m‘kV!PÉğ	ªå40xÀóæ¥&÷-8>ğ@cÕ¸ó(|Ÿqø½P–Äó IŠ›,‘>İDÑg~	8©Sèq#Ì„âaN°Õò¬ñGo@îe€4.ZkP$ş{'®xI]Nz$•† ´QH1
ŒÔ>vPhNa™?=Û™¬‡"Xóó>Q.TÏlMÔkh¬Ğ)òêÑÖJ¦Šr»¹J^,4Msï;¯ò"›Ånğáú&]€DìëÈcÈ!@3á6€ˆJ"ä*	¨/.'B~l9™wì¨…fS>ò—e-Ş"õxGpX—^Õ ÿéKâÄySEæ{XNEï¡Šìï¨fQ äØòá3f:ÏOL=‚ÃTBàã²j­oÄJ+Š•âWîâc3Ÿ2sèÈ)~LïAÀÀa?ÆI-¾óB…vô’…`O€´àì“—2QK˜¯ˆsJRleˆÄI(¤.éL#´ o*{ÏWÉçkÓHv¼	S`ãähhê‚ s@Ei\.=ĞnßâŞ,Êo&ÔÎ-*LdaoüşO2Imèoİçvfct|A/€°L7®¸lá½‡şèË­Q×.UÆıšñÖ!}ä|"s¦-®µg&]kûÈŠbö~ñ4ì”o7|FşÜm±$nPcIuó*0Oó°*R+eb6kåq,yÿgm$uÂ%‡Îd’é,%N$&îœJ¼ŞoÕáˆdªCÎ”<„8ÎeníBV Lh×tø cSè¨o#àfqtÄğÁë½f\ 4jĞ]ÎS­Í@Çì`:œú¿Ö¬m²îw¤’	 rOøDáIOÛ×œUä#‚Ä%‹tKqdèc¦ ¤·ÅŞ‚ÂVæ²ÿ!*=ÏîO«nßÒ ÆùÎ|Œ(ªXg­«%ZG¤ßŞ3ççw ãÇ˜÷“Ê&a,h*NwP`'üÌ~¤0ékø#³N+ßF·<]j”ã^uöÌ´Óc8ÀG0ÈM'?ü8ğşÔÌ%
$(J5'¨!ØÃBÚ «§Xs)}Ú¦ñ+$pï¡.:É„úßó’üLãmÑóã6éä}b `(EóaõøPÂ ‰… # S¶ÌuéE…{¦  $‰L™Ê‹p¦yLå…'Go\u°°ğàÛ#­ÌgÄ½4â>HÁ +NÿTŸëîõ\çú-æNìéjq@©Ã"ÃkM=òÌækì'8Ê´Ò+ójj:BÅ®!	$ÄÃ|úè€Q_ğ÷léî±ä^sê nàºj|ß÷aÏi=bÙåUeaÖ·¿¬ dàEÉÈAùm¯*¡Ì‡è+Æº–VR¼*s=u9æ&rHİd,4jNE”}ÿmÓËEX$NpàÂe±TÜXúDvcäÄfÁo„H¹0p¦­¦1Ïgf âÿ-çidŠ3+õ	ÑV8²l¸‰ì}'‚iÂSSøÜmÖØÒ¡KÖîfYÏ*PAëCèâñjuÂ Ë:él-ıäJ
˜¤¡hÍS2(HD*¶s!W5âg(I"Uéto(m"êL¾ üäïİ ø®/`fxæß¯–siŠy_òµ3¥}Glà1p(~õ$4l36¹.a0Ë§ãz  ?tÓ‹Ì#VSÓş€q}q¾…ye„Ú®UK9æ×¬nä>5Ô*8ìrwÒûDí rÄÜN¤N:‹£DeŒ6oìC<})upêl`Š¯)`¨¦·!õvÏnaô/Ta?áhÛ$Nc„=T 	  µV„/x9DÚZ‡_Lópp@}\Îd´Ÿ¥BbÂDRM|y`Ë{¿;ŞtÉcCÓC"l'ñá!¬¨­[lDş¡òÊ(¢àá¡Â¼XÑrq7µÆG7Md!Â8…‰ùnI(³4æõîdA1îuÜ~OÃ¡ÊDã%@›ævDã§è ¥èÅUÕtqù‚+œUQ^¶b}ª°@gEV‘€Q”›€¸/Ê(™*‹1b"$#">Ëª6ÕY5lê&í‰b&lÌå®è¼|BÌøou´ÛL2PlSGåÎ¾Nl9åJc1CbĞÑâ|”`š­0@3,Y÷Wp £1®yŒQÊ/ƒœjÆd6ÉaP04mëW^nñ‹'"lQmØø}å»ò1„÷W¥*ş y£º*È"™ÎÇ¥eBËÚ 6-†$K,Úe<Ä¼fQ!ğÓ›c[VOğ
‰ªæ áÀ@ÿÂ.ìø(!`„+‘ãà?¯¥,¨tP,Q[qú8Ÿ¥`HiHĞx|šh!µ~}1«DV½,#ïÄ73ê_ZÑ>¡Ã†TN¦ês¸gmÌæm)á\JåÃÂëg| ¼	cÅ# óïoé{å|HYÓãqçÁ#ÉÔ¼l¢Ê.öW $Âjahà‹H`g©òĞ¤¿ÓõçÇùn÷2E±ØƒA{\ëmvçŞ@·¨|ñJE¶ÜéêZ1J>/oÄÚ—¸róèÍeñ0äk™2k‘w`ÍgÓÆìÚ¹Åè ¤¢í.7V=-AÍd>0UovgVOŞ.S–f”3N|ôíLç'ÍmşávL¬afm7RK'cds7$%ñÆXŞCnEn%™/.)…TEì‰i%Àåm\y%'
MP·’u®4 ¯{%'B5mğ¿£dÙQÅè|T‘èoÎßôá€ÃVc¥M%[ÜÙx[!÷_>¤tşë÷îÌÒt¦$÷Tp.ÿ¶b{ßTÛ
·Íµq`Tw95í{Ø¿Êéôé=Ìa%p¿)vÛèxçâI¤VÈÚÆñSR¾$ Ay2{´§ècÒ/k ’{¢(î|R’!u¶¡/ª$AşÒ´F‡FÆcX-HışTIöm6±Ô©x,U²‹ò,Lp‡NXóuy·|ä–È	yån‚¯íV†ƒEŠ‹ ¤5O/Ä¾0@jåàİâ:P
w5 ®o%P(jáã®Ğ“ê~vÎ1Å#©ís(æ·¨Ém¸ì!R Œ2üw›ùVÊ‹(#!-q+¿¡Ë¥#`½lvthj€J-°Ú…jA+n	ğÿE4ˆ_sbVÇs YÌ+!î51ÇõÄfqéc{ÙX´¢Ägg!Ñê©Í­îøùü¤Ké{kd3Ğs9eK±Â§¸}Cıg8óÇ+mH¢ˆQƒdH>Zãd5İÆwÕaä{ã(öKşçxáõEäÇ?r`#Kò}dÎKÖpiì6sÑÔæQnGÂcwØqü«ÅraR5tRR")ª9äQkéCõëTGu £3 pf»oÌYUc»zº`öá%ræ®Fğø_ğ.vÓsúUİé=_ãÍZ‹æé¥7*_rwİs <Ä™å¿^|ñîUN¥¦fëß`Ffcl@oé´ı*<²ËGæ qtŞ~È1ü®RØªƒ§c+Q!Ã”Í*|`ßÒ·~¾L†~(ûÄfG,…'á5"R<<ÊğKAEh+¤O|Ë"uwù&$¥.«êU¸("	]lp~ëI:dïaexgm9®ú+ÛîÌ“k·UhFœOHu!a³/äÌ‘t«? ÈY(ZY*eÖ[f©p?QLõnZôx$wñwnë­fptgñXõ`F$¢xd{(á…·]:ÌoğÓk„|9ô:¬öÿ 4Fvâ™ÀrÊgjÑíF$$ÈkÀC;ş+º¡Ê:8Ãás€¨W}ö"5!eıÃoÄ|‚p	#ğ©}t»ìÀæ,E
òñy'årp=xC5œ0 ê¡@#a07ªäj8Rd§»Î0éhÂÖ A •;%tIsóEh—Yõ\bqãşŸ ~s‰6)¹’/³?_îü·6mjr`^PPg»?Å&…hö)³[Qgıå=ec`ÒÄwaXÊjE{k3a9z‘snn[&Ò(Ya#1-6
qàwFa¼&ğ¼mvl3*>dWk¦:E˜´s» uzp"dË+êE„vKe=§'‡^úhù0«bäzù&0WÃ ô0yÍ£NÌalmÔüoç0ñaxhm°î}d´à#IóÛ|HŞ·È%;rFd 9sãøá‰tè²âé/£
7r0¼]"l ©uì÷4qxcânâä!şdkw…PurW#gËãåjxR‡¾ZgÒ %p?şberl<¨_,ÓkŸüíIì¹/« ~µ_Xÿ·t$º¸Ëåb³p]t:iè [@õUâI¾C/B§'c’h™/†õç-hOtPqs¶±ò[ï‚Ma	5Ù'k ª¤Dµ€·cõiÆ0@hqaqB¬–>½ èbñ_nraí•h ¸vÿ"2úyaK×='²j3¡orª-­ Çó“(!yfh}_÷SP4ñIHGŸ8NÔ‚yè^'ÇpúsÃR& Áw[*bxè©vİLˆ5ç5¹şÿãi '…­gûÌÀr¦v2~«ˆ/!`¯C°o’¢Ô‡}”]Ìª1-ÇŞ…O4n GNn3#6ßt ôRú @Ë"N6ñhV3d?®;qÙKTiRñ¥J°âgJ–£¥rà^	!4z‘r07áöi¤”qÑbfdl¾Bác` Â(\cJ26i}ÁR½dºg™G·:
t¡£È C¸!­~Niç;D~ev¬¥_³*¾$D#”Ä«MusKxé’»gÌ]ÆÃMÃıe‰¼_†(Ø÷íëİğI-z9£ÖÆës‰`±ie}
!32¬¾#`¦¨a.!ãx!)æ	SË*E0×Î5$á~Ddgù¾5zuùf[9yj1
¦ë?(m¢c«·[I÷v'r Ôê­ğ`1ùt¤Ñ7é¸&°^j,ù¢§®~kN°$¼p Ú¤& «Š7qq·İ_åj$ørR~ÿkyd=V#DPñDñwüY©J04rI*gz&wy˜E:§(+ON-3¶?ó¥æ0=§,—n.Æa4Üå pn%½]U´ˆ”nØ.8'>±4µwöp(74ôF¨ÖVa~a>àµz¥Êğe;MqŸÇxñ.ÆÏ!?ºìuò¨0?äe¿yå¬5Š`áÔÉŒD_ÏŸmV€jOyßzhP23ş-`i`$`¼ {hñ-ø4ÚJ„ m¬@~úïò¢%&t4S DdìAugü1k5aòÊu!A	¡ (+1fqj ôf‚Mcvt²A:Ap¨4t$c(…'1_¡MìÑÖ?N'…z]ë˜GLG'~eø0PHE©/P
tì3í#¼>Q:o¹b¦"d$Øk,¡nˆ²,$€Û†ìp|wãJæoWw8 ­İO,no¶–Wø‰ñ¤3i1tÏĞv×"ÛnG7xe€3ÿwujıÔ‹–?vC¿8–j›XL>sj$ç¨<gåö(äò8Ü”f	10áY!shUe1{fRrMí|¬w¿t18•â§g£ñcàğ'#8r¾xfò  ¡§#!€Eé: Ì‰"
Se“lR¢å3Á3DuE#«(c?½®eu‘óäuJ¬1ˆ ,êø­eYd²e´ µA`|?d¿û±( so$©/h¨âvS¨@'¹p°±û­‰g e–<`Aÿ/rÇRCâen`XëbêGíbÖdZ8€Jæ ê¯vs3cw``e	mLNF ¡aizê~äX¡{Téq­~¸7ÑøèUî\bhınú £i e§fpdT ÷a°fju¯B2Ií ÷qùÒìA© }ıi£ÇO<ñØˆ?lo,Çª¾"¨W OmŠHtGoï-se-|mGH>8HT~/“.}ı³õ %©Q0uM¢!aRå¸eì%Ó"`n,WªŸì­S8tà4¤rsñ{”ÁAj/ar¯r5j–ôztö~{¡3ìv‡aa=_ä}±¨‰gm8Ğ9vã{'ğ”rn<Gd‚oGíà¯uFS¢FºwÏnu5ğaEx9såA÷‚vÉïíçl~€˜3BµşÂs(cTs?2p xz{ò­6ş/ ÔH6gùlræŠc¡$ğ„uqnw$ÕQ:i+X4aìclU,ªäkebm_'(²r4*UW8ıkµ!­ŞàÎlôoLÔ<pI{x84¦e~}qmÌj(Ÿ*!pW?,kWä¬áÇš¨¯ñÃ>E##\»™4` ¿¡W}¸ê88ÅñçeWm"<vZ»Ğ¤
NâöÒ5h™n%rêK}s
ñv+
gXúJxwâ#hx‡/~M O8¶Øó|z_bÃ '´ót"s)³&8îâ&º¡§lø4`f©ÂB;g %÷j147pG
tº>INaâ@¡,Ñn5u@›RÚÏ…yf9[aÌafÒg¬ï8Œ
Oså#AEj}3Dwô#!ç¹ÈuBt
.É-·<0¤Ÿ:_Û2ÇXìDôDprå`]Q[À%5JTrĞsÇ?Vfs÷r€ç	ôgx1äİnXtÙ„”^m2y âğ`åN,]aŒÆÂ'1/#i{¬é÷dÚo¦J Aa:t4KL­Ù:xpf]³ëh©-olï*™jnár)Dİ
Xï«Ÿs²…Œ.·U?eÕË1dF,èsæU~$hº,m§m^hç°pŸÆ€4Éô$ l°uqhbOŒ6Fé+¦%9n>{2{ _¨y</ÿ~è#òñ,lˆùvQÇâb,8c/NHFçmjn¢²± G=Õ48Q[¤M7)Áğ32*)ta,k§C¶èîí&ì_~_IEíİ°‰LftåóuÚD|Û,ß†2õiîöweHhl¨wè,’yàq2=áõšJÕÌ[{I¡º†Š[nz6C&ò'Ìi¤~ æ…+,bó
Q¥–íÉ$%1Å#6õre3Èr©t•,&$}2,mUxíZ |bYÁ°ö$±nüA4M)f’c.âd/­6uT—
m–«& WDW$§qDoª¥¯z¬Á™H—-ÁÁ_É^<I2ùïpÔ8¿e}ä¿@g×/!gêY‹ï u>x½aØ£]0oÓYJ¢/¶é|mc úæMv&	>Bò-¶0òéï	Ï@A	­^5(S0éºfqQ­&%P74ñude4E¤]T}<PÇA€E•GØAêC0£ tá8êÖ"Êç,yw_“¸îšq ¦>ciµ†:*£dll¾ñ`Sù0­+eò5½…½æÓŠzï“¥Èg-÷¤Ñå§ğa©u)ªqÆd|\w$T|»Qj,}ë9`ñTEæÑ	kbšX7aç~ƒ)à{*vB4EHöÆW_0À'fá|pEµ>iß{ãò"¿³÷s€Ë4ôk‚`.1Ào¬be(#(Á	(?0l bà©*e2o0‹ ÙGCähP{mšd6 #Ÿ+4scp:l ÆfSaCfp'öš]Vñ(u¾Ùi‹Öt/©o¤Š²áÍMk1Q™àTzÅ§	£ß¨hËÕ.å*v+Ò3&dàË²ºío¬±m«B7`*vÉ4Oá
PvJ6"?tjÍnPÒV4fdT5¦"QPÍo Û ÇW¹VÖ¦İ(
Äá$4ú eDìÆ6J¢”i)¥xò#)b`TkDÆsp=Vlõh$u:ÕrPÍ5 _şåI•ym¾^[5xÖòä.4_+åõ"g¥üSx@ú_r{pVFŸ2q	PÏ0U©[ÜS&u1 à4QşèOïq9$Šd<pcñ•ú	(×œfÛv5r1$4Ôë¡¦3EÛ'f’ûh[!rSkiqe=`ªÃ=.Şn‚u‹UX 0)9/eJ
&n&¦ôéàÎró8òâ83DnÔ1ÑU#`{7iÍEïw	!´Õtğ&tÑQg;ø};ëŠxÙ'î]0s<˜tó¡2ESÃáqaBB°¥á´"ZN^lOŸ·*„Thá> ò,8!HpÈgïb~õ- q,-Ü^ë$#3 êğ:|"µUki
ÄMHlZú»²’;èÉî(HQ­2¶s<y`´·tfé@$1®L^¤tïN%‡ª Å@iI0hcóâ1B­yí:–´`ÇAiŒòNd(uúF‘1œ*d¤0{ô2á‡Êµò8¨q¸/3 kOÄ°¡¥r6Vrbç8Tv¨#ê ü•Ó9-w¦rltı@£äëï&¨gÏb pVHwkf÷’On€¶»ø{m`cØ§¦FM»E[J^ÚèFŠZL”TÁ=!DOºF ¼JÙ|ks¥am¤U.Òt˜mV’eP68Í„õâP hOeB›BW*qIÊ "¬{Tû@ibg{}; úkV °Ï@nG=Qïˆwø,@®]à‡½SX¥½ÈrAjoÜDS¥q›ÊJd¸i.R¦~gi,¸.19!5ì¢7 PÑ!£1RaÁÁ)é|è1üQˆv!TÓƒ( néâoÃŸfí²A5,§¬ÁìÈÚf,tlÑõoÔf—:H9q²j dñÜ;ì¶JQ.³¨¤”’~Ã@¶ec‹b 2qP}3uà&+	â_7Ì ¾C.¯ìÂhi~;*yàGş àãÏ(ğo1Æ®†yv$ÌTı”~9u^[Ì·á8ï¾1Õµ!#Â'û&VYµÔ¯wEhé‚#¯€$}ı0+d‹šú­$ã(t:ä:$Er5cY•xc‘<áJé’yAkå t*È1|G3U¤â=¨}6w0oÜ•]ám+ba@Ô ä`#é¢q<xÑT%CFOºi+µ%ßp£à„ò5¸¥J "ò«cF$mXa¬t`¬3$~l1;Z3i§GvY5M”actuv(?¨#¼æ{çïéØcùºäğd…zdñ$Ayp·¿!k¦„¯¯0¢ËhCsĞèNq¡dÂÈ!,·t|?öÚdtÅÍ/ª6Ñk_&a¬KaR)ğf¬9s`*ã–º}•¥/-YhÇõe3
’èp·^Ş: "kİgóÉhğTÿà|í¯Â  lß!oT2¢Røåª¨óÄ0ÀH\V²D§s¡,ø®+oëC˜å…í_Drra	^Y›§×35é`áœ­É% òfF÷B|l+eœ.û4õ*ñq@òbtoÍrkWÖª ÅåLGRaC|zf
°¨%?ÂñÁ8ÎlÍµ½DkM'mÌCøb>-.Š!
ø|Ni²`0²hvfË{çwcvOb«Òä¤£'qo	ìF>¾
&ûYÃ Äv³oJãJ ¸ó-’B°N{( ßÁ@ùÄP¡!}>MEQ~İC^…µo, rDÙòv¹@¿?«µUC3©T§® Üa!V5ŞR`Œ`à6 –"$Còy
Ì5NvÂn3Xà%ïÒÜĞbiˆµÌSS{ñ½(r>OAnˆ2u+jÉxu`bü©œ°*Vqt7–e/Ww<¤-*"1àF)«ÀÂ€=ˆâNÂ”½¦,4+õå½4^K26ºW4/ğÓÄv03~t±<³ı<òf—6p!,&N5˜‡t*û.7ziRò)0í3¶t
€Q&1éO)-‡a~îÊôc Ã%]Exèb±82ÿvh*é 0oºÚ7o¶³ ?à/ØÕFyÿĞ“{#u07E*Éadâ¨df·Zğy4‘‹dc©¥!q3Ôı{h%¤àõD#$ä‡û& ¦aIÌ/Äh%`r
Ëê¶(3yÓ\Ût[ÖO$ »–`½Uƒ©rj9ÌTnšğÍIşh	gm`N3:gLÃ·TÅí dS	s¬¨ îçÛ~²\{hª”T=ä<$*8/¢`),¥ S/t<Q!ÄRRG¹ÀRÑÆÄ9"kîâ{áá<`ñLÆÃœ7)/F»²te8i÷ü<ìaM?éz%ı‘@håí£u±¥4eIm:¼£]¡w,G?A-JbOàò‰&ø“¹‹½3'x5í5PïÒtèdYáC#=I $-´GğëºUx#8‚J\Uc­Îašq~$.¬Ì$)+`-îíBz32Z$ÌÕà3"îxH)pû$ã¨(ƒ{ÇT62Vùeé`mî‰ a5çåq T#,,Ú@,cd1Jmp~¨ektê(hÅÛ—¥Re>3x/zxNVp+n"DzhÊ`n<T\Ò@ã"1èhäsLùğÏ0Qág-!âVÁ»Šêlfek9lmæWä½iv..l²dØôoD$b`<ş˜Xx-fá,Ï¶2)ÜK'¼dópå”¤6«6(öıi1i¸	pUa,óF4úµ+r$~£Øwh
¬ô~|á «k0´h75İi°GÔ·˜ktAOiXJqfax»hc ½f`fH¤!¥¶>7¾©`Ä1/v1ã¢G®eXò²µlTm1›*l²vé© ñÄœåeÔ“}ş	î¡¢ld²pi|Ò
u0æävïî%a`i0g.u¯!ïsFóOgÀ²ˆü!c”Q|MOyLi9uN-($9*,=ykv1*7Ä9kaWfUèÏ,á÷ê¶ncp®AsãëD?Nö("v]Øå]a6R1AO;Š¥1aÎçö0Sï4ç*ğ q|ñ*~Yù×trÇ² @M´Û=S<İº`õNr<©S1S„`@w0pä¦5éeo`Êe´,.aî'ª;'/~Ë;$•¦±%¼UL(C„<vR!ioa¹p˜{[l¶*Ğù÷4@LDM<$låkD0¤Ö©6>u”Næ rƒ¹K\m¸NUï;oòtìnÄ±º&]­ €­kÍCX£N;aˆN2 *	m¾wXv<soù¹lª€dS>òVå-Öbí\GFÜåÌsóII$âä{kM$ûIODï 'ü‹¼`MğåÛò`75}~ÏOl=‚9ï`bd«²j%şT+ª•JWê?ó g|
"sèé?¡vI(ÄÀa2ÆY¾³j@~2Öò”%pM%½gè“ß&[Üç 7Jr,!ˆd	Y(dzí .H:üf5w+[í\Ï£+³Hf¼IC, e(h¸²¸1UÅi^&5éîŸàÊ,BOo•â(*TddCiüş_"!/ì+]{>o3t}‚D’LuOÌ±lÍ•=“Ûj^ŠA—.pCtp´×3=/¨t2sÆ%¾åuf]©øèZr>l`2>ä?58úØm£ kpŒcIÕkcÑ37×Fód¨o"k>¶uhX×Ÿc(5U@4Eèı¼’ûIm%r1îO°ò\éĞ¡!‰äª›N<”?8i'"¯"F$FáÆ•tø¡o)Bê¸î	cq6y|d0@é9F]h%xÂ}ê­íDÁÏ <ş·Ö¤lº€ä?¬6	0rOleHÿÃÅœqõaòä$ Ëñpèa¦ ô¿0EJƒÂ^¶²ş +½ÙnfåoÒò!Ä¹Ì=Š9&>8g©+jG œ\3çcg.£áüöUJ"|ishz®szôëfİèt#Åpágx‡±I)ÛN–8Yc½µóf|Zö`<OceĞrˆM" üzèøuÌ]d4*j-'(ğãBú¤3òTu)xÚ¤y)&vÌ%$2«EúßáBôvD9Óm™÷ã6(¦]f`B(KóõxpÂ( 8c`4Ítóe{¦/ À?L‘k»ËD&Üí…'gg\y·°ğàÛ;-7Œeî=5òC2 ©É¢"+k2TŸëîÓ|ãú-lêhkkpM©×£cCe<óíçxl#q¼Ø«´ò+±$ÿ}FE1î'M'FGtúî9 UZĞ÷é®¾¬/qjnB›N|Éóo!)bıeUm0iÖµ¯«í dä MÈùm‰&¡èUS(F²vb7´'9e;¦o!>HŞv ¿¯N+Å”|í4á«EX"Op¤EÂ$ùtÜH«valÄöAçæI½ã@'½çYJEt¡rÿ-çie€+ÕI…uq’lª)æ=4gj6APS´ÑoŞhÂ£!ö¥tñÏ:ñëÃè®ñjjÂ¿ K{Ær’)ıl`vôaxÜ<Q0hHD*¶b9„7âgAt%W¡>/ê`+j*Ğîî/àóğº'"bfb×>cë y\ñ§3%='oÀ1`8~å,4€m77¡.ig'ïã:¨ 5%ñ‹Ê#^(3Iöq8±·´ eeš®ÿI3âÄ¬n d^Uß<¬ŒòvRáÌ)¤ˆRDÿnŒo;'£Duä±7.¬C<u	m‰‚¬'º¿m ÍD¤7©u$Ïm@Y>9Ğİq5à–lÊdF#Æ?T‡	 •~$y,<Dóh5]@³`p)bnŞà“!ovÂ@S]}8pK½{M½9àtÉsFÙS"|'1ñ!¤¾½YnDø!â0n:£Øé£‚hYb1e5dg7õd-Ò8I±>k(²4æÿîd!ntR~O|C¡¨º^âqÀšæ~Oã:£à ­èEdÕVry0ò+œWUV¶b|ù±àev‘„—Û‘¡Jœ“³`"Ec ŞÓª>İQµl'ïÎ"lÏıäé¼}DÊpg´H‰Ew'H.%S˜gÍ¼zl=åbbuGâ‰YPv)U`ºäpA;l{÷×p1wñ3º_Ÿ[yu"-OœèÔ@w™a 7=ËwŞna#&dPmšøí7hû23‡ç¥(ôy3ã¢È%˜şG gYB7šâ~,¤S$òe0´¼nu#ô‹ïc0yIø‹º7ÀåPHû‚$èü(%`€*yçá;•à¾(<d=QŞy~y®¥pHCÒ8xàQ´{m!£"Ew½®tí ?1êñpå†TJ®ªqyg}Îâ)k¡XnçÀÎ+"l(¬É¾Bä hóåÏx¿ô<H[ÂêqgÁ3ÉÜœT£ÊîvW"Ö„j`bô¹pènøò@ï¯qqçÅ9ln2EùÈ’rzl#]ëmæÇşJ÷¨}}k>¶ \éæJ1Z>-/:ÔÚµør±¸=es0äKœ:k/ ŠvÓ;ææ;¸ÅIÈ`„e#.Œq/ $D®—*2(Uo~$^Nÿ)U—4âsFlômO,oGMíúåv=,¡sm57[-ãcdw7¬5s¯BfUn%™/.¹Eteêˆc%à§Om|}$'G¿’÷>œ4 ¿?!/7%è¿¯eÙšpAütÓènJ²WáÅpk%môJäû~Mï×6¥dzb÷êívTæqP0.ÿugZ¯\¬×
c7é·q}\z95íúÈ¿Fú+òn1Ía`¾1-#W 9{çâ¬4%ˆÚ«¢×3r¿l0ayr{ô¯ìa—?, ‚{¡ ş~)P’"e¶¡/¢Á$C½N`vãNÄã5i=.5	¾-µo¹v©yA²V‹òHyÇèPN³5q7}aå§J	Ñåo‚jíT%¥—ƒ!o*¡Ã`O¿Ä=|dz¥æ×b"X*u5¬ş­:!7PhIåk§ñê~ßj#À·=©ow æ§¨É¨­l Mì6üt?ıRËƒ¼#4r;ŸAÍÏ#+ ½ìf|h~ 2¨c *%b+6-p~j4ˆ]sPÇs y·ˆ+)!ë6aÚ4tvqézĞP=ãÆetá°g)Í,n|õ¹¤
©{&$0‡ôV=%j7Š§¸y*ıe83ã+iè`«QeNA5kä4õò%õe {',æø|o ëñõäß?s`&jÖ7lÎAwñaF2rùÖ Ynsşrùeü»Õj=Bu4ê0iĞî=æbkùS4ıë‘\GsC3N" v½SÜyI{»{ò ô÷ rdNü.ğø?ğ.|ÿ
êØeé}|Êì~sfãqu"}bW%Z4¬Î©å:|ó/}*§7vãŞ`gfip
ïk·Tır¬bÃbÄ¤2a}Ÿ>Ø!Ôk®>RØ¨Ãtc«•!È”Í" ^á—Ğ¦~~na¿ÁfG(' µ'v,.jôo 4˜'5h}C2tñpd¿.âí,-&	U ///
  /// In case of error, the implementations must set `status` to a value
  /// different than `TF_OK`, free any memory that might have been allocated for
  /// `entries` and return -1.
  ///
  /// The allocation and freeing of memory must happen via the functions sent to
  /// core TensorFlow upon registration (see the `TF_FilesystemPluginInfo`
  /// structure in Section 4).
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if all matches were returned.
  ///   * Might use any other error value for `status` to signal other errors.
  ///
  /// DEFAULT IMPLEMENTATION: Scans the directory tree (in parallel if possible)
  /// and fills `*entries`. Needs `get_children` and `is_directory`.
  int (*get_matching_paths)(const TF_Filesystem* filesystem, const char* glob,
                            char*** entries, TF_Status* status);

  /// Flushes any filesystem cache currently in memory
  ///
  /// DEFAULT IMPLEMENTATION: No op.
  void (*flush_caches)(const TF_Filesystem* filesystem);

  /// Starts a new transaction.
  ///
  /// An opaque transaction token is returned in `token`. Ownership of the token
  /// is in filesystem. Token will be freed in `end_transaction` call and any
  /// access to token after that is invalid.
  ///
  /// In case of error, plugins must set `status` to a value different than
  /// `TF_OK`, free memory allocated for `token` and return -1.
  ///
  /// The allocation and freeing of memory must happen via the functions sent to
  /// core TensorFlow upon registration (see the `TF_FilesystemPluginInfo`
  /// structure in Section 4).
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if transaction successfuly started.
  ///   * Must set `status` to `TF_FAILED_PRECONDITION` if multiple transactions
  ///     are not supported
  ///   * Might use any other error value for `status` to signal other errors.
  int (*start_transaction)(const TF_Filesystem* filesystem,
                           TF_TransactionToken** token, TF_Status* status);

  /// Ends transaction and free the `token`. Any access to token after
  /// that will be invalid.
  ///
  /// In case of error, plugins must set `status` to a value different than
  /// `TF_OK`, free memory allocated for `token` and return -1.
  ///
  /// The allocation and freeing of memory must happen via the functions sent to
  /// core TensorFlow upon registration (see the `TF_FilesystemPluginInfo`
  /// structure in Section 4).
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if transaction successfuly finalized.
  ///   * Must set `status` to `TF_NOT_FOUND` if token is invalid/not found
  ///   * Might use any other error value for `status` to signal other errors.
  int (*end_transaction)(const TF_Filesystem* filesystem,
                         TF_TransactionToken* token, TF_Status* status);

  /// Adds file/directory in the `path` to transaction in `token`. It is a valid
  /// operation to add a path that doesn't exist yet to a transaction.
  ///
  /// In case of error, plugins must set `status` to a value different than
  /// `TF_OK`, free memory allocated for `token` and return -1.
  ///
  /// The allocation and freeing of memory must happen via the functions sent to
  /// core TensorFlow upon registration (see the `TF_FilesystemPluginInfo`
  /// structure in Section 4).
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if path added to transaction successful.
  ///   * Must set `status` to `TF_NOT_FOUND` if `token` is invalid.
  ///   * Must set `status` to `TF_FAILED_PRECONDITION` if file/directory is in
  ///     another transaction and multiple transactions are not supported
  ///   * Might use any other error value for `status` to signal other errors.
  int (*add_to_transaction)(const TF_Filesystem* filesystem, const char* path,
                            TF_TransactionToken* token, TF_Status* status);

  /// Returns transaction token for file/directory in the `path`. Note that path
  /// may not exist yet but still might be part of a transaction.
  ///
  /// Transaction token is returned in `token`. Ownership of the token is in
  /// filesystem. Token will be freed in `end_transaction` call and any access
  /// to token after that is invalid.
  ///
  /// In case of error, plugins must set `status` to a value different than
  /// `TF_OK`, free memory allocated for `token` and return -1.
  ///
  /// The allocation and freeing of memory must happen via the functions sent to
  /// core TensorFlow upon registration (see the `TF_FilesystemPluginInfo`
  /// structure in Section 4).
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if a transaction for path is found
  ///   * Must set `status` to `TF_NOT_FOUND` if `path` is not part of any
  ///     transaction
  ///   * Must set `status` to `TF_FAILED_PRECONDITION` if `path`  is
  ///     not in this filesystem.
  ///   * Might use any other error value for `status` to signal other errors.
  int (*get_transaction_for_path)(const TF_Filesystem* filesystem,
                                  const char* path, TF_TransactionToken** token,
                                  TF_Status* status);

  /// Returns transaction token for `path` if it is part of a transaction else
  /// starts a new transaction and adds `path` to that transaction
  ///
  /// Transaction token is returned in `token`. Ownership of the token is in
  /// filesystem. Token will be freed in `end_transaction` call and any access
  /// to token after that is invalid.
  ///
  /// In case of error, plugins must set `status` to a value different than
  /// `TF_OK`, free memory allocated for `token` and return -1.
  ///
  /// The allocation and freeing of memory must happen via the functions sent to
  /// core TensorFlow upon registration (see the `TF_FilesystemPluginInfo`
  /// structure in Section 4).
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if transaction found or successfuly
  ///     started.
  ///   * Must set `status` to `TF_NOT_FOUND` if `path` doesn't point to this
  ///     filesystem
  ///   * Must set `status` to `TF_FAILED_PRECONDITION` if file/directory is
  ///     not in any transaction and multiple transactions are not supported.
  ///   * Might use any other error value for `status` to signal other errors.
  int (*get_or_start_transaction_for_path)(const TF_Filesystem* filesystem,
                                           const char* path,
                                           TF_TransactionToken** token,
                                           TF_Status* status);

  /// Decodes transaction token in `token` to human readable format for
  /// debugging.
  ///
  /// A new `char*` buffer must be allocated by this method. Core TensorFlow
  /// manages the lifetime of the buffer after the call. Thus, all callers of
  /// this method must take ownership of the returned pointer.
  ///
  /// Plugins must not return `nullptr`. Returning empty strings is allowed.
  ///
  /// The allocation and freeing of memory must happen via the functions sent to
  /// core TensorFlow upon registration (see the `TF_FilesystemPluginInfo`
  /// structure in Section 4).
  ///
  /// DEFAULT IMPLEMENTATION: Dump token and owner address.
  char* (*decode_transaction_token)(const TF_Filesystem* filesystem,
                                    const TF_TransactionToken* token);

  /// Returns pointer to an array of available configuration options and their
  /// current/default values in `options` and number of options in array in
  /// `num_options`. Ownership of the array is transferred to caller and the
  /// caller is responsible of freeing the buffers using respective file systems
  /// allocation API.
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if `options` and `num_options` set.
  ///     If there is no configurable option, `num_options` should be 0.
  ///   * Might use any other error value for `status` to signal other errors.
  ///
  /// DEFAULT IMPLEMENTATION: return 0 options and `TF_OK`.
  void (*get_filesystem_configuration)(const TF_Filesystem* filesystem,
                                       TF_Filesystem_Option** options,
                                       int* num_options, TF_Status* status);

  /// Updates filesystem configuration with options passed in `options`. It can
  /// contain full set of options supported by the filesystem or just a subset
  /// of them. Ownership of options and buffers therein belongs to the caller
  /// and any buffers need to be allocated through filesystem allocation API.
  /// Filesystems may choose to ignore configuration errors but should at least
  /// display a warning or error message to warn the users.
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if options are updated.
  ///   * Might use any other error value for `status` to signal other errors.
  ///
  /// DEFAULT IMPLEMENTATION: return `TF_NOT_FOUND`.
  void (*set_filesystem_configuration)(const TF_Filesystem* filesystem,
                                       const TF_Filesystem_Option* options,
                                       int num_options, TF_Status* status);

  /// Returns the value of the filesystem option given in `key` in `option`.
  /// Valid values of the `key` are returned by
  /// `get_file_system_configuration_keys` call. Ownership of the
  /// `option` is transferred to caller. Buffers therein should be allocated and
  /// freed by the relevant filesystems allocation API.
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if `option` is set
  ///   * Must set `status` to `TF_NOT_FOUND` if the key is invalid
  ///   * Might use any other error value for `status` to signal other errors.
  ///
  /// DEFAULT IMPLEMENTATION: return `TF_NOT_FOUND`.
  void (*get_filesystem_configuration_option)(const TF_Filesystem* filesystem,
                                              const char* key,
                                              TF_Filesystem_Option** option,
                                              TF_Status* status);

  /// Sets the value of the filesystem option given in `key` to value in
  /// `option`. Valid values of the `key` are returned by
  /// `get_file_system_configuration_keys` call. Ownership of the `option` and
  /// the `key` belogs to the caller. Buffers therein should be allocated and
  /// freed by the filesystems allocation API.
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` if `option` is set/updated
  ///   * Must set `status` to `TF_NOT_FOUND` if the key is invalid
  ///   * Might use any other error value for `status` to signal other errors.
  ///
  /// DEFAULT IMPLEMENTATION: return `TF_NOT_FOUND`.
  void (*set_filesystem_configuration_option)(
      const TF_Filesystem* filesystem, const TF_Filesystem_Option* option,
      TF_Status* status);

  /// Returns a list of valid configuration keys in `keys` array and number of
  /// keys in `num_keys`. Ownership of the buffers in `keys` are transferred to
  /// caller and needs to be freed using relevant filesystem allocation API.
  ///
  /// Plugins:
  ///   * Must set `status` to `TF_OK` on success. If there are no configurable
  ///     keys, `num_keys` should be set to 0
  ///   * Might use any other error value for `status` to signal other errors.
  ///
  /// DEFAULT IMPLEMENTATION: return `TF_OK` and `num_keys`=0.
  void (*get_filesystem_configuration_keys)(const TF_Filesystem* filesystem,
                                            char** keys, int* num_keys,
                                            TF_Status* status);
} TF_FilesystemOps;
// LINT.ThenChange(:filesystem_ops_version)

/// SECTION 3. ABI and API compatibility
/// ----------------------------------------------------------------------------
///
/// In this section we define constants and macros to record versioning
/// information for each of the structures in section 2: ABI and API versions
/// and the number of functions in each of the function tables (which is
/// automatically determined, so ignored for the rest of this comment).
///
/// Since filesystem plugins are outside of TensorFlow's code tree, they are not
/// tied with TensorFlow releases and should have their own versioning metadata
/// in addition with the data discussed in this section. Each plugin author can
/// use a custom scheme, but it should only relate to changes in plugin code.
/// This section only touches metadata related to the versioning of this
/// interface that is shared by all possible plugins.
///
/// The API number increases whenever we break API compatibility while still
/// maintaining ABI compatibility. This happens only in the following cases:
///   1. A new method is added _at the end_ of the function table.
///   2. Preconditions or postconditions for one operation in these function
///   table change. Note that only core TensorFlow is able to impose these
///   invariants (i.e., guarantee the preconditions before calling the operation
///   and check the postconditions after the operation returns). If plugins need
///   additional invariants, they should be checked on the plugin side and the
///   `status` out variable should be updated accordingly (e.g., to include
///   plugin version information that relates to the condition change).
///
/// All other changes to the data structures (e.g., method removal, method
/// reordering, argument reordering, adding or removing arguments, changing the
/// type or the constness of a parameter, etc.) results in an ABI breakage.
/// Thus, we should not do any of these types of changes, except, potentially,
/// when we are releasing a new major version of TensorFlow. This is an escape
/// hatch, to be used rarely, preferably only to cleanup these structures.
/// Whenever we do these changes, the ABI number must be increased.
///
/// Next section will detail how this metadata is used at plugin registration to
/// only load compatible plugins and discard all others.

// LINT.IfChange(random_access_file_ops_version)
constexpr int TF_RANDOM_ACCESS_FILE_OPS_API = 0;
constexpr int TF_RANDOM_ACCESS_FILE_OPS_ABI = 0;
constexpr size_t TF_RANDOM_ACCESS_FILE_OPS_SIZE =
    sizeof(TF_RandomAccessFileOps);
// LINT.ThenChange()

// LINT.IfChange(writable_file_ops_version)
constexpr int TF_WRITABLE_FILE_OPS_API = 0;
constexpr int TF_WRITABLE_FILE_OPS_ABI = 0;
constexpr size_t TF_WRITABLE_FILE_OPS_SIZE = sizeof(TF_WritableFileOps);
// LINT.ThenChange()

// LINT.IfChange(read_only_memory_region_ops_version)
constexpr int TF_READ_ONLY_MEMORY_REGION_OPS_API = 0;
constexpr int TF_READ_ONLY_MEMORY_REGION_OPS_ABI = 0;
constexpr size_t TF_READ_ONLY_MEMORY_REGION_OPS_SIZE =
    sizeof(TF_ReadOnlyMemoryRegionOps);
// LINT.ThenChange()

// LINT.IfChange(filesystem_ops_version)
constexpr int TF_FILESYSTEM_OPS_API = 0;
constexpr int TF_FILESYSTEM_OPS_ABI = 0;
constexpr size_t TF_FILESYSTEM_OPS_SIZE = sizeof(TF_FilesystemOps);
// LINT.ThenChange()

/// SECTION 4. Plugin registration and initialization
/// ----------------------------------------------------------------------------
///
/// In this section we define the API used by core TensorFlow to initialize a
/// filesystem provided by a plugin. That is, we define the following:
///   * `TF_InitPlugin` function: must be present in the plugin shared object as
///     it will be called by core TensorFlow when the filesystem plugin is
///     loaded;
///   * `TF_FilesystemPluginOps` struct: used to transfer information between
///     plugins and core TensorFlow about the operations provided and metadata;
///   * `TF_FilesystemPluginInfo` struct: similar to the above structure, but
///     collects information about all the file schemes that the plugin provides
///     support for, as well as about the plugin's memory handling routines;
///   * `TF_SetFilesystemVersionMetadata` function: must be called by plugins in
///     their `TF_InitPlugin` to record the versioning information the plugins
///     are compiled against.
///
/// The `TF_InitPlugin` function is used by plugins to set up the data
/// structures that implement this interface, as presented in Section 2. In
/// order to not have plugin shared objects call back symbols defined in core
/// TensorFlow, `TF_InitPlugin` has a `TF_FilesystemPluginInfo` argument which
/// the plugin must fill (using the `TF_SetFilesystemVersionMetadata` for the
/// metadata and setting up all the supported operations and the URI schemes
/// that are supported).

/// This structure incorporates the operations defined in Section 2 and the
/// metadata defined in section 3, allowing plugins to define different ops
/// for different URI schemes.
///
/// Every URI scheme is of the form "fs" for URIs of form "fs:///path/to/file".
/// For local filesystems (i.e., when the URI is "/path/to/file"), the scheme
/// must be "". The scheme must never be `nullptr`.
///
/// Every plugin fills this in `TF_InitPlugin`, using the alocator passed as
/// argument to allocate memory. After `TF_InitPlugin` finishes, core
/// TensorFlow uses the information present in this to initialize filesystems
/// for the URI schemes that the plugin requests.
///
/// All pointers defined in this structure point to memory allocated by the DSO
/// using an allocator provided by core TensorFlow when calling `TF_InitPlugin`.
///
/// IMPORTANT: To maintain binary compatibility, the layout of this structure
/// must not change! In the unlikely case that a new type of file needs to be
/// supported, add the new ops and metadata at the end of the structure.
typedef struct TF_FilesystemPluginOps {
  char* scheme;
  int filesystem_ops_abi;
  int filesystem_ops_api;
  size_t filesystem_ops_size;
  TF_FilesystemOps* filesystem_ops;
  int random_access_file_ops_abi;
  int random_access_file_ops_api;
  size_t random_access_file_ops_size;
  TF_RandomAccessFileOps* random_access_file_ops;
  int writable_file_ops_abi;
  int writable_file_ops_api;
  size_t writable_file_ops_size;
  TF_WritableFileOps* writable_file_ops;
  int read_only_memory_region_ops_abi;
  int read_only_memory_region_ops_api;
  size_t read_only_memory_region_ops_size;
  TF_ReadOnlyMemoryRegionOps* read_only_memory_region_ops;
} TF_FilesystemPluginOps;

/// This structure gathers together all the operations provided by the plugin.
///
/// Plugins must provide exactly `num_schemes` elements in the `ops` array.
///
/// Since memory that is allocated by the DSO gets transferred to core
/// TensorFlow, we need to provide a way for the allocation and deallocation to
/// match. This is why this structure also defines `plugin_memory_allocate` and
/// `plugin_memory_free` members.
///
/// All memory allocated by the plugin that will be owned by core TensorFlow
/// must be allocated using the allocator in this structure. Core TensorFlow
/// will use the deallocator to free this memory once it no longer needs it.
///
/// IMPORTANT: To maintain binary compatibility, the layout of this structure
/// must not change! In the unlikely case that new global operations must be
/// provided, add them at the end of the structure.
typedef struct TF_FilesystemPluginInfo {
  size_t num_schemes;
  TF_FilesystemPluginOps* ops;
  void* (*plugin_memory_allocate)(size_t size);
  void (*plugin_memory_free)(void* ptr);
} TF_FilesystemPluginInfo;

/// Convenience function for setting the versioning metadata.
///
/// The argument is guaranteed to not be `nullptr`.
///
/// We want this to be defined in the plugin's memory space and we guarantee
/// that core TensorFlow will never call this.
static inline void TF_SetFilesystemVersionMetadata(
    TF_FilesystemPluginOps* ops) {
  ops->filesystem_ops_abi = TF_FILESYSTEM_OPS_ABI;
  ops->filesystem_ops_api = TF_FILESYSTEM_OPS_API;
  ops->filesystem_ops_size = TF_FILESYSTEM_OPS_SIZE;
  ops->random_access_file_ops_abi = TF_RANDOM_ACCESS_FILE_OPS_ABI;
  ops->random_access_file_ops_api = TF_RANDOM_ACCESS_FILE_OPS_API;
  ops->random_access_file_ops_size = TF_RANDOM_ACCESS_FILE_OPS_SIZE;
  ops->writable_file_ops_abi = TF_WRITABLE_FILE_OPS_ABI;
  ops->writable_file_ops_api = TF_WRITABLE_FILE_OPS_API;
  ops->writable_file_ops_size = TF_WRITABLE_FILE_OPS_SIZE;
  ops->read_only_memory_region_ops_abi = TF_READ_ONLY_MEMORY_REGION_OPS_ABI;
  ops->read_only_memory_region_ops_api = TF_READ_ONLY_MEMORY_REGION_OPS_API;
  ops->read_only_memory_region_ops_size = TF_READ_ONLY_MEMORY_REGION_OPS_SIZE;
}

/// Initializes a TensorFlow plugin.
///
/// Must be implemented by the plugin DSO. It is called by TensorFlow runtime.
///
/// Filesystem plugins can be loaded on demand by users via
/// `Env::LoadLibrary` or during TensorFlow's startup if they are on certain
/// paths (although this has a security risk if two plugins register for the
/// same filesystem and the malicious one loads before the legimitate one -
/// but we consider this to be something that users should care about and
/// manage themselves). In both of these cases, core TensorFlow looks for
/// the `TF_InitPlugin` symbol and calls this function.
///
/// For every filesystem URI scheme that this plugin supports, the plugin must
/// add one `TF_FilesystemPluginInfo` entry in `plugin_info->ops` and call
/// `TF_SetFilesystemVersionMetadata` for that entry.
///
/// Plugins must also initialize `plugin_info->plugin_memory_allocate` and
/// `plugin_info->plugin_memory_free` to ensure memory allocated by plugin is
/// freed in a compatible way.
TF_CAPI_EXPORT extern void TF_InitPlugin(TF_FilesystemPluginInfo* plugin_info);

#ifdef __cplusplus
}  // end extern "C"
#endif  // __cplusplus

#endif  // TENSORFLOW_C_EXPERIMENTAL_FILESYSTEM_FILESYSTEM_INTERFACE_H_
