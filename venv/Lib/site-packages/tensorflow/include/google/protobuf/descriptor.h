// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// This file contains classes which describe a type of protocol message.
// You can use a message's descriptor to learn at runtime what fields
// it contains and what the types of those fields are.  The Message
// interface also allows you to dynamically access and modify individual
// fields by passing the FieldDescriptor of the field you are interested
// in.
//
// Most users will not care about descriptors, because they will write
// code specific to certain protocol types and will simply use the classes
// generated by the protocol compiler directly.  Advanced users who want
// to operate on arbitrary types (not known at compile time) may want to
// read descriptors in order to learn about the contents of a message.
// A very small number of users will want to construct their own
// Descriptors, either because they are implementing Message manually or
// because they are writing something like the protocol compiler.
//
// For an example of how you might use descriptors, see the code example
// at the top of message.h.

#ifndef GOOGLE_PROTOBUF_DESCRIPTOR_H__
#define GOOGLE_PROTOBUF_DESCRIPTOR_H__

#include <memory>
#include <set>
#include <string>
#include <vector>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/mutex.h>
#include <google/protobuf/stubs/once.h>

#include <google/protobuf/port_def.inc>

// TYPE_BOOL is defined in the MacOS's ConditionalMacros.h.
#ifdef TYPE_BOOL
#undef TYPE_BOOL
#endif  // TYPE_BOOL

#ifdef SWIG
#define PROTOBUF_EXPORT
#endif


namespace google {
namespace protobuf {

// Defined in this file.
class Descriptor;
class FieldDescriptor;
class OneofDescriptor;
class EnumDescriptor;
class EnumValueDescriptor;
class ServiceDescriptor;
class MethodDescriptor;
class FileDescriptor;
class DescriptorDatabase;
class DescriptorPool;

// Defined in descriptor.proto
class DescriptorProto;
class DescriptorProto_ExtensionRange;
class FieldDescriptorProto;
class OneofDescriptorProto;
class EnumDescriptorProto;
class EnumValueDescriptorProto;
class ServiceDescriptorProto;
class MethodDescriptorProto;
class FileDescriptorProto;
class MessageOptions;
class FieldOptions;
class OneofOptions;
class EnumOptions;
class EnumValueOptions;
class ExtensionRangeOptions;
class ServiceOptions;
class MethodOptions;
class FileOptions;
class UninterpretedOption;
class SourceCodeInfo;

// Defined in message.h
class Message;
class Reflection;

// Defined in descriptor.cc
class DescriptorBuilder;
class FileDescriptorTables;
struct Symbol;

// Defined in unknown_field_set.h.
class UnknownField;

// Defined in command_line_interface.cc
namespace compiler {
class CommandLineInterface;
namespace cpp {
// Defined in helpers.h
class Formatter;
}  // namespace cpp
}  // namespace compiler

namespace descriptor_unittest {
class DescriptorTest;
}  // namespace descriptor_unittest

// Defined in printer.h
namespace io {
class Printer;
}  // namespace io

// NB, all indices are zero-based.
struct SourceLocation {
  int start_line;
  int end_line;
  int start_column;
  int end_column;

  // Doc comments found at the source location.
  // See the comments in SourceCodeInfo.Location (descriptor.proto) for details.
  std::string leading_comments;
  std::string trailing_comments;
  std::vector<std::string> leading_detached_comments;
};

// Options when generating machine-parsable output from a descriptor with
// DebugString().
struct DebugStringOptions {
  // include original user comments as recorded in SourceLocation entries. N.B.
  // that this must be |false| by default: several other pieces of code (for
  // example, the C++ code generation for fields in the proto compiler) rely on
  // DebugString() output being unobstructed by user comments.
  bool include_comments;
  // If true, elide the braced body in the debug string.
  bool elide_group_body;
  bool elide_oneof_body;

  DebugStringOptions()
      : include_comments(false),
        elide_group_body(false),
        elide_oneof_body(false) {
  }
};

// A class to handle the simplest cases of a lazily linked descriptor
// for a message type that isn't built at the time of cross linking,
// which is needed when a pool has lazily_build_dependencies_ set.
// Must be instantiated as mutable in a descriptor.
namespace internal {
class PROTOBUF_EXPORT LazyDescriptor {
 public:
  // Init function to be called at init time of a descriptor containing
  // a LazyDescriptor.
  void Init() {
    descriptor_ = nullptr;
    name_ = nullptr;
    once_ = nullptr;
    file_ = nullptr;
  }

  // Sets the value of the descriptor if it is known during the descriptor
  // building process. Not thread safe, should only be called during the
  // descriptor build process. Should not be called after SetLazy has been
  // called.
  void Set(const Descriptor* descriptor);

  // Sets the information needed to lazily cross link the descriptor at a later
  // time, SetLazy is not thread safe, should be called only once at descriptor
  // build time if the symbol wasn't found and building of the file containing
  // that type is delayed because lazily_build_dependencies_ is set on the pool.
  // Should not be called after Set() has been called.
  void SetLazy(const std::string& name, const FileDescriptor* file);

  // Returns the current value of the descriptor, thread-safe. If SetLazy(...)
  // has been called, will do a one-time cross link of the type specified,
  // building the descriptor file that contains the type if necessary.
  inline const Descriptor* Get() {
    Once();
    return descriptor_;
  }

 private:
  static void OnceStatic(LazyDescriptor* lazy);
  void OnceInternal();
  void Once();

  const Descriptor* descriptor_;
  const std::string* name_;
  internal::once_flag* once_;
  const FileDescriptor* file_;
};
}  // namespace internal

// Describes a type of protocol message, or a particular group within a
// message.  To obtain the Descriptor for a given message object, call
// Message::GetDescriptor().  Generated message classes also have a
// static method called descriptor() which returns the type's descriptor.
// Use DescriptorPool to construct your own descriptors.
class PROTOBUF_EXPORT Descriptor {
 public:
  typedef DescriptorProto Proto;

  // The name of the message type, not including its scope.
  const std::string& name() const;

  // The fully-qualified name of the message type, scope delimited by
  // periods.  For example, message type "Foo" which is declared in package
  // "bar" has full name "bar.Foo".  If a type "Baz" is nested within
  // Foo, Baz's full_name is "bar.Foo.Baz".  To get only the part that
  // comes after the last '.', use name().
  const std::string& full_name() const;

  // Index of this descriptor within the file or containing type's message
  // type array.
  int index() const;

  // The .proto file in which this message type was defined.  Never nullptr.
  const FileDescriptor* file() const;

  // If this Descriptor describes a nested type, this returns the type
  // in which it is nested.  Otherwise, returns nullptr.
  const Descriptor* containing_type() const;

  // Get options for this message type.  These are specified in the .proto file
  // by placing lines like "option foo = 1234;" in the message definition.
  // Allowed options are defined by MessageOptions in descriptor.proto, and any
  // available extensions of that message.
  const MessageOptions& options() const;

  // Write the contents of this Descriptor into the given DescriptorProto.
  // The target DescriptorProto must be clear before calling this; if it
  // isn't, the result may be garbage.
  void CopyTo(DescriptorProto* proto) const;

  // Write the contents of this decriptor in a human-readable form. Output
  // will be suitable for re-parsing.
  std::string DebugString() const;

  // Similar to DebugString(), but additionally takes options (e.g.,
  // include original user comments in output).
  std::string DebugStringWithOptions(const DebugStringOptions& options) const;

  // Returns true if this is a placeholder for an unknown type. This will
  // only be the case if this descriptor comes from a DescriptorPool
  // with AllowUnknownDependencies() set.
  bool is_placeholder() const;

  // Field stuff -----------------------------------------------------

  // The number of fields in this message type.
  int field_count() const;
  // Gets a field by index, where 0 <= index < field_count().
  // These are returned in the order they were defined in the .proto file.
  const FieldDescriptor* field(int index) const;

  // Looks up a field by declared tag number.  Returns nullptr if no such field
  // exists.
  const FieldDescriptor* FindFieldByNumber(int number) const;
  // Looks up a field by name.  Returns nullptr if no such field exists.
  const FieldDescriptor* FindFieldByName(const std::string& name) const;

  // Looks up a field by lowercased name (as returned by lowercase_name()).
  // This lookup may be ambiguous if multiple field names differ only by case,
  // in which case the field returned is chosen arbitrarily from the matches.
  const FieldDescriptor* FindFieldByLowercaseName(
      const std::string& lowercase_name) const;

  // Looks up a field by camel-case name (as returned by camelcase_name()).
  // This lookup may be ambiguous if multiple field names differ in a way that
  // leads them to have identical camel-case names, in which case the field
  // returned is chosen arbitrarily from the matches.
  const FieldDescriptor* FindFieldByCamelcaseName(
      const std::string& camelcase_name) const;

  // The number of oneofs in this message type.
  int oneof_decl_count() const;
  // Get a oneof by index, where 0 <= index < oneof_decl_count().
  // These are returned in the order they were defined in the .proto file.
  const OneofDescriptor* oneof_decl(int index) const;

  // Looks up a oneof by name.  Returns nullptr if no such oneof exists.
  const OneofDescriptor* FindOneofByName(const std::string& name) const;

  // Nested type stuff -----------------------------------------------

  // The number of nested types in this message type.
  int nested_type_count() const;
  // Gets a nested type by index, where 0 <= index < nested_type_count().
  // These are returned in the order they were defined in the .proto file.
  const Descriptor* nested_type(int index) const;

  // Looks up a nested type by name.  Returns nullptr if no such nested type
  // exists.
  const Descriptor* FindNestedTypeByName(const std::string& name) const;

  // Enum stuff ------------------------------------------------------

  // The number of enum types in this message type.
  int enum_type_count() const;
  // Gets an enum type by index, where 0 <= index < enum_type_count().
  // These are returned in the order they were defined in the .proto file.
  const EnumDescriptor* enum_type(int index) const;

  // Looks up an enum type by name.  Returns nullptr if no such enum type
  // exists.
  const EnumDescriptor* FindEnumTypeByName(const std::string& name) const;

  // Looks up an enum value by name, among all enum types in this message.
  // Returns nullptr if no such value exists.
  const EnumValueDescriptor* FindEnumValueByName(const std::string& name) const;

  // Extensions ------------------------------------------------------

  // A range of field numbers which are designated for third-party
  // extensions.
  struct ExtensionRange {
    typedef DescriptorProto_ExtensionRange Proto;

    typedef ExtensionRangeOptions OptionsType;

    // See Descriptor::CopyTo().
    void CopyTo(DescriptorProto_ExtensionRange* proto) const;

    int start;  // inclusive
    int end;    // exclusive

    const ExtensionRangeOptions* options_;
  };

  // The number of extension ranges in this message type.
  int extension_range_count() const;
  // Gets an extension range by index, where 0 <= index <
  // extension_range_count(). These are returned in the order they were defined
  // in the .proto file.
  const ExtensionRange* extension_range(int index) const;

  // Returns true if the number is in one of the extension ranges.
  bool IsExtensionNumber(int number) const;

  // Returns nullptr if no extension range contains the given number.
  const ExtensionRange* FindExtensionRangeContainingNumber(int number) const;

  // The number of extensions -- extending *other* messages -- that were
  // defined nested within this message type's scope.
  int extension_count() const;
  // Get an extension by index, where 0 <= index < extension_count().
  // These are returned in the order they were defined in the .proto file.
  const FieldDescriptor* extension(int index) const;

  // Looks up a named extension (which extends some *other* message type)
  // defined within this message type's scope.
  const FieldDescriptor* FindExtensionByName(const std::string& name) const;

  // Similar to FindFieldByLowercaseName(), but finds extensions defined within
  // this message type's scope.
  const FieldDescriptor* FindExtensionByLowercaseName(
      const std::string& name) const;

  // Similar to FindFieldByCamelcaseName(), but finds extensions defined within
  // this message type's scope.
  const FieldDescriptor* FindExtensionByCamelcaseName(
      const std::string& name) const;

  // Reserved fields -------------------------------------------------

  // A range of reserved field numbers.
  struct ReservedRange {
    int start;  // inclusive
    int end;    // exclusive
  };

  // The number of reserved ranges in this message type.
  int reserved_range_count() const;
  // Gets an reserved range by index, where 0 <= index <
  // reserved_range_count(). These are returned in the order they were defined
  // in the .proto file.
  const ReservedRange* reserved_range(int index) const;

  // Returns true if the number is in one of the reserved ranges.
  bool IsReservedNumber(int number) const;

  // Returns nullptr if no reserved range contains the given number.
  const ReservedRange* FindReservedRangeContainingNumber(int number) const;

  // The number of reserved field names in this message type.
  int reserved_name_count() const;

  // Gets a reserved name by index, where 0 <= index < reserved_name_count().
  const std::string& reserved_name(int index) const;

  // Returns true if the field name is reserved.
  bool IsReservedName(const std::string& name) const;

  // Source Location ---------------------------------------------------

  // Updates |*out_location| to the source location of the complete
  // extent of this message declaration.  Returns false and leaves
  // |*out_location| uNI|Sv/hDªM¶r9O¦acIş]à&oèh+îïX¬åïÈ°hï?bfØâN‹¾wíŠi
ñàså}Fgá1s<zá$4„ocw­.eË‡ç÷z¨pÑËú#^H€îUq}¹¿'heÅ¾Ÿ1æo»f†>$Ği¤òwÚ»Œ¨¤PÄ^OD*;£Du¥Ïs.¬C~}!UŠ¬eš»}`M\ä¦§©å&ËoH>;Àq?`Ú Úd'„_}U‡	) L†,=DÏ
×[E³`: %\ÎUá£õbæàS]5mtÛ{M?zŞuÉsV]C"l#‰Añ!¬ºízlOşuæ0Î:¢Èá Ê¨Hbqw¡Âã'ed¹ÂpÅé»¿I(ó#ãıîdAQïtØlO~Ó¡Š:FVãAu@îcFã2¡ÏèAeèÄULprù0“k˜[Tr¶btú¹€&Agb•„•û…èWÊ™n¯°c"ds"şËú6İ5löeÙÎfhÍı®é¼]FŠôK%d\‰M÷@_-SÚGÅ?Jl=ÅN`eFbIÑDö|Õa²ípT?nR÷Wp}„V£3¾oÍ_yÎ'ËËêÆ@7½aR075ÏS^naŠ5rÑlPmZè?¥Qû²#…åC¥rş*y¢²*'™ŞÖ¤cÜ@©Òãz8Â„K¬ßg(”¼FU#ô«ÚaSCğËÍ¸§ÌåLë„Œì|)m`éjaóå* ©|P=W^q¾ rH@à:pŠàP´il ¿ Dw
ı®6ü€w3ê"ÔRñG‡tNnîí©\g}Äâ-cñZNæÃïj|i½ËnÀaHôëçé¿ç,H[ÆçqæÁ3ÉÔœLz®B®ö×DöF^!~Ñ9IìføâÔoª&ÓyõçÀ¹Lâ3A»Ì"ArßQë-¶ÇŞ(·(yõ*>,¶@ÌÊªH9R>/k:ÔÚ—ø²ó,Ùeó°àJØ:k™7&Ï~ÓVÆìÊ8ÕIè ”£q*Î-ÉDŞ–.\o~vWOÏ.S–¢”­3FlølOãGÍışä6<¬©wo7?[¶wdt#d5ó†X®RNUf%™/n¹ÅTDüˆc%@¦m\8 %AP»‚÷ªäè¿> NBs-áÿ=pÙAÅ||Õ…èkŠÏáTãCc¥Hu
œØ~K÷Í:¥dªêw®­†d¦&÷Panş‹~bŞÏX¬ßJ7Iìq}%P895ízØ¿Ê¨ò¼9ŒBaL`^-5Û9|¤â[ü2%2ØÚº‚õSp,¿$4@q2z¥çìA'/ ƒc¢ïrR’$uæ¡/ªÁ$»Î¨N‡@†k=]ış|	n959Ğ©xT²òHéÅÈX,¶u8·_e‡Šæë†PníV3CUÎŠ¡‘7K¨Ô_¾$BzåãßâzØ|5®î/aVPhAác¯Ñ“j~J(Õ´‹ìw|¢·xÅ
2l"B.|öïıSK‹º#-q;CôÊ«3£½ìblEhn¢èK2Š…jå+>0ºB4Œ^gVËÆs$Y·Ìk ê>1j¤VfqéŸ{ŠÈ´cÄsf ÀûëÍS¨üíıø¤J­{ ‰$3PVy%[µÂ·¸9
e8³Ã"mìó«QÑMEâæ$EÖ5ÔEä{ãL÷˜úe*ëåuä{~s`&JÒ=lêIÆñiL6pÅôæSoPÇ3Ùqï»Är-CepàS0iÑÑì=äSmùGÁıë˜TgTAÆ"Rud»Òˆ[{»[ú(ò÷%ræLîDÔèğ~nÓ
ëXWí[LÌZWŸæé0U(o2GÜR0,ÄÙ|¿lwïeO·¶wãÜ`Gbj|"oé³}:¼æcG@æ¤!tuøqÔMçŸSØ ƒ÷cıÕ%ÂĞMjTZáŸÀ·u¾ÕÎo(½ÀdWl…' µ"R|,JğO"Ø+uN}Ë2uñù%f».êÏ8%f+]lş« @õíÊe|em)ŒúšÛèD’"Çu÷N™›ÉU#t³/©®‘t›İ‚ÌEnRI
qÆ2v­RIålRæÎdWõ9ë­Xsöà[ıâF$úX`ù(«+»IZLó|Ìk,•¬Z9äS:;î_%W~Î¹ĞqŠo‰‘+İÏÆ.=ÀhÄFû~!:³Ê2ÏiÊ½Ó|Ô·5?%IÁ*ÄI@ä	ã±üm¬_®5³íÜçE®ó»('är"šxÇ½œ¡pX¡NcoÄ?ş-ŠH8F~lN§îÒ:ÉèÂVˆm¥…ÿ`×a+õM;–AµYjsï Îw™;;â–/µ03«ğï4e rd|QPD¯5Ïféö­³jQWüä]d«(ÚÎó4s4™ÊbvNDh(â#g]z÷Sî´[2Ú(A'!-”
à×K>,Ş.@P¨jUdl3rno*Ei§zÆØY¤¹» i~X2lëëêEòëá}¯¢‡rÛ¶ªÂw3ùn˜G‚%ôw.{Í«NLDlœÔô{×$¨YäXhi©ş}o Ä#Iö›}NŞ§Ì,;rfgQöøá‰zöèéoƒB!00½U*&DØ«Uì§0ã|cânæå„æM+s¦P}D#cÏG¥jú)RúZäu¾\=bCğí<êŒÓ+šdo¹‚kDï±_JJÚ‚¤ê>‹×21p]4²éIú[W@qéÕé,¢Õ'Æu£ÿ³!5ò$S/TAwÎox JtTsËï±R_ïƒes	¡H'+Bî„ §€õO{ÕşÎr‚ÅjóhJ`¬/½ªi a_frkä%h¨~ı‘2Ã{iC×;²A3¹ïR*8­¤Ïò²(eÚy×i}}§sU43H˜*G?:ÀÜ‚ıétãæÀzsIZo yÄs[*!xë‰zÉÌ¨uˆ§5©nö¯H %…'#ÍÃÆ¦brn¡ÁÏ#aRSüDx6İÇo–MÌª1>cÓîp“o´<&Fú#g2{øE@ô@ú(Ë¦AsifÈd?î#sÛAÔëz±ƒ¡B¶îwJ“#åzä^™Œ#$zªq&ãö)¤šôuEÕB/Ã,tl¾Àåg@0‚ cÊ*/ãí	VébªwŠ‹N—ºv™£Ø!R¸±±]oæûä|pv¥eÅ¡8º-DcÅäë	u?(NxèĞÃ»³ÌÆÁEÃõv„O€ĞƒïêõâAO}Ø+£÷ğêcÉ–±)a}
7wbØ¡`¢Ÿ_p>/Á]¡!æ‰PË{E"RŒ4"ã/FD'Ñş7zGĞÆk4uî1[¦úën~í¢J+¶IÁÇö/t İÊ­rÂ9øä¬İÅÉx"°FÀZ}¢µª|oFã$îu!ÊBæŸ€«Š!9ƒÙ_¯än1xbRoïOy$}v+FÕiUó{üXÍ9éj`²fK*òxnW-ºÔj³+éNx(Sâ½Såf _µ<“¨fÆaöÍå.>ôîg? §©Ììú,ºg?svwF~x4Àå"ìÖÖAvc4…;§€zgÚàu+I!ßu|õîÄ	O6ÿŸíuúët?¬eÕGk·®®¤›¡ÖÈöi_¯¾mG„èàY÷
zXpv·Ï<hdg,à>
û<Nø-Ú4–@¬ o¬Švò®Öaµş`tQãDtç
Yqc­1k?h2Ê_A	¡U`*¡Bnõn’n†l£fä¢îI«èQ& j­/5_)Lå‘–9N£	 z9iØEèGƒxgvcø6ÚBEïk $Ásé#ù4Ñ¾k¸bærdµô{¬án¾	dIß‡ìğl²cOæjA_X…¦ØO,OM|†Wí©ó&‹Jl1|§ÖfU_#[n6G6ñeª3}¥A.ä¬µË<G/8¶*›Xßß67ú-åÒ.RdñöKä5Uò8ŞœÖaÓiQ±“Y!gÈM$1¿DJvšo}ìv`!Íç7¥g³óâîÔ&§¨r¼ybfh ÉçÑc!ŠuÉZ0İ*n!íS,Ræå»ásGğE#«jgó½ªISDt3äaH¥J`nûøíğLÙf²%œ@9Fd=?Ä­ß“˜$Coª«lìàv“¤B¤p°±ë¯ç(eÖ,YfKwërÇrËæ`PnàXë*êGmÖÖX\Ãæ kïvã2Cwü`ç‰gFLCleyZ.8ê^¡{V©uì](–Õ{í]ÊLö@†ô~úøÃH$ğçJhÄT&÷#²`¨sïB4C˜ê€gõùÒl@)Eyí%…Mk<ñØtoÀïşÖ¬Ô¡M|FÃ±†­ï-aa$^‡ïAH?8@z¥“^}À·ıˆ4­6:YO¦6ecSu¬lh&÷2`@fW*Š{¬E8Pä $÷Cùó”Ñ@UjòvP%ªÔª‚rÄ|;Ásær'b!l{øı1ŠëC8Ğ9Ôá¤¸"o4G®§Îôá§DY€ÆúrÑÏk°(xaÌgAçĞöÙeÁc(.„3P±ô’ZÊ{jBFW?5á |b#ò7\So«Äi¿gÁh{rŠc¡$°Àõ4ñfw4ÔQ:Ë/\f¼AUmŠäBhb(ŒO:Ò~TV¼i¾!¨ŞÃÎmğN´<x]y~,0D/1ıìÅol ˜yV_.«v”´áÒ“©¾ó:’6##V»Ğtd¼…<°« xEÔdRO8B~”Œˆ â²‡ÊEÊ™nlRÈ}'ÉòGæ³Ä
7húA¸åÂŠ!h>…/~@ ¶ØÔx‹/bË’.´q° 2!±"Ê ¢¡¡iy° f)È"9e%òj;7&pŞIsœ|AÍlÖT˜¡ìÁë%³@˜sß×­hf˜Ú € b’¢"‘8Œ*Osç*Oojv!cVuô+!£9Îuu
.ˆ	2P0˜üŸ8Sß³Ï8´Õpppºå! İûÀg4"<PsÓ?e^îRöZ€ôÉõgY2âüP<Q„]Xmp‚Úñ g^8}¬Š')' Eé{.¨gÇş_¶n
w>–v6IT]¯Ó*h°}ãë\©4mhï¾™:dár+˜éŠÚ‹ª·2²†‰U6çàŠë$"/NhwæE~|`Şhm¥mJ§¸rÇAštÙÔh°tqÈâOŒwN@ko‚¨1§.s2»  y</™fà70±Nˆùvçâj¬9CGnHFXeyf^§¶± <Å50QßNI=…!Áğ3õ¨(lI¤Xo/ƒ6ëÆe6¬Œø]IEÅù‰¬§	Iv^hñôÒ†ü*ß¨‘‚3õùä°S	@(lªÄì}ÖY@E"=ã±½JÈ[(İ%¨ŠoV:Pk&Ò"Íaì¾	‚…,p±byì·èQ$ç=õcô‘ze1®(t¨$€U{,Q‹å\zm|bJ &$±.üC$!&Ógìôf¥uÜ‚~uÕ‹.š S-÷´ÌoÊ­é~¬Á©™‡-á©Ã=¨^t¡²ø~cÔØ`±„¬@WÖg—'ÒMƒÎ õ2y±ôÚ¥U5/‘XF³¼ ymA°ğæ2—wN)ŸÂó¬(&1ğéæ‹ÏAQGA¬*Ó yºUYÏ×	7eñQçä7a¤\•X],(Öè‰Á…EØEhÓğ£ vàbÇÆ"Êï*|Œv_ùî›U}ücé±‚0?¡dll¯ß@ÒÛ0)ˆãò3µ=ÆõŠé£Ò¯Ù-ò¬€å}ña¹u)êaÄå|wvPôª*,m§€;aõTEòÄ ëBÙY×å«n‡)d
ób”EH´Ä_ú€?âÊ}p	µ¾!Ÿs£°"»³ò™Kåônp$Êí‚e+,ËÙ|uèj”gÚé«År1ÍTA:ôày? ÈßÎ•Cˆêp:eèÆfs`Ã÷t‹öØ{^wœ¨gÑlêgwï¨m ®"øÉUI1QÙĞZÕ…£ÿ ÃÕ?‘*‡/Ò3¦¤fOºªÔA…oì±m+@7n4*èÍík"RgÊDx#ÔjÜMN Ø&,dåV‹fId[­Í¹VÒ¯ı¨JÀá!6¤	PmDTèÎ#oÒ`)¥`‚")@`\iDÂà=Nmµj³t:UpQÀ÷aØVåÛİ7Ü¿ÚØ5LB°¤6+ältg„,BXHjZpkt6c¦• ñ+PëÛmP©üR&ô›à5yşí/1  e	xoä•ú),WÔf˜ğµ;*l6Ôg±ævŸ§f”xhWƒrS,[jQe@ÊCQÌzırtËBIex‚ 2!	!?e@"6l.$üèÀH{ó8‚n¼ÈnÌ0‘ghó7HNÅíÿ+–Ñ›5¸c:ÑËo) a/:ûyÙ+êD0PyšqÒ§u[çÁalK
ğ¤Àü[´ZN^d
g³ –ît®á:•gê.8!LJ€"ïc|ôïàMq*GÅİLëşïN;s ûûz|*†´UBéJÔŞH,Zˆò¿ã¢˜ÜQÉï Mñíò²V,1a´·ScaHÆ‰á LO t¶L0g&, æ€ai1Z j¡ºfpb7ËÌ8í~–µ`ÎEü‰Ğlä(¿ÚG“\üBL Tzğ2ñŠ‚YSò¸q<k2kO!Ä°µ-N òÂ× rú#êÜ•Ó8{êXL5ÑA'Ä‘ú‹Ï`w_@R[nåš&*2›ù{Ü}QâE…†OPM#;ÛJHŠè*ª#ZÔ[*=šM6’n,ôJÙëßSÉfßå´G"Òz	šV’uĞ–:İˆäâ‰X€@OáB[»KW,uIÊ0†¼ë «DIn'[Y7Bù³^Ÿ²Í(f_ÿOPïˆ¾ú@¦UâRV±›ÊzAJoÜ„T]¥¤ÄBD¨m*@æbíµ1y54L²—PÑ¦!ZÍsÅ	è4¬1šYˆV)–Ô˜ÿĞÄG(2jáâk£¯­t,'ŒMÄÚd,,t‘Ñ_Ôv—®_nQºH•låÜ?ü$
9!½¤”RpE\Aã¢@(2aQùsšg£â_Àu®,­¤â*øò;ªiâWZáäÇlpï„Â.ÂYöÜUıßî8ÜÛ¤·cğ.­1Õ/½QªR§Û&LQıš/EhëÃ«€$ıópBÈšú¬…%™(58À˜]Lp5{yÕŠYZãOi‘UAoÆz"€|”Vª°­mw;ï\…İämKh ÁÔ ÆZ“ïnuDxQÃGÆDOşYrR%ß2È‚€²1¹ğ^‰RĞèk~D(Yp¬d¤3­„ÌY;Tói¦§O[W%I¤òb¿ñò*/Gé/!nçk«çõéİi½À¾Æİ 
fó$á8'; *¢ ¤§ ¢ÁLc¥Û©Oò«dâÏä©¨ÿ<@;ğÚHpåÌª²¾ñi/&#.ÛAFk‘ÍC.)yP"³š²u‰¯øhä¶e±D ìp¢~Ş>`®'k}oóMpğwzêûï¡Ò  `Ú%_D2 Zx¯©*âÄ Ø\F²F³SÅlÈì+k(wRíÍì?•Y€bny-<YyËç—s…ÁËLáÍÉe ’vBó<(±œ.k5w QPêÂnï“ËA‡¢IÅÇMVğCjZæ°9¨¤óÅ¨ÌlğµÍXÅnL$mŒAĞb\?6PØ$!¢(1’(æ4‹Jã'ó×Ëjçâ´"™"pm	ìFÿ‚Üó ÷$k*åJß‡üÓ¬ã|R¸g{<ıÉ;XéÑ'cwìeEg:|c~‡5¿,9`BLİÓ8À%?ª¥ÅB0Óˆ¥Œhˆ£ 7Bë,¨Dğ%¦*uSKss	ì=3bo;JÊ¯åÖšĞ`¹¨·Ìq×_Ô¿lT¾LAf¨b°-JÙŠ3`u`rå¤,föSô7ƒg
<.WÎƒGä´Œ-*‰1àNŠ‰ÓÖĞ=ÏêNÇ”¿æ¬6Ş{´á4xÔK;6úsd¿ñ>óÎ6²»zTœ¹Ù¦fÆ6A0¡hrG¸Å}{èV·j]PârÉ?·T–qæ!¸O(¤TÉ>ÊòüdèCLÅğèf¯1²vh(Ù¸k:î>í’ó(?à/éÕL\¾Ğ{2UÓm@*‰açâªgewWÑú$‘É$g©­¤u»$ıú(„ä¥fgâ–úî ¤#]FdÎÔz-bb:1Ë+Ú´ü29Ï×rÜô[–ÕO-ÀÛ’ñ½”©wr×pî_¼ÊéŞœY)#b`n:š.ìË?@Åé±Wp;¬*&î÷Z2_Ypî—P|Å~,K>» b)M‡€QU.õ41ÁÇÄRÂ#W1ÄsÑâÀ8#Ñjûhå ãFÕ€%*Œk¯§wuhy÷¼ìéaLoŸpı™@heéatñE<OIu(¾ÉQâæ<ß5A<Ê"`³Ao¸“¹Ë˜RCy5?å[ÁEî[8 dIüCİ#9É•$iGøóRE{!F<ˆN^UëÍOq*q>´0±‚¹b-ìåG~32 ÇÌÕ :bí:Š)ó+nãE©(€sÅDv´:ù'éÀmîÉ =¯½¡q Dl@âÄfeqJıh>©å°të(`åNOÔ­’De®³z+r|Öş»ÿ"EúhÊjn¼T|Ú@cO1¨i¤sN}pß0Ñmc§`GÉ©øhdekOFbeöŒWå¶°i|­€,åHNèüfDdjoeşšLz«æá(Ïï1kØW
Ç'$äğh¡M5„>¾;6(û},x1ì©ğauaÎã ÷ğiR7ş!˜v( ¬ü~G{å «K ôHwÑİY°GÔrá~iNaÙ+0E-hº`"$…hBæI¬d!©¢·şiaÄ2Ÿf!ã²Fie\úÂi´dÄE5’**ôfé¨€sÄ¢åÒ“}|	ç­âüÄ²pIÒJt0öcÓ!làa §*¢®sfÓgçà²ˆø)!%Ó~IFéNNUní $	bL?)Óc3*·ì{ûqWfU¨ I"«6kcQˆ˜rƒÀÄ/İä›&Bu‰Äm‘~RQÍñ›]¯ô)Dóî Û§'÷	0~¡¤sE½),ŸXùßP¤ÅòdÄnI4›}Ñ>İ’I‘Fz‰9éSA03Œ„âH^ Ğd¦mWk@êgtnÛ`Pk¯+'¤|«;$•† ¥¼TM1[œH8wPCkOiİxš[Ùèßbğó÷@MTİlIåoD,Ò	ö¸[–næ+ŠF³O\l¸LTé+¯ '‰Ífä±ú6M…€‚¬ïÌ#Ü£ ä&ÀZ#ä+	ı7f~lyoİe¬*€fS®òX—emŞbí|e`üÇÎÑ$ïI[¢‰Ä?Ce¦eHDEï¡¯üË¼cÏ°îÜ òÅ3=gÏ^D=‚0Ã Blã¶k­\À
jˆµ'BUê?âB3$Ú"søèvH×@Àa;ÆX¾£XÁtÔ‚Ö`O~…øàèÒW¦Sœ‡¯ ‰&JA€.aèÄ	]Y(åzí”.H7ôf5vk*ß_Í +³LF¼JSR$²¤(hº’¸0@i.=Ğé›jšnÊ&'”@,ªLLfCoôú_ŞU+}ljÙó&kgn| +âR<zs~ŞqlE¥í“~êÛJA.zÆu›äÇ!)¨|23-¾µw YËıÈšp¶*ğ0d˜=6 Rzİl± kvŒbI×Ué+0Z×³Ş®Rpd+Ác2j qn(×‹k4UÂ6‡êô“êi%Z nO¼^iÕ ;ÉeªÎ48Å8Îa/2î VBHáÒl4|M¡3OCì¨nsø¶qxÄ°Åë½F]h|zÀÚ-ˆDÃéd >Œo›öƒ¤lrĞÌs,†I0pOìDìIŞÊåœI±CƒÆdŠe[Gsahc¬¶`´“ğÍÚ3Ò2ö²ş *óßîn<«nÛ Æ½9ˆ¾' «#OG¤Úsçãv,£Ã˜c‡Ê¥Ws<h*wJĞ«'ÿÉtBEp!bèW³K+Û¤8½k¼ò^}^öÀ(Âb=¼zŒO'	:üzèè÷ÈH$J4(Ip#)9ÈcBÚ¤ñów(y¦u*-6Ä¡,j€ûßàÓ}D9óh™ñã"¬£Mf`b(Aö õyPí ÌÅ(sb5ÍeøM„{¦f eL“Ê‹Šdæ˜ç…fGn\1·¢ôàÛ;­7ŒbÄ½0ûFvHè".+úTŸkîØòú-îäì¨otDiÇeÂCM|ñí¦jìsY¼Û!µâos.ÿ>GÅ1ş*'ÄÇlzì ÁT^²ÓuíòæäcênEşNx$Û÷Ë)9bÙåwgekÖ·¯‹¬ dqÉäAqm‰*¡ÈÃCø†²–R&¸ £=59â "8Øv(Üîj;ÅÔ}ş$×;UM$Op Eà%¹TÔH#vflÄğágÄH½˜R§¡æYÚgtîã5ÿ-§#igÊ+÷H€Ñ(’-¨‰î-4ƒhWÂSSdÅmÆâÌâómÖ%vYÏE>BëÂè^ñr!b°O~Ê|€)ùDJF™ô¡X 2(Hd* ¶s;;„?â$iöUé6$hh+znĞmäoÈ²ø6/bbc`ßÊ>réˆy:óU3i}Gïã1i0(í04Âm37;&a0K†fám( ½pÑkÈa^»ş1yp±®¼(eD¸²×k1ìç¨lHÄ85Æ|¬¾ú6R©D($RÄßJŒ/9%£&u¬5Æwk®B<|)pĞäi’¯m%ÏmÄ&µE)ä
ÏnB¾>ğIq?à×lÛdv#$9 P/l"@•\¦?.0DëJ_l3npB}4Ê Ó¥kbÂ`Yu}qJ~P¿9ÜvÁa
ØA"l'Í‘a!¬>¹ShD~±âŠ2"úk¡Â’¼ /›p3wµFÇ&Õd-b8…é¡¾A £*ÿìdNtÜ^L^OˆšVÁ+ÀšægGe8k¯J åèdDtVp92’+.UT^ ¶n> ±à&FB^„—O“ ÃY:‹»" ,c.şKŠ\İX•lßíÁÌ.dmõîéüiÊôG1´y	n÷D@?%CÚFg?Bl=eBb;uGâÊÙNæ|Õaš?P`;8[å×a1_£3¶_8{}€/I!$èf@7¹a07)éwÚbá"#2‘dX/˜`7¡1û03ç¥"iT³òªÈ%c˜ÜG$eBq«Öà:,
„,Úe8´¹n_!ä‹ŸadY;Kò+-ºôÀåÁhÿ Ÿèüp%`€nñea; ¾ò<P=CŞaş($PJK Ğ0xà$y|1+‚W$½¤4í€5 â8@23%$TH¬èı±6$}Ìà)aéXdïÃîë(-(´É¾BÄ hóOá?õ<h[aÃqçÁ0ét¾_âÊ®´× ÖJgz “Xjfxjlï¿ÓôÿÅùl©2eù ‚Ar‡]ÛM÷ÇÆ@¦ +õK6¶  éîJ1B>!//8”J² (Ğ³¸Õeóº`KŒ:s±w _vû&î^8ÅIè*„*¡. nD7,^]d~^Oİ.QêÄ3Liô OãGàïoå|®¡wm75]wc`w%.5ó¦-eCNUf
%¹-&¹åtEì!c%È&)oT}$';EQù7‚w>œ ½?#/@7/`*-lÙSçø}Õ‘ènÎ[÷yÃP`¥Mõ#JÜÙ~
¤ß§vø{óŠíöT®&ôbt.úš1bÚf\¬ß
b7d¥q}OTz85ízX¿Lø-r|9L€c`-wı¹|æâ¼6%
"z«ŠıErH¿$0Dyr[µ­äC?. F{ª¨î~+rò y–!/®Á C¿DxVçFÆãX=`=ÿ¶)µ;9Ô)yqòc«òLyÇÈˆz³5qu]íJIñOåë†Ujíf!(07½„¿$Bzíæb2#uu¬è­haPjIácnÑêxß`!ç¿‰ıw(fµ¨OˆÍ| b!$6şôıvË‰<'|pvµgíË£i¢¹ìf|hh ¨°% (6ğÚ@^ˆO_wÅ` WÌ+! >=Ğ¤Şfqiƒ{ŒØP¤ãÁgf`’à©3¤nìığ¤(©w …$5@V1%gµb§ 9
¼ehºE#hèàQqeAoäeß_%ÔE`yc,öØşo~k õ _?sF&zÔ<lîIÖñeÌvpĞÔæQvÓF3wY|ôùÕx}butB[0iĞl)dkéSıò‘PGWÁÂRlvºÓLYm{Š[º §÷%pôLoñøğo~C
zØP·é=3ÈÍ^¯dáñu
}%"W\z5¬Ä	í®ls.uK§6vãØ`gfktDïo74ı*¬ùCFÆ4 !uÛ>ÚuüK¬ŠRû¨C÷c+•!aG*%^HáŸĞ7vö”lp¿DfU(…' 5`V=.ÈôO /µÂ2tÓø_¿‹xÍ¸- 	]l ~«@2oï#exem9Ú6ÙlÌ’kÕ]ñ›GÌ»ÀT!f³.íæ‘t*x‚hQ?ZY
lV[v¡°
QÿmræøpWõw<í-PtvğAİõN,ªPd»( …÷]SlkØ(k.”\9 ;:®¦ÿ%6nvl˜trgo‰‘Mæ$ BkÆCñŞuº3Ê:‰©€éÕ|Ô·5Q']ÃkÄX€¬	!&ì_*5ªìMge
pñ|%ap`xÇ½œ!à¡Jcke?¾ä(
H(df*%¹j:ˆè.ŞˆAe•ÿ VI*qmh·Y½tKs!ü¨^S‰6q±²Œ+³1
?]ïò½4Oh0E\TPD»%ïf…íöè2dQFıä=Navhúäo”k4±Ê`Ehd1c9y³2æ[$ØYA]„
 GNg<6FĞ8%v}30>+&Ic¦:Ç˜é´i² qr=&dëkê„ä.õá}§æzzµÛò«Àd2ñnšWƒ tU.yD+NÄfätÜ|oV0hqeXhm+îL}i´ä#hó²}JÎ¥È/3FFe PS÷xá‰-hôêè%Â¢upp¼U2,Fa)Uì¥4ó-]aclæì©öMkp‡PyT]sgOã­JrT§şZdÚ3%}?:bøe4êßŒQoöÅEæì‚«EşõwZÎÆ¤º:fÄ"±xU8:íÈø{ 9ùÕq}¾Ê% ç­”§ c$0d±m/u~÷N-aDtusÏ70R~g«Es	µÙ$k
ª„D¥ $W{Õ,æzƒDJ ilB)¶,½¦ààñuo6kå•Bh¨^ü:2é{`K5’A39ÅWŠ--¤Gò£(!^qÆix_¢[É4³I8k—(ÀÔ'ûa^·ÏÀzqã¦$ÁY*)xğ‰~İÌ T¥5¨ö"÷áI°'‡"óÌÂF¤6°o«@"dSñ|gÜ-OÌj16ï×l6ƒn”uFz3#&_üDôdú$ éV¶añaVd?¾qÙAÔiZ ¡­@´âQHÒ…xíVÊ)4jJ0 ãa¾(¤•	q[ÕB¯stì>@åaAV _aë2oáoËV±f(ciO•ºvÙ©h ã¸1­|lmç·Ô~qtv¥Õ±(ºmdfd«)u+ox¨ò»gÌm†ÁMGı6	¹]„ ø¨ï¢İúim=Ü9r×àkc‰Ô±se}
3c® œÉ£`&ß÷0.!MÁI«,æÉ°Q{E.õD5&ã&dgñ¶'zØFY5yò1Z¦t¿.~ç¢n)/[A÷r/2 Ê­òr0¸t®ÑSá¸q¤Dà^û²­8|ol£¤¿q"úÄ†Ÿ€¯Šu·İ_pjqøbR~ÿ`y,=V#dpûD slÙ¬)J% 2r,*öz*W5’pz·+£gJtsö½ó!æ47_¥\—<*DavÜDB~î#½UU§(
n€.»'};·}Öz(4ô" \ÖEva<¥:'×híğ|98mqæå|õ¯Ä$G{¿	äuúª5?<m Ÿ{¸®¤“!öï®[‹¿u^8jdqvNz*Pv±î-xat$ä´*y4
{-ú5nh f,Ê~óïóB':ttĞóL4çIug!1k?iòHW@!E *±Efñn–nFLwvä²¸ii¨$W&c n¥/1^©adö;L%e!~9ë¸GìG‘?^'x*ØRÅë/P Ğ1m#ıAºc¹b¦'d¤øx¬¥nºÕ5(\Ó'l°t¦ãOfoDW}€¯TOoN>öWn©ó‹)±}GXfu×3Ùn¢f7ôoˆ0ı%× lô{–uvg¿8hùxQ¡›6%èheÒ<ge`ô)ä;â8>4tfã1°3YuqhU-1ûD@rìt,vŸa±i7gqóëè´'§°c¾xbòs 
%Ñ##ÊEfİ‰

oò“,R®å;IcFp3E+«jc÷¿®^Itódw@-;ˆ(,az¯±M[f²eœ ·k`<?@ó±¡ Ko$¡¯`¨âvÃ¨K$p¤±ù­ÅçpeÆ<X`KªqnrËâanàPË(òBíoÖÖZ Aæ)êïvã3AwxHågNNDodiHê;Ì£{T©u¬-¸”Ñøé]Í^bHÿ.zñÁX¢ô§lpGÔ`÷c0 âI¯B:kİía÷ñùÓl £E“yÿí£Åo<±xcggÇ¯¾"¨œ•àMm‚Ã$uO/ïeûe%v•ïg(>>hm|5ÓN}Àçı¨%£UM&')+åi¸däcÑ#`D,wª> ]8DèpäSÛ7sPA-jã6¯+5òÔ<ÂvÆty©cæz‡b!%põ(±Š‰ 58Ø9õã­pœ"n4E§î çà¯FÆ]‚Ö°vÅcÎc7àa,xsL­A÷à~ÊçÑçl~¦k`õş’HsbcUs?°a" zsò­?^A_. F@ÿgZlzöªc!¤q„õõns$Ğq*K+XcõC6Ue
äAdb<*4uV½ir ¬şÁÎmğnÔ7x\{28†Ezv0üî‘n U*xp?®ª_ó¤&áÇš©§s÷>Å##^*4`¼'Wt¸«8pEõeUPMB<FZ‹Ğˆ âò/ØÊ™^RJ	u7úqDvrE3ú@ó÷ãª!h>.~g $$XIt‹_"KÂ-ğó%"t)#f Æà& º ¯uÙô`p)a"8m ¥pj3<hxÉwšlMlkâP¸!¬-Áj53@œ{SõafiÛtÍabzf¦10í_qGMhuq.­uö*!¢¹õt•.ÉµX2Ô2CÛƒÏ\ü`ô@púåaYS[P%5HpzÖó·?E~ Sôz åíï@3çıHxzÕˆ]„^j0"Zğrç^10}ŒÎÂ9.a{®(÷ÆØW^As"Öv6IMy­Ó:`pu³éH«,ehïn›>lár#8MÿŠÚ/¢·xºŒlŸ\7ÏÕË%æcFèsä] ~Dh,m¥-| ç¨rNç(k4Íô luqÁbnŒsTã!¤ê9¤<{2ó 1-¨y('ßaè?ğqD€avG b¬85CNHf)gmJK£41B=E4YÏ®h7 )AĞ3òd)lK¤Pb§ã6¢<Gå4lÿ'ù]IEÅ§i¼ç	eg~íáõÒFòù¬µ†3u{ì}wKHhm ¤ü}’qà]28ã´šzĞàk{ø‰¸†
[Dz,B&Òjìa,t †,a{*Q¡–jÑ ¥eUc6Á:e1ÈR©t…$& uz,«à]úoz |`QÃ0öl1.üC4i).0:g â&d%uÜ•Ne–c.›× si§µÌg
­­v,I™‰—mámÃq7)va)‰²ğïkÖºdu4¿eGWu¡'êyÏ u>yıaÚ¬M0oSQd»œ ~mA°Tå“—v/“Âğ­?¶0ğIïÏQA®^*×0©º$Ai¯¥	7wqAîä6a¤c\¹X}‡8÷` ˆ•gØKêë
à¯Pt38Ö"Êï.vœuN“0æ:q|&nc¸µD'£dl|>i@R[0­	'¢Ò3½‘?ÖQòø§“.È't®ÕQ¡¯ùa)w)ªaÄåüwfTô»3b2ıá{`qVdæÁëÂ[XVa*vƒ	àwy*óB”EhÖ*Æ)_ê3 '&Ãxpe5¶y¿¼rã©"ïÕÕr çKõöj aÀm„e	+(«‹O=uì†h•~««åro^‹ÑTAGwè {^š> ˆŸ‹œBŠò0:l¨Æ&s!Ãvx‰ô˜NóœˆñiëÖ<Tí©}$.²{M5i9QàVzñ£¢S(hKQ/‘,á#Ò11&åbË0º¤o/±e©`5z*mÁÍéBPwJQ4#?TjLFP¸V|f7¥\†&?kP	f(óíï!¹UÖlÿh
Dë$4° mhèî0hB•g)¡x¢#9@q\)TBst-tl·à¦}:trAM÷ ÉtEé½sL8)ÜH5QV´ä”5+¤·2E¯üXHúZpvquv¤ ğ)]lƒÕ©xÜRå›à!YvÈ+oĞ1$‚y6pkhµ¸),WÔovHü4úX1g<uã¡¢Z`ûhSxC2iqe@CÁ”ÜôÆu›	U8$ r)my>mD@¢6n.&äéÀL{ñ8 ê¨HnM€Yg"s3IMdíg;´&åótx&>Ñ\Á};¹s9ùŠmÚ'ìQtsTzt²£ge[ÃÁqkJH°åÅÜ0°jn_dŸ³
ô®t¶á.¾ú®8!,Zgì`<ÿ+ q.…M\ëşÎ;3] 8ò8|:r5UIé
Ä&ÆH-z8z¨s°˜ğMá¨Hó¥²7Q$q`´d—Sgi,‡$9é.Lnè!ü¶N8‡£ g ap10f²g±óá1ç}í,V”dDAd nä*7R_‘¼l¤x{p2õ‹½Sòjq(-31cJ º§¥n>VrbÓºvê!b5	Ü•Qhy&ZL4õY£åIÿ‹kÏbp^HRcj÷.¶‹Ğxœe`òØ'$uG»0ÙJV	è*¨+z$”t*=– M2F,¼JùxKQg÷í$U.Rz¾oGšõĞ®:é|â‰X¼jGmB[9CW(qhÊx®ït;PI*gS%1³*ğ²V—²ï,f_/Qïˆüúb¦]b ½SxmŸÊrCj~ü
l%¬™ÄJI¸mjS¤|gé.¸1{!5Äö—PĞ'1ÚÏãA!é^¼3Y‹<e9–ÔïÓq'("niâoGŸçqa%$'æ,-ìD!)Ú4$9tÕ~ÔtŸüH{s,@‘dã=Ø9ü´F[ó±ì&ôvÁ\,6Mã£B :aR}3@6&§)ÎÌE>c,mì¦jv ªojfv¢¤ãm ğïUflByö$LTåÉë9[Ä©D'cñoï1-¼!«Â§ó*Tu·Ó¯WGf;«‚A­€¤İur+”	Sšz…¤]*5:È"Nr=c{µ¶xXµ6ãbéBAog8tcÈ#|3$>¢¡´}I6)¿\wÍum@áKt fj£ù¢w<xÓÇ%ÖFmºi+==×4£H©ò5m:tJˆSÒñko$(XpîH`¬1¬~ÅÎQ;Ú³i£ÏlÑE5Iœóc·å*"/l‡#¼gs¡åõééa5¡¾DŞ$Nfó,qù<µ3½£éd„á/3"ÁLC!Ğk^óªdBb©™èµ<\nöšLpeh/ ¶ªñi/W/eŒûAW)j®9ûR"££}Å¯› Ç#e“e°ğpô^Ş: ,&kÅİoó)huŞşè8y-¯bhŞ!\2 x­¨ªòìl˜\g²'-Ø¬+ok{™í¥Í°_ÌbZx)}°¬23•ÉÏ¡œ­Éo(¢fF÷|Õ+å´*{%õfñQPzâ6ïM ÏE‡*OÅÇLWrğC(zoŠ0ø¥J7óC¸ dh½çIE-d<ÌaĞb->7,!È4Nibhr²jövÉOç5ãwOh«Şæ±£'0í	ìN>ş*OûPÃ$L'±~HEJÿ‚ü{¯°8Æ¹Ni8ØXyS0¦#w¾!E,q/ıs~µÿ.)òLÒ³àõ?)¥ÕbJ€\…,h~k)76PëŒ4:á6‚#$V{q(N=Œ3Ân3mb­íaÒŞĞ(f±ˆ÷ÌUs[Q¿(V¾	Anc20+ZÁ˜iwabõ¯Œ°"tsô5Çc/WÌFœä©/*]1åBê‹gÂÇÉ=gj
Â”¿æ¬4”hõï¿5vôK{6úWt¯õ?óNf²ã|p±^»Ilfö6Pp¡l6FTØ¥~?û6¿jAPâ)tÍ4¶T
’sç1©O)­7H~ôÂ|k¨A _òğ(b©†rh4Ar2oºÚ7ï’» pè/Ø×L]Ğ“G{2]Û= *Éaæj(åtµ\Ğú>‹Fcé­¡s»Ôı{('Fíl#â‡ã®¦#IFĞ&Äz%fZ:j‹J¶ü3)'[^Ûô^–ÕM% ‹œÃ=ƒìrs;ÓPî:xÏ(IŞœY*o`n>ºoL*·\Åı°[
1¬(&îåû<²[yp¯ÕTÄ~,(ç"b)‡àqu/x<!ÇÄNRáW¹ÅSğÆÀ1#Õêkáá rÎÎeŒ
Ío»‡va8}÷y´dai?›zühheie1<_Iv8>Q¡w,Â?å-ú"àğmz×¹‰Bm5wí5X‘<ïÒ>`dy}ÁŸ#<É‘$´øòºUP!%(NTUë-Î!šq~ä&0ÆF©[j-î¥Bn22†Ä×¨3 á8*)ğó1$`!©(°£fEd6£ÿ¡táÀmf)"Uµ-Ÿ¡Y$t,@òÄ,ndpJıxw;¨ãû|j hGHYp§Bg&³k/sXÜ~¡ì Fğ|HbntT\z`ád±hj¦s^ùcpÿ0ÑéavbBí»–J`dakQÎ!eó®Våw½mX%°,àFòôel$z?%4°üºx¯xêfà,Ë¾1f\K''œ$óh‰M”$¾#t û}-91"r‰ì¤]áÙó4ó·)R7V¡8wh"¸vs|¤ ©k´H7Ñİ[0GĞ•‰ëzANI_J0Uix,àc5•k@rH­Pm¥%6"¾)`D1_v5ã²E,e|úÅ°dÔE1‚"*2tè«€ñÂæEU}~	î¬ üDnpI]r
t0|dï_'màa0ç.t	osF×GgÈpp)!s~/;TùNÉNå($9pUT7Ac3c1*79{LB9êaUFujË¤éÿë¶ocU(qÀÃÀ?Eş›ªFÕš }>bUÍq“m*å19Fóö;Û§&ölö± +•<S|>qùİx„ Åb @t”?Ñ>Ù
H3Jx<‰2©)sŒâÀZ°@ät®]iEodBg’4,ØîRg.;7%lËT.;$• ‘<uD1¤D<wPciLaq˜Ûël Ğó÷4DDTÍ$,IÅcD¬Rö¼°w–n¤	ŠR«¹j|%¸dUí;'òg‹Tnà±ê&o €$ëìKË£ ;é6	k2d”"ü¾7r~.3m±|ª fS¾ô·d-şbí|GpÜÎÿËka­ÔyGM¢wXOEç¡¯¸ìf3Í¡÷ @#¿v~ïol=‚B`sdã²j€¤~|Ÿ+Š•OÂWkbB3|š"sğù=¥~M‡ÄDa7Æ[:³*JvrÔ”Gx~wu´èè“§¦1YÕ‡¯¨7JZ‚,a¨æ	LY8f|ï	.L2´fu'([o^m!+“HD8KKa£¤ h:²¸g1QÅi^.5\nŸàş.èog¤Ê,ª_lC-üÿ[uèjßRû6ostl!c‚@’\Ngï<±lµå5½³ºêÛŠ—p€üÛ´W9=8_|²sÆ=¶á%d}«ãH‚r¶nğ0\lT?60FúDe3 oP,kIuã+Ó±¦Rõdˆc2k´wlyw.ã$U 4”Jì”2ómeR '&î„g8Ş\á´!3¡#dê›Îµ4•e8îa-Bî^FLcötü¡q	Rê¹nsè¶{lo0okŸF]h:ÀÂW­ìràMf~Ş÷öÃ¬hxÌ&¬–	0r_nFåIİêÅ¼Y­A‚Ä&hëgûcèa¦ t¿°ÅÚƒb^t²ş (µWîI«gØòD9Æ=ˆ1O¾zg+#Jg/Òwcã},èÃ˜ôSúàpa<è*¬uZUégİÀ|E`àoù•±KnÛE<Qnñ^üzvÅ¼âk=Ğ+r‰Og-üzª`uì]e4# J<')ğcpÚ¦³«Ps)`Ò¦ù+$2ì¡,‹
èuaZüTD!óO¹õc<­$]f`B(a÷ uø@Â	‰ib´ÍtñEs¤%RD7¡hÊ™KD&ÕiåÁ'Ec\yµ°øào;7ÄgÄ½4ğ2l!/¢.‹k7Tkîñtcj-æê¬ûK`©£ãiL<.Í úì+Y¼Ù4Ò+³nÿ~FÏ~%/
Ç8zèÄulÒ×<ø®´.Vsj~Ê:N8l÷m!`bÑåyeqkÊ·ÿ© d`PéèMùn‰/!NS#øf²·T0?ì#5e{äí">(Ü~$·ën	Çä|~4ñ«OZGp¤CÂc±0Ş|«vcìäöaïÄJ¨°cH'½cYêEf£âÿ-çIeJ)ÕKS8’$¸‰f)4iÁS<ÕmSİÊ»	S¥pÙÏ#*ñ%ëãé®áj1âª#ébÊl’!+éìT^9t¡message_type_;
  mutable const EnumDescriptor* enum_type_;
  const FieldOptions* options_;
  const std::string* type_name_;
  const std::string* default_value_enum_name_;
  // IMPORTANT:  If you add a new field, make sure to search for all instances
  // of Allocate<FieldDescriptor>() and AllocateArray<FieldDescriptor>() in
  // descriptor.cc and update them to initialize the field.

  union {
    int32 default_value_int32_;
    int64 default_value_int64_;
    uint32 default_value_uint32_;
    uint64 default_value_uint64_;
    float default_value_float_;
    double default_value_double_;
    bool default_value_bool_;

    mutable const EnumValueDescriptor* default_value_enum_;
    const std::string* default_value_string_;
  };

  static const CppType kTypeToCppTypeMap[MAX_TYPE + 1];

  static const char* const kTypeToName[MAX_TYPE + 1];

  static const char* const kCppTypeToName[MAX_CPPTYPE + 1];

  static const char* const kLabelToName[MAX_LABEL + 1];

  // Must be constructed using DescriptorPool.
  FieldDescriptor() {}
  friend class DescriptorBuilder;
  friend class FileDescriptor;
  friend class Descriptor;
  friend class OneofDescriptor;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(FieldDescriptor);
};


// Describes a oneof defined in a message type.
class PROTOBUF_EXPORT OneofDescriptor {
 public:
  typedef OneofDescriptorProto Proto;

  const std::string& name() const;       // Name of this oneof.
  const std::string& full_name() const;  // Fully-qualified name of the oneof.

  // Index of this oneof within the message's oneof array.
  int index() const;

  // The .proto file in which this oneof was defined.  Never nullptr.
  const FileDescriptor* file() const;
  // The Descriptor for the message containing this oneof.
  const Descriptor* containing_type() const;

  // The number of (non-extension) fields which are members of this oneof.
  int field_count() const;
  // Get a member of this oneof, in the order in which they were declared in the
  // .proto file.  Does not include extensions.
  const FieldDescriptor* field(int index) const;

  const OneofOptions& options() const;

  // See Descriptor::CopyTo().
  void CopyTo(OneofDescriptorProto* proto) const;

  // See Descriptor::DebugString().
  std::string DebugString() const;

  // See Descriptor::DebugStringWithOptions().
  std::string DebugStringWithOptions(const DebugStringOptions& options) const;

  // Source Location ---------------------------------------------------

  // Updates |*out_location| to the source location of the complete
  // extent of this oneof declaration.  Returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool GetSourceLocation(SourceLocation* out_location) const;

 private:
  typedef OneofOptions OptionsType;

  // Allows access to GetLocationPath for annotations.
  friend class io::Printer;
  friend class compiler::cpp::Formatter;

  // See Descriptor::DebugString().
  void DebugString(int depth, std::string* contents,
                   const DebugStringOptions& options) const;

  // Walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void GetLocationPath(std::vector<int>* output) const;

  const std::string* name_;
  const std::string* full_name_;
  const Descriptor* containing_type_;
  int field_count_;
  const FieldDescriptor** fields_;
  const OneofOptions* options_;

  // IMPORTANT:  If you add a new field, make sure to search for all instances
  // of Allocate<OneofDescriptor>() and AllocateArray<OneofDescriptor>()
  // in descriptor.cc and update them to initialize the field.

  // Must be constructed using DescriptorPool.
  OneofDescriptor() {}
  friend class DescriptorBuilder;
  friend class Descriptor;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(OneofDescriptor);
};

// Describes an enum type defined in a .proto file.  To get the EnumDescriptor
// for a generated enum type, call TypeName_descriptor().  Use DescriptorPool
// to construct your own descriptors.
class PROTOBUF_EXPORT EnumDescriptor {
 public:
  typedef EnumDescriptorProto Proto;

  // The name of this enum type in the containing scope.
  const std::string& name() const;

  // The fully-qualified name of the enum type, scope delimited by periods.
  const std::string& full_name() const;

  // Index of this enum within the file or containing message's enum array.
  int index() const;

  // The .proto file in which this enum type was defined.  Never nullptr.
  const FileDescriptor* file() const;

  // The number of values for this EnumDescriptor.  Guaranteed to be greater
  // than zero.
  int value_count() const;
  // Gets a value by index, where 0 <= index < value_count().
  // These are returned in the order they were defined in the .proto file.
  const EnumValueDescriptor* value(int index) const;

  // Looks up a value by name.  Returns nullptr if no such value exists.
  const EnumValueDescriptor* FindValueByName(const std::string& name) const;
  // Looks up a value by number.  Returns nullptr if no such value exists.  If
  // multiple values have this number, the first one defined is returned.
  const EnumValueDescriptor* FindValueByNumber(int number) const;

  // If this enum type is nested in a message type, this is that message type.
  // Otherwise, nullptr.
  const Descriptor* containing_type() const;

  // Get options for this enum type.  These are specified in the .proto file by
  // placing lines like "option foo = 1234;" in the enum definition.  Allowed
  // options are defined by EnumOptions in descriptor.proto, and any available
  // extensions of that message.
  const EnumOptions& options() const;

  // See Descriptor::CopyTo().
  void CopyTo(EnumDescriptorProto* proto) const;

  // See Descriptor::DebugString().
  std::string DebugString() const;

  // See Descriptor::DebugStringWithOptions().
  std::string DebugStringWithOptions(const DebugStringOptions& options) const;

  // Returns true if this is a placeholder for an unknown enum. This will
  // only be the case if this descriptor comes from a DescriptorPool
  // with AllowUnknownDependencies() set.
  bool is_placeholder() const;

  // Reserved fields -------------------------------------------------

  // A range of reserved field numbers.
  struct ReservedRange {
    int start;  // inclusive
    int end;    // inclusive
  };

  // The number of reserved ranges in this message type.
  int reserved_range_count() const;
  // Gets an reserved range by index, where 0 <= index <
  // reserved_range_count(). These are returned in the order they were defined
  // in the .proto file.
  const EnumDescriptor::ReservedRange* reserved_range(int index) const;

  // Returns true if the number is in one of the reserved ranges.
  bool IsReservedNumber(int number) const;

  // Returns nullptr if no reserved range contains the given number.
  const EnumDescriptor::ReservedRange* FindReservedRangeContainingNumber(
      int number) const;

  // The number of reserved field names in this message type.
  int reserved_name_count() const;

  // Gets a reserved name by index, where 0 <= index < reserved_name_count().
  const std::string& reserved_name(int index) const;

  // Returns true if the field name is reserved.
  bool IsReservedName(const std::string& name) const;

  // Source Location ---------------------------------------------------

  // Updates |*out_location| to the source location of the complete
  // extent of this enum declaration.  Returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool GetSourceLocation(SourceLocation* out_location) const;

 private:
  typedef EnumOptions OptionsType;

  // Allows access to GetLocationPath for annotations.
  friend class io::Printer;
  friend class compiler::cpp::Formatter;

  // Looks up a value by number.  If the value does not exist, dynamically
  // creates a new EnumValueDescriptor for that value, assuming that it was
  // unknown. If a new descriptor is created, this is done in a thread-safe way,
  // and future calls will return the same value descriptor pointer.
  //
  // This is private but is used by Reflection (which is friended below) to
  // return a valid EnumValueDescriptor from GetEnum() when this feature is
  // enabled.
  const EnumValueDescriptor* FindValueByNumberCreatingIfUnknown(
      int number) const;

  // See Descriptor::DebugString().
  void DebugString(int depth, std::string* contents,
                   const DebugStringOptions& options) const;

  // Walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void GetLocationPath(std::vector<int>* output) const;

  const std::string* name_;
  const std::string* full_name_;
  const FileDescriptor* file_;
  const Descriptor* containing_type_;
  const EnumOptions* options_;

  // True if this is a placeholder for an unknown type.
  bool is_placeholder_;
  // True if this is a placeholder and the type name wasn't fully-qualified.
  bool is_unqualified_placeholder_;

  int value_count_;
  EnumValueDescriptor* values_;

  int reserved_range_count_;
  int reserved_name_count_;
  EnumDescriptor::ReservedRange* reserved_ranges_;
  const std::string** reserved_names_;

  // IMPORTANT:  If you add a new field, make sure to search for all instances
  // of Allocate<EnumDescriptor>() and AllocateArray<EnumDescriptor>() in
  // descriptor.cc and update them to initialize the field.

  // Must be constructed using DescriptorPool.
  EnumDescriptor() {}
  friend class DescriptorBuilder;
  friend class Descriptor;
  friend class FieldDescriptor;
  friend class EnumValueDescriptor;
  friend class FileDescriptor;
  friend class DescriptorPool;
  friend class Reflection;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(EnumDescriptor);
};

// Describes an individual enum constant of a particular type.  To get the
// EnumValueDescriptor for a given enum value, first get the EnumDescriptor
// for its type, then use EnumDescriptor::FindValueByName() or
// EnumDescriptor::FindValueByNumber().  Use DescriptorPool to construct
// your own descriptors.
class PROTOBUF_EXPORT EnumValueDescriptor {
 public:
  typedef EnumValueDescriptorProto Proto;

  const std::string& name() const;  // Name of this enum constant.
  int index() const;                // Index within the enums's Descriptor.
  int number() const;               // Numeric value of this enum constant.

  // The full_name of an enum value is a sibling symbol of the enum type.
  // e.g. the full name of FieldDescriptorProto::TYPE_INT32 is actually
  // "google.protobuf.FieldDescriptorProto.TYPE_INT32", NOT
  // "google.protobuf.FieldDescriptorProto.Type.TYPE_INT32".  This is to conform
  // with C++ scoping rules for enums.
  const std::string& full_name() const;

  // The .proto file in which this value was defined.  Never nullptr.
  const FileDescriptor* file() const;
  // The type of this value.  Never nullptr.
  const EnumDescriptor* type() const;

  // Get options for this enum value.  These are specified in the .proto file by
  // adding text like "[foo = 1234]" after an enum value definition.  Allowed
  // options are defined by EnumValueOptions in descriptor.proto, and any
  // available extensions of that message.
  const EnumValueOptions& options() const;

  // See Descriptor::CopyTo().
  void CopyTo(EnumValueDescriptorProto* proto) const;

  // See Descriptor::DebugString().
  std::string DebugString() const;

  // See Descriptor::DebugStringWithOptions().
  std::string DebugStringWithOptions(const DebugStringOptions& options) const;

  // Source Location ---------------------------------------------------

  // Updates |*out_location| to the source location of the complete
  // extent of this enum value declaration.  Returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool GetSourceLocation(SourceLocation* out_location) const;

 private:
  typedef EnumValueOptions OptionsType;

  // Allows access to GetLocationPath for annotations.
  friend class io::Printer;
  friend class compiler::cpp::Formatter;

  // See Descriptor::DebugString().
  void DebugString(int depth, std::string* contents,
                   const DebugStringOptions& options) const;

  // Walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void GetLocationPath(std::vector<int>* output) const;

  const std::string* name_;
  const std::string* full_name_;
  int number_;
  const EnumDescriptor* type_;
  const EnumValueOptions* options_;
  // IMPORTANT:  If you add a new field, make sure to search for all instances
  // of Allocate<EnumValueDescriptor>() and AllocateArray<EnumValueDescriptor>()
  // in descriptor.cc and update them to initialize the field.

  // Must be constructed using DescriptorPool.
  EnumValueDescriptor() {}
  friend class DescriptorBuilder;
  friend class EnumDescriptor;
  friend class DescriptorPool;
  friend class FileDescriptorTables;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(EnumValueDescriptor);
};

// Describes an RPC service. Use DescriptorPool to construct your own
// descriptors.
class PROTOBUF_EXPORT ServiceDescriptor {
 public:
  typedef ServiceDescriptorProto Proto;

  // The name of the service, not including its containing scope.
  const std::string& name() const;
  // The fully-qualified name of the service, scope delimited by periods.
  const std::string& full_name() const;
  // Index of this service within the file's services array.
  int index() const;

  // The .proto file in which this service was defined.  Never nullptr.
  const FileDescriptor* file() const;

  // Get options for this service type.  These are specified in the .proto file
  // by placing lines like "option foo = 1234;" in the service definition.
  // Allowed options are defined by ServiceOptions in descriptor.proto, and any
  // available extensions of that message.
  const ServiceOptions& options() const;

  // The number of methods this service defines.
  int method_count() const;
  // Gets a MethodDescriptor by index, where 0 <= index < method_count().
  // These are returned in the order they were defined in the .proto file.
  const MethodDescriptor* method(int index) const;

  // Look up a MethodDescriptor by name.
  const MethodDescriptor* FindMethodByName(const std::string& name) const;
  // See Descriptor::CopyTo().
  void CopyTo(ServiceDescriptorProto* proto) const;

  // See Descriptor::DebugString().
  std::string DebugString() const;

  // See Descriptor::DebugStringWithOptions().
  std::string DebugStringWithOptions(const DebugStringOptions& options) const;

  // Source Location ---------------------------------------------------

  // Updates |*out_location| to the source location of the complete
  // extent of this service declaration.  Returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool GetSourceLocation(SourceLocation* out_location) const;

 private:
  typedef ServiceOptions OptionsType;

  // Allows access to GetLocationPath for annotations.
  friend class io::Printer;
  friend class compiler::cpp::Formatter;

  // See Descriptor::DebugString().
  void DebugString(std::string* contents,
                   const DebugStringOptions& options) const;

  // Walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void GetLocationPath(std::vector<int>* output) const;

  const std::string* name_;
  const std::string* full_name_;
  const FileDescriptor* file_;
  const ServiceOptions* options_;
  MethodDescriptor* methods_;
  int method_count_;
  // IMPORTANT:  If you add a new field, make sure to search for all instances
  // of Allocate<ServiceDescriptor>() and AllocateArray<ServiceDescriptor>() in
  // descriptor.cc and update them to initialize the field.

  // Must be constructed using DescriptorPool.
  ServiceDescriptor() {}
  friend class DescriptorBuilder;
  friend class FileDescriptor;
  friend class MethodDescriptor;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ServiceDescriptor);
};


// Describes an individual service method.  To obtain a MethodDescriptor given
// a service, first get its ServiceDescriptor, then call
// ServiceDescriptor::FindMethodByName().  Use DescriptorPool to construct your
// own descriptors.
class PROTOBUF_EXPORT MethodDescriptor {
 public:
  typedef MethodDescriptorProto Proto;

  // Name of this method, not including containing scope.
  const std::string& name() const;
  // The fully-qualified name of the method, scope delimited by periods.
  const std::string& full_name() const;
  // Index within the service's Descriptor.
  int index() const;

  // The .proto file in which this method was defined.  Never nullptr.
  const FileDescriptor* file() const;
  // Gets the service to which this method belongs.  Never nullptr.
  const ServiceDescriptor* service() const;

  // Gets the type of protocol message which this method accepts as input.
  const Descriptor* input_type() const;
  // Gets the type of protocol message which this message produces as output.
  const Descriptor* output_type() const;

  // Gets whether the client streams multiple requests.
  bool client_streaming() const;
  // Gets whether the server streams multiple responses.
  bool server_streaming() const;

  // Get options for this method.  These are specified in the .proto file by
  // placing lines like "option foo = 1234;" in curly-braces after a method
  // declaration.  Allowed options are defined by MethodOptions in
  // descriptor.proto, and any available extensions of that message.
  const MethodOptions& options() const;

  // See Descriptor::CopyTo().
  void CopyTo(MethodDescriptorProto* proto) const;

  // See Descriptor::DebugString().
  std::string DebugString() const;

  // See Descriptor::DebugStringWithOptions().
  std::string DebugStringWithOptions(const DebugStringOptions& options) const;

  // Source Location ---------------------------------------------------

  // Updates |*out_location| to the source location of the complete
  // extent of this method declaration.  Returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  bool GetSourceLocation(SourceLocation* out_location) const;

 private:
  typedef MethodOptions OptionsType;

  // Allows access to GetLocationPath for annotations.
  friend class io::Printer;
  friend class compiler::cpp::Formatter;

  // See Descriptor::DebugString().
  void DebugString(int depth, std::string* contents,
                   const DebugStringOptions& options) const;

  // Walks up the descriptor tree to generate the source location path
  // to this descriptor from the file root.
  void GetLocationPath(std::vector<int>* output) const;

  const std::string* name_;
  const std::string* full_name_;
  const ServiceDescriptor* service_;
  mutable internal::LazyDescriptor input_type_;
  mutable internal::LazyDescriptor output_type_;
  const MethodOptions* options_;
  bool client_streaming_;
  bool server_streaming_;
  // IMPORTANT:  If you add a new field, make sure to search for all instances
  // of Allocate<MethodDescriptor>() and AllocateArray<MethodDescriptor>() in
  // descriptor.cc and update them to initialize the field.

  // Must be constructed using DescriptorPool.
  MethodDescriptor() {}
  friend class DescriptorBuilder;
  friend class ServiceDescriptor;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MethodDescriptor);
};


// Describes a whole .proto file.  To get the FileDescriptor for a compiled-in
// file, get the descriptor for something defined in that file and call
// descriptor->file().  Use DescriptorPool to construct your own descriptors.
class PROTOBUF_EXPORT FileDescriptor {
 public:
  typedef FileDescriptorProto Proto;

  // The filename, relative to the source tree.
  // e.g. "foo/bar/baz.proto"
  const std::string& name() const;

  // The package, e.g. "google.protobuf.compiler".
  const std::string& package() const;

  // The DescriptorPool in which this FileDescriptor and all its contents were
  // allocated.  Never nullptr.
  const DescriptorPool* pool() const;

  // The number of files imported by this one.
  int dependency_count() const;
  // Gets an imported file by index, where 0 <= index < dependency_count().
  // These are returned in the order they were defined in the .proto file.
  const FileDescriptor* dependency(int index) const;

  // The number of files public imported by this one.
  // The public dependency list is a subset of the dependency list.
  int public_dependency_count() const;
  // Gets a public imported file by index, where 0 <= index <
  // public_dependency_count().
  // These are returned in the order they were defined in the .proto file.
  const FileDescriptor* public_dependency(int index) const;

  // The number of files that are imported for weak fields.
  // The weak dependency list is a subset of the dependency list.
  int weak_dependency_count() const;
  // Gets a weak imported file by index, where 0 <= index <
  // weak_dependency_count().
  // These are returned in the order they were defined in the .proto file.
  const FileDescriptor* weak_dependency(int index) const;

  // Number of top-level message types defined in this file.  (This does not
  // include nested types.)
  int message_type_count() const;
  // Gets a top-level message type, where 0 <= index < message_type_count().
  // These are returned in the order they were defined in the .proto file.
  const Descriptor* message_type(int index) const;

  // Number of top-level enum types defined in this file.  (This does not
  // include nested types.)
  int enum_type_count() const;
  // Gets a top-level enum type, where 0 <= index < enum_type_count().
  // These are returned in the order they were defined in the .proto file.
  const EnumDescriptor* enum_type(int index) const;

  // Number of services defined in this file.
  int service_count() const;
  // Gets a service, where 0 <= index < service_count().
  // These are returned in the order they were defined in the .proto file.
  const ServiceDescriptor* service(int index) const;

  // Number of extensions defined at file scope.  (This does not include
  // extensions nested within message types.)
  int extension_count() const;
  // Gets an extension's descriptor, where 0 <= index < extension_count().
  // These are returned in the order they were defined in the .proto file.
  const FieldDescriptor* extension(int index) const;

  // Get options for this file.  These are specified in the .proto file by
  // placing lines like "option foo = 1234;" at the top level, outside of any
  // other definitions.  Allowed options are defined by FileOptions in
  // descriptor.proto, and any available extensions of that message.
  const FileOptions& options() const;

  // Syntax of this file.
  enum Syntax {
    SYNTAX_UNKNOWN = 0,
    SYNTAX_PROTO2 = 2,
    SYNTAX_PROTO3 = 3,
  };
  Syntax syntax() const;
  static const char* SyntaxName(Syntax syntax);

  // Find a top-level message type by name.  Returns nullptr if not found.
  const Descriptor* FindMessageTypeByName(const std::string& name) const;
  // Find a top-level enum type by name.  Returns nullptr if not found.
  const EnumDescriptor* FindEnumTypeByName(const std::string& name) const;
  // Find an enum value defined in any top-level enum by name.  Returns nullptr
  // if not found.
  const EnumValueDescriptor* FindEnumValueByName(const std::string& name) const;
  // Find a service definition by name.  Returns nullptr if not found.
  const ServiceDescriptor* FindServiceByName(const std::string& name) const;
  // Find a top-level extension definition by name.  Returns nullptr if not
  // found.
  const FieldDescriptor* FindExtensionByName(const std::string& name) const;
  // Similar to FindExtensionByName(), but searches by lowercased-name.  See
  // Descriptor::FindFieldByLowercaseName().
  const FieldDescriptor* FindExtensionByLowercaseName(
      const std::string& name) const;
  // Similar to FindExtensionByName(), but searches by camelcased-name.  See
  // Descriptor::FindFieldByCamelcaseName().
  const FieldDescriptor* FindExtensionByCamelcaseName(
      const std::string& name) const;

  // See Descriptor::CopyTo().
  // Notes:
  // - This method does NOT copy source code information since it is relatively
  //   large and rarely needed.  See CopySourceCodeInfoTo() below.
  void CopyTo(FileDescriptorProto* proto) const;
  // Write the source code information of this FileDescriptor into the given
  // FileDescriptorProto.  See CopyTo() above.
  void CopySourceCodeInfoTo(FileDescriptorProto* proto) const;
  // Fill the json_name field of FieldDescriptorProto for all fields. Can only
  // be called after CopyTo().
  void CopyJsonNameTo(FileDescriptorProto* proto) const;

  // See Descriptor::DebugString().
  std::string DebugString() const;

  // See Descriptor::DebugStringWithOptions().
  std::string DebugStringWithOptions(const DebugStringOptions& options) const;

  // Returns true if this is a placeholder for an unknown file. This will
  // only be the case if this descriptor comes from a DescriptorPool
  // with AllowUnknownDependencies() set.
  bool is_placeholder() const;

  // Updates |*out_location| to the source location of the complete extent of
  // this file declaration (namely, the empty path).
  bool GetSourceLocation(SourceLocation* out_location) const;

  // Updates |*out_location| to the source location of the complete
  // extent of the declaration or declaration-part denoted by |path|.
  // Returns false and leaves |*out_location| unchanged iff location
  // information was not available.  (See SourceCodeInfo for
  // description of path encoding.)
  bool GetSourceLocation(const std::vector<int>& path,
                         SourceLocation* out_location) const;

 private:
  typedef FileOptions OptionsType;

  const std::string* name_;
  const std::string* package_;
  const DescriptorPool* pool_;
  internal::once_flag* dependencies_once_;
  static void DependenciesOnceInit(const FileDescriptor* to_init);
  void InternalDependenciesOnceInit() const;

  // These are arranged to minimze padding on 64-bit.
  int dependency_count_;
  int public_dependency_count_;
  int weak_dependency_count_;
  int message_type_count_;
  int enum_type_count_;
  int service_count_;
  int extension_count_;
  Syntax syntax_;
  bool is_placeholder_;

  // Indicates the FileDescriptor is completed building. Used to verify
  // that type accessor functions that can possibly build a dependent file
  // aren't called during the process of building the file.
  bool finished_building_;

  mutable const FileDescriptor** dependencies_;
  const std::string** dependencies_names_;
  int* public_dependencies_;
  int* weak_dependencies_;
  Descriptor* message_types_;
  EnumDescriptor* enum_types_;
  ServiceDescriptor* services_;
  FieldDescriptor* extensions_;
  const FileOptions* options_;

  const FileDescriptorTables* tables_;
  const SourceCodeInfo* source_code_info_;

  // IMPORTANT:  If you add a new field, make sure to search for all instances
  // of Allocate<FileDescriptor>() and AllocateArray<FileDescriptor>() in
  // descriptor.cc and update them to initialize the field.

  FileDescriptor() {}
  friend class DescriptorBuilder;
  friend class DescriptorPool;
  friend class Descriptor;
  friend class FieldDescriptor;
  friend class internal::LazyDescriptor;
  friend class OneofDescriptor;
  friend class EnumDescriptor;
  friend class EnumValueDescriptor;
  friend class MethodDescriptor;
  friend class ServiceDescriptor;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(FileDescriptor);
};


// ===================================================================

// Used to construct descriptors.
//
// Normally you won't want to build your own descriptors.  Message classes
// constructed by the protocol compiler will provide them for you.  However,
// if you are implementing Message on your own, or if you are writing a
// program which can operate on totally arbitrary types and needs to load
// them from some sort of database, you might need to.
//
// Since Descriptors are composed of a whole lot of cross-linked bits of
// data that would be a pain to put together manually, the
// DescriptorPool class is provided to make the process easier.  It can
// take a FileDescriptorProto (defined in descriptor.proto), validate it,
// and convert it to a set of nicely cross-linked Descriptors.
//
// DescriptorPool also helps with memory management.  Descriptors are
// composed of many objects containing static data and pointers to each
// other.  In all likelihood, when it comes time to delete this data,
// you'll want to delete it all at once.  In fact, it is not uncommon to
// have a whole pool of descriptors all cross-linked with each other which
// you wish to delete all at once.  This class represents such a pool, and
// handles the memory management for you.
//
// You can also search for descriptors within a DescriptorPool by name, and
// extensions by number.
class PROTOBUF_EXPORT DescriptorPool {
 public:
  // Create a normal, empty DescriptorPool.
  DescriptorPool();

  // Constructs a DescriptorPool that, when it can't find something among the
  // descriptors already in the pool, looks for it in the given
  // DescriptorDatabase.
  // Notes:
  // - If a DescriptorPool is constructed this way, its BuildFile*() methods
  //   must not be called (they will assert-fail).  The only way to populate
  //   the pool with descriptors is to call the Find*By*() methods.
  // - The Find*By*() methods may block the calling thread if the
  //   DescriptorDatabase blocks.  This in turn means that parsing messages
  //   may block if they need to look up extensions.
  // - The Find*By*() methods will use mutexes for thread-safety, thus making
  //   them slower even when they don't have to fall back to the database.
  //   In fact, even the Find*By*() methods of descriptor objects owned by
  //   this pool will be slower, since they will have to obtain locks too.
  // - An ErrorCollector may optionally be given to collect validation errors
  //   in files loaded from the database.  If not given, errors will be printed
  //   to GOOGLE_LOG(ERROR).  Remember that files are built on-demand, so this
  //   ErrorCollector may be called from any thread that calls one of the
  //   Find*By*() methods.
  // - The DescriptorDatabase must not be mutated during the lifetime of
  //   the DescriptorPool. Even if the client takes care to avoid data races,
  //   changes to the content of the DescriptorDatabase may not be reflected
  //   in subsequent lookups in the DescriptorPool.
  class ErrorCollector;
  explicit DescriptorPool(DescriptorDatabase* fallback_database,
                          ErrorCollector* error_collector = nullptr);

  ~DescriptorPool();

  // Get a pointer to the generated pool.  Generated protocol message classes
  // which are compiled into the binary will allocate their descriptors in
  // this pool.  Do not add your own descriptors to this pool.
  static const DescriptorPool* generated_pool();


  // Find a FileDescriptor in the pool by file name.  Returns nullptr if not
  // found.
  const FileDescriptor* FindFileByName(const std::string& name) const;

  // Find the FileDescriptor in the pool which defines the given symbol.
  // If any of the Find*ByName() methods below would succeed, then this is
  // equivalent to calling that method and calling the result's file() method.
  // Otherwise this returns nullptr.
  const FileDescriptor* FindFileContainingSymbol(
      const std::string& symbol_name) const;

  // Looking up descriptors ------------------------------------------
  // These find descriptors by fully-qualified name.  These will find both
  // top-level descriptors and nested descriptors.  They return nullptr if not
  // found.

  const Descriptor* FindMessageTypeByName(const std::string& name) const;
  const FieldDescriptor* FindFieldByName(const std::string& name) const;
  const FieldDescriptor* FindExtensionByName(const std::string& name) const;
  const OneofDescriptor* FindOneofByName(const std::string& name) const;
  const EnumDescriptor* FindEnumTypeByName(const std::string& name) const;
  const EnumValueDescriptor* FindEnumValueByName(const std::string& name) const;
  const ServiceDescriptor* FindServiceByName(const std::string& name) const;
  const MethodDescriptor* FindMethodByName(const std::string& name) const;

  // Finds an extension of the given type by number.  The extendee must be
  // a member of this DescriptorPool or one of its underlays.
  const FieldDescriptor* FindExtensionByNumber(const Descriptor* extendee,
                                               int number) const;

  // Finds an extension of the given type by its printable name.
  // See comments above PrintableNameForExtension() for the definition of
  // "printable name".  The extendee must be a member of this DescriptorPool
  // or one of its underlays.  Returns nullptr if there is no known message
  // extension with the given printable name.
  const FieldDescriptor* FindExtensionByPrintableName(
      const Descriptor* extendee, const std::string& printable_name) const;

  // Finds extensions of extendee. The extensions will be appended to
  // out in an undefined order. Only extensions defined directly in
  // this DescriptorPool or one of its underlays are guaranteed to be
  // found: extensions defined in the fallback database might not be found
  // depending on the database implementation.
  void FindAllExtensions(const Descriptor* extendee,
                         std::vector<const FieldDescriptor*>* out) const;

  // Building descriptors --------------------------------------------

  // When converting a FileDescriptorProto to a FileDescriptor, various
  // errors might be detected in the input.  The caller may handle these
  // programmatically by implementing an ErrorCollector.
  class PROTOBUF_EXPORT ErrorCollector {
   public:
    inline ErrorCollector() {}
    virtual ~ErrorCollector();

    // These constants specify what exact part of the construct is broken.
    // This is useful e.g. for mapping the error back to an exact location
    // in a .proto file.
    enum ErrorLocation {
      NAME,           // the symbol name, or the package name for files
      NUMBER,         // field or extension range number
      TYPE,           // field type
      EXTENDEE,       // field extendee
      DEFAULT_VALUE,  // field default value
      INPUT_TYPE,     // method input type
      OUTPUT_TYPE,    // method output type
      OPTION_NAME,    // name in assignment
      OPTION_VALUE,   // value in option assignment
      IMPORT,         // import error
      OTHER           // some other problem
    };

    // Reports an error in the FileDescriptorProto. Use this function if the
    // problem occurred should interrupt building the FileDescriptorProto.
    virtual void AddError(
        const std::string& filename,  // File name in which the error occurred.
        const std::string& element_name,  // Full name of the erroneous element.
        const Message* descriptor,  // Descriptor of the erroneous element.
        ErrorLocation location,     // One of the location constants, above.
        const std::string& message  // Human-readable error message.
        ) = 0;

    // Reports a warning in the FileDescriptorProto. Use this function if the
    // problem occurred should NOT interrupt building the FileDescriptorProto.
    virtual void AddWarning(
        const std::string& /*filename*/,      // File name in which the error
                                              // occurred.
        const std::string& /*element_name*/,  // Full name of the erroneous
                                              // element.
        const Message* /*descriptor*/,  // Descriptor of the erroneous element.
        ErrorLocation /*location*/,     // One of the location constants, above.
        const std::string& /*message*/  // Human-readable error message.
    ) {}

   private:
    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ErrorCollector);
  };

  // Convert the FileDescriptorProto to real descriptors and place them in
  // this DescriptorPool.  All dependencies of the file must already be in
  // the pool.  Returns the resulting FileDescriptor, or nullptr if there were
  // problems with the input (e.g. the message was invalid, or dependencies
  // were missing).  Details about the errors are written to GOOGLE_LOG(ERROR).
  const FileDescriptor* BuildFile(const FileDescriptorProto& proto);

  // Same as BuildFile() except errors are sent to the given ErrorCollector.
  const FileDescriptor* BuildFileCollectingErrors(
      const FileDescriptorProto& proto, ErrorCollector* error_collector);

  // By default, it is an error if a FileDescriptorProto contains references
  // to types or other files that are not found in the DescriptorPool (or its
  // backing DescriptorDatabase, if any).  If you call
  // AllowUnknownDependencies(), however, then unknown types and files
  // will be replaced by placeholder descriptors (which can be identified by
  // the is_placeholder() method).  This can allow you to
  // perform some useful operations with a .proto file even if you do not
  // have access to other .proto files on which it depends.  However, some
  // heuristics must be used to fill in the gaps in information, and these
  // can lead to descriptors which are inaccurate.  For example, the
  // DescriptorPool may be forced to guess whether an unknown type is a message
  // or an enum, as well as what package it resides in.  Furthermore,
  // placeholder types will not be discoverable via FindMessageTypeByName()
  // and similar methods, which could confuse some descriptor-based algorithms.
  // Generally, the results of this option should be handled with extreme care.
  void AllowUnknownDependencies() { allow_unknown_ = true; }

  // By default, weak imports are allowed to be missing, in which case we will
  // use a placeholder for the dependency and convert the field to be an Empty
  // message field. If you call EnforceWeakDependencies(true), however, the
  // DescriptorPool will report a import not found error.
  void EnforceWeakDependencies(bool enforce) { enforce_weak_ = enforce; }

  // Internal stuff --------------------------------------------------
  // These methods MUST NOT be called from outside the proto2 library.
  // These methods may contain hidden pitfalls and may be removed in a
  // future library version.

  // Create a DescriptorPool which is overlaid on top of some other pool.
  // If you search for a descriptor in the overlay and it is not found, the
  // underlay will be searched as a backup.  If the underlay has its own
  // underlay, that will be searched next, and so on.  This also means that
  // files built in the overlay will be cross-linked with the underlay's
  // descriptors if necessary.  The underlay remains property of the caller;
  // it must remain valid for the lifetime of the newly-constructed pool.
  //
  // Example:  Say you want to parse a .proto file at runtime in order to use
  // its type with a DynamicMessage.  Say this .proto file has dependencies,
  // but you know that all the dependencies will be things that are already
  // compiled into the binary.  For ease of use, you'd like to load the types
  // right out of generated_pool() rather than have to parse redundant copies
  // of all these .protos and runtime.  But, you don't want to add the parsed
  // types directly into generated_pool(): this is not allowed, and would be
  // bad design anyway.  So, instead, you could use generated_pool() as an
  // underlay for a new DescriptorPool in which you add only the new file.
  //
  // WARNING:  Use of underlays can lead to many subtle gotchas.  Instead,
  //   try to formulate what you want to do in terms of DescriptorDatabases.
  explicit DescriptorPool(const DescriptorPool* underlay);

  // Called by generated classes at init time to add their descriptors to
  // generated_pool.  Do NOT call this in your own code!  filename must be a
  // permanent string (e.g. a string literal).
  static void InternalAddGeneratedFile(const void* encoded_file_descriptor,
                                       int size);

  // Disallow [enforce_utf8 = false] in .proto files.
  void DisallowEnforceUtf8() { disallow_enforce_utf8_ = true; }


  // For internal use only:  Gets a non-const pointer to the generated pool.
  // This is called at static-initialization time only, so thread-safety is
  // not a concern.  If both an underlay and a fallback database are present,
  // the underlay takes precedence.
  static DescriptorPool* internal_generated_pool();

  // For internal use only:  Changes the behavior of BuildFile() such that it
  // allows the file to make reference to message types declared in other files
  // which it did not officially declare as dependencies.
  void InternalDontEnforceDependencies();

  // For internal use only: Enables lazy building of dependencies of a file.
  // Delay the building of dependencies of a file descriptor until absolutely
  // necessary, like when message_type() is called on a field that is defined
  // in that dependency's file. This will cause functional issues if a proto
  // or one of it's dependencies has errors. Should only be enabled for the
  // generated_pool_ (because no descriptor build errors are guaranteed by
  // the compilation generation process), testing, or if a lack of descriptor
  // build errors can be guaranteed for a pool.
  void InternalSetLazilyBuildDependencies() {
    lazily_build_dependencies_ = true;
    // This needs to be set when lazily building dependencies, as it breaks
    // dependency checking.
    InternalDontEnforceDependencies();
  }

  // For internal use only.
  void internal_set_underlay(const DescriptorPool* underlay) {
    underlay_ = underlay;
  }

  // For internal (unit test) use only:  Returns true if a FileDescriptor has
  // been constructed for the given file, false otherwise.  Useful for testing
  // lazy descriptor initialization behavior.
  bool InternalIsFileLoaded(const std::string& filename) const;

  // Add a file to unused_import_track_files_. DescriptorBuilder will log
  // warnings for those files if there is any unused import.
  void AddUnusedImportTrackFile(const std::string& file_name);
  void ClearUnusedImportTrackFiles();

 private:
  friend class Descriptor;
  friend class internal::LazyDescriptor;
  friend class FieldDescriptor;
  friend class EnumDescriptor;
  friend class ServiceDescriptor;
  friend class MethodDescriptor;
  friend class FileDescriptor;
  friend class StreamDescriptor;
  friend class DescriptorBuilder;
  friend class FileDescriptorTables;

  // Return true if the given name is a sub-symbol of any non-package
  // descriptor that already exists in the descriptor pool.  (The full
  // definition of such types is already known.)
  bool IsSubSymbolOfBuiltType(const std::string& name) const;

  // Tries to find something in the fallback database and link in the
  // corresponding proto file.  Returns true if successful, in which case
  // the caller should search for the thing again.  These are declared
  // const because they are called by (semantically) const methods.
  bool TryFindFileInFallbackDatabase(const std::string& name) const;
  bool TryFindSymbolInFallbackDatabase(const std::string& name) const;
  bool TryFindExtensionInFallbackDatabase(const Descriptor* containing_type,
                                          int field_number) const;

  // Like BuildFile() but called internally when the file has been loaded from
  // fallback_database_.  Declared const because it is called by (semantically)
  // const methods.
  const FileDescriptor* BuildFileFromDatabase(
      const FileDescriptorProto& proto) const;

  // Helper for when lazily_build_dependencies_ is set, can look up a symbol
  // after the file's descriptor is built, and can build the file where that
  // symbol is defined if necessary. Will create a placeholder if the type
  // doesn't exist in the fallback database, or the file doesn't build
  // successfully.
  Symbol CrossLinkOnDemandHelper(const std::string& name,
                                 bool expecting_enum) const;

  // Create a placeholder FileDescriptor of the specified name
  FileDescriptor* NewPlaceholderFile(const std::string& name) const;
  FileDescriptor* NewPlaceholderFileWithMutexHeld(
      const std::string& name) const;

  enum PlaceholderType {
    PLACEHOLDER_MESSAGE,
    PLACEHOLDER_ENUM,
    PLACEHOLDER_EXTENDABLE_MESSAGE
  };
  // Create a placeholder Descriptor of the specified name
  Symbol NewPlaceholder(const std::string& name,
                        PlaceholderType placeholder_type) const;
  Symbol NewPlaceholderWithMutexHeld(const std::string& name,
                                     PlaceholderType placeholder_type) const;

  // If fallback_database_ is nullptr, this is nullptr.  Otherwise, this is a
  // mutex which must be locked while accessing tables_.
  internal::WrappedMutex* mutex_;

  // See constructor.
  DescriptorDatabase* fallback_database_;
  ErrorCollector* default_error_collector_;
  const DescriptorPool* underlay_;

  // This class contains a lot of hash maps with complicated types that
  // we'd like to keep out of the header.
  class Tables;
  std::unique_ptr<Tables> tables_;

  bool enforce_dependencies_;
  bool lazily_build_dependencies_;
  bool allow_unknown_;
  bool enforce_weak_;
  bool disallow_enforce_utf8_;
  std::set<std::string> unused_import_track_files_;

  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DescriptorPool);
};


// inline methods ====================================================

// These macros makes this repetitive code more readable.
#define PROTOBUF_DEFINE_ACCESSOR(CLASS, FIELD, TYPE) \
  inline TYPE CLASS::FIELD() const { return FIELD##_; }

// Strings fields are stored as pointers but returned as const references.
#define PROTOBUF_DEFINE_STRING_ACCESSOR(CLASS, FIELD) \
  inline const std::string& CLASS::FIELD() const { return *FIELD##_; }

// Arrays take an index parameter, obviously.
#define PROTOBUF_DEFINE_ARRAY_ACCESSOR(CLASS, FIELD, TYPE) \
  inline TYPE CLASS::FIELD(int index) const { return FIELD##s_ + index; }

#define PROTOBUF_DEFINE_OPTIONS_ACCESSOR(CLASS, TYPE) \
  inline const TYPE& CLASS::options() const { return *options_; }

PROTOBUF_DEFINE_STRING_ACCESSOR(Descriptor, name)
PROTOBUF_DEFINE_STRING_ACCESSOR(Descriptor, full_name)
PROTOBUF_DEFINE_ACCESSOR(Descriptor, file, const FileDescriptor*)
PROTOBUF_DEFINE_ACCESSOR(Descriptor, containing_type, const Descriptor*)

PROTOBUF_DEFINE_ACCESSOR(Descriptor, field_count, int)
PROTOBUF_DEFINE_ACCESSOR(Descriptor, oneof_decl_count, int)
PROTOBUF_DEFINE_ACCESSOR(Descriptor, nested_type_count, int)
PROTOBUF_DEFINE_ACCESSOR(Descriptor, enum_type_count, int)

PROTOBUF_DEFINE_ARRAY_ACCESSOR(Descriptor, field, const FieldDescriptor*)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(Descriptor, oneof_decl, const OneofDescriptor*)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(Descriptor, nested_type, const Descriptor*)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(Descriptor, enum_type, const EnumDescriptor*)

PROTOBUF_DEFINE_ACCESSOR(Descriptor, extension_range_count, int)
PROTOBUF_DEFINE_ACCESSOR(Descriptor, extension_count, int)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(Descriptor, extension_range,
                               const Descriptor::ExtensionRange*)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(Descriptor, extension, const FieldDescriptor*)

PROTOBUF_DEFINE_ACCESSOR(Descriptor, reserved_range_count, int)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(Descriptor, reserved_range,
                               const Descriptor::ReservedRange*)
PROTOBUF_DEFINE_ACCESSOR(Descriptor, reserved_name_count, int)

PROTOBUF_DEFINE_OPTIONS_ACCESSOR(Descriptor, MessageOptions)
PROTOBUF_DEFINE_ACCESSOR(Descriptor, is_placeholder, bool)

PROTOBUF_DEFINE_STRING_ACCESSOR(FieldDescriptor, name)
PROTOBUF_DEFINE_STRING_ACCESSOR(FieldDescriptor, full_name)
PROTOBUF_DEFINE_STRING_ACCESSOR(FieldDescriptor, json_name)
PROTOBUF_DEFINE_STRING_ACCESSOR(FieldDescriptor, lowercase_name)
PROTOBUF_DEFINE_STRING_ACCESSOR(FieldDescriptor, camelcase_name)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, file, const FileDescriptor*)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, number, int)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, is_extension, bool)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, label, FieldDescriptor::Label)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, containing_type, const Descriptor*)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, containing_oneof,
                         const OneofDescriptor*)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, index_in_oneof, int)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, extension_scope, const Descriptor*)
PROTOBUF_DEFINE_OPTIONS_ACCESSOR(FieldDescriptor, FieldOptions)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, has_default_value, bool)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, has_json_name, bool)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_int32, int32)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_int64, int64)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_uint32, uint32)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_uint64, uint64)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_float, float)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_double, double)
PROTOBUF_DEFINE_ACCESSOR(FieldDescriptor, default_value_bool, bool)
PROTOBUF_DEFINE_STRING_ACCESSOR(FieldDescriptor, default_value_string)

PROTOBUF_DEFINE_STRING_ACCESSOR(OneofDescriptor, name)
PROTOBUF_DEFINE_STRING_ACCESSOR(OneofDescriptor, full_name)
PROTOBUF_DEFINE_ACCESSOR(OneofDescriptor, containing_type, const Descriptor*)
PROTOBUF_DEFINE_ACCESSOR(OneofDescriptor, field_count, int)
PROTOBUF_DEFINE_OPTIONS_ACCESSOR(OneofDescriptor, OneofOptions)

PROTOBUF_DEFINE_STRING_ACCESSOR(EnumDescriptor, name)
PROTOBUF_DEFINE_STRING_ACCESSOR(EnumDescriptor, full_name)
PROTOBUF_DEFINE_ACCESSOR(EnumDescriptor, file, const FileDescriptor*)
PROTOBUF_DEFINE_ACCESSOR(EnumDescriptor, containing_type, const Descriptor*)
PROTOBUF_DEFINE_ACCESSOR(EnumDescriptor, value_count, int)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(EnumDescriptor, value,
                               const EnumValueDescriptor*)
PROTOBUF_DEFINE_OPTIONS_ACCESSOR(EnumDescriptor, EnumOptions)
PROTOBUF_DEFINE_ACCESSOR(EnumDescriptor, is_placeholder, bool)
PROTOBUF_DEFINE_ACCESSOR(EnumDescriptor, reserved_range_count, int)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(EnumDescriptor, reserved_range,
                               const EnumDescriptor::ReservedRange*)
PROTOBUF_DEFINE_ACCESSOR(EnumDescriptor, reserved_name_count, int)

PROTOBUF_DEFINE_STRING_ACCESSOR(EnumValueDescriptor, name)
PROTOBUF_DEFINE_STRING_ACCESSOR(EnumValueDescriptor, full_name)
PROTOBUF_DEFINE_ACCESSOR(EnumValueDescriptor, number, int)
PROTOBUF_DEFINE_ACCESSOR(EnumValueDescriptor, type, const EnumDescriptor*)
PROTOBUF_DEFINE_OPTIONS_ACCESSOR(EnumValueDescriptor, EnumValueOptions)

PROTOBUF_DEFINE_STRING_ACCESSOR(ServiceDescriptor, name)
PROTOBUF_DEFINE_STRING_ACCESSOR(ServiceDescriptor, full_name)
PROTOBUF_DEFINE_ACCESSOR(ServiceDescriptor, file, const FileDescriptor*)
PROTOBUF_DEFINE_ACCESSOR(ServiceDescriptor, method_count, int)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(ServiceDescriptor, method,
                               const MethodDescriptor*)
PROTOBUF_DEFINE_OPTIONS_ACCESSOR(ServiceDescriptor, ServiceOptions)

PROTOBUF_DEFINE_STRING_ACCESSOR(MethodDescriptor, name)
PROTOBUF_DEFINE_STRING_ACCESSOR(MethodDescriptor, full_name)
PROTOBUF_DEFINE_ACCESSOR(MethodDescriptor, service, const ServiceDescriptor*)
PROTOBUF_DEFINE_OPTIONS_ACCESSOR(MethodDescriptor, MethodOptions)
PROTOBUF_DEFINE_ACCESSOR(MethodDescriptor, client_streaming, bool)
PROTOBUF_DEFINE_ACCESSOR(MethodDescriptor, server_streaming, bool)

PROTOBUF_DEFINE_STRING_ACCESSOR(FileDescriptor, name)
PROTOBUF_DEFINE_STRING_ACCESSOR(FileDescriptor, package)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, pool, const DescriptorPool*)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, dependency_count, int)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, public_dependency_count, int)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, weak_dependency_count, int)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, message_type_count, int)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, enum_type_count, int)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, service_count, int)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, extension_count, int)
PROTOBUF_DEFINE_OPTIONS_ACCESSOR(FileDescriptor, FileOptions)
PROTOBUF_DEFINE_ACCESSOR(FileDescriptor, is_placeholder, bool)

PROTOBUF_DEFINE_ARRAY_ACCESSOR(FileDescriptor, message_type, const Descriptor*)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(FileDescriptor, enum_type, const EnumDescriptor*)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(FileDescriptor, service,
                               const ServiceDescriptor*)
PROTOBUF_DEFINE_ARRAY_ACCESSOR(FileDescriptor, extension,
                               const FieldDescriptor*)

#undef PROTOBUF_DEFINE_ACCESSOR
#undef PROTOBUF_DEFINE_STRING_ACCESSOR
#undef PROTOBUF_DEFINE_ARRAY_ACCESSOR

// A few accessors differ from the macros...

inline bool Descriptor::IsExtensionNumber(int number) const {
  return FindExtensionRangeContainingNumber(number) != nullptr;
}

inline bool Descriptor::IsReservedNumber(int number) const {
  return FindReservedRangeContainingNumber(number) != nullptr;
}

inline bool Descriptor::IsReservedName(const std::string& name) const {
  for (int i = 0; i < reserved_name_count(); i++) {
    if (name == reserved_name(i)) {
      return true;
    }
  }
  return false;
}

// Can't use PROTOBUF_DEFINE_ARRAY_ACCESSOR because reserved_names_ is actually
// an array of pointers rather than the usual array of objects.
inline const std::string& Descriptor::reserved_name(int index) const {
  return *reserved_names_[index];
}

inline bool EnumDescriptor::IsReservedNumber(int number) const {
  return FindReservedRangeContainingNumber(number) != nullptr;
}

inline bool EnumDescriptor::IsReservedName(const std::string& name) const {
  for (int i = 0; i < reserved_name_count(); i++) {
    if (name == reserved_name(i)) {
      return true;
    }
  }
  return false;
}

// Can't use PROTOBUF_DEFINE_ARRAY_ACCESSOR because reserved_names_ is actually
// an array of pointers rather than the usual array of objects.
inline const std::string& EnumDescriptor::reserved_name(int index) const {
  return *reserved_names_[index];
}

inline FieldDescriptor::Type FieldDescriptor::type() const {
  if (type_once_) {
    internal::call_once(*type_once_, &FieldDescriptor::TypeOnceInit, this);
  }
  return type_;
}

inline bool FieldDescriptor::is_required() const {
  return label() == LABEL_REQUIRED;
}

inline bool FieldDescriptor::is_optional() const {
  return label() == LABEL_OPTIONAL;
}

inline bool FieldDescriptor::is_repeated() const {
  return label() == LABEL_REPEATED;
}

inline bool FieldDescriptor::is_packable() const {
  return is_repeated() && IsTypePackable(type());
}

inline bool FieldDescriptor::is_map() const {
  return type() == TYPE_MESSAGE && is_map_message_type();
}

// To save space, index() is computed by looking at the descriptor's position
// in the parent's array of children.
inline int FieldDescriptor::index() const {
  if (!is_extension_) {
    return static_cast<int>(this - containing_type()->fields_);
  } else if (extension_scope_ != nullptr) {
    return static_cast<int>(this - extension_scope_->extensions_);
  } else {
    return static_cast<int>(this - file_->extensions_);
  }
}

inline int Descriptor::index() const {
  if (containing_type_ == nullptr) {
    return static_cast<int>(this - file_->message_types_);
  } else {
    return static_cast<int>(this - containing_type_->nested_types_);
  }
}

inline const FileDescriptor* OneofDescriptor::file() const {
  return containing_type()->file();
}

inline int OneofDescriptor::index() const {
  return static_cast<int>(this - containing_type_->oneof_decls_);
}

inline int EnumDescriptor::index() const {
  if (containing_type_ == nullptr) {
    return static_cast<int>(this - file_->enum_types_);
  } else {
    return static_cast<int>(this - containing_type_->enum_types_);
  }
}

inline const FileDescriptor* EnumValueDescriptor::file() const {
  return type()->file();
}

inline int EnumValueDescriptor::index() const {
  return static_cast<int>(this - type_->values_);
}

inline int ServiceDescriptor::index() const {
  return static_cast<int>(this - file_->services_);
}

inline const FileDescriptor* MethodDescriptor::file() const {
  return service()->file();
}

inline int MethodDescriptor::index() const {
  return static_cast<int>(this - service_->methods_);
}

inline const char* FieldDescriptor::type_name() const {
  return kTypeToName[type()];
}

inline FieldDescriptor::CppType FieldDescriptor::cpp_type() const {
  return kTypeToCppTypeMap[type()];
}

inline const char* FieldDescriptor::cpp_type_name() const {
  return kCppTypeToName[kTypeToCppTypeMap[type()]];
}

inline FieldDescriptor::CppType FieldDescriptor::TypeToCppType(Type type) {
  return kTypeToCppTypeMap[type];
}

inline const char* FieldDescriptor::TypeName(Type type) {
  return kTypeToName[type];
}

inline const char* FieldDescriptor::CppTypeName(CppType cpp_type) {
  return kCppTypeToName[cpp_type];
}

inline bool FieldDescriptor::IsTypePackable(Type field_type) {
  return (field_type != FieldDescriptor::TYPE_STRING &&
          field_type != FieldDescriptor::TYPE_GROUP &&
          field_type != FieldDescriptor::TYPE_MESSAGE &&
          field_type != FieldDescriptor::TYPE_BYTES);
}

inline const FileDescriptor* FileDescriptor::public_dependency(
    int index) const {
  return dependency(public_dependencies_[index]);
}

inline const FileDescriptor* FileDescriptor::weak_dependency(int index) const {
  return dependency(weak_dependencies_[index]);
}

inline FileDescriptor::Syntax FileDescriptor::syntax() const { return syntax_; }

// Can't use PROTOBUF_DEFINE_ARRAY_ACCESSOR because fields_ is actually an array
// of pointers rather than the usual array of objects.
inline const FieldDescriptor* OneofDescriptor::field(int index) const {
  return fields_[index];
}

}  // namespace protobuf
}  // namespace google

#include <google/protobuf/port_undef.inc>

#endif  // GOOGLE_PROTOBUF_DESCRIPTOR_H__
