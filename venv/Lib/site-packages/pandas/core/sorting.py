""" miscellaneous sorting / groupby utilities """
from __future__ import annotations

from collections import defaultdict
from typing import (
    TYPE_CHECKING,
    Callable,
    DefaultDict,
    Iterable,
    Sequence,
)

import numpy as np

from pandas._libs import (
    algos,
    hashtable,
    lib,
)
from pandas._libs.hashtable import unique_label_indices
from pandas._typing import (
    IndexKeyFunc,
    Shape,
)

from pandas.core.dtypes.common import (
    ensure_int64,
    ensure_platform_int,
    is_extension_array_dtype,
)
from pandas.core.dtypes.generic import (
    ABCMultiIndex,
    ABCRangeIndex,
)
from pandas.core.dtypes.missing import isna

from pandas.core.construction import extract_array

if TYPE_CHECKING:
    from pandas import MultiIndex
    from pandas.core.indexes.base import Index


def get_indexer_indexer(
    target: Index,
    level: str | int | list[str] | list[int],
    ascending: Sequence[bool | int] | bool | int,
    kind: str,
    na_position: str,
    sort_remaining: bool,
    key: IndexKeyFunc,
) -> np.ndarray | None:
    """
    Helper method that return the indexer according to input parameters for
    the sort_index method of DataFrame and Series.

    Parameters
    ----------
    target : Index
    level : int or level name or list of ints or list of level names
    ascending : bool or list of bools, default True
    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, default 'quicksort'
    na_position : {'first', 'last'}, default 'last'
    sort_remaining : bool, default True
    key : callable, optional

    Returns
    -------
    Optional[ndarray]
        The indexer for the new index.
    """

    target = ensure_key_mapped(target, key, levels=level)
    target = target._sort_levels_monotonic()

    if level is not None:
        _, indexer = target.sortlevel(
            level, ascending=ascending, sort_remaining=sort_remaining
        )
    elif isinstance(target, ABCMultiIndex):
        indexer = lexsort_indexer(
            target._get_codes_for_sorting(), orders=ascending, na_position=na_position
        )
    else:
        # Check monotonic-ness before sort an index (GH 11080)
        if (ascending and target.is_monotonic_increasing) or (
            not ascending and target.is_monotonic_decreasing
        ):
            return None

        indexer = nargsort(
            target, kind=kind, ascending=ascending, na_position=na_position
        )
    return indexer


def get_group_index(labels, shape: Shape, sort: bool, xnull: bool):
    """
    For the particular label_list, gets the offsets into the hypothetical list
    representing the totally ordered cartesian product of all possible label
    combinations, *as long as* this space fits within int64 bounds;
    otherwise, though group indices identify unique combinations of
    labels, they cannot be deconstructed.
    - If `sort`, rank of returned ids preserve lexical ranks of labels.
      i.e. returned id's can be used to do lexical sort on labels;
    - If `xnull` nulls (-1 labels) are passed through.

    Parameters
    ----------
    labels : sequence of arrays
        Integers identifying levels at each location
    shape : tuple[int, ...]
        Number of unique levels at each location
    sort : bool
        If the ranks of returned ids should match lexical ranks of labels
    xnull : bool
        If true nulls are excluded. i.e. -1 values in the labels are
        passed through.

    Returns
    -------
    An array of type int64 where two elements are equal if their corresponding
    labels are equal at all location.

    Notes
    -----
    The length of `labels` and `shape` must be identical.
    """

    def _int64_cut_off(shape) -> int:
        acc = 1
        for i, mul in enumerate(shape):
            acc *= int(mul)
            if not acc < lib.i8max:
                return i
        return len(shape)

    def maybe_lift(lab, size) -> tuple[np.ndarray, int]:
        # promote nan values (assigned -1 label in lab array)
        # so that all output values are non-negative
        return (lab + 1, size + 1) if (lab == -1).any() else (lab, size)

    labels = [ensure_int64(x) for x in labels]
    lshape = list(shape)
    if not xnull:
        for i, (lab, size) in enumerate(zip(labels, shape)):
            lab, size = maybe_lift(lab, size)
            labels[i] = lab
            lshape[i] = size

    labels = list(labels)

    # Iteratively process all the labels in chunks sized so less
    # than lib.i8max unique int ids will be required for each chunk
    while True:
        # how many levels can be done without overflow:
        nlev = _int64_cut_off(lshape)

        # compute flat ids for the first `nlev` levels
        stride = np.prod(lshape[1:nlev], dtype="i8")
        out = stride * labels[0].astype("i8", subok=False, copy=False)

        for i in range(1, nlev):
            if lshape[i] == 0:
                stride = np.int64(0)
            else:
                stride //= lshape[i]
            out += labels[i] * stride

        if xnull:  # exclude nulls
            mask = labels[0] == -1
            for lab in labels[1:nlev]:
                mask |= lab == -1
            out[mask] = -1

        if nlev == len(lshape):  # all levels done!
            break

        # compress what has been done so far in order to avoid overflow
        # to retain lexical ranks, obs_ids should be sorted
        comp_ids, obs_ids = compress_group_index(out, sort=sort)

        labels = [comp_ids] + labels[nlev:]
        lshape = [len(obs_ids)] + lshape[nlev:]

    return out


def get_compressed_ids(labels, sizes: Shape) -> tuple[np.ndarray, np.ndarray]:
    """
    Group_index is offsets into cartesian product of all possible labels. This
    space can be huge, so this function compresses it, by computing offsets
    (comp_ids) into the list of unique labels (obs_group_ids).

    Parameters
    ----------
    labels : list of label arrays
    sizes : tuple[int] of size of the levels

    Returns
    -------
    np.ndarray[np.intp]
        comp_ids
    np.ndarray[np.int64]
        obs_group_ids
    """
    ids = get_group_index(labels, sizes, sort=True, xnull=False)
    return compress_group_index(ids, sort=True)


def is_int64_overflow_possible(shape) -> bool:
    the_prod = 1
    for x in shape:
        the_prod *= int(x)

    return the_prod >= lib.i8max


def decons_group_index(comp_labels, shape):
    # reconstruct labels
    if is_int64_overflow_possible(shape):
        # at some point group indices are factorized,
        # and may not be deconstructed here! wrong path!
        raise ValueError("cannot deconstruct factorized group indices!")

    label_list = []
    factor = 1
    y = 0
    x = comp_labels
    for i in reversed(range(len(shape))):
        labels = (x - y) % (factor * shape[i]) // factor
        np.putmask(labels, comp_labels < 0, -1)
        label_list.append(labels)
        y = labels * factor
        factor *= shape[i]
    return label_list[::-1]


def decons_obs_group_ids(comp_ids: np.ndarray, obs_ids, shape, labels, xnull: bool):
    """
    Reconstruct labels from observed group ids.

    Parameters
    ----------
    comp_ids : np.ndarray[np.intp]
    xnull : bool
        If nulls are excluded; i.e. -1 labels are passed through.
    """
    if not xnull:
        lift = np.fromiter(((a == -1).any() for a in labels), dtype="i8")
        shape = np.asarray(shape, dtype="i8") + lift

    if not is_int64_overflow_possible(shape):
        # obs ids are deconstructable! take the fast route!
        out = decons_group_index(obs_ids, shape)
        return out if xnull or not lift.any() else [x - y for x, y in zip(out, lift)]

    # TODO: unique_label_indices only used here, should take ndarray[np.intp]
    indexer = unique_label_indices(ensure_int64(comp_ids))
    return [lab[indexer].astype(np.intp, subok=False, copy=True) for lab in labels]


def indexer_from_factorized(labels, shape: Shape, compress: bool = True) -> np.ndarray:
    # returned ndarray is np.intp
    ids = get_group_index(labels, shape, sort=True, xnull=False)

    if not compress:
        ngroups = (ids.size and ids.max()) + 1
    else:
        ids, obs = compress_group_index(ids, sort=True)
        ngroups = len(obs)

    return get_group_index_sorter(ids, ngroups)


def lexsort_indexer(
    keys, orders=None, na_position: str = "last", key: Callable | None = None
) -> np.ndarray:
    """
    Performs lexical sorting on a set of keys

    Parameters
    ----------
    keys : sequence of arrays
        Sequence of ndarrays to be sorted by the indexer
    orders : bool or list of booleans, optional
        Determines the sorting order for each element in keys. If a list,
        it must be the same length as keys. This determines whether the
        corresponding element in keys should be sorted in ascending
        (True) or descending (False) order. if bool, applied to all
        elements as above. if None, defaults to True.
    na_position : {'first', 'last'}, default 'last'
        Determines placement of NA elements in the sorted list ("last" or "first")
    key : Callable, optional
        Callable key function applied to every element in keys before sorting

        .. versionadded:: 1.0.0

    Returns
    -------
    np.ndarray[np.intp]
    """
    from pandas.core.arrays import Categorical

    labels = []
    shape = []
    if isinstance(orders, bool):
        orders = [orders] * len(keys)
    elif orders is None:
        orders = [True] * len(keys)

    keys = [ensure_key_mapped(k, key) for k in keys]

    for k, order in zip(keys, orders):
        cat = Categorical(k, ordered=True)

        if na_position not in ["last", "first"]:
            raise ValueError(f"invalid na_position: {na_position}")

        n = len(cat.categories)
        codes = cat.codes.copy()

        mask = cat.codes == -1
        if order:  # ascending
            if na_position == "last":
                codes = np.where(mask, n, codes)
            elif na_position == "first":
                codes += 1
        else:  # not order means descending
            if na_position == "last":
                codes = np.where(mask, n, n - codes - 1)
            elif na_position == "first":
                codes = np.where(mask, 0, n - codes)
        if mask.any():
            n += 1

        shape.append(n)
        labels.append(codes)

    return indexer_from_factorized(labels, tuple(shape))


def nargsort(
    items,
    kind: str = "quicksort",
    ascending: bool = True,
    na_position: str = "last",
    key: Callable | None = None,
    mask: np.ndarray | None = None,
):
    """
    Intended to be a drop-in replacement for np.argsort which handles NaNs.

    Adds ascending, na_position, and key parameters.

    (GH #6399, #5231, #27237)

    Parameters
    ----------
    kind : str, default 'quicksort'
    ascending : bool, default True
    na_position : {'first', 'last'}, default 'last'
    key : Optional[Callable], default None
    mask : Optional[np.ndarray], default None
        Passed when called by ExtensionArray.argsort.

    Returns
    -------
    np.ndarray[np.intp]
    """

    if key is not None:
        items = ensure_key_mapped(items, key)
        return nargsort(
            items,
            kind=kind,
            ascending=ascending,
            na_position=na_position,
            key=None,
            mask=mask,
        )

    if isinstance(items, ABCRangeIndex):
        return items.argsort(ascending=ascending)  # TODO: test coverage with key?
    elif not isinstance(items, ABCMultiIndex):
        items = extract_array(items)
    if mask is None:
        mask = np.asarray(isna(items))  # TODO: does this exclude MultiIndex too?

    if is_extension_array_dtype(items):
        return items.argsort(ascending=ascending, kind=kind, na_position=na_position)
    else:
        items = np.asanyarray(items)

    idx = np.arange(len(items))
    non_nans = items[~mask]
    non_nan_idx = idx[~mask]

    nan_idx = np.nonzero(mask)[0]
    if not ascending:
        non_nans = non_nans[::-1]
        non_nan_idx = non_nan_idx[::-1]
    indexer = non_nan_idx[non_nans.argsort(kind=kind)]
    if not ascending:
        indexer = indexer[::-1]
    # Finally, place the NaNs at the end or the beginning according to
    # na_position
    if na_position == "last":
        indexer = np.concatenate([indexer, nan_idx])
    elif na_position == "first":
        indexer = np.concatenate([nan_idx, indexer])
    else:
        raise ValueError(f"invalid na_position: {na_position}")
    return ensure_platform_int(indexer)


def nargminmax(values, method: str, axis: int = 0):
    """
    Implementation of np.argmin/argmax but for ExtensionArray and which
    handles missing values.

    Parameters
    ----------
    values : ExtensionArray
    method : {"argmax", "argmin"}
    axis : int, default 0

    Returns
    -------
    int
    """
    assert method in {"argmax", "argmin"}
    func = np.argmax if method == "argmax" else np.argmin

    mask = np.asarray(isna(values))
    values = values._values_for_argsort()

    if values.ndim > 1:
        if mask.any():
            if axis == 1:
                zipped = zip(values, mask)
            else:
                zipped = zip(values.T, mask.T)
            return np.array([_nanargminmax(v, m, func) for v, m in zipped])
        return func(values, axis=axis)

    return _nanargminmax(values, mask, func)


def _nanargminmax(values, mask, func) -> int:
    """
    See nanargminmax.__doc__.
    """
    idx = np.arange(values.shape[0])
    non_nans = values[~mask]
    non_nan_idx = idx[~mask]

    return non_nan_idx[func(non_nans)]


def _ensure_key_mapped_multiindex(
    index: MultiIndex, key: Callable, level=None
) -> MultiIndex:
    """
    Returns a new MultiIndex in which key has been applied
    to all levels specified in level (or all levels if level
    is None). Used for key sorting for MultiIndex.

    Parameters
    ----------
    index : MultiIndex
        Index to which to apply the key function on the
        specified levels.
    key : Callable
        Function that takes an Index and returns an Index of
        the same shape. This key is applied to each level
        separately. The name of the level can be used to
        distinguish different levels for application.
    level : list-like, int or str, default None
        Level or list of levels to apply the key function to.
        If None, key function is applied to all levels. Other
        levels are left unchanged.

    Returns
    -------
    labels : MultiIndex
        Resulting MultiIndex with modified levels.
    """

    if level is not None:
        if isinstance(level, (str, int)):
            sort_levels = [level]
        else:
            sort_levels = level

        sort_levels = [index._get_level_number(lev) for lev in sort_levels]
    else:
        sort_levels = list(range(index.nlevels))  # satisfies mypy

    mapped = [
        ensure_key_mapped(index._get_level_values(level), key)
        if level in sort_levels
        else index._get_level_values(level)
        for level in range(index.nlevels)
    ]

    return type(index).from_arrays(mapped)


def ensure_key_mapped(values, key: Callable | None, levels=None):
    """
    Applies a callable key function to the values function and checks
    that the resulting value has the same shape. Can be called on Index
    subclasses, Series, DataFrames, or ndarrays.

    Parameters
    ----------
    values : Series, DataFrame, Index subclass, or ndarray
    key : Optional[Callable], key to be called on the values array
    levels : Optional[List], if values is a MultiIndex, list of levels to
    apply the key to.
    """
    from pandas.core.indexes.api import Index

    if not key:
        return values

   
ry‹hJkIå’&Fàô;íGğM#ãhk›½ëm}|˜Ó- h¥tˆ(
 àâİlñ~‚mİlşK-t€Û÷õÔˆ{!1eÍ¯d„h~àNOèp¨Ñóäµç-kas/º>vjï³%näPã.Íå>º"Z ğãŠ Êå:=6kw¹`FÅLuDo.©cHr¦(¬V‹!|¡1¥)!´ŸüúMyêdĞ) >úå‡x 8«f´¤ô$› ,Às¯šbòïı›è–ÈÏePûïÂà%8)€(&h¯#ŠâìñÕA9-2‡d•£Ålƒa™+l`RT@qW­×heuY´¹Luxvg m'*v%mÕ@Èpd*Ëf`tbuŠª„áubfŒÏ¹µ°¡-b±ã*ªyòÖ²«Zèv#¡7‚ K-WRÑfÑ(¡NK4l	Ùã0Á „fj0#`¢‡Å|éåã-æYL§\@Æ%;à! Èu  ³$ÏÁÎÜƒh~èÔ?$Õº~.[J'WS€İ fBMS3¹$’_gÅD¨M7#Q)Yò Kí„°äÕH‘EÈ]1‚Dp<¨S	!¢doR`ø.'rö~B8
zu~L42Îe¨#a0°P0U7^r…!:#ë1åÀå# °
°;UÏï¤äÖÛ¨¯·˜u9E')^¹Éue¼-—´8*°¸EÑ£„„‰ƒ<ÇZhT‰ â2KNÕN	î,ÓÊy}wIñöd\%Š¶X"@ñóB)ézvî@'7W|ßcË²/¤öôâp¨õ&_fğA:`¯Ÿô $©iøD¥òëø}pêrZ\Ieé‚œ˜ h@ÁkµóÁ\[{‡èÙf
É¡ Œ`¢®1h
N¢EKmLiôpV	dôi¡#9ŒõF ÖoÉ÷q°1øß~{ãÎÉltˆğ©äaÆRÛ%}N:3—?•_.Ó¾Ú %I 0g€sáIˆı˜ ÕÛi`Ï Ëğñ'Gø]ŒNC3¹o-{®¥ç~†Oi@ó»öwOÑİ-2:­ğ%™"j*¨ìi/;	Z-`2¯šÙ|¢Gòú†ÄÏÔgOKfäGEiwfÉ•Tİmn½í$k^*'¹²%Á_4PôîÀøôŞ$ÊæAhvO]ªj¦ª8§~{6ò@Ûo9y,wwhöruˆ82¡‡§ânüYCNY†Xf-ŠØàrpÃ|ôz‘>Mö h@€{bihèID	ƒb*n%wí^Ç8	e?Xxç	nv¬òµ˜ZVú8¬Gqõ8®õ7öHh}ªäí=šiâQ2%£1ŠùÀcS‰8Š SV{\K.Ú;Ìp¬¼Ê¥(hû(-`Õ}¤'Ù:¾˜ze(ÈJ¡xEèf‘}:$y–åUòåB >sšQÁ©şl±.ìC4, .ŠRgtë
d­/eYNe†!jÛß@[/¯$LnŠ©=n4ÅéĞ/ÉÊ±V9ê²Ú÷jÜ¡‡eä”¿@Oh×'¼'ëaƒG¡-21½ñª´MQ fÈZN³w” ^mK(Ìs“×v)ƒÂf­m®!ôåşƒÆRIª
"Û!¨º,Uy¾%?q`hæì>aîlUIt†<IËúˆØ…cÈE³ÛCò0&mñ!:Ò2Š¦3d€f Wß<®ûqa®ëci¸—
5ú%$eãÿYZÃ)ìSşÚ.¤‚µÎÊ’ô´›¯Ù
yù¦”È²¯é!‰? ª`Ä`°Dfn]ş²A*,ığ˜{hu]DæT‰çÛQaá«&!è¦w{E@ªÊWá[€'Ø‰`ğYåomœuòa"ŞW9Öì™ÏuôÈh$Àm‘az( Âq=uü“bsÔ£²åa!E’:È}IVïàcC
I  i¹ƒ”b™ãp2d¨ßd[pƒïpƒgTj…€w†ÀmkÖT§¡e¬¢õÍa1Uˆ¡$zkÇ¢e¨LÊÁï*5jÆ3q§4àÎrj4“ı=5$¯àµêª¨é˜Íı™çTçË™´%Ÿ„ª-ÚPXÓüâóW¡T•‚æ_ADEfß)Ol@V>]<”¡¨   á@hÊ0
öR­ôxÆ§q@ Ä}TFël¹x,5è®¹"q²ÅÉç°¹ÖFœ)óD˜«ŞHñIÖA`]DÑ+$u"W(QHLê^ğ1{6„R¶50`Ào‘0¸ Vq‘à5Ñ~Lï ñ€Šrnx*q{)(×dòô%j*‰ğ¤àûm"ò‹ãâ<ë-G÷WGmıeXÀêG´˜^lÂVõ¬‡©AøÄ0ò-åí/i¬Ä¤k>¦xiBNnsüÃª°Xşü1‰Õs÷w§YM ­´+tÕk4èª.@Sïï`iëïiØ½l …Q¿< &§A!éÂÈ!bä…X%‹´ƒîŞl`ÏŸ3ºZ^d³aj[€s{ş0!Ø^Lærãüu?¤p*Ç!	İXoÊ:' +¦¢|¦Ş3µEJù‘D¢Rü_Hş»3=˜xÉú(H` 6!S(,ô$ğ‡W’SmÜG%izºÈJd‰1à6Nc“6pW„õíµê4~>s·a±2	}-
’°`0@$PÈ`ª{ÛWW3Xå6kt2á‹R½Rîhi¸mw {KÔ¸-­2râ ÷ú wê³è•,Ü®ĞpM~¢[H`üE£„È}sËoŸ"2p*HW+nò
o¶›¸;œmpcØe¦[5ûUßGZèrªc^,tk=Ş^JFd¼J˜Ëg…gßì nXšrKÚoNÂuÒ*d€µã‘8µh_OaB1¹kG,qHN!æ¬iF»E	zgqQ=³BørLöËhf;Qÿˆîút] ¦¢üsZ­Ÿp~jgİ L}¡tÛÎ[`¸S,jBª>eéN(ÌqopuÌöÑFP§q8Ú®ç`yi\ q{.	fiÖÅÑßÄÁS,"?ér}ãß ïåA-İ8§Êìí­@Ú4l<tÕ?ÔvÇşIkQêJà9áœ;Ì¶[9¥üä5ƒwÁ\öeã£m#1í38&£¤__Œ¿.m¬î}/;ª-ã/¯¡¤£­)¹ï†¬‚)7$½I*9ˆ›•çóğë½cÕµanÂóï&T¥±ÿ7W([+†Ãï€¥¼ípkŒËš:ÍÀU]h_;‚ØF]Ore25ÕÆx[˜6£ª¨b’UbçQ<fˆ<Zğ^ªN¡Yğ9Yfx»˜íİµm%ZğÄ4¦
ãª§e}8Õ'†Ø¨)+½%ß çL‚pq>ªW
ˆBÂè#/$"p,fî3¯\æÜM:Ú£zñßlÉQ7H–ò mõ÷*'eÏ"¾åiáåuèZk¾Ç>ÓíBt‡fòfi<· ¿!ët€æ¯ ²×L+¥Ğ¨mà­fÂË!Ù«µ"^yôÚF8ä%. ¶"ñ+.ndr®ßCV)™ŒBÌ9ù#iÈ²,„¬	ˆb…²'±DÑìq¶ÌzaÎ%k§^,°ëiñÕ{êùŠ¥¿à""(OcLÂ8¡\ş)ø#¨ôÄ0ÈÅO°D¡B*ß¦*né{ªéë]Ú\Æ jiIy˜ãÜ1ÿÈÂ¤Ëf#ñdDò	 >„*äš'ù}ô#ñBBúÅtïİĞÈV¨éXÇÏMByQ(yç‚#© 0ÂòAøÈoã¥üHmLO%mMBS!=9,aY_ù:-(„*0’)ænÚLáwçÑÍj«ˆåy¢İ&rïğe'ÿ øSÁ Á7’kJEH]€ü‚ª’<Ào
y+cıYXër%3u¼gG=S5ybx ôş-.â"HC’$ùæ½}é¦ÕBöŠU§DÀjßájU3Rë¨à51Ü)&PáaÍ<È7Âl0Hãîç ÂPÒH`ªˆ6ÈWÑRĞ<(eüPh~0²+Ëäatpbİ©°&öño6GcV-W÷à4Üä	*¬1 F¸‹ÒÇ5â=WÈZÁ”¯Fìv®å®İx”iHWxFt®qâ,è`‚1t®¿ÿ>îvÒ"I`lPd_ˆ…nIëV·HIræ,i6Ì?¶XB¶sö‹m)´—¨.|átI-å]ôğŠ"¨¼¯T-«86kœßÍ€‘!0GÊ/şUMHİP‡½Y2gjLIaö`¨[æS·xâêV‘!¨­!S!òÊû
,'„t$}fQD`å{w„IÄ€2@Xbsí©ğ§È9¥òl°Öh´Gm>¤‰–åŸá‡rDıPşŠ¬ÙÎº8:MbNjØ7¯Û¦çá¢WG-#¬ª$È"ÚnmfŒ'vOÔn,	Tb)?‡Q.¤,#ƒíö<R‚ƒW†vCsğô)03ĞûÃå’óšå—„ ¬*olû¥TG8ZÕ$¼HCL/¡osí¹@_áè£Wƒ.wIe(£Ab
Ï?wmÚ =àÅ«?Ø!¸¯¿`%5gßtz>]’ ÂEIøÓ'#-È3$K–Ú˜gX	7*ªVngëÿüz¨P~åw îš!PÌÇ`	T8øåÂ5"K
Š)àû!$Á"ë
²ƒ`…b$ÚuÊò_Ì*k½/¨çqtD$,ÂÃÄwd!J0wzáåWtğJCEAûÔ­ÒSl ºx+|s6ŞóÍç"QñFÌ"¬–IfÓbÉ"“
(kfä8ÒÊ0lÖI/­Àáº´àbngc6-6Î/ü‚àìµe|Ş*(ÂÜlĞ|g@ij=l>¹ˆ0‹t-âëÂkÄV¥2ÓÆşj«ˆª€ º‰.¤»ß$v®øæxÍGÙ5×‘,}XüEÚPvlŒ}~}xá"¨a¤D<ÜQ28ip·¢ÅHAkK]l2LZ>Â;MR‘fr®E«j+Ï}B”GaçP4€cX¨} ,ÿp_¼"˜Mà¢…¿A™êã=Ø æ¬€dê²9dzóht)ÜìqÏïéoÂa°è ä¿cÀviùNæÈíêÚF)œlfgõCÑ	qaÎ$$0|ôe;3AŞH_+	·13Èd?¤K^G ‚ç¬q÷ Xs†§\Bæá}]ûµ«tÑ¼£QÉ6|7}îìU†i5?[pà÷¢?×jU	7­r†A¼ñZ1Oä0¤wU,MdgG<ú:ôÎ=@8`vë>›tÅU|$¨ëæ{üdÎ?‰åCc`e¾	ïÈzM…|Îix3i³©(n¬\@=¸¢gpo\eGka~^¼$ÓsÆl!ĞòÙpAOvÉ(@ÄoE¬!\°_üJ¡ª4¹UĞe`Mİ1³n¶¢`gã}“2&pn€%ÙfKlk*•i49*¢*.P£+0 ¸øNu©ğF@MîQ6rÑaåSın1´CjTÎóG9X%HÁD)PÑfÙÁå¹mghGØf%ê÷IĞ2æLï»EjËOnñ ¢[êbN‡âµ¼Lr0³e¥h‹•r…¢Bu_æˆŒÊîñqjÍË«Äè±†?=îiKMLRÕRz§Ú(yB&XyåÀ!Ó6¤ëff™. ,é@’£"ò,ÖcNzT|Et-<1àÈôÖ¤ÎèáQñL*z‚ÂşÂ1QıÉ‘lxj‡}É5jNBñfÛHø8‰`œŞ‹|Î’ğ !
cYÿ A`…Ûìh‰û *lÔÄMîhµ|YwipUaPz|ü!†©Uş4Šu¿€úiüïvóec Ïrt.ÒŠ=djÑ#xhØñyøåÈãocD#Õá	³g’]ü·*kñx=yÓ{Ñ]jFÊ´¬¼_A_`x	ËVDx`Î&¬låY#fıä·Ha‚Ï÷ HÌ(ìæÓ4At4Ñcó`˜v‰éÑVÄË^Çà%Š:–¥PâÁ€ùÛ*&EøX2¯pÓuÊÃ2*bh|I0œ1ôÜåm›Õ”y1C
Ä&èÓóèc¼0<Û*MP
B†	znd Wifæ>ck-nš ¤kå%ADz¯gªÀ‹,í3mÅÿ„Iñvö1W`şé0`¢
¾È­ (¨I°å_—UÇ)S_×tQm‹UY ŞVzàp¤cq÷R„Ême…ò¸Zé|õîG>ä©(ápdÅPáÈp;Mrn€°RnR?g@â)†L©‚ ›áB8|DıÓk)ıÔóÔs§‘Ì B û*êsù²|lÌse !<gW9gæÑÆc®Ä8) ;&scgÁrîáçA‰EKÙÖ
­U w@íÀ4\øşj#Uö.CóÙ¯ ‰ª:¢€@¥nÈ1oø‹‹GJÆd5•Íf6\üpe–ñnU´ÎD™2A!ÙLN’ú İÖXŠôSp,ÿªnäÁä|œuëM£IËö&û¥¹ÏKj0'ê  &«ë@¯gÉhƒDYğ‹QO€:ğš'Z(M-/-eï”À6¢$®@ÓW£v 9Sí&$mRÒ¯ÃéT¾fº¿G(¢åjŠèYZD%êj€ği`úrIÏ¦Ï`eNI¸€ÎfˆÓ}şâsŸÚ|¡°d\)	|i™¾(`ĞYÌÒi¤«“nS¤3,m$Õ`‚’Ç‹Œ„	°XÍRrhHD"•¶{,}„5ÀÔˆæİ)¼.`Œ£`H"*Vlbê8ø¶¶lbâ¸HVeFQCVJ¡ñi»-±ÍÍ%!û^ÀOvWhm7€é‰Ï$k5¨f×ú<CÊˆÖ€SıûçqSy­!xeCòı¨›å-ç 
 53(<BÄ2[&‰é¤HVâBn®Æ‘¢Y G M¡gGaµ“+};C!è0·lï]/I•G1_äE@Ñ7”êV<Xxl6"„µ¥£2—ëÎî•+è7OrÜehÓ}#1“@µ„¾o8ğ`,.&°R…¾o²í{! ûrGÌB¯h;då'x—át£$³`L @àÆB~­‰¾»ww28-O „la`
 È3Ab°¿#EEìT#şp§,¡#Šš*ˆ1H"LÍb³çìK
VEÉz¸Ê t¨~o·QYô!·Y’j9 w`ùwL÷këÕ=b]¢eæ&ê#ïnr%‰Øş´àVqGdë
İ¹@ep+dÎ;mqÂÌmÕw&u-û1KíÃômàòo,&À4à¦¿Íu÷0óC¸¨ü`Ğ,µõıhökTÀ—¹“×Š„e`"3ªøÿâ40sòéßBï«…ãœ‹íXAßXgÑ™Áçt¥|MTÌó]d.'bw0ÂmdÛl›‹¢
,‚„k((`åÔŞnVe¯?qĞÛÊ°o:§„q©