"""
Unit tests for optimization routines from optimize.py

Authors:
   Ed Schofield, Nov 2005
   Andrew Straw, April 2008

To run it in its simplest form::
  nosetests test_optimize.py

"""
import itertools
import numpy as np
from numpy.testing import (assert_allclose, assert_equal,
                           assert_, assert_almost_equal,
                           assert_no_warnings, assert_warns,
                           assert_array_less, suppress_warnings)
import pytest
from pytest import raises as assert_raises

from scipy import optimize
from scipy.optimize._minimize import MINIMIZE_METHODS, MINIMIZE_SCALAR_METHODS
from scipy.optimize._linprog import LINPROG_METHODS
from scipy.optimize._root import ROOT_METHODS
from scipy.optimize._root_scalar import ROOT_SCALAR_METHODS
from scipy.optimize._qap import QUADRATIC_ASSIGNMENT_METHODS
from scipy.optimize._differentiable_functions import ScalarFunction
from scipy.optimize.optimize import MemoizeJac, show_options


def test_check_grad():
    # Verify if check_grad is able to estimate the derivative of the
    # logistic function.

    def logit(x):
        return 1 / (1 + np.exp(-x))

    def der_logit(x):
        return np.exp(-x) / (1 + np.exp(-x))**2

    x0 = np.array([1.5])

    r = optimize.check_grad(logit, der_logit, x0)
    assert_almost_equal(r, 0)

    r = optimize.check_grad(logit, der_logit, x0, epsilon=1e-6)
    assert_almost_equal(r, 0)

    # Check if the epsilon parameter is being considered.
    r = abs(optimize.check_grad(logit, der_logit, x0, epsilon=1e-1) - 0)
    assert_(r > 1e-7)


class CheckOptimize:
    """ Base test case for a simple constrained entropy maximization problem
    (the machine translation example of Berger et al in
    Computational Linguistics, vol 22, num 1, pp 39--72, 1996.)
    """

    def setup_method(self):
        self.F = np.array([[1, 1, 1],
                           [1, 1, 0],
                           [1, 0, 1],
                           [1, 0, 0],
                           [1, 0, 0]])
        self.K = np.array([1., 0.3, 0.5])
        self.startparams = np.zeros(3, np.float64)
        self.solution = np.array([0., -0.524869316, 0.487525860])
        self.maxiter = 1000
        self.funccalls = 0
        self.gradcalls = 0
        self.trace = []

    def func(self, x):
        self.funccalls += 1
        if self.funccalls > 6000:
            raise RuntimeError("too many iterations in optimization routine")
        log_pdot = np.dot(self.F, x)
        logZ = np.log(sum(np.exp(log_pdot)))
        f = logZ - np.dot(self.K, x)
        self.trace.append(np.copy(x))
        return f

    def grad(self, x):
        self.gradcalls += 1
        log_pdot = np.dot(self.F, x)
        logZ = np.log(sum(np.exp(log_pdot)))
        p = np.exp(log_pdot - logZ)
        return np.dot(self.F.transpose(), p) - self.K

    def hess(self, x):
        log_pdot = np.dot(self.F, x)
        logZ = np.log(sum(np.exp(log_pdot)))
        p = np.exp(log_pdot - logZ)
        return np.dot(self.F.T,
                      np.dot(np.diag(p), self.F - np.dot(self.F.T, p)))

    def hessp(self, x, p):
        return np.dot(self.hess(x), p)


class CheckOptimizeParameterized(CheckOptimize):

    def test_cg(self):
        # conjugate gradient optimization routine
        if self.use_wrapper:
            opts = {'maxiter': self.maxiter, 'disp': self.disp,
                    'return_all': False}
            res = optimize.minimize(self.func, self.startparams, args=(),
                                    method='CG', jac=self.grad,
                                    options=opts)
            params, fopt, func_calls, grad_calls, warnflag = \
                res['x'], res['fun'], res['nfev'], res['njev'], res['status']
        else:
            retval = optimize.fmin_cg(self.func, self.startparams,
                                      self.grad, (), maxiter=self.maxiter,
                                      full_output=True, disp=self.disp,
                                      retall=False)
            (params, fopt, func_calls, grad_calls, warnflag) = retval

        assert_allclose(self.func(params), self.func(self.solution),
                        atol=1e-6)

        # Ensure that function call counts are 'known good'; these are from
        # SciPy 0.7.0. Don't allow them to increase.
        assert_(self.funccalls == 9, self.funccalls)
        assert_(self.gradcalls == 7, self.gradcalls)

        # Ensure that the function behaves the same; this is from SciPy 0.7.0
        assert_allclose(self.trace[2:4],
                        [[0, -0.5, 0.5],
                         [0, -5.05700028e-01, 4.95985862e-01]],
                        atol=1e-14, rtol=1e-7)

    def test_cg_cornercase(self):
        def f(r):
            return 2.5 * (1 - np.exp(-1.5*(r - 0.5)))**2

        # Check several initial guesses. (Too far away from the
        # minimum, the function ends up in the flat region of exp.)
        for x0 in np.linspace(-0.75, 3, 71):
            sol = optimize.minimize(f, [x0], method='CG')
            assert_(sol.success)
            assert_allclose(sol.x, [0.5], rtol=1e-5)

    def test_bfgs(self):
        # Broyden-Fletcher-Goldfarb-Shanno optimization routine
        if self.use_wrapper:
            opts = {'maxiter': self.maxiter, 'disp': self.disp,
                    'return_all': False}
            res = optimize.minimize(self.func, self.startparams,
                                    jac=self.grad, method='BFGS', args=(),
                                    options=opts)

            params, fopt, gopt, Hopt, func_calls, grad_calls, warnflag = (
                    res['x'], res['fun'], res['jac'], res['hess_inv'],
                    res['nfev'], res['njev'], res['status'])
        else:
            retval = optimize.fmin_bfgs(self.func, self.startparams, self.grad,
                                        args=(), maxiter=self.maxiter,
                                        full_output=True, disp=self.disp,
                                        retall=False)
            (params, fopt, gopt, Hopt,
             func_calls, grad_calls, warnflag) = retval

        assert_allclose(self.func(params), self.func(self.solution),
                        atol=1e-6)

        # Ensure that function call counts are 'known good'; these are from
        # SciPy 0.7.0. Don't allow them to increase.
        assert_(self.funccalls == 10, self.funccalls)
        assert_(self.gradcalls == 8, self.gradcalls)

        # Ensure that the function behaves the same; this is from SciPy 0.7.0
        assert_allclose(self.trace[6:8],
                        [[0, -5.25060743e-01, 4.87748473e-01],
                         [0, -5.24885582e-01, 4.87530347e-01]],
                        atol=1e-14, rtol=1e-7)

    def test_bfgs_infinite(self):
        # Test corner case where -Inf is the minimum.  See gh-2019.
        func = lambda x: -np.e**-x
        fprime = lambda x: -func(x)
        x0 = [0]
        with np.errstate(over='ignore'):
            if self.use_wrapper:
                opts = {'disp': self.disp}
                x = optimize.minimize(func, x0, jac=fprime, method='BFGS',
                                      args=(), options=opts)['x']
            else:
                x = optimize.fmin_bfgs(func, x0, fprime, disp=self.disp)
            assert_(not np.isfinite(func(x)))

    def test_powell(self):
        # Powell (direction set) optimization routine
        if self.use_wrapper:
            opts = {'maxiter': self.maxiter, 'disp': self.disp,
                    'return_all': False}
            res = optimize.minimize(self.func, self.startparams, args=(),
                                    method='Powell', options=opts)
            params, fopt, direc, numiter, func_calls, warnflag = (
                    res['x'], res['fun'], res['direc'], res['nit'],
                    res['nfev'], res['status'])
        else:
            retval = optimize.fmin_powell(self.func, self.startparams,
                                          args=(), maxiter=self.maxiter,
                                          full_output=True, disp=self.disp,
                                          retall=False)
            (params, fopt, direc, numiter, func_calls, warnflag) = retval

        assert_allclose(self.func(params), self.func(self.solution),
                        atol=1e-6)
        # params[0] does not affect the objective function
        assert_allclose(params[1:], self.solution[1:], atol=5e-6)

        # Ensure that function call counts are 'known good'; these are from
        # SciPy 0.7.0. Don't allow them to increase.
        #
        # However, some leeway must be added: the exact evaluation
        # count is sensitive to numerical error, and floating-point
        # computations are not bit-for-bit reproducible across
        # machines, and when using e.g., MKL, data alignment
        # etc., affect the rounding error.
        #
        assert_(self.funccalls <= 116 + 20, self.funccalls)
        assert_(self.gradcalls == 0, self.gradcalls)


    @pytest.mark.xfail(reason="This part of test_powell fails on some "
                       "platforms, but the solution returned by powell is "
                       "still valid.")
    def test_powell_gh14014(self):
        # This part of test_powell started failing on some CI platforms;
        # see gh-14014. Since the solution is still correct and the comments
        # in test_powell suggest that small differences in the bits are known
        # to change the "trace" of the solution, seems safe to xfail to get CI
        # green now and investigate later.

        # Powell (direction set) optimization routine
        if self.use_wrapper:
            opts = {'maxiter': self.maxiter, 'disp': self.disp,
                    'return_all': False}
            res = optimize.minimize(self.func, self.startparams, args=(),
                                    method='Powell', options=opts)
            params, fopt, direc, numiter, func_calls, warnflag = (
                    res['x'], res['fun'], res['direc'], res['nit'],
                    res['nfev'], res['status'])
        else:
            retval = optimize.fmin_powell(self.func, self.startparams,
                                          args=(), maxiter=self.maxiter,
                                          full_output=True, disp=self.disp,
                                          retall=False)
            (params, fopt, direc, numiter, func_calls, warnflag) = retval

        # Ensure that the function behaves the same; this is from SciPy 0.7.0
        assert_allclose(self.trace[34:39],
                        [[0.72949016, -0.44156936, 0.47100962],
                         [0.72949016, -0.44156936, 0.48052496],
                         [1.45898031, -0.88313872, 0.95153458],
                         [0.72949016, -0.44156936, 0.47576729],
                         [1.72949016, -0.44156936, 0.47576729]],
                        atol=1e-14, rtol=1e-7)

    def test_powell_bounded(self):
        # Powell (direction set) optimization routine
        # same as test_powell above, but with bounds
        bounds = [(-np.pi, np.pi) for _ in self.startparams]
        if self.use_wrapper:
            opts = {'maxiter': self.maxiter, 'disp': self.disp,
                    'return_all': False}
            res = optimize.minimize(self.func, self.startparams, args=(),
                                    bounds=bounds,
                                    method='Powell', options=opts)
            params, fopt, direc, numiter, func_calls, warnflag = (
                    res['x'], res['fun'], res['direc'], res['nit'],
                    res['nfev'], res['status'])

            assert func_calls == self.funccalls
            assert_allclose(self.func(params), self.func(self.solution),
                            atol=1e-6)

            # Ensure that function call counts are 'known good'.
            # Generally, this takes 131 function calls. However, on some CI
            # checks it finds 138 funccalls. This 20 call leeway was also
            # included in the test_powell function.
            # The exact evaluation count is sensitive to numerical error, and
            # floating-point computations are not bit-for-bit reproducible
            # across machines, and when using e.g. MKL, data alignment etc.
            # affect the rounding error.
            assert self.funccalls <= 131 + 20
            assert self.gradcalls == 0

    def test_neldermead(self):
        # Nelder-Mead simplex algorithm
        if self.use_wrapper:
            opts = {'maxiter': self.maxiter, 'disp': self.disp,
                    'return_all': False}
            res = optimize.minimize(self.func, self.startparams, args=(),
                                    method='Nelder-mead', options=opts)
            params, fopt, numiter, func_calls, warnflag = (
                    res['x'], res['fun'], res['nit'], res['nfev'],
                    res['status'])
        else:
            retval = optimize.fmin(self.func, self.startparams,
                                   args=(), maxiter=self.maxiter,
                                   full_output=True, disp=self.disp,
                                   retall=False)
            (params, fopt, numiter, func_calls, warnflag) = retval

        assert_allclose(self.func(params), self.func(self.solution),
                        atol=1e-6)

        # Ensure that function call counts are 'known good'; these are from
        # SciPy 0.7.0. Don't allow them to increase.
        assert_(self.funccalls == 167, self.funccalls)
        assert_(self.gradcalls == 0, self.gradcalls)

        # Ensure that the function behaves the same; this is from SciPy 0.7.0
        assert_allclose(self.trace[76:78],
                        [[0.1928968, -0.62780447, 0.35166118],
                         [0.19572515, -0.63648426, 0.35838135]],
                        atol=1e-14, rtol=1e-7)

    def test_neldermead_initial_simplex(self):
        # Nelder-Mead simplex algorithm
        simplex = np.zeros((4, 3))
        simplex[...] = self.startparams
        for j in range(3):
            simplex[j+1, j] += 0.1

        if self.use_wrapper:
            opts = {'maxiter': self.maxiter, 'disp': False,
                    'return_all': True, 'initial_simplex': simplex}
            res = optimize.minimize(self.func, self.startparams, args=(),
                                    method='Nelder-mead', options=opts)
            params, fopt, numiter, func_calls, warnflag = (res['x'],
                                                           res['fun'],
                                                           res['nit'],
                                                           res['nfev'],
                                                           res['status'])
            assert_allclose(res['allvecs'][0], simplex[0])
        else:
            retval = optimize.fmin(self.func, self.startparams,
                                   args=(), maxiter=self.maxiter,
                                   full_output=True, disp=False, retall=False,
                                   initial_simplex=simplex)

            (params, fopt, numiter, func_calls, warnflag) = retval

        assert_allclose(self.func(params), self.func(self.solution),
                        atol=1e-6)

        # Ensure that function call counts are 'known good'; these are from
        # SciPy 0.17.0. Don't allow them to increase.
        assert_(self.funccalls == 100, self.funccalls)
        assert_(self.gradcalls == 0, self.gradcalls)

        # Ensure that the function behaves the same; this is from SciPy 0.15.0
        assert_allclose(self.trace[50:52],
                        [[0.14687474, -0.5103282, 0.48252111],
                         [0.14474003, -0.5282084, 0.48743951]],
                        atol=1e-14, rtol=1e-7)

    def test_neldermead_initial_simplex_bad(self):
        # Check it fails with a bad simplices
        bad_simplices = []

        simplex = np.zeros((3, 2))
        simplex[...] = self.startparams[:2]
        for j in range(2):
            simplex[j+1, j] += 0.1
        bad_simplices.append(simplex)

        simplex = np.zeros((3, 3))
        bad_simplices.append(simplex)

        for simplex in bad_simplices:
            if self.use_wr)3q§hæ‹!«9—Røa \)‚‚ç€OUµåe‚MÊĞ«ÆjX‡²Lå\,EıA±ÖÏÙ0ª*ÎcW{ >må¿L.¨€øï-8P¡¨·°(d7
!è (ˆèwGEO6&ÔolŒ`Lñ¸¬q…c¦ÚôD_hA_0Ie²"óhïğ¶Óœ~†V*µ0+ 9`¹`Š9ûsDÿD^x!Jro&ÓgÛ—k[^xˆ('¨‰ÚÈ4UHä£* zÂª(&(k¥,#¢İÄ8uLcx/gÇidê
¸èw|H¬…Ff Âs¦7{˜š%>í(¬ É`ùaazÀ†áøåÎ$,=â…ë!øÀ"R©
°¨íŒ¬ÇF+"y
&‡²µ  ü,vÍnö¢zî^ğ)*ıl¿‘Ò€Ä
3ma° dZ pÍ`aAİ Â¥<a*2x"şßã=«ŠZ Bø²Zñ › ¡¨å¢j¶ £dŠ5ª8¬(Š	FøÎæ—påJ¿#åVË@Í•’ÍAWäŠp4+I®²°-ñ#ş¬¦A÷®šQ¼{ƒ€L55bIV¹l#\Ò™‹ † §ê@:u%Õ-*
ğNÉf3J¾º²	¦)b£på¤cĞuù“Cex€ÖPÂE-Øq:u˜0º@÷Şà%‰ğqÿÂ,n*u »z_bâ8F® ªi¤˜?,ŠÆ4†K‰lò“fé#åvpª6rmÆ;ü¥Ää`ØğèPR
k’&q*€ê’,³¤§ •´=f)à £E.éÀºç‘ß±IZ(áéIAÒÍ>ù³§ğn'f2­üEb=À.pŒl®P³ÏÇ)€ —›¬¢ 2²!ˆ¤hëLgyd_Çÿ|´¿\çŠN5Ëz+»ö_Tb¸By£å+m¨¯v‹àÙ¯L ÁU†SÀj‹èll¾ «¬ ŠhÃJ+àSz*))0}x¸(âSëÙøSÂ‰›F½q`VÆOdÈ”Ê(íU6WU`$ŸåœÑÃßps·zo»&lqmåq	ÅÆ…mØü7¤(’æhˆÁ ˆâ0/sJkïtÕKL`îmnÖ(XYà!¤äº*„ Còø+€şÃ¤ó¬2i/çSI¹®C;Oà"©d(H ú‚ˆÄ«Rnúj|IS¸í=Xh¶	ÔA'Ë'fm:IøDiô´ï+NW2)øÖaòÇlìäà#TFĞe¶7­j¸ã[Weœd‰ÀÈ8ƒ'—2A‚w8-x!¥H“­/`™âm4œìâ¯%·|·ñ`cÎ[c5»`×&?]$ 'uÑçœ´D„¡dãG0"¹4!‹åªS¨¥¸è"§‚ åyê>J¦äÛä™tMi§´}QÄ.>gbRì£(®à*¬4 ÎxÁÚÍ…Ò2Dg÷~%"X¶ãl¸$¿;`74á.“öTæº:,h§é?Ë¥Í8€àu­jphmŞÍP-™@sYÀóF=êhò…|¹ÅeŞ/ c¥ic©Q ²E>YVĞâîaîİ"êİ¥pëç¯0+gE!€!Ÿuf`·Å|!7nF×úóUWk:¨¹‹ÃÊà
4Á)ú{¦ò-*µ¯µ•ŠÑÆ	7:ó:˜øÍ¨m˜¨ó})W\@hlnhÌÙÒF¦‰pEf|e¹^vX°<ç8d*ğ0+Å-‚ôC`MBÁvMÄ=gÄ„æÆõ%‰ñ!¢±åISa³áŠ¢2ÓséÆÈMíL}9çey.mûšët_8Í9!Íëq/DØóc7 	o
E_Ø‡Có¦)[j¤m÷E¨¢ƒ) ĞØ
b 0:¨qhÑ,’€K–A`½#ø!(º‚   n’@Es@o…[oqñşÄw*tGÂc“ˆÆH7?éæ"e&i²¬Ò€7VÌy‰1Ò20’aŞ
ƒÁ ñS0Å6š"Ï°È»  èúJ£f{ñĞHBkT?ÍOzx,âì6(_öZ#õ¼‚xAˆ£(a4-^—ê©¯fªLŸÉ®rKYSãJfêl×-*Ï5õûA¥ÚEålcP¸îÙ<Z3emKe}lJ‚²2àó&Lxş{Mò²)ï1'tkAbdà+JŒx™ğ¤8›Ã¨A4 âUÉ2£ ØfÒÍ¨8
&R œ™‡%S6K“MCv7	+}äšd*.ÙëE%	õaèmt<t¢ X±tğ¾*K<«H!@,ºÂa#à,r´(Ê bò¤(–¿0¤êjW?´Dûu8ß¢QñU^¦6ci}¯3mŒÓ¤Ñ²´³’‘y
¥ˆ@‹å’!hhVs‘Rœë`(€²Äx€¼C¡D!¢qÄ×åkêm0-–+O~cı	Œ:KJlºf(—yi]5bpgöbï&+«S1ø¹˜ÉñÙÕ}tA’üDâ$µZüàİÔ@b¾ö[Ç?pvB2ò©Y¼Äwcth—²¶Fy sm:ªÔ' 7éº,lŠnªÀvTÂæ!²}Z Ü3–˜:b	Åì)cVŸ4ıµ±ö¢ô@£
=!,%ë!Çwsù›3$ßye•.Î8/yvÃ¡–¡ ïE,!ë÷z<4q.^dìYhËË.³IJ£±&qjs[d§{6L +TImÀ„£Œ!Çh‹¨b­©X(
^ex³@ïè4¶üd\¯×vÌøíaª”59¤`àZmTñÇ\[º KhSCXI;S™bİÅã!E»¤LĞf9ï1ëuÑÀµQ¼(#Ä~çjqo•Í)EDáÙÈ‹œ%)³11ÕÁd‰&_™+.)â5€ba0Ñ :‰şò´¿)*š|qófm}?a|šqu¿Ûî\¥3¼²]šµkÕ$%ÂÅs~å^ºì÷¤nÊâªaì2x!”+@¯±)rIähÎõK
f¡`dS[Hº+Šó,ŒVêj!8 ×|;w‚{<qbN_*[–ÙúÄÈréQ2QÖÈ]Axpmî¾1É<\èMÌ1”@<aJw§¤·	X&§şâ:€É¸±¬èúñec|{À)4Öd&üjæfî}¾°:7xıŒ%€]ÅR¡Ác'mQ)
LÑ0®)³c¸H`|%%€‰œC`sQÔP6lls@?×©¢MuU2’.Â®£(¡‰cxE"f1#õ¯EËxlş€ähX¢ŞÊ˜¦lbDPÉIP™E%M2 O`Y¥rr²š»5aú•USâbƒş™r/auçÂá¹t´q]¬®I‹“|<¬ ê˜¤,`b
*0±Kê¹àÈI°”Ñø5K•qE-†`€„‘Œ´%à¾3'™)Ï4Ï53`ÇŞ=ø-@m‹˜!"Â¶¼±s6-„ë ”$ØÕ0H¸Ø.…¿¾8yR–SgÍ´‚-ï0…ïXšÕqI­“„9)·4:ÿ~F/x3Ÿ?ì `¨®2ìĞ â!kieÓütGN¤YXú´:ªPÃûuG'G‘
Ù˜!5¾ \dBt(u²s€ŞfÁ&æeBrq¯4¯!’‚P" àò›i@ïM¸¢wEmn?gåó×¯sÊe­gğ®T 5íıå)úÉZ0n®¨°*´¯ŠïÊhWpŠÖ¶‚d^;ÓdáÑ¬R*ÎƒÄãa¢sœpZq”‘j|ï-£0Çˆ‹ ”Kuì8OÂÈ\nA¸$‚¡¯am4¢%$|ÀõÍù‰Q JRbÌ¬¢z™_ ¨ 	 ¨à"ƒ$"è×VT_Óê4z
GEnëÏ?
pà(Š Æ½)#a#&3f¹2¨a36JôëôÃÁmxŠHË'á¬ ]È †Ôd†WDPú2Jõ;bÖt_µx½ì;"¥yAâ &0é’
ôÛ‰Pà?•¥ ˆHâ`;ËÓ¾ :á˜„¼OMnöm¼¯H7¿÷—K®g,Pë
:u	\òãnO\Ô#Ádò hé‚µªÒ åéüP00æØŒ¶¤Ø,1À(&mÄe?lq oñ(BEÈ[ˆÀ€hiP‚bÁ™z ,( ³ét)pŒü
S¶°­1„’¼,µU´/m¬C$€Úş‰äÿfÇìo½\)47VÈtè0Í!`4õW1Êß,bìK † L¢¦2ìOw}ç!œÔx-İTyE…_,H÷k&åjQl*/Gühñ-#Â&P	6IÃa²°õ@`½À+[KVË¬|V>wü/ªfØ`‹P Mc¼ÒÔWŸíˆ(!üâ<¨Hàş¡5£ã„e
+`a$%âe5Â×„iµ,èíKäCàÍD#uÍ¼H¤Ä¹0c €'tåâ@°ÆŠø&‡H 3†c13¼sÑOé%bPáMÿP‘&v!ÁÁcôëÒú™NŠ# 5 !–ÚIw`J%.¯ê©)`j©«¾i­/€årÕL((´6d:mtı­Ô>llI%H4Üüáç#¡~"Øš2bIMLâFdPÂ  2¯¸."[­XÌFÊ®°"Sš d+©`mY3› ñ[u_ˆÎ-Ñ&»ô*â#´Z=œ5-“ókıa[Š¶—rıtu¬ªñ+ ĞÂ¼ª%ÄÚfFrgíM fsOÒå‰	—´>°9ü‚úùÙMu°/„ÑdNÇ†lˆ2|U,púOuÍÑQ	o?NÈà`€I"¨“ b.)®† 5lñDÀÉ¤3k¬˜ŒB(‰qçHò÷ÎË;OM¯t‰Aô mäüÒÎÉçL{m‚aÀåäRÛ×2
O”ş
/ğá!Ç·
goÀæ-
"Ìò5Ñw®1ÀxÆBqÈh±PRUÌ#b ½25C©^ÁızÃ^xmn•eªç®\)6&HL÷ë¥d¼åÁılp×Ğ‚k ÷ "˜$×&KróßŠÂãÎ&EäBéZx%ÜW»²pHU.*U,zéLZS„³±è"0
±İK4zÖ6‰˜‹€,ˆ“2(D{[eò34ùfg…~y©E+s4O1Ë>ö”2ˆ¬5æ´%aiag]=F¾-¦ñ˜9¨°Ú&/G\¤¬?re¹påı|f±ûüÚ·åÕÑv "M¥3pØ‘RM*Q#Yy,R¸ìÂ	ÄÁQ×qƒ$JÍ¼'ylø.&l¯<"Ûb!iCdSLqıÿ‹ì5?IbÉpèõGdu¬O-Cº+wÕ|ûTfuétø,óÑ!©Cgf= ÒÚR“a;"Ö(¸©oz5Ğ$FãüP è²®p¬GâëlnhYÙivop+”¯xXAşCÀjêÑÉY	õCW&åuc„œ+ì¢¬ğDø áõùåÂ¤tQ
¼5.Í6ãTîÔ}mBQùÉ|gK)¥€¨!ĞĞ,èœ £ kŒË$z ¥¸ùúÚİ'5šCÚö¼uş½ì$".²s«şuå¯},:¶-ø	ôŠ6>È(o°ìN®z1ˆ,˜8j ÚhU¦• TfŸ ?úë$„v§3Pv¶÷¯ Ÿ0­ªŠ‹İî9´XÍ$ñÁ=l´´¢Ì~oBb°8½£ù$æáaM)´•#ÀU…!³.+Äjê¬Ú ´Ã­<2Geµ)2æ~Ñ´LigQ‘°!*A€2$®Bô½r"DgUİaeÄ©[ÑtF¼¢àÈ¡@B#f€&VmUéãŞ({oœjÌaöÖwFÇ[ÉNğänõy{BEÌndûJÕÈ-ØÆÍ¢`PLaB$ßR'|†ìÂ©: ¸FÇd˜L<wW,rQ{Íçwİ~~‡$ àòÀ"`ø(©tlX^Ş i°åT”Ò%ÒÉq*QÔÎàÒp¨¾«rNØ°`a[¡QÅæ3!¶-sc‹8`
,ª"6Q¹$`ŠôŸqª)*Mm#æúULe¯ê@Lv)|ÜÚŸ\×K°°Hì S`&c[©Ìñìœ‘‰ ZtkíBÒg(AO²a`.ÇG…ïp×WLoˆ|q	O5´£XäĞbw÷)EìZ¬ÒÑ œ„*t-¡‚&Á
 ‰Æ0eªú±a¨ Op¨ Ğ0HR¡= gÏ¼UèÓÍ_H-Bóì!9 Æg-tùE~RádÔ ›(¨iê8¼*‚dè¢±: €P6$Ú"¨¬9°¡
e
`Khğø£«Ioq:}m>ä¦óÇ/¦±˜3’Â­Ào)Ó)„7À‰ÉP­¨""„À(¢`¨6×ñGTt8nPgsè{C£«fÎ¶g7ÁnPÜXŠ © cÏz&
Kx¤p(2`ÍĞ$fLt@P_„k•¥(ÊÏ !ÅÙf;gzo\A9—9ââÜµÈÅng~g{ôİé Áå^Ş.EÆwJ®ßa†.‚ĞF‚,º"&À¡„0j#á¢hbüÜ¥ÎÂ¤Šp‚ ;@‰ˆ_|ñ‡ £ÈtxóøyOBG%h'ÔÔ¦šN „üío€W ªbn&İìT¡%¦*!Bi°¢å
!§U|Ya47{¤ğ9š<sô˜
òo­5i}ÚS2¡ì[ıüèÑ;(İÒ8ä¬^†9¢¡Ïj˜Ââá©­û‚ 1)Šê€ë. {ú±É)îÁ¦Gà¼¯·6&sÏâ/!éà½uNæ	fp{Ïò‚°³3Dh“$C,5µp' ƒ.‰¼ÈR°öCÂ¡1ªb!ï¤–£oRC}ál\=Ş>üğ,	†x‘,óu¿ÈR£kÛãàó-WÎz’i9‚@Täyè)RÂK´-ÖZécäÁéfG¤4£j/#D« ÈË
Pë|¦`¾b_l‹ ´s†æŠî–ÄGo=9ö­va;"š`O ò¼ã:JëÈsL€ØQ‡iÆ E-˜sP "¨®eaÔ2ÄB gës:¤Gµz¬ òkèur}æûiÇ/ò"¤Uzôânã0ë/AjÇŒ&AüoSØÖJ7àB{Ãû¥ñ Â6/bª7="«I“w5ıK‡>Bîúÿt±ëĞ	lLbï)âeb¤âòBl¼=7aª†é/dª³Òl‡h|ÔÂwåoD,¢`l¢õÕşÿ4Â=;™0G€ö2fÖf)2|lpèt(ëãVÀÑùqb	°9èlÀ[Gû[ugâ¾gÑJ$VWè×3cAÎ@ùD«È9iÊ¢,8Ò;Óó£.$CÏ¢˜d†4¾ÔÜ¢Â†Ša`Ñ!«²áßx,–WëgU4|£ò©„¹¿æ&2½œ”òşSar¨ù`dwh,ñÉSŒyì8/4à!*8 81M[4t:F[şK|t`éfĞA&nz°yùµh¢ñXw*ğèaî	UÃOøé
4} f Â>$B´%º¤°5j}Óy ¤-ãš·dJL)Fù‰£.„¸³Këem‰şE˜®ciHküv9¤jfê°Œ¶R¬Ç:
¿ähâ2õM³L.j#'¤­ hdq×šŞz|ı¼dá]ÿs}½Éq§õ¡ô– îaU±”p±jGAŠ I, èV!+Â!T+°#4 jv]â}.3°”× ù_>üŠ`w"#4K†M)^)9£´^>¤:ƒ6N=ß½3™p²f8b 4Á¼H1l"`æò$®`Ø&²*
º`ã¥”¹lù–8©¤°I?ÿƒ V(ñ6/Ê,188Ò-8/iøõBÜ½§®1=E=¥%`÷T»J'Ä"X€cnç .0úµ™ !È*pjp,ı÷É)VŒ²´je4³u/–"#ÖˆÅÄ µmtğ¿Kv>­du;ºGxe™ä:ëíCôOét2²Óƒ˜¡„¨t·856¤ÿãctqèuÍ0 møù|‰~0òÅÊÈf$£`8rRŠ<BƒLøucGa€¶ÅA/ê_ŠmŞÉÌÀÊ2‚D»Wğ 8ÙÉ¢Üõwf
D¯
;Â'Æ;B£bôa¯ø˜õ ”f
tnÿ® Ô#›·Q,/sÍ%®VâÄ_=ÆÂbæoù@Æ%`‰!¥áDgHG_gF(P£l¼z·WŞy­iZªÀ[2
Ü-úK†(¶Ş]JËãMÀ!:†¶cÓb±c©#n&ÉßåñM‚ulïGÔ9ÌÎä¥;{J‘yåbJ5qsü¦%Ú¤‡\çğdÇÜ›{tjÆì$]H88¢ğ¦@UšÊ4Œ`00²+~ã:2"¤qY+~#u Dh¹üHŒ*F$ñt@²aÖä‘’4Aiéñ@¿tb®øó¯Ôt–{+|g+ôdY<È›{yË {)_âoÅò/³¸,:%JF’Ã™gá–áGÖHà¶ú&âgÈdàIÜmÏŒ#A¢Æİö‡Ç%SMdTæ
ÑUØCTs
²³E:0F1ÖÍpsq>ûD¢QŠeä[#­! ƒ† Àp€cÑÑ!M®3"©#& h  !è 8 eXßEQ~©>ÌD¿é kLĞ-Fä·	
*-+" f{{›ñme»	ı9=LÒÍRã³S×ŸÿøÆ(’à+"X¬‹qe8
§ %¹Œ,8äƒÄWtq<:AO»¤ï¾avâš«şk),K»}j\®E†“zÆg%l­Vü¤¡à!mi°+[0a4ğŒ€n»8D¬ \á6 A.âbXÏâ=õÔ÷ÑJi¡5qş›aov^ Lh\a<İ*FÎ]YHX÷he.€>ÇdİvqîYØòo:'dêøæBc¬fiÕŠ¤,Ş.MuäK{	D&u!\r¶M7æ˜.Q`M¾)ßN²1Bˆ…êMQš§›Ÿ_¾¦·4Ş’q#.|ÌÓtU)RT3S³u)«&‡ÕpÊÄ” ;òº|]+¢hƒdR;·Û $¢/"^ Œûô (U$@
Ñ™’€8<µJ8L17(ğrA|op(“u[=ç9=Jm	7¾ÿy	µei<Øš­¸¼¿³6ù–»(ïS`÷´‰àQ"m³6‘=!?n™<M7|(x™5:òÇß|ı@792)Ôn(uÍ¶ØDi!¨!‰8„I&¨7=¬*.Îºà³`y8®PCé¶qÚS
ucM__n|84ĞãÖ1a„0ceßìM„´%äßz^MäiLä…fÌhñ ¿ËÛhMtñïë:/à°áY´Y¹¹Ğ·aÈ:#?-Murâ÷(m,â`i †xNƒªyßÒÉAßh2(pQathh«GòÆmeääRìa%¤Ì¨%@äa:c2è iR¡™b‚+ ü(º¹L1^BÓ4¤úQ‚
ïFarQà,u¸#PE26¯‚0â»SşåbtH…ƒ\MlÎ~eÛÕ<œsib[ê q_Ük:¢—¬i#ãÙnqE¢fd%7Äa„V MÓîvĞ{LÙ´~‘Lc^å.nÕ8iş‚fÓm—Óc0j!İÔ·ùásæÜlù»`%sVêlhöfËÍ2@y~&óku5P´²g1å_D³GNo¸|*ÕØäÃôdÍ3îÖh·`öb@aòãCéº 
HEUMæ­‹ß*
DÈR®€ÕP~Ì(ûìG¥ªuyèr¹0ğÕ›6äLçq™UPÄØ†§Ã¦ÒCü6oOa¶“û:!tGÓÏmoŠ’±lGÃsQ£çœgÜjÅ {”ğ¨jpòDÅ{ƒ>C:Ï\ÕeƒÕI
ƒÉœÎGÔÕ ™yÒS×æ©¹áğ9 6/&˜…á3>()©2©Pq`ş}7nÈ İàZq¬”G&1K¥Ù–(YéQ9#ö®©aKÉXrÊ'#ö¤Zº œo
ñı¾ØbÈ¦Pù5MÅ¬pœyPÜY@yàòÛñêl>€–6Èi…‘`å÷ 9àÎ õa€c¾¦9É X=j¬f0üh ``UBE.€:M\AÍYFAP¤ww“Úk „rí¯éîEï’ÏM±ñ#ñGFc¨x$ôp k‚(Âb8gP1(oğáOkx÷¬äX-KÀQ2©ĞâùæÀ,HÉvš*ï}hfQÅ²{çdpƒ€1u‘iT,ãKwuOD&Ã„&æ(¹Í@ëX_!äcèâQšù-mÔh5€d<:*òvİYjšÖ6*Èf†<
Y8p£¹¶ƒ`u½Æ'#­n%·`QHv1GşÉgyéïªpËF,F!&óg<>eM"`29>q¨w§Ç\^ÅxĞáş.¨e%â`E¤c8«à)Æ:_âA‰$šqğ^åi¢Â¨©]EÌ`c0oa/Ïtµ g=d£pMsLå_r÷;+Ãt?u"~¼ÕhÅf7ßµO±	 ª‡.B^<»}êa}çúãNry ¤ü?˜ªÏ|k^Eœl8i|Ñ fsr ºx[:ÿÜ›ô‘aØ‚]®ıiéŠ ĞE(¨ÆqÃr$ìZbêÄ¼Ä>apÔ!àl„¡§n=nsO$ÌÖõ w‡ù[Éj#Än‹"ÚÆ]À%éÓt¶ Í ”-cçÉå+a+ ŸSz?c0}f°Êgˆwe5ee#ENĞ:Çj™k¦Z@­H-|0±ÔÏÙ2>
!cH{ 0©»:,øÀ]ï4- P#¤w!TwbeĞa:ëÈa¿UM{·d0(l¨Dc`nùS¹ Ÿg…BàöL]|1SOä³¦rhvñàÓ¶J“"(÷Pj¬(Rp1±tÚe¹z{tíLXx!mfn„.ŸÒgH[—ëWuNxê(67)Úb*5†Q¤ *erâÎ2*e(ií	n{­¦¼H%lg|+wUkpì8¸ u(D¬…å$  r¥7s¸šå 6í	»	h°da3À`±tÕÖ0.;¼b^eë`ıHFG	&‘éí¼¥@_s¯N{j&¶.—` ä$ 6ío± + ^™ñ(*)°7±p‡ Ä*3$ñôqn^=vbmEõB‚^õ<a§sú}úİ")¢ÈSˆ[¤CşbXy
sø)çj6Y+TÚ5/4,$Ú	øíæ—œtË¾#4^‹@©…’ßD/Wí«q$k¢’µ­ñórí…®aßlú³u¬{c¨E.5F|ö,L.£X`!¹qÇt$@§t	íl:p!q9kñFõl3Jš‘'1b% t¦bÓ{Õü0bmx vRFG_úq;t¸wºL7œô#ƒp3$]â,n p€rtp{_sê<V®'¦kåŠ9mgÉg\eÓ	MdòÃ.í£å>pÒ¾3ìV|¥eÌˆ(LúèĞ æHF$ª]€ëŠ¥a„ôı$÷twe	äÀşEráhÀ¸"ÎóeZ)áêAaÓä<ø—º±.Huf.¬"9#¯q|¯S$2ÏÒM€ »¬M’06HrDŠPånbDcùa}Ç>}´¥Yã ÀhwWÚ)«çWTjéb9£­oåm¯r£ ğË" A†S`tOø~l/i«(€ïxÇHàq{n)8u| €«Scy·`:œ‰»™~t`Â_tdÔj:ít¶$ñi$½aU[AÖ`q§ğd³çl}oåy-EÆelğğoä,ºbìI?g ÎMâ+r5Kî4ÕLLmj¦-n^ jQ%älÔû* C²ø!±®C%ƒ<C0m(§9/+Zà( d‘8H _êÂ	î"–jèj<I*¸é=Yè¾—S"Ù5ul61¸$I¼¶©;9Ó8øÒiºpìüä!/t.¨e6/lØñ{efˆé-4G˜r F€w	˜ò"¥<|“5¯mà9æe4,²¯%y–y)'Ra1;P_.?õ®  "'uİ¯´D„¡tcG><2yô.Oåª[¸¥¬z"§& pyî¾H$ôYí¹uÍn·5]]D,<n]0Hì£­d:Ì`°Î^dA,h…#R$Vgßn `R¯o,w¸&ö{H0örSIù>&4Tæ‘. 8‡ù=š§‰Œ‘9ğâ-wä`
pjlŞñP,:dûKÙKòEl)ûhÚÏ+x9•ÄÄ-$d%)c-$9À2Å2”2ĞefŞdæÙjeØopû§ï¸l!ƒ%Ÿ5eT¿ÕŠü!¾C.csù5_g8ùù‹ãêğF´Íú„kæ²~ÿkˆ³F¨'0q3˜ø¬*%‘ •m)7\ h ô@LˆÒB (T5gtqJö|F‰tç-;u¢ô0+å}œö!jAÂ #vm (%Ä%¶2„W%©±!!1¡Iw£ÁÛ¢; ãª…‚°E6míM=9gu9/¥ªºë4,4L9$ß+yzÕ	s#·¡)k*%]Œƒó0)›j´o¨u &-ŠĞI‹cy6z<}}U-—„K7Ekµ³ı9+;!¡0N’ÎW9sI.+~mqûæt¹t} c“ÄÌ4we©ã"_e"qˆÚ€wuÌ{M;Òúq
aıO¦Á ñS2Ut®µ&Oµêºnì¸Ò!#t[5ñHC@LJE"p¬Bì&@röªğôÒPI÷,y5 ’ïé§fe:`—hİorOY sHâjhó/fÍ}Çza¥îuõdc¨nA¼R0eiAu`ì2*‹ú|`,ˆl¿%qi¥²¿o4gt hb4é­J-1x)Ò`};ËdM(æU`2#"‹ˆæ(+i¨#¸µ/&œ™‡-v´o—SI÷ÿdU›5ä÷DLh"Ù*A%}eiMa=pj¨M,±tğ‡5ş[]:X @x|8ÊNs=áar¹:Kv.ò h2”£0!ªbT•$D,f8_¢p1U|¤4cld%!?¨ò¢ñ’ óÒ‘yË+hÀëÅ“%alenwÁ‘<àà(ÀQ“x ¼b¡@2q¤ÕeÚàg0% )+>`ù(rkXl¯&|v•-y9M–or!ô"¿";¨s0!7PüÒˆĞØ•mX)›üTê¦µB.äMAù¨1¬Y§7}và¡ùÖ>s6t•³¦Fı|Sm8Ô'S³o². b+è/wtòä!p}A4ü;÷<¸ºnÅlètœ4ä0±ô9àô`Nıs<,êaç_siY3&ÅyMµo)-|wæ±–¸ ¯e,as÷; 5|dèYhı	ê®0I
â.§qJs[d?w€*IıÁİã¬P)ÇlÒŠøfe¨4H`‚{eşp©“!úi<¢tdmëótWØí!¾²=   ª9tàV({{JíSc K>b|M g™¤}QÆ!…1«%dÅÆq}¼Ÿ(#Á~çHrn—­$OU›¥ø‹½% ™±±ˆ7ôÁ0	'WQ#5)qµ` ‘Á :Şë$şmNÏötÕ"gí?c}&o¿ËOkK
#”¢°SºßoÕf…ÊÇ?eVeì"ì÷°¯qÃ«º#à9Õ*@µ9G).„xÊt	g¤$iS]J¹i¨ó|ŒZvãje:Á…~;õ ó<%¦^5-[›pÕ¡
¼y&UÉmÛhp}ì®Ê8m¨lè=œJ4o7u[§­	Yd¿nc2€Éú±¼èú¸ Ã+sĞˆš•"d&lrjÆsò-´“:7l­œ%€u7N©@Kfi%(ëN .0¼m1küHa-å'”œ`2HP6n|Ó!7DÕ¨¢m}ir’&F‹c,¾‹azE*m3gø÷më¸,îP¥,H¢Üèn¡|bDxİ$-@ˆQE± ÿè_§yv»Ú³5azElj£‡şIpthõ]Ëú¨p¹{fíîI©“¨},œ0ë¢- rª ³(z¡áJ0D$Á$Ø1Í"‘aÍ ¬†`Q¤€¤¡à†î1~¯íhÇN^53hãõ`-PÚL$-1Ab ¾$ Ó6= „k°p$Ôõ0P°hØn‘Ô6<¥}r’Qç^ÉõÃ=lï(!ïÙuóz¹“D¹\U+;oExFixşµì2[,¦³'íP¡rg3_cÿqü=r.Ş¥y]ú¼ræ‘7úf%0
Y²å}wğQeFP(}2q©îDà&®Î}np2ñ4ï3`,¢7`£fp òŸá¯@®é°âu%e:6%£—§2îe=e0¨u€5sí}õ)®`r0bîß{µ:´e_Š/ÊiVušG¶‚^GláÙ¨P"/v‹dÇOgmu¢wœpct±jüi=$4=”‡è¡6G5´8o"ÌTfI¸dÆ¡ªco$ŞàV% |PõG	uRrSb\œ>j™O!9dX.( ¢ƒ42i<"^uJÒË1`ŠNéE>"rè{ ÖU)`k#¤#ö ¸#‡Y­e3"ˆtÒ$¢aínX¢Àˆ'S¬¥=@)B¤æd
ÆUyPb1Xõ?‚’U_5,½¬³wygd 6!é–Û	Ğè_=´-ˆˆMÀr;óşšñ;ûaç½¨-ÖX-¼«I7»§;(ŸamPˆ òdÒB$ĞfAD1şhé÷¡ÒƒÈqoÿX~qMvzış$.Ø,hĞt('m e05`Õ G± @EÀV!ˆ¥À€héBÄ`á‘R!&(p°åVmĞlü
w§ú¯·@1„‚¹=!µTğ?årÃd$ÚÿCävÅlµ+|4wFHğî0}ÿ%=gxwôèÿ1Ê_-rîX–¢L,&t1®_a}ï+!\Ôº-	t U(:Vâz"åjSl({ìhõ1oÄfPA4M%a±u 0µÁAj_sZÉ¬|_pwõ%îfxp$-p Qc}ÚDŸíˆ(!üğ”^©Isş1õ#Ñ­mc«hg$©ã¡5BŸô!4xn»K?ğspßtT!wM<It´ÄyÙ*HˆgqEÏzaqÖŠø'‡è`3C9¾ôMa%c\*áN]Ğ‘u&c6!Áácäû’iOšc©À` 5C-–jIwj
¥.?7j ­pom»µmu/ åp5l¹=´6o?o‚5ı-ü<7¥L'=3T6‹â€~<âÜ‹fiINÿætP(7µ_İ.+[ı^ ÷Î¯°"Wdd™aïU¿¿'õQu{ªMğ&»46ç£qµS(uoÇ³5b([ä´—sçpt´ªñ?Ğú[¿®'Z„H.w"çíb3eK”I%	¶r}ó)ü
YøıW ğk$ÁàOÅæêŠ-2uEŠBrDt2YP~“^èâ3qY®“!g,¡UnöeİxllÀÁ%qi¬ÛøMf$ÑY[%L,öt~N;MM'ı!Bàayä,X,·Lyl`uğRÛS BO´ş¯ q Å"BboÍnlÆ"Lò>qûfHZáC ñ hQR]í£" ¬w%R¥Ä„±XÂ¤\hmj•gQç:X!`P	·{5$,Æ!şêpóòçknL× Ğ4a&SpòıŞªåÂ&Aà•Ci[juØs³²(pHv8L-:qMšR…€µ°{9,55C4~f6ˆ˜o‚Bl°130U[lò+t4Dûb§|u©?s4?1ï>_şTTrÎluÖyXhi"696N¯/%uu¨´[gO\d¬>g/¨Xãı~¢‘ÙlüĞ6eÕ°vªY¥kZÉ‘ŞMbQ,ù9¤QÉTÄƒÌéQq€^%jÍ<gyWop.&Ï¿<&ïæ hg-gELq}şªl%±éâîxhõGau½9O=Ob™W}*T`ÿtø¬sÓUix¹Cgd8b~$ÒZRC=ví(¡½)oh5W PÆ'}0&¨úìP¥g'çd/yYÙ)´,´#œUŸ(Xm×M*L*1œÍQ µC&î]gšlôwTA"C¬ôLéŸ_½õmüçÃ 416º÷.í}`T3”íeBqùCÌmG6k1eÂ¼ĞX$èŞ4yÍkdzàí°±ÿúŞ•' 1ŠcBæşeî¹Nl`p+.ºs£öõVå­y7\|¤/x'àªæN@)k+°­®r! ¨0$Ô88h'zzU.Ôädfş¢;êêÔæ3ps2÷÷ª`®èë›cy¼h@Ä@é@#=#$´íƒì|nm£@~â¸.,ü++%æáeP=/¤—;²À_'33.„Úø®tÛ –{¥(VfUµ(,\ñ´ÈdA „4'jç2h‰Fş­b"?sgq—`uÄ ™
P0L´ èÉá@B"¦ &Fa ué(œmoœhhaöörU•_Bp,où}9¢Miï$û
aşl-0˜–l¢r	Z-c&&·H­†áÒù\|³OaÇf\ì50tl`j+Tïw¹.ÿEådäà@#P=i‰tü
ßhé¡ÅT.%ÒVu:ÒÛñPp¤v8zNØ bh[%EåÆ'—5qg§sèk,ª"$uye"
&Õs4YVam2î^Unm«ú&sv)|.|©9¯øKpG±Èlı†€3ak×©\¡Ìü 8zéBÒf @Ï³A".ì/g ÷q'dWtm8ôq)i5õ§Yìdb'ıkG¸Fèòx(¼Ÿït)-µ“*.Á& É‹F%0W[Ú0I¥	%ğ0!ğuC0-? g‰ìEè`ÍO–-"±ì£9¸ÆWhT µ—~Âäl$£ß
¥mh 2ºµ
ÄlWê!ñr äP6,JB¬yñ¥tç
N+l|(¸£©@f18Hwixæ&©~«£±¸5G`.Ä{=À9ÌNx7DÉ Ø­é&$æÀ`µE`rYº6–ı"\|0E~Y7sèa` ¨fm¶e1ßÑnTYz‡ô©ÈucMxNCLz p>(²`ÍQ=fÜ8Q[ÀK‘¡(âìa½5b$rchj
x9ëÈõ÷È‹!4*m/w{|ı© Âåê³+Ù÷j¶=¥é‚óFˆ(Ş"&Q¥U0rkùpŞjıœ¥oêåp6+oI©ÈWmóÇ³h|n#úyvnk!!"œ†#Fn¥ı}O—W ëa~&İí­˜%¦ Âi°" ¥-·]]@a ı¦ñxß<pv¼
8ë)#+šQ2(¤[ğ< {ìÿÒ?ì­^Fİ² I¯n=ÃâÁ(>„1¹#u
jXé632y01Yko´' ¬­›:&6'ø+E0ååì}^Ş)v`s‚Ã4´Sd}ÏCtÿ¤p‡Á'.Nƒ?ÄBòvkeÙ79ªæiê?³o^C{$!Ú>ıp8—Z±,óRu¿Èv"Ûãèõ-k:ÒiydvV¤yà)@Èj94-Òú!/K©á &Æ¦%;§jgFê¨Èˆ” Pn|§`>Ê¤4·{„ş¢%ôo¥5°ë½vp9"peo§ó	ş×=—NéÉ{L‹ØÃk$E¨sPD%:ÉeaÖrÄRbks:&5:¨hNkø}l}yb[HF¥ãĞ„pxrâ¤n£8©¨!|ƒ…süuÁp†(v2f¹Sê$i^V?c~7-‚+˜9s¾$Í[¤ŞPBéú{|!Ër( \âÎ9@ar,bsph¼}q*æï:d\wV ì30l‚i~PB}ö/D¸¢ d2õŸÖ}¼À9+Y8ç 4
†d!2_$MèVkêcw’Ûû&y`s5³9ìpÀKÔFÛUc#g“)$VwxŞ9~PÎEVjF	yÍ(iè  ºQ;Qs£!	å¾xÆ‚¬F,¢SçJcpÑ¡Y;óéÜ<m7÷ûg$ğé´©„9½õ6!´ˆœ–úşØarÈx=plgx/õÏO1WPÕäj\o$ò5(2(i92O[4}oÎ[vYxeäù´rÇjh2yù!b ŸáXw2q`1¾AÃOLìÌÏy@D¡Â2>${ğ…%>á°9({W{²¤-çƒeJDicÙi’/„è¹jıe­Úúu˜biØK1¸b)"ëè°4‚lÍ.}Ìhâ"ôMóOD?hc7¬¼m*`s/Xjp£8¸%¡^ıv,=îy£ñáµ<Î"H°¢03hOgQš0Il¢à^"akÀ!U+²c6 cs]à}¡ °”W"qo,$Š$w"/L[L!~é(4^?ànf?Ë° c¢d
b7yğuá¼H'[l:açò5¾t^.2«nºrÃ\õ±|é7,¨¨ M¾ [CªÆ,á–.`,)C#ÂìÊD/!ô÷hüıã…®8-A30À`wûF¤"„#møgÿgá.µù¿_†qEÈ"únj.íç¨…E²´8a$0±j”"1Ô8£Å#¡Mm±'Zv4-Fu3>G|t¦d:ë0éHô,kƒdĞ2swƒ<¡€5¶ ?wä;ÿãC0]heÆ(õé3{?tİ~æÅÚHgv²}4vB‹8F³Lœûta c`2Çd"ê{‹V'Î‰³Ò.cr‚BûUÔ1:yEÙÅ'şÓ#d*u)?"Ô;Su£f¶ã~ø°ôkA´f
tnê¬&t#¶U$#ñ>…v-E†b]_!öFáæoèT´b® ¬l!%dWåB)H‹m¾z· gÁq¥u]ªÁ šV/~a†:rŞ]ÒK¢mÃ>Å¶ $ “B9k« én-éå†áE(í$¯SV(İîÔ$8{DI%kZ=tá½©$€F„‡\=wtfÁÕŸ½9™/T|Âì|H|%<¢ñw:&ñÊ$Œdp2+~f2c´qØ/]9‚u#ExéèÎ«D{4úvÅ°b\à†5yañ ¿ubføóÔ4Ğ;i~g jT&]4Îƒ[±n«+w_âo d/¹ ¬>aQrS™oÁRÖm`ş²v£g dp#)ŒaA"ÂİöÇ# İ$Tâª€á#LTrJµóA:8B1†¬cûcût%_»eä[í!(ƒòÀUq 4fQÑ#M®}H!©c&6i„X11;ØBy¤eHÌEQv¬vÄD/Ë »h‘:fä71a&*-{0À~a†}‹ql@em;1n{Rc£Sİ¼ïxÆ(š #tX,‡qg0'`=±Œn=f"Ek>$0D¸¤k<!vn’
%î¹*,bºk@|o3“~Ä?tl­^ü×¹p!oi2+Y4a@5 ¬€H:`è`de¶ägH5ïapÏâ1öô¾Ñzé¡!a~!aofÒœH0\%<Ø
çxYiywxE °Ä`,ws`[ğfò®_:/¬ªü'a,léuª´,Ü_e?n)d:1 œ2¶-5dÿ˜öQbŞ)Ló7Bå_oOE·Ê?—'¿¦ÓS5O2d'F|Î4AabUsÓ±sA¯&ÃNÑÔÊÄÔf+ó­m[+£HÂhiB*¶Ãàd(;"^H!Œ(t ,U4DNØè<mµJ9LQ6,`RAukP3(õA%æ‹9ùJM±¾Ï{	¥EuHk­º=1yÖù(K`w4ˆÍqâfi«t•me6o$M§p(y¼eºöÇßtuÀv8s+ĞBluÍ¶rÜDi'¨áÅ<MC"¨g,­‰"dÌsºê®Hyğ®RGq11~J5f-r7Cf~1=ÔåK¦ iÔ4cdsLd³€à>jLäxä%çÍhy°<ëÛhHV±5æ«p¸,è0åÛ¤ÎÏ¹™Ğ·qM¿V'/=M?vjs¨q,æ,0i æzZã¨x/ÓÔáÀÙh#Lq[Uã`à&ù©GâÆid$¤Vè³€á%$`±%Äåe:g0é!ıRaÁ`F&QÜ‘,½©h7I~CÃabÂ	Ïi? ö,1ˆğ""Á"¬¶;4$æ¾ìå"$HƒÚ|Ìî¬mÛÕœ·iBSî¡ad{?ª—`é"ãPæxE Îf%6Ôe´J¬DÂèò@{DY°îLsenjCpi÷!nûæ‡Óó0o)ÔÔ÷Q-àa®Ü|yûb5&Vúk(*goÏÈr@|8$Ó{45Z”·a1dGL¢GNf9x*õ4åÂ´p2ç µcõ"` ;.ã‡Cë FÈEEä-‹Ü""äZPî„E0xF(R[|E%ºhR½÷r•»²ô›œ§ñº“TYÖÈS·Ó¦^sş7{˜a¾£ÿjtg¤_T/GšÚ,E3Q³ãÿçwzá‚9•{m¥jxûDÕ :ƒ6”C.\ôeÁN7[#MÏGPµ$ yÂÛV·)=`ù=¡6o …á+<!5ò>éXaùú|rnìŠÛÅZqå>dB)kçéVnLë@1¦­aá`$ EXzKcä¤Rúıiyuû¿õÌ¦IXù=]ÕlğœEy lÒ yàÒûqâ®>Šõ:Cmá“ %§ (¤Šğµ`!<†8É 4 <¬b¼z ` bAg 3©}AMLf]Q¤w2›ø •"/|¯î!ÊÅ¯¸	2å!4òEB1#¨üeôtskBç1dT(ftoáKjaw˜lp,O u"¡Qåffô>zJivÖ/³íi<Qô²kç(xƒ 5‘ë&} ëoWeF0e$bD&  09m4`íl5dw¨¢q#šÙìÀc$Èe> 
ò—ÜLs’W6nÈF·¸&Y(`cv"w¸¦'*€£`7·deB,L|0Gúá3yéf8ƒªp	q,F0"ö%<?-)! à0y:µ ä$- TÓhĞ±ú.¨J,%ìJW!brh»æxâ1#¤&šq Ğ^µ O´Bw;)¹AŒ q&oa?it¤g56$tMp\uKrõ*'Ãq3=2r|Qx÷ª4/?µn9mPş‡.@L~¾5êe}ãzÃ|R90”Ü>(©íüq NE”(8*u0Ğ0–gór&&Q:ußÎşléŠ0şM(åË¡ñWz 1Ô0Ãp,<H”bêÍ¼1M<aòœ
 à ~„³2"-s6@J¤'P×3àtùk‰kƒ`f¼"øçqûÉd–	xK(     # check BFGS does not evaluate twice in a row at same point
        def f(x):
            xp = float(x)
            assert xp not in seen
            seen.add(xp)
            return 10*x**2, 20*x

        seen = set()
        optimize.minimize(f, -100, method='bfgs', jac=True, tol=1e-7)

    def test_l_bfgs_b(self):
        # limited-memory bound-constrained BFGS algorithm
        retval = optimize.fmin_l_bfgs_b(self.func, self.startparams,
                                        self.grad, args=(),
                                        maxiter=self.maxiter)

        (params, fopt, d) = retval

        assert_allclose(self.func(params), self.func(self.solution),
                        atol=1e-6)

        # Ensure that function call counts are 'known good'; these are from
        # SciPy 0.7.0. Don't allow them to increase.
        assert_(self.funccalls == 7, self.funccalls)
        assert_(self.gradcalls == 5, self.gradcalls)

        # Ensure that the function behaves the same; this is from SciPy 0.7.0
        # test fixed in gh10673
        assert_allclose(self.trace[3:5],
                        [[8.117083e-16, -5.196198e-01, 4.897617e-01],
                         [0., -0.52489628, 0.48753042]],
                        atol=1e-14, rtol=1e-7)

    def test_l_bfgs_b_numjac(self):
        # L-BFGS-B with numerical Jacobian
        retval = optimize.fmin_l_bfgs_b(self.func, self.startparams,
                                        approx_grad=True,
                                        maxiter=self.maxiter)

        (params, fopt, d) = retval

        assert_allclose(self.func(params), self.func(self.solution),
                        atol=1e-6)

    def test_l_bfgs_b_funjac(self):
        # L-BFGS-B with combined objective function and Jacobian
        def fun(x):
            return self.func(x), self.grad(x)

        retval = optimize.fmin_l_bfgs_b(fun, self.startparams,
                                        maxiter=self.maxiter)

        (params, fopt, d) = retval

        assert_allclose(self.func(params), self.func(self.solution),
                        atol=1e-6)

    def test_l_bfgs_b_maxiter(self):
        # gh7854
        # Ensure that not more than maxiters are ever run.
        class Callback:
            def __init__(self):
                self.nit = 0
                self.fun = None
                self.x = None

            def __call__(self, x):
                self.x = x
                self.fun = optimize.rosen(x)
                self.nit += 1

        c = Callback()
        res = optimize.minimize(optimize.rosen, [0., 0.], method='l-bfgs-b',
                                callback=c, options={'maxiter': 5})

        assert_equal(res.nit, 5)
        assert_almost_equal(res.x, c.x)
        assert_almost_equal(res.fun, c.fun)
        assert_equal(res.status, 1)
        assert_(res.success is False)
        assert_equal(res.message,
                     'STOP: TOTAL NO. of ITERATIONS REACHED LIMIT')

    def test_minimize_l_bfgs_b(self):
        # Minimize with L-BFGS-B method
        opts = {'disp': False, 'maxiter': self.maxiter}
        r = optimize.minimize(self.func, self.startparams,
                              method='L-BFGS-B', jac=self.grad,
                              options=opts)
        assert_allclose(self.func(r.x), self.func(self.solution),
                        atol=1e-6)
        assert self.gradcalls == r.njev

        self.funccalls = self.gradcalls = 0
        # approximate jacobian
        ra = optimize.minimize(self.func, self.startparams,
                               method='L-BFGS-B', options=opts)
        # check that function evaluations in approximate jacobian are counted
        # assert_(ra.nfev > r.nfev)
        assert self.funccalls == ra.nfev
        assert_allclose(self.func(ra.x), self.func(self.solution),
                        atol=1e-6)

        self.funccalls = self.gradcalls = 0
        # approximate jacobian
        ra = optimize.minimize(self.func, self.startparams, jac='3-point',
                               method='L-BFGS-B', options=opts)
        assert self.funccalls == ra.nfev
        assert_allclose(self.func(ra.x), self.func(self.solution),
                        atol=1e-6)

    def test_minimize_l_bfgs_b_ftol(self):
        # Check that the `ftol` parameter in l_bfgs_b works as expected
        v0 = None
        for tol in [1e-1, 1e-4, 1e-7, 1e-10]:
            opts = {'disp': False, 'maxiter': self.maxiter, 'ftol': tol}
            sol = optimize.minimize(self.func, self.startparams,
                                    method='L-BFGS-B', jac=self.grad,
                                    options=opts)
            v = self.func(sol.x)

            if v0 is None:
                v0 = v
            else:
                assert_(v < v0)

            assert_allclose(v, self.func(self.solution), rtol=tol)

    def test_minimize_l_bfgs_maxls(self):
        # check that the maxls is passed down to the Fortran routine
        sol = optimize.minimize(optimize.rosen, np.array([-1.2, 1.0]),
                                method='L-BFGS-B', jac=optimize.rosen_der,
                                options={'disp': False, 'maxls': 1})
        assert_(not sol.success)

    def test_minimize_l_bfgs_b_maxfun_interruption(self):
        # gh-6162
        f = optimize.rosen
        g = optimize.rosen_der
        values = []
        x0 = np.full(7, 1000)

        def objfun(x):
            value = f(x)
            values.append(value)
            return value

        # Look for an interesting test case.
        # Request a maxfun that stops at a particularly bad function
        # evaluation somewhere between 100 and 300 evaluations.
        low, medium, high = 30, 100, 300
        optimize.fmin_l_bfgs_b(objfun, x0, fprime=g, maxfun=high)
        v, k = max((y, i) for i, y in enumerate(values[medium:]))
        maxfun = medium + k
        # If the minimization strategy is reasonable,
        # the minimize() result should not be worse than the best
        # of the first 30 function evaluations.
        target = min(values[:low])
        xmin, fmin, d = optimize.fmin_l_bfgs_b(f, x0, fprime=g, maxfun=maxfun)
        assert_array_less(fmin, target)

    def test_custom(self):
        # This function comes from the documentation example.
        def custmin(fun, x0, args=(), maxfev=None, stepsize=0.1,
                    maxiter=100, callback=None, **options):
            bestx = x0
            besty = fun(x0)
            funcalls = 1
            niter = 0
            improved = True
            stop = False

            while improved and not stop and niter < maxiter:
                improved = False
                niter += 1
                for dim in range(np.size(x0)):
                    for s in [bestx[dim] - stepsize, bestx[dim] + stepsize]:
                        testx = np.copy(bestx)
                        testx[dim] = s
                        testy = fun(testx, *args)
                        funcalls += 1
                        if testy < besty:
                            besty = testy
                            bestx = testx
                            improved = True
                    if callback is not None:
                        callback(bestx)
                    if maxfev is not None and funcalls >= maxfev:
                        stop = True
                        break

            return optimize.OptimizeResult(fun=besty, x=bestx, nit=niter,
                                           nfev=funcalls, success=(niter > 1))

        x0 = [1.35, 0.9, 0.8, 1.1, 1.2]
        res = optimize.minimize(optimize.rosen, x0, method=custmin,
                                options=dict(stepsize=0.05))
        assert_allclose(res.x, 1.0, rtol=1e-4, atol=1e-4)

    def test_gh10771(self):
        # check that minimize passes bounds and constraints to a custom
        # minimizer without altering them.
        bounds = [(-2, 2), (0, 3)]
        constraints = 'constraints'

        def custmin(fun, x0, **options):
            assert options['bounds'] is bounds
            assert options['constraints'] is constraints
            return optimize.OptimizeResult()

        x0 = [1, 1]
        optimize.minimize(optimize.rosen, x0, method=custmin,
                          bounds=bounds, constraints=constraints)

    def test_minimize_tol_parameter(self):
        # Check that the minimize() tol= argument does something
        def func(z):
            x, y = z
            return x**2*y**2 + x**4 + 1

        def dfunc(z):
            x, y = z
            return np.array([2*x*y**2 + 4*x**3, 2*x**2*y])

        for method in ['nelder-mead', 'powell', 'cg', 'bfgs',
                       'newton-cg', 'l-bfgs-b', 'tnc',
                       'cobyla', 'slsqp']:
            if method in ('nelder-mead', 'powell', 'cobyla'):
                jac = None
            else:
                jac = dfunc

            sol1 = optimize.minimize(func, [1, 1], jac=jac, tol=1e-10,
                                     method=method)
            sol2 = optimize.minimize(func, [1, 1], jac=jac, tol=1.0,
                                     method=method)
            assert_(func(sol1.x) < func(sol2.x),
                    "%s: %s vs. %s" % (method, func(sol1.x), func(sol2.x)))

    @pytest.mark.parametrize('method',
                             ['fmin', 'fmin_powell', 'fmin_cg', 'fmin_bfgs',
                              'fmin_ncg', 'fmin_l_bfgs_b', 'fmin_tnc',
                              'fmin_slsqp'] + MINIMIZE_METHODS)
    def test_minimize_callback_copies_array(self, method):
        # Check that arrays passed to callbacks are not modified
        # inplace by the optimizer afterward

        # cobyla doesn't have callback
        if method == 'cobyla':
            return

        if method in ('fmin_tnc', 'fmin_l_bfgs_b'):
            func = lambda x: (optimize.rosen(x), optimize.rosen_der(x))
        else:
            func = optimize.rosen
            jac = optimize.rosen_der
            hess = optimize.rosen_hess

        x0 = np.zeros(10)

        # Set options
        kwargs = {}
        if method.startswith('fmin'):
            routine = getattr(optimize, method)
            if method == 'fmin_slsqp':
                kwargs['iter'] = 5
            elif method == 'fmin_tnc':
                kwargs['maxfun'] = 100
            else:
                kwargs['maxiter'] = 5
        else:
            def routine(*a, **kw):
                kw['method'] = method
                return optimize.minimize(*a, **kw)

            if method == 'tnc':
                kwargs['options'] = dict(maxfun=100)
            else:
                kwargs['options'] = dict(maxiter=5)

        if method in ('fmin_ncg',):
            kwargs['fprime'] = jac
        elif method in ('newton-cg',):
            kwargs['jac'] = jac
        elif method in ('trust-krylov', 'trust-exact', 'trust-ncg', 'dogleg',
                        'trust-constr'):
            kwargs['jac'] = jac
            kwargs['hess'] = hess

        # Run with callback
        results = []

        def callback(x, *args, **kwargs):
            results.append((x, np.copy(x)))

        routine(func, x0, callback=callback, **kwargs)

        # Check returned arrays coincide with their copies
        # and have no memory overlap
        assert_(len(results) > 2)
        assert_(all(np.all(x == y) for x, y in results))
        assert_(not any(np.may_share_memory(x[0], y[0])
                        for x, y in itertools.combinations(results, 2)))

    @pytest.mark.parametrize('method', ['nelder-mead', 'powell', 'cg',
                                        'bfgs', 'newton-cg', 'l-bfgs-b',
                                        'tnc', 'cobyla', 'slsqp'])
    def test_no_increase(self, method):
        # Check that the solver doesn't return a value worse than the
        # initial point.

        def func(x):
            return (x - 1)**2

        def bad_grad(x):
            # purposefully invalid gradient function, simulates a case
            # where line searches start failing
            return 2*(x - 1) * (-1) - 2

        x0 = np.array([2.0])
        f0 = func(x0)
        jac = bad_grad
        if method in ['nelder-mead', 'powell', 'cobyla']:
            jac = None
        sol = optimize.minimize(func, x0, jac=jac, method=method,
                                options=dict(maxiter=20))
        assert_equal(func(sol.x), sol.fun)

        if method == 'slsqp':
            pytest.xfail("SLSQP returns slightly worse")
        assert_(func(sol.x) <= f0)

    def test_slsqp_respect_bounds(self):
        # Regression test for gh-3108
        def f(x):
            return sum((x - np.array([1., 2., 3., 4.]))**2)

        def cons(x):
            a = np.array([[-1, -1, -1, -1], [-3, -3, -2, -1]])
            return np.concatenate([np.dot(a, x) + np.array([5, 10]), x])

        x0 = np.array([0.5, 1., 1.5, 2.])
        res = optimize.minimize(f, x0, method='slsqp',
                                constraints={'type': 'ineq', 'fun': cons})
        assert_allclose(res.x, np.array([0., 2, 5, 8])/3, atol=1e-12)

    @pytest.mark.parametrize('method', ['Nelder-Mead', 'Powell', 'CG', 'BFGS',
                                        'Newton-CG', 'L-BFGS-B', 'SLSQP',
                                        'trust-constr', 'dogleg', 'trust-ncg',
                                        'trust-exact', 'trust-krylov'])
    def test_respect_maxiter(self, method):
        # Check that the number of iterations equals max_iter, assuming
        # convergence doesn't establish before
        MAXITER = 4

        x0 = np.zeros(10)

        sf = ScalarFunction(optimize.rosen, x0, (), optimize.rosen_der,
                            optimize.rosen_hess, None, None)

        # Set options
        kwargs = {'method': method, 'options': dict(maxiter=MAXITER)}

        if method in ('Newton-CG',):
            kwargs['jac'] = sf.grad
        elif method in ('trust-krylov', 'trust-exact', 'trust-ncg', 'dogleg',
                        'trust-constr'):
            kwargs['jac'] = sf.grad
            kwargs['hess'] = sf.hess

        sol = optimize.minimize(sf.fun, x0, **kwargs)
        assert sol.nit == MAXITER
        assert sol.nfev >= sf.nfev
        if hasattr(sol, 'njev'):
            assert sol.njev >= sf.ngev

        # method specific tests
        if method == 'SLSQP':
            assert sol.status == 9  # Iteration limit reached

    def test_respect_maxiter_trust_constr_ineq_constraints(self):
        # special case of minimization with trust-constr and inequality
        # constraints to check maxiter limit is obeyed when using internal
        # method 'tr_interior_point'
        MAXITER = 4
        f = optimize.rosen
        jac = optimize.rosen_der
        hess = optimize.rosen_hess

        fun = lambda x: np.array([0.2 * x[0] - 0.4 * x[1] - 0.33 * x[2]])
        cons = ({'type': 'ineq',
                 'fun': fun},)

        x0 = np.zeros(10)
        sol = optimize.minimize(f, x0, constraints=cons, jac=jac, hess=hess,
                                method='trust-constr',
                                options=dict(maxiter=MAXITER))
        assert sol.nit == MAXITER

    def test_minimize_automethod(self):
        def f(x):
            return x**2

        def cons(x):
            return x - 2

        x0 = np.array([10.])
        sol_0 = optimize.minimize(f, x0)
        sol_1 = optimize.minimize(f, x0, constraints=[{'type': 'ineq',
                                                       'fun': cons}])
        sol_2 = optimize.minimize(f, x0, bounds=[(5, 10)])
        sol_3 = optimize.minimize(f, x0,
                                  constraints=[{'type': 'ineq', 'fun': cons}],
                                  bounds=[(5, 10)])
        sol_4 = optimize.minimize(f, x0,
                                  constraints=[{'type': 'ineq', 'fun': cons}],
                                  bounds=[(1, 10)])
        for sol in [sol_0, sol_1, sol_2, sol_3, sol_4]:
            assert_(sol.success)
        assert_allclose(sol_0.x, 0, atol=1e-7)
        assert_allclose(sol_1.x, 2, atol=1e-7)
        assert_allclose(sol_2.x, 5, atol=1e-7)
        assert_allclose(sol_3.x, 5, atol=1e-7)
        assert_allclose(sol_4.x, 2, atol=1e-7)

    def test_minimize_coerce_args_param(self):
        # Regression test forèmyt9q¸³ô! 3^Æ,.¢uˆúP[_bè(V®®k¤
*iIÇ\†ZìW0,ò“$¨#ä>8ª¾2è×ì¥ÀÌˆÈğìPdÒ'’nuª
¢ëÒoõ¬?0Õ°d') @Ë*ÁéaÔÒ¦ØÎ2HJxé¨IÛˆ,¸“: Hg"7ìbyÄ;aYl¯P,³³7Lˆ(’›¬°6
 ¥Š¥jûLcydm‡¾|6»¢ ©J'ËÊª©öVTb®B93¥/íì¯r«´ğP	ï_ €U¦*êøllµ £¬€ÏxÇJ
ákn)<}|¸€£	ãÙ®é:–€›QR:´pÂnd	ØÑN(í¦õ}$¯å=ŒÙÃßpb·J
±¢l!gåsÄÆ•lØpsd,ãæ|˜Å ÜUòX/aJKêtUK(Jª)`Î HYĞ !ìNä:*!Çòú,œşK¥‹½S"én'Mù­ûZàr dõ0hà_êÂÉÆë–n„êj|IF(ì=Y¨¶„C#'5y2L¹Aô´ë+ZsaøÓ`¸Óíüäá!PÆ‘g27ƒjXç[C!Üb‰ÍÌ4Ã–šcAf‚?}èC%\3]-«à‰&m4È­âï%}¥½)s¤[G1³pÒ.Ó  &f}Ñ¯•µ€¥4æe4zùÖeïå*_¼¥ ¸ú"§Ç`¥~ª¸J¦ô:à‘t¤.#°‰ Ä.>&İpRdcL¯dnHu²Ï^FÙØÎˆKÅÂfDgã|a`X*ó(¸ ;h#Ü[A;n³¢Dæ (†é=š§˜\ŞUxÅğq©rë‹pHiüÉ@,’@x	Áò9ùxº|¹”„/ `¥)b4¨	@à¢É:Rø?çÎdö™3êÛ¥0».¨*wA¡%Ÿ%f4·q‹ü`¶">ƒëóYWf:­ı›ÓÊğ
¶Åaş ¦³~µo5…‚Óäˆ$w>óg˜úa}™º-)  (lìHÄÉB¦‰ÖUf}tJîRüÅ˜,ö9t*t0+Åz^šæB*]b€vmÄ(gF„ò‚%¡ñ §³à	W¢AßÀö;ÓâêµƒuMM­Oûãm9/¡ú’ë4_,İ9$Yª@?‘˜ò"% 	/KE]ƒó§(Šh´uëG¨¦Ã,ÊĞÛfI7>¼qmÄ%Ïâ·Ei½³ù5)‹†$ïtJ’ŞEc@j€Zlqáê,p¹tOÂa“ŒÇÌ7u(ã#e'y²
ÂWWÌ;‰;Ò: ’aGƒ¡ ñS0Ôvô6Ï°‚» tìúZâráÑLB@E}Ì]:hì@¬&™²Zªğ$ÇXUÉ‡(y4^êh«fE¸M›h]ïrKyWsJ`î(Öe+ì5£ú@%®ô`# ¨îİ¤Zp {Ku}mƒó €óˆLe¯¥kI¢òXï4g~hHbå	FŒy‰Ò¤}ÏèSEC(âUÙ23*‰¨æÒÌ¨0Œ
.Bd˜¤–W²Ï³Mp÷÷	 Wú}tD("Y«Le	õe¨LiÖyp¢­],ñvğ¾æK3_ûXat|Bªb#¡)0¤2Êr²¡jÇÜ¿0¡7êBBµ¤D?f8"x±d¦4"h}§3>ˆß‚ Ñš¤³Â9É
…ÈB«Õ“%il•mV_Á	R¼ëh,@UûÅxÔšC)`¦Q¤'¥Š¢e0%×*/<gÙ‰{IZn¾	c~V—m9]–1x0-¢b·6#¨@uVÈıÈÙÑÌ}UAš¼4â¦µ
üÀÍ`á»¦J†?$v²)Yy€:3$hµ0¢Fı CmjJÔ'·ér,HÎj«ÈÀPR² ²~[´Ü#Ò˜ºc9Ñ	l-bV’4ù°¸ô¿²ıBNõ!>5îaCwsx™7$Şye….¨+OyvÃ±–± #,!ë2; 5,N$èhÿË¬±hà¤'1HpB ¬{€+$@ù€É£ŒEiÆ|ĞÊùf­ A(ªNm`‹‚ğé8¢€¼d«ÒöˆÈ¬!®5-¤  ŠyPğ”\a»[éSA*
âÙI£ P´MĞF8­ £'5!ÁJ°U¨h#€|÷hql“Œ-;!YÈ%Bú³­Í'ØI0&U‰+>(³ €`!1ÑÀ2ŞK¤ş)LÎòqMroy?Ğa}š5Ÿ˜/îi\/•òI]_›÷OoÔ$ÒÇeTå(¢ø÷ä—UŠbª#ì>(Ä.@­±.)&XôhOôgf¤$aqK»(šã, ~k*e0äÇr>¬‚s<!¾N=*[’ƒºµˆ
¸y6Q†ÉXÛhpEUmÎ®ÊEZ0L‰HÊ1œ@6`KwQ'¤¶	a&/¾£:±È¸±¬èº¸d +cĞ™åÖd'LjjF&òl¬ 2RWxØí‰dÅ]Uv©À['iQªËhÑO0ºiócşMaxM%”™C &…P6nlR ;Õ¨¢Mm3’.Ê*£  ‹bxE*f"ø¾ Ë°,Š€%(œX§ŞëŞ)lã@XÍ$@˜AdG¯àzI¤Ukw²š»5cú3D^âáƒşœa;lM´]Ky¸p´(2í¯I‹’08„°i˜¦,Ar[*4³¢øqÚ°V”É5Ï‘qID­ÆdÑ„Œd©säş1şš…(Íz±qhÇé‹\è9P˜M)A"Â>¼ ¡R2=€êàÑdÜÕpUX¸hXn•Úí8RÊRç[ZÉä‚)n4¤oX›Ñ`!“€»ĞE*#0ŸxF	›`öŸ±l† [@X;V­î²WñĞ`âO]i}Stbú¤_Xúô»ê€Ãğ!f'‘ Ù0 }ÿğ]lBp u²aîR "Æ}F`±®5«aÂ,âiP£ğ	r›õŞ`‚êLğ¢uDE\:'¥òÕ¯2ÊD­g°(Q‚5vîı\(>È"0"ë8èµ*´¯NŠ§‹•hWqšÆ,€*NÓì¡íéF+‹ÎëÅ…ÅÅ]u³wœpK4„j¬ê,¦†ƒÈ ôJ¨0"È|nA¸fÃ¦«a})âF5!|€uOÍ‰u ÖCgÜœ6z[-Ä.èdğ£Ó4"í<ÇTJÖËin>ˆnëË>2ày0‡ı)"c# 3B ¨#Z¡a1"‚äÒ°í8ŠÀŠ'¡® È!F€D&†E\Têr
e?’U_¼=ô¬»[2¥y@b 60é–ä“€°àm•´ ˆ MÀp9Ê¢¾Š±3QØå¨ˆ-ä -¬+I%¿§“7ªÿiMAªvaĞPc..TFÑTÿ	hé[w¯‚Èõ¥ïH0pÌæ¨È^,ø(H°’%”('äÄd=hå ñ)EÈ\Œ¥ÄÄh­B¤#Ñü!>8xóg”-âÌøW·úüX3”£¼=E1 ´"©üÁd„Ú'ˆ öfã. (Ï°wÈ ¬0ş ,(0 ™w0îß-clKÆâ\.ç2¬b}æZ¡œ$Öø_ØW-•],òkE&äjHh/4ìIµ)3F"P	&H
%²1õ $ñÁ+}[2ú©h_~sıl®wØpDP"]cùÚÔG©‰($¼sÔQìiğ> µ£d«dg$aã¢uJ€eµøè³Jäk²İ@#sÍ¼(LY¤D½Èw`euG°A¡;†"¸g‡Âà‡Ga¸ÑO©$#|
áy½°$6%Ğã"ì«–úÈ
Š)Á !!%ÏÌ'bNæk¶ú©<`,ì»ªèé$
 bõL}46e:i‰4}­ø4(!i"(4@¬ëæá~_âÜŠ"K:òÆ$ „ 7¯_ø #zıVˆĞÎô7wŸllN™eé\³› ±SEK
	Å&;´6¦¡ 4J-œ4,Ö³
üb›Êæ–sıluìªd/ğBÿªeJÖ.F
§¬ ";J’äÅ‰—…ôu°)ü
PÊü%  k„ Å‚ÉÈEr@pzOvÙaw°?KˆªqC
Œ g.Ÿ­î†5Ûd€ €Á¤sz ›è=BdÍPXYçLLföVÎ;Y¯ı™RáwyæŒÜÎ¶L;l‚AÀ õàRÙ×@OJ~
«ğr1Å³Jb$ÀâhÎ"Œâ>Õó®À^ÇC@ñ(åQRYÍeb!­G!Z­Õ$ıJƒN^l)j•gÛd¯z)XNXT ·ıôd¼ä…÷ìpÓP¦j‹Ló È0–*KpóßŠŠ£Î&A ”é<%Qº"r|>=D-:±L"Wd…ç±ë%UÍK4|Ö4ÉO‚BLØ[2HZ|ğ/0ùf§|i(=r41Ë~ú”TrÇ¬5ÔñXiig6	<F¾%§s˜õ¸¼^J&/W8¤¬r,¨0!í,¢Ixš§ğAæ  Y…"RÈ Êajt£Ù=$Q©ØÊ˜L"—p‚6!Bİş#yoøn&Î¯="•ßt `W`	0ı4Šì$½ÙaÌ{¨õCcuøEmFú¿wÔ}ÿQfºpü¬çóa»Gsb(^¤rÊBÓ9?2Ö €¼¨+zuÑ!TÄ³ùŒ7éÙªpä¢ghdyİXiôjµkó”yXEÓÅ.LîÕÜŒ[ ±C
ägs„Ü+VQ&®ğUø‰V åõVùìƒ 4#ªµ.ø6¢ÔûımFQùÉOiFAK}õÂ©ÑĞ,ËÜ0’²{Ë`zàà8ùŞêP™%>AÎæíÒ!Æ¹Í$P	j@.ºs!¸õFå®y ]>¢-8	 *.À)h0ìb¬z80ˆs,TÙ<~Û:T·ÕäPgß€?âê„Æ§3Pw¦öï,¿`ÌêÊ	İc}¬J@ÉaWéA9(4õ‚ŒthŠ@~b°xõ¢«tháuH´¶³ÄG…3÷..Äê®\šà¦Ãm<FGuµ)ê\Ğ°LègCÔ„´'*€2 «ø¨À"- gQ”awÆ”™ZÄ0L¨	¶àÉa@B#æÀ&VnPq©fŞÆ}kÜhÌa÷VbwÇSj°¤ná}ÂÍ 1¬*È)4¸B­¢r	ZMc&Ÿx7%’mÚ­:˜e²ç @07-dP«Üçw‘~}‡åtdâÀcRùlˆtüHMÙè ÅTz'Ætu;ÒŞqÒtìnëzÙ°b`{äEÁD31(‹ƒ=sc¢9 J.ª"6Aù cˆĞŸ¹ªQ(	a3æŠQiïê InipìËYÎØ“IğcğINı Si6×Z¨Ì¡Bˆ‘› 
8:¡ós(@Ïr]@ &ÏN…ïp×U\oˆvqw¥¤Yd•j'÷(C¨DøpÑ(œ”oOt,±CZiÅl€É«Æ $GªØ±I¬“ ¬¡ĞuMR¡? gÊìUèÒéO ¥1ì£9°ÄF(T¹
“.¢  Ô€›(¥%ª¨¼Æ`Pê£±z „6$Ú
¬¬x±¥^çZgKmõ*ø£«vLgq8vih´¤³	î«¦ ˜ Â­Ä(s <Ã8ÄF\6ÄÉÉØ©è&â„)ïEpY¬4ÖÿC\u0~ %7øÿC4«æÏ¶uvßÁ
z`ÜXŸà¡hAÏhJC
8¥p  ²`ÅĞ%&øhJ€K¡§@OFÏ!ƒŒ&:cChjI—(¢lÜôÈÁnx+g{<(  å
Ú!*QÖf
¾Ï)’ ¢ÑBŠlÎ"$Å¤0*i¹„hb½Ü¡ÚÊ¤Pªq–+oI‰Y_|³Ç #È|xŸçh)~GC!b1”Ì§şN^…}í_ÑsDégNvÙmT­˜!çK+Æa :¥„-·P Ya4!ÿeàyË<sóœ*òhí"iKúp1 ì{ı4ùñjèİØ=ä¬WÆU¼¡KÏnÃâà©ïu±mêÉë: aª°É	këÁ_¤ h¯“r&w b/l éä¬}Zâ	tp#ÎñÒC^´³sDq’çGlu÷•r‡CÇ.ª½ÌRu÷K‡ù9êïïï„—3o^Cy ¡<Ûì°8‡,á5«€R‹*Ûãà@-Ï:’yiÆd”ä`¨)^LK)ô¯ÃÚ©'å)Á¨"f¤0#£*Kc_ª`ìÊSPëd¢`¾ÈZ¤‹4´s†öŒ‹ğ–dfë-¸¾5vWÏq>"ÚgK$cü‡:¯NzÍsL’‘Ø×oÆ$DØwP&ÊÎe!2ÄBrê :„G5>¨`zkù}r8fûMÆ†çG”(Xô`…n£ «¨Tj ÈgÑİ/SÈnJ2´F»ÈB¬û¤ñÖ]/cªw="¯ÒPûw4¥É[‡şBêĞ¿$±ÃĞı)L ¯0â]qr¤âóq<}=a«ÆïolIO	ªs’è“),ĞÂOå¢¸¢ h µ”–Ïş®Â3+Ù,ï€?v¿–â(00( tëëcWòÛûxfsI²=ølÂÛÕVÿEg¡º2'³$W_ìRsnQì@~xB	‚º8aÊ (8Ó)“qã!Ï®Øå§UşFÜ«ĞÏÊê`u¡©÷eÛ<,<–çÿ.W5úó´©Ö¹-÷6 ¶¨9œ¤¢úHa2Èø1 hs  /ñÍS ‘PŒUìj}>à5*t JxpMê4a:f[ôKy^täéµĞÇ#Nkºx¢à¥b¢ñb2ğé1¸L ÃãìîÆ›|ÀGâR^>drô•%³å°%(qÇ;°¤-åšaJHiC™‰’/Àø‘K]emÜôAßchÜJº )¤Kv ±†¶€¬Í6¿Ìh>â áe³IN?jC7 ¸ejdc×&nÊjx½øeá[ÿp<½Ë}£yå¥–<Î" „p!jkF1Š0	ih èDa+Â!Vğ#& awM¢u…A®ğÅ× Y_)¼+ew3#|M#^éyƒ¤!^¤]—f^O9«ıˆcâogb}QuC¸L[h"eçâ4ê6Ü.²

¢pcVó¥¹|hÖl­èàM¾Ó‚nÇ(±¢. )B!8ÃìÚn/işñS™=¥…®8-á<qÀe ¿T+Jl&aÄ#YÙn¥i/1ú¤™‚qÂh~nh™,ıåÈ!VM1¤:%$±±k"1Ò8™ƒÅ1Le¶¢zv<­D4xºG|t‹¬:ééäª€d€2óÇ‚œ¡.‚0¿8?&ğ
ÿ«ÀKt]¨gÎ*¤é~"™ :
·ÊÈgt§x*tS9d—Lœùpdc•²ÅT+ê /Ú¡ˆ Ós²EúWÂ1
9ĞqÍ!œ£s&
«)Kı‚Ö+BUãf´á¿øœdKE”.
pn‹®$”#¶$~sí%ËOæÅ9vÆàæíétÖ%bS ¤nE%L_çFIX‹l(j5gŞu­u_«ÄÓ&Û.ÿY†:¶ê]ZÎæ]Àá>€C6 #‚B8"« ğn+Éà„ñí‚í$7CÄ8Xîæ¤}kNÑ\§{J?q÷í©ò„ŞÆ‡N]ô"ÅõŸ?‘Wjbì,<¢¡o ¦ ”Š$Œfp£+|²
"` °pH/] aDx@íùHŒ»F$ïtá£"Şä6–0yé°@¶1"îøÒ«4€(+¼g +ô ,Š{±Ë£f)nâoÅîo{©ì.eFÓ­gÑ—‰ÒI ´º6 g dà¸l¿qPªbíô–Ç+Ñ=4â¢ÁÜtHtDcJº#zB – a{qVëR§_šmäN_ƒ­! YÖÀÕa€6gÓÑ#Mü]Ns>¨c&&i-‘e	6Z@.1&e@ßfQ6¬~Ì_­Ï Ã‘}Få·h(y{2Åpvi® õ‰ñl»í+LÃˆBó©B×ş¿øÆ(Öà!vX¬qg(ƒ§`)½Œd-ÄÃ†Fa<*QJ»´ÿ½aôæÚË ş (,Bº}il®Ö’—z‚15h­GüÅ°t!li2+[4mEvå­ÄKºsDì Láâà @;æb\Ió9ôÌòa[é©3@¾a+<&P”Hh}% Ø*F€\Éi÷hd>€¢Æà¬7cêQØbò®2'$¨ô¦cîgéÕº´lŞ]?dMsn	V63 2°L3â¦˜÷Q`Ş)MNÓ6BÍÜêM@½·Ï]?¿¦Ó$Ş“a&ïfxMÓ,A!TòĞ³	eaë"ÃnÕöÊLÔÂ+7ómiZM«§HÃnc?¶çfe¢.*JHÿ}!-U6Dø˜€<mµJxLQ6/àRAyoqÓô^-ç‹9ùKMúîoyµem9ÙÊ­ª½5¿03ù–ë)oC`÷¬™MQæVi¢6å|7em?o˜KçlHyÁ™exöçtíÀ'#)” heÍ0LTI!( É|„MI#ég-]í«jnŞS:à³H|rşRCá²1Ş!5w-J7	dh:<Ğå—JuI”4cf	&„
µ `šhN¤x „'Èhñ  ,ŠË(Mv¡ë«À8?e`¤äË¤Îo¹À³q°ÍìÔ'+-M~ë³ˆm#,æ   Çújƒ~xÓÖÉ@ßcsHaeãtÿù»EòÇme¤´Vèc‰A-„Ü°! å$8f3{!åRAİcÆl
,ş,ú¹HZBÃ„ ¸@Ê
ßaOo æ-0Œğ30EÉ6¯ 6¦¿9úôb |…‡SYÈÎ®mÚÕ¼6y¢[n$pı~>¦·ˆI"Ø®`¢¨$%7äqR¬‚î¢‘1L´z‘Mc**Õpi‚(.“¬—Ñó!l)ØÔ¶Ù±cöÜüùº`!"Rê((s&ÛÈ2`Xš&Ğ:15”@´·[1®_@£EN)©h*àÌdÒ60»bgÖ2³i§`@ ò,ãÏSËºn
OU]Mn­‹ŸrJ@ÜV®åÅx~b(Úü'….5¸èV¹…p*…²´‹çáUyĞè—öÃ¦ÖSüsk¸aö‚û:tGÄòo{‚­hUÃr§çîçÜnÅ"ˆ”+ğ,jxóDÕ{¢.–C"Ï\ÔmÃÁH·_…ÉjÈÏGR• ™iÒÂÖ·©¿¡ğy 6/7!˜á%?)_í¾)XuÙúu·.ÌŠİM@p-´G` +µé–n«P -#â¯é B¬‰gXzËƒ73å¤ZºÂİkQøÿD
æ†	TøL¬8Ÿ¸x EÌP mğÒÛùj¬:*×:ÃMÅ_‘&d'÷à=¤øôd‘¾†8û$X=K.f(¬r `d˜U"Ug4ˆ<MAİ XFQU s6‚|+qÔ"ol«nêÅ®ÚÏuòå#$òoaDc¨üd[åñDoÂBf8rE(f´k±	jhóäL)G€R2kÁ`èçÈ¾[jÉtÎ'ûíéQÅ¢k¤"x£07‘+],pOwuL M&@Äoæ(òÍ†@-Î5äuè¢ABšé-eÀc5I5z+òŸİL:¶×R&,ÈF—¸I(`£ö…`v¬ƒ' *.&§QHLlspGºI'xé~™ƒ®PÏ,¤&çcN<>-K"à2k*µ¨ ¤LÑhĞ¹ş&¨Hœ!æNE¤`h‹ä™Æ:àŒ&ŠeJ²Nµ)o²@¹±]AÌpc2ge/Ïu¥pQg=¶§tI`Iå_±öê"?Óq;?"n|ĞxÅ* )›4OóIó®­>E^»-êf=æïÃZq9€¨6iÏ¬{^DŒ(8h-ÔgssŠ]*şâŸ¾‘`ˆ$ªŒyåË¡Ñb(¨0Ãr 9
„"¨À¨Ğ<aòĞ> á€n„²¶b73B¤¬ ’² p›úK‰jÀfšš2†Mê‰t$xÍ”-·£Iç©p£#xa m}’ÆçÀ"õåe‡¾CŠĞºäj0ƒ H¡)P< °ÖÈŞ Šc
(">l€¿X|èÉüë¹8Fñ¬÷)T7hfĞdx‹aXCM[·f£.lŒEC,`é
)¬¦t BÌÚğDY,“:‹Kg³e’iîóòG*ÆV*µ2Oä=	t7qÙÁ±»qj X( 
foE"¿×rß×nNqNlÀh7íÊJ0UÇJæ£ª zÒÜ»*g(kk€ln£”…1œ#8uÇkp"ôìu|pªÅÁfÒs£^kZš…:é)şÉ`ùeezÕÆqüÙÆd( -\â…*`µÀd)éíŒ&ÆsomVyJ'Ç¶ a ü,"È$²§kêFİï,jı$‰’B€
;iqdğNZfı `!ÂNôje/2h2uÿwã/ëÌZË[ f²zñ›"à°åNâl¶p¢Pš1®<¨mŠ)fúç–°å{®"åË Í¥’ÜWåªp5/E®sõ-ññÿï¢AîúÓ0½8yÃ¨WIN5%fÅ¨L(£]À™ŸAå%¤%D(eaÑqêzñ^éfck÷¾¢Ø§)c¦(å·cUõ­ŠCmx@ÒGÂG-x-;4˜": 7 ô p3%ÿ ,hªu€ûaPC_bjtV{.b¦š7m,éÂT ÛKm(nò¢&)£)>p¨6 d 3ü¥ÖÌ¯_ğèğGÆešN4ª€fë’­ù„2ÿoÕ¤e	gàíE>Áó!Âš$añHZ)á¸A	Sî6xy¹H7ff­n 9ä/td­B²ïWMÌH¿“<¬}=6jğFŠ núLcñ`uS>}¶öYã€ìhwKRª+SUTj0bu!f­;í(/p+nòA?w$Á]„c(zÏH~(·  ,€‚xZHà_qd	m9t8 ãSãÙüVv‘V±btf_dÌ	5è í5¶Ñi!eœ¹ãÖ0s§ús³¢lSgeq	/ÏæElØğ5æ$2fì˜D |Iz8-r`Kn<=KLhª n(@Yôqä~äók†dÃşøs™şÇ©ƒ<C2å.%1 ¯ «0àr d•9Hà_bJiÆë–,Ååj|IR°m=
è¶ôQ"™ w}2U¸Iu¶í+_ÓS9(ÒaºÓì=üf¡?tö˜e¶n­jĞæ[|m9fIŒ<C!%º&p!f w)˜iúg¥iy“-¯èíäe<ˆ¬â¯f›u—û)`„Za3»Pµ&.İŒ   #u ¯‘´D„ ¡QtáG#2hv%Ïå *<ã!<ê.§Ã`åyï>J¦àÛt™tÍ!·$]QÈ& d™2 ì¢¦ä*Ìt°M\mÀ×®M…@&Dgg~c`b¯ó,|¸4ülHgôyAq}“åTŠ14 h…ğ=r§‰4Ì“e9èâ¬u­jŠ[h}^­Plšfû)ÙÀòDd;û|ÚÅ}¹ÄM/ `#+ ¸`"Å:”ÀfÄlí™s'®Ú§pf§.¸sE¡ %Ÿ5nTâõAü!¾,•.óo2&)y‹ÁŠ`"4@	ê¤s¦±'|µï•ªÚÎq*:c3xğ*o™¾Ÿe)K\Bh`üTÎlÒG&‰ÔuoN9u™NüBü<ï;t ù0kÅ}^¼ôCj=Â¡fMÀ oŒö/ÔW%‰ñ! ³åISW±C÷â;Óãh#EÇIıM%¹¥m$9g§ì²û4O<M9_éq<Õs"7¡	-e[]ƒó¶)KbqoëU©¦Ã˜-ŠĞÛœ‹O62¼q}d)ç¢z—Mkü!}1(š¤!4¡1Î’ÎE[ag»YOasns9$_Bc€¼ D3w=©a"<e$y¶€ô¨gWì{é;núd"2aÖGA$ñS0Õv|•xÍ°Ê: ìòúã/%r{ñ4HR@DÌE(x¬Àì&HdvXªğôÂXqÉ'(y5o³îémfD:E½HİîrnÙóJèh`G'=Í5ÃùA%Î%ôdaën}¼R0tiXuuì
ú @³€dl¾…hib² Ÿ-<gvbHbí©h-^p™Ò¤}›KèIœ `u°2!",©YærÏ(¸}A/n¬½×­¶ÏYCôõ)W™=äd9"Ñ£A!	åeémaÖtr&¨Yñvô‡t~SWûXJ`t\¸Â.c"a,r4:Átxú­hÆœ·0áâbV—¤d7f8ß®zu]¤6c d-®17ˆ¯ "eóÒµyÉOlèEÓ%mh4M4wÉRoè<@Q«%xDb¡d¶qÀ×åÒègz¥Ô+>cY&yKzn?ftn·];Gwr ö3¿
;«Q0!TP`úøĞI}Vaütä®±h¬ÌLAók6[?4v¾æ©qùÄ>`40•³¦Fı²s m:*t§1`²,ºjkh×TÚö%`[´Ô;Ö:f9Ål,èF¾4è21ô)òô@›lÿ!>5jcÇu{[›&Y`•  yuÃ±S±"¯$)ëÿ? 1fìyn#‰L®°IkÂ¬§aJw[,?y> *Aõ`Õ#„)÷lP‚tf(©	H(‚gWh¯“Eúò=¢äd]({ş-Úm!¾i=¦  ª}\ ÖT{z0{ígC8I>‰bKÍ£! ›t]æÆ0­1£N'm‰ÇÎùu>·_#€ü{hsls-,o›!ù ‹-$bÙ2±i7ÔAp	&_3+>)á½Ò`s±U€:ÜÑrşmNğqUto|?—`}÷u¿SO¢ICï"”2y-Z×mQ$…Bçe^tì2ü÷u‡têã*+ü"dÓ*L¯3ou.¤lÆìtgä$lS;J(i»s,¤9Vkje8ÁÄ|%ÿòó=%7¦d=/[’™ºW(HüY>UéIûaplo®Š8\¨è1´@<(7u[§ w	I =úã;±qÁ´Q)èê¹dëcqèˆœ•Vd-&újÆfği¾¶007lÜ­˜ˆ]åJ¨ÁC'au&lA:¯*1±"öa}e,”¼`7` P6nhÒd?×!"}!:
&@ "¤0«`pe*d3eø5Më¸lî¨¥(ŒH¢Øj¢¡dâDXí	@(wgE/3àÿuj@¥s~»"95ağ·^"ãüüp6h'õ[Íhøhp4ŒSRíéi«“ÿu°ë0˜ %`rª41záëNáF”ÑØeç‘qÍ¬„`m¤€Æ¬b_äü1|¯^í,Nßõ#`LŒßå-`Úx $¸a(b ¾<8Ó<=í”ï8T$|U:xºLønÅÜ¼¡}C’sç)~áõB=No&…çXûÕó¹"³d»ğUaÓ0<Ü|f7hş7ç¾p["};¬î£Cítéào_-õÃür5^ Q@ú új‘¡ú5F#Ñ*U¸¥}ÿø]eJP:uòq¤fRÀ2ä}npvñ¬$¯3Ô,gP£òQúë@‚ëD°¢uEP:s¥óß2ØNeg± U‚7.mùõ)¶(P0búùµn´t_«¯Ú½hVišå¶ˆ
NSîáYèR+m‹ä¡ÅM!uòu¼rB|‡‘bük=&
–¥È ”5$8
‚è\"a8d£!¨a($Œà$% v µÌÕ‰urqjŞœ>z¹g!¹Ä$è,á¢—6*é^THàË1,s
GnkË>/r y® wßei#k#¦D0¸1Z­`3"Š´òôƒÁíKX@
'ã¬,Ø!F¤Äd¬ÒQ|Pş3
õ5‚UK¶9½ì»[%yQì 60é°Û¡Ğà_´ˆ‰`Àp3`Óş±30q@Ç ½kT-¼«i7ú'·*—a,	a‹ğe-ÒDânĞnElşhá©÷+ò‹ÈõçxppMüØlŞ¬Ø,h@3Ä(&íLeq=hÕ0Gq)dEÌ~…a€(éRÆ"A‘Ú!.8p3íVmĞlü WmúM½y9æ²?=AµT²?smlGn„ä}tÇîO½)K´uFHò¬0?ÿ )x0ôİ ê?'"ìJ´‚¢`&¢ ¤{c-ï¡ÔpÓV)„U,0,ài%"ÇbQ 'lHá9wÆ&p6L%¶³õ (µ k^szC®x_vwı-®dhpdp!MiwÒVW§í (
!¼ò\9H~~°u§Óe.«ig,¡c"eBŸ…)µx(»ab{ğuìT#wÌ²iM8$Ä9Ùa`0eqÇ®òa½_Äˆ¨'‚À £C0¸ÑO¨%"\á]wğu &$!AÁcd+ò9o˜c-A, %A%\ébêj%'¿êj-3o­¹+å -˜e2UB™}´6g*m Š%ıoÔ8<,¥c'H4"Ôı‹æ©~nà |fiql'F$P‚ 5-}ğ.#[5~,÷ş·¸$q›ef"dÙamZ·qkWrŠŸMY&;t6î£qµY7-u,Õ³¯·b YÂ¶…s¹p!¼(ñ'qÒ¼ %z„Ò.D"$íMf;J²é‰‰•…0} )ô‚pXı	.uPi¤ àmE†É(3}mqZNv?ù¸[ 4^ÀâsqÁ{
“$e*=ÿ!aî’0×läaáäsy¬ëú@4ÍÙ=[çLvgŞ@;m¦ıBhcydüÔÄeLzláåğb{ÕŠoOåş)¯0óaÅ¦Jf/Ìì(n!Ìr6Ñû'CZÅCÂsJ QRUÈ£" ,W!Z¬Å¦©Zã®0m*•e[g´r X.(T
^÷y½$¾ä%~(pÛØ¢k#lu P4s$[póßÊŠãî&Aà’é[<?ú[j²ppN<8E->ù<’W-·©Û1
µtK4~R4Mk‚RLX“z [~ú+x>UÙv§|i«=s<31Ë>~ü0T2Î¬uÖ9xi,d6,D¿-$õˆõ ´û WDä,`/(p¡}|"°ÙüR·ñE@ö Y pğ±ŞMjQ&Ù-¤QÙ\æLHSyVeJD¼'y7ïx&Î®,"µÛf!hWdEqìş«ì}9éhHxèõGgg=UO-gò›÷tótn¸t}¬wÓa¹agb83z¬R}Bó}<|\(rµ¯mz=é(yÆ£ùQ.iòªR¥G"gh/}Ùˆo´n´+<8hXŞ Å"DªÑœM{ ¹c.à]'°„|(ôQ¢ $ğd0‘´õ ï£ 484.é6 áTwœ^m=BAûuì`EEi;¸Ê¼¡Ø,À “´{mzd[`eø{ßzÚe'1S*àluÎ½ì$5jX.ºs¡`udå¾ù8g\z¯-ø`.î*Liki²eF®x;g¨¥W,Tø8nêrM¦İäWl™ >àè	ŒÖ§3Rw<÷+ª•`¤êŠËãy<Z@l@'éÁ=!h4 ƒÌ|(m€@`à 8ü « âáe
E/x±†W…3¿.¡„Ú®¬JÛ Â­<TuS5)x^ñ¬LègCÕ„0'(ç¡0,£şıÂ25@oN•`uÄœ¹SĞ$L8šè€á B!æ * aU©ƒ?io¼hÌiæôhW_Bp¬nñqÂMíg${
ŞJ-˜æÍ«zlZ/a&…x,­­Ú­0±G€Gd€Ì507$`!«ÜG5¹<'ådäâà"P¡h
‰`|hWŒYé ÅT–¦%àVu8=ÒzóÂx¨¶¹zø B`Y eÀÄ310+“=sa† àa.*"&õñe ˆ8Õ{(YAm3æÚ],mÑ«à\v)|‹ü®ø+k±O˜È
ı€#`7×©!6Îœ Z2"i@Òq  ç A  .Î+Gåÿp÷W\-ªüuN5´§nôB%ı(G0DhÒA(;œWÏt-±›n.åÁ«Ä4GºÚxa­_¯Ÿğ¡¥Ø}m2¡= g‹ìèÒM º¥ 1ı£s°ÏW`Tû7^ÂålÕr
-mª¸4
ÇlQêª©y ¤P{.ÓJc¬y1§NcSFklõ
ô£¨@m 8(sixä®ğì©&±˜7“Â­Ä
}=Q9”N`7¤É Ø%è&`â+7L`"Y¢6¦õSVp1v&7wèûB  æe¶g'õant^XßğaÈ7Gß®ZlCNråp(,°`ÍĞ-$\zx0Q{…IH‘å#ÂÇ !&:c"hzYµ1aÈìõˆ/`&m+u)üY¡ bdÒ³n[v÷H¾ß­ªë'Ón‚,v"&!¥q0biqxşbıÄ¥ïÊæ9 p¦+{IAè+|ó,3H|x›§ø)~BC!"4®§œNîMıkG •GWIëi^gWåP­À%¦)Â)v¢æ…/K·E\{i 5/¤òp_<söô
2i­#i_ºQ2 äYe4 ‘8ìñú<ì ^¤]º )`fAbA =á†1±#ƒhøã	?l{î‘Ioí¨> ¬¯³&&v òoE éåüu\ş	vxsnó2ã|¶¯SG}QíCluı´pË.3-ìXÒ.Kâù1êæég×³o~Gki¡>Şvğ,dz“$=óu­èB«:Ûs‚àU)7Ë:²ly†F väyê)Chj1ñ-ŞØ#%æ«Í(dÆ¤1[«zcN< WHëPhtî`şÊZ†¨4´s†ö1
Kö6Ggw°g½f¯qo(8eG¥ó}U(ŸGëìsM’‰Ğ‡iædFÈsD&¿eaÔsÌJ9k
s:†F% ¨`8kø}pıâ;H ¥â™„uxt` nó8é¨p#c&ÑCÜOÁÚ"°F¸ÁG¬ó¬º6ö~/a$79‚¨9sŞ9íúybëZşt±ëĞ½((Râ¯9ëdR´ê9Ğ,¼>6!ª"ï'dY_^"³2ì¢é$ĞÀw5¯F¸&l2uö¾¶b;g+À8!G <2¯–îa2>,Màpë£cvÒ)ûy"s!³:ht@ÛôÓ#]g£0&‘#$ 7 Ü3~QÎ‰e^øD ûÍ-)ê (¸a;ó£!Ç´ÍD£¸ÆøªRïÊë`Ñ¡9öa}<,7ÕyeQ5x²4)½¿f6B4 ;”ò~UÚ`rÈø5llvxT%µÉQ˜WÜİlj™g 6 5"8 c80eÓ$õ8d{ş{{dä¹´RÇ,b’a’ñ¥b¢ğXw:pà!¾.ÁOèæÏ-‰m@F¡8B6$Pä…!4$°%(n{s`¤mgmjNiC™€˜)„¨1_]a­zt¸4¦ciÜI!¸2)¤ë2âá·‚®Í,0Ìhbª4l3ML7hc"¤0mftq[¦újxü¸%3ÿv,¿Éy'ñ¡·†4Î 4°„0³*EFQª0	Il"æV'akÊmW#0#6 K7]b} #0¤U Q#,<Šde"/GDz†M!|é9«´‡\?tšN\=9éå!c &"½0Ğ1C¨HKl:açò5~vœ.2‹8xÃFõ€9pé,¨  e¾(S¢„(°–$@)S!x(ÌÚL'yìà@üu§„¨8-A<€ µ$yJ„'à#yØcÿgã%µªµ„q%H òbh•,=gèVm2´:id³±b– 3æ8›£é Md±³Zv<%L>1¸G|t*ì0éé"ô ád01Ç#œá€Š;?z?7äŸã!Apèel" õ)1#x2Y~0ôGkBdv³y:vRƒjF“Lùna$c ²ÅD+ê[‹/Ş‰hØGËrŠLûSÄ :qAÑÁ§8ñqd U­…#¿†&Ğ;CUvf´cø¸ôhA¤l(t"k¬$”#¾´!,-óo­2â‘Y9v&á¤í¹tr` ¤lD$iwçG\d¾~·
GŞuõu_ªˆ³3Ú</jIÖ8¶üyÚË¢e…Èa2Ã¶0„c‘E±g«$ãd')ße† Í‚í$'Ô8]$ô$9{dĞy¥yj=0c­)¦€ ¤‡TöôfåU¾;‘tjâìbum< ó¢Ášê$„n`³)~""b´qX7ır‚uDxa}íH^¯{,sxÅójßä—a5As)qd½7jæôS¿°603+üe /\ !<Ê‹K1c)!_¢eæ/¹¨¬>dQBa‘&A”öHà¤:2¢g€dè+Vœ=¯ 3ã¶ÊMt®Ï!àıpPâŠÁĞ#Tr ´¢az 1&¤`ûq>zT q
eà	ƒ¥! ËFBõqèvÛS#M,Yh:½a.4iŒX1+Ø@ &e@EP<.~ÌF³K£›l±vF÷7I*}{2@0~k†ı‹ù,L{	ı;1EYRê£ñƒ4îøÆ(Ö`1wX¬aeyº%`½‰lmÆÃ–Gr>g.Qo³¤ß¼aöåš¨'÷;h,ºya2|ª––“~Ò=enívz×%p!ee2z{4ac5wÌ¨a=dì Da¦àE ?kcXOş1ôÔêQZé!#Yş¡aofP¡J(]%<ş
FM}Yáqszq¾ºçè®Ws YĞ~ğ®M;5¬jü"k¬aéÕªd$v]H5¤ynl71#0¶7öı¸v1`%V"İ^û&@İ©mC¿·Ê\¯¶Ó5Ÿ–`'F|LãtEiV]÷Ó²lI©&éFuôÎD´æmú-ly+§Hƒl`B:¶Kâ@ o#ZHŒkT&,u4E.Ø¡¢Á¼mµz9Qu,hrAmgPX|õr-c‹9qIM±¬My)¤GmÙË­º¹³/ñ²{9ÿb7´€í âk¯v•t%;o¥,(y¡e/2æGKt}Àg))ÔJhuÀ¶(Ü$i ¨Áã<ÄMM"¹e)­«*jï º`³`yø¬RCá²1şJ5C_+ä|:4Ğåu!i´4cd;Ä „5€Aành~æzìƒåÀha°¶¢X`Mv¹µç+À¸( à åY¤nÇ!‘@·q0å='=H>4ê¢m æ,6a€Fú?X‰(XÉĞÉÀrh2LpSEãtàTñ½GbFi%¤,vø±
á ¤Ì±%¤$g?e#é#ıA˜jâŞ,°¹@t"ã”`dâ*çaôe9mğ36Eév¯¶?6gf%şå`$EĞÚuÌÊ.mñpœ=—q‚[n$ sM{>*• á#ãˆ®pÅ¢Îd%5Dk”r¬DÂîrÕ{mÙ÷n³lkÇ&jõphÿ‚NÁì7q50n)»v!Ûàr¦üô û`52Vze:(vgKÈw@X’7Û345”W”³c9äOl£GNn¹x#×ÔçŞ4`3e` £a³ @*.,ãCË(n hUeMd©«""d:R¯$ÄzNW ^Qx…5°îr«×`½‘›2Ô‹”çñÚ[UQÔÀ7Ó¦ÔQ|5!¶’y*tE×5'oš¢± WcsQ³öÿåÛrİŠ™°yğ­bxódU{#n”G.O\ÕeíÁH7ZƒIzØïOĞ$»qc[Ö·)¿ñòi¡6'2€¯á#=*iºaXpÙ²}&n¢ÕÄzaå œ@1K0A6lLéA=&¯éab@gx{Ê‚#f¯RºÙiR}ñ¿$ˆôL„Pë|Uíğ™yLĞ y`R›q¢,2ª0ãiå'‘& %ö !¬®ø¡`±¼† É04 =K¤f™¼z `dštjGo€;E<]AeXFQY¡w4³6ø+1„ gü(æQÊåòšÏqqå#4òMC##èüeğt<kÂÆ}h(fõo±K`iö˜æXmOPU"©ñÃèäp¾[ÊIv¯o³íá,qm²kä xc17ãU(ëOwuNe.ÂÄ&æ(¹ÍfíÎ%fu(¢SÊñ,äbc=Êe>*
òÜL;ö" nÈFW¸`Y; ¢9ó…lw¼†gÁ+n77D1@Lv0GòÁwqéf9®pkQ,F/0fö-:=--!"À"y:µ=æ.TVjQ¹¸.(j'¦Ju'$Bi 9zà!¡.&Ÿqr^µdo²Â©9Y˜AŒa{6ok?Ïtµg-²æVmpluZóşª#a?=2jüApdª4/?µ9Ğ®6 Z<:5ba}ãâGR9„~>: Ïüc^E…(8a} p4š:có"$Y2¼_—ô a¨Š½¦Ü eë¡ÑW" Ü0aq$¹H´bêW´X<qò<!` |¤²·"-q6@¤¤ö¡ Tû	j€f˜8Ö]@ûÉuzí”"/µ§Éæ©q+1»"øa U- "ââ€[%µee†Ge;QşÄoÃ¦F%Pt±°Ïù^
c;c>m£·M.y`ü­(§8P¡¬uĞ)TgJ-X (:‹èH½amk·&0dŒdCÎ`ly¹¬¿t…b®Zôd}|“9I%d³&2hàq¶Ój÷e*µRŒ9 p¹!zE¹ûslï(h`!Bfi„$vm(ÙK{uLxˆ(47¨½jÊ=T†Af3ª(xÒÎº(g(kíÁl{¥ …5ct(w‚kpî¸àpd ®åGdÒs§5¸ºe0>é	m1Ihi)ea@Fñôõò0, !œ"~¥áa} F‰‘èíŒ-gWa­Ty"&4…` 0$86åo²> !î^€ñ( 5´‘Â…Ä*1lñôtDKvübeeÕ Â^ñ<` ø2<³ßà)âLi¤cşrXğ±
¡ğeà*°Y¢tz5#6,,‹)Løîfn”õË¸!õVN@…õ"2ƒå«p4/i"’µ­qó¢í ® ß¬H u¼4{ã€6M5'F[V(L,£\À™0@Ç$@§ o@:0!Ğ0b
pN`b3j>¸²¹¶9-b¡(m¦cÓ"Õ½’cm` @RbG't_(sol.success, sol.message)
        assert_allclose(sol.x, himmelblau_xopt, rtol=1e-4)
        assert_allclose(sol.fun, himmelblau_min, atol=1e-4)


def test_line_for_search():
    # _line_for_search is only used in _linesearch_powell, which is also
    # tested below. Thus there are more tests of _line_for_search in the
    # test_linesearch_powell_bounded function.

    line_for_search = optimize.optimize._line_for_search
    # args are x0, alpha, lower_bound, upper_bound
    # returns lmin, lmax

    lower_bound = np.array([-5.3, -1, -1.5, -3])
    upper_bound = np.array([1.9, 1, 2.8, 3])

    # test when starting in the bounds
    x0 = np.array([0., 0, 0, 0])
    # and when starting outside of the bounds
    x1 = np.array([0., 2, -3, 0])

    all_tests = (
        (x0, np.array([1., 0, 0, 0]), -5.3, 1.9),
        (x0, np.array([0., 1, 0, 0]), -1, 1),
        (x0, np.array([0., 0, 1, 0]), -1.5, 2.8),
        (x0, np.array([0., 0, 0, 1]), -3, 3),
        (x0, np.array([1., 1, 0, 0]), -1, 1),
        (x0, np.array([1., 0, -1, 2]), -1.5, 1.5),
        (x0, np.array([2., 0, -1, 2]), -1.5, 0.95),
        (x1, np.array([1., 0, 0, 0]), -5.3, 1.9),
        (x1, np.array([0., 1, 0, 0]), -3, -1),
        (x1, np.array([0., 0, 1, 0]), 1.5, 5.8),
        (x1, np.array([0., 0, 0, 1]), -3, 3),
        (x1, np.array([1., 1, 0, 0]), -3, -1),
        (x1, np.array([1., 0, -1, 0]), -5.3, -1.5),
    )

    for x, alpha, lmin, lmax in all_tests:
        mi, ma = line_for_search(x, alpha, lower_bound, upper_bound)
        assert_allclose(mi, lmin, atol=1e-6)
        assert_allclose(ma, lmax, atol=1e-6)

    # now with infinite bounds
    lower_bound = np.array([-np.inf, -1, -np.inf, -3])
    upper_bound = np.array([np.inf, 1, 2.8, np.inf])

    all_tests = (
        (x0, np.array([1., 0, 0, 0]), -np.inf, np.inf),
        (x0, np.array([0., 1, 0, 0]), -1, 1),
        (x0, np.array([0., 0, 1, 0]), -np.inf, 2.8),
        (x0, np.array([0., 0, 0, 1]), -3, np.inf),
        (x0, np.array([1., 1, 0, 0]), -1, 1),
        (x0, np.array([1., 0, -1, 2]), -1.5, np.inf),
        (x1, np.array([1., 0, 0, 0]), -np.inf, np.inf),
        (x1, np.array([0., 1, 0, 0]), -3, -1),
        (x1, np.array([0., 0, 1, 0]), -np.inf, 5.8),
        (x1, np.array([0., 0, 0, 1]), -3, np.inf),
        (x1, np.array([1., 1, 0, 0]), -3, -1),
        (x1, np.array([1., 0, -1, 0]), -5.8, np.inf),
    )

    for x, alpha, lmin, lmax in all_tests:
        mi, ma = line_for_search(x, alpha, lower_bound, upper_bound)
        assert_allclose(mi, lmin, atol=1e-6)
        assert_allclose(ma, lmax, atol=1e-6)


def test_linesearch_powell():
    # helper function in optimize.py, not a public function.
    linesearch_powell = optimize.optimize._linesearch_powell
    # args are func, p, xi, fval, lower_bound=None, upper_bound=None, tol=1e-3
    # returns new_fval, p + direction, direction
    func = lambda x: np.sum((x - np.array([-1., 2., 1.5, -.4]))**2)
    p0 = np.array([0., 0, 0, 0])
    fval = func(p0)
    lower_bound = np.array([-np.inf] * 4)
    upper_bound = np.array([np.inf] * 4)

    all_tests = (
        (np.array([1., 0, 0, 0]), -1),
        (np.array([0., 1, 0, 0]), 2),
        (np.array([0., 0, 1, 0]), 1.5),
        (np.array([0., 0, 0, 1]), -.4),
        (np.array([-1., 0, 1, 0]), 1.25),
        (np.array([0., 0, 1, 1]), .55),
        (np.array([2., 0, -1, 1]), -.65),
    )

    for xi, l in all_tests:
        f, p, direction = linesearch_powell(func, p0, xi,
                                            fval=fval, tol=1e-5)
        assert_allclose(f, func(l * xi), atol=1e-6)
        assert_allclose(p, l * xi, atol=1e-6)
        assert_allclose(direction, l * xi, atol=1e-6)

        f, p, direction = linesearch_powell(func, p0, xi, tol=1e-5,
                                            lower_bound=lower_bound,
                                            upper_bound=upper_bound,
                                            fval=fval)
        assert_allclose(f, func(l * xi), atol=1e-6)
        assert_allclose(p, l * xi, atol=1e-6)
        assert_allclose(direction, l * xi, atol=1e-6)


def test_linesearch_powell_bounded():
    # helper function in optimize.py, not a public function.
    linesearch_powell = optimize.optimize._linesearch_powell
    # args are func, p, xi, fval, lower_bound=None, upper_bound=None, tol=1e-3
    # returns new_fval, p+direction, direction
    func = lambda x: np.sum((x-np.array([-1., 2., 1.5, -.4]))**2)
    p0 = np.array([0., 0, 0, 0])
    fval = func(p0)

    # first choose bounds such that the same tests from
    # test_linesearch_powell should pass.
    lower_bound = np.array([-2.]*4)
    upper_bound = np.array([2.]*4)

    all_tests = (
        (np.array([1., 0, 0, 0]), -1),
        (np.array([0., 1, 0, 0]), 2),
        (np.array([0., 0, 1, 0]), 1.5),
        (np.array([0., 0, 0, 1]), -.4),
        (np.array([-1., 0, 1, 0]), 1.25),
        (np.array([0., 0, 1, 1]), .55),
        (np.array([2., 0, -1, 1]), -.65),
    )

    for xi, l in all_tests:
        f, p, direction = linesearch_powell(func, p0, xi, tol=1e-5,
                                            lower_bound=lower_bound,
                                            upper_bound=upper_bound,
                                            fval=fval)
        assert_allclose(f, func(l * xi), atol=1e-6)
        assert_allclose(p, l * xi, atol=1e-6)
        assert_allclose(direction, l * xi, atol=1e-6)

    # now choose bounds such that unbounded vs bounded gives different results
    lower_bound = np.array([-.3]*3 + [-1])
    upper_bound = np.array([.45]*3 + [.9])

    all_tests = (
        (np.array([1., 0, 0, 0]), -.3),
        (np.array([0., 1, 0, 0]), .45),
        (np.array([0., 0, 1, 0]), .45),
        (np.array([0., 0, 0, 1]), -.4),
        (np.array([-1., 0, 1, 0]), .3),
        (np.array([0., 0, 1, 1]), .45),
        (np.array([2., 0, -1, 1]), -.15),
    )

    for xi, l in all_tests:
        f, p, direction = linesearch_powell(func, p0, xi, tol=1e-5,
                                            lower_bound=lower_bound,
                                            upper_bound=upper_bound,
                                            fval=fval)
        assert_allclose(f, func(l * xi), atol=1e-6)
        assert_allclose(p, l * xi, atol=1e-6)
        assert_allclose(direction, l * xi, atol=1e-6)

    # now choose as above but start outside the bounds
    p0 = np.array([-1., 0, 0, 2])
    fval = func(p0)

    all_tests = (
        (np.array([1., 0, 0, 0]), .7),
        (np.array([0., 1, 0, 0]), .45),
        (np.array([0., 0, 1, 0]), .45),
        (np.array([0., 0, 0, 1]), -2.4),
    )

    for xi, l in all_tests:
        f, p, direction = linesearch_powell(func, p0, xi, tol=1e-5,
                                            lower_bound=lower_bound,
                                            upper_bound=upper_bound,
                                            fval=fval)
        assert_allclose(f, func(p0 + l * xi), atol=1e-6)
        assert_allclose(p, p0 + l * xi, atol=1e-6)
        assert_allclose(direction, l * xi, atol=1e-6)

    # now mix in inf
    p0 = np.array([0., 0, 0, 0])
    fval = func(p0)

    # now choose bounds that mix inf
    lower_bound = np.array([-.3, -np.inf, -np.inf, -1])
    upper_bound = np.array([np.inf, .45, np.inf, .9])

    all_tests = (
        (np.array([1., 0, 0, 0]), -.3),
        (np.array([0., 1, 0, 0]), .45),
        (np.array([0., 0, 1, 0]), 1.5),
        (np.array([0., 0, 0, 1]), -.4),
        (np.array([-1., 0, 1, 0]), .3),
        (np.array([0., 0, 1, 1]), .55),
        (np.array([2., 0, -1, 1]), -.15),
    )

    for xi, l in all_tests:
        f, p, direction = linesearch_powell(func, p0, xi, tol=1e-5,
                                            lower_bound=lower_bound,
                                            upper_bound=upper_bound,
                                            fval=fval)
        assert_allclose(f, func(l * xi), atol=1e-6)
        assert_allclose(p, l * xi, atol=1e-6)
        assert_allclose(direction, l * xi, atol=1e-6)

    # now choose as above but start outside the bounds
    p0 = np.array([-1., 0, 0, 2])
    fval = func(p0)

    all_tests = (
        (np.array([1., 0, 0, 0]), .7),
        (np.array([0., 1, 0, 0]), .45),
        (np.array([0., 0, 1, 0]), 1.5),
        (np.array([0., 0, 0, 1]), -2.4),
    )

    for xi, l in all_tests:
        f, p, direction = linesearch_powell(func, p0, xi, tol=1e-5,
                                            lower_bound=lower_bound,
                                            upper_bound=upper_bound,
                                            fval=fval)
        assert_allclose(f, func(p0 + l * xi), atol=1e-6)
        assert_allclose(p, p0 + l * xi, atol=1e-6)
        assert_allclose(direction, l * xi, atol=1e-6)


class TestRosen:

    def test_hess(self):
        # Compare rosen_hess(x) times p with rosen_hess_prod(x,p). See gh-1775.
        x = np.array([3, 4, 5])
        p = np.array([2, 2, 2])
        hp = optimize.rosen_hess_prod(x, p)
        dothp = np.dot(optimize.rosen_hess(x), p)
        assert_equal(hp, dothp)


def himmelblau(p):
    """
    R^2 -> R^1 test function for optimization. The function has four local
    minima where himmelblau(xopt) == 0.
    """
    x, y = p
    a = x*x + y - 11
    b = x + y*y - 7
    return a*a + b*b


def himmelblau_grad(p):
    x, y = p
    return np.array([4*x**3 + 4*x*y - 42*x + 2*y**2 - 14,
                     2*x**2 + 4*x*y + 4*y**3 - 26*y - 22])


def himmelblau_hess(p):
    x, y = p
    return np.array([[12*x**2 + 4*y - 42, 4*x + 4*y],
                     [4*x + 4*y, 4*x + 12*y**2 - 26]])


himmelblau_x0 = [-0.27, -0.9]
himmelblau_xopt = [3, 2]
himmelblau_min = 0.0


def test_minimize_multiple_constraints():
    # Regression test for gh-4240.
    def func(x):
        return np.array([25 - 0.2 * x[0] - 0.4 * x[1] - 0.33 * x[2]])

    def func1(x):
        return np.array([x[1]])

    def func2(x):
        return np.array([x[2]])

    cons = ({'type': 'ineq', 'fun': func},
            {'type': 'ineq', 'fun': func1},
            {'type': 'ineq', 'fun': func2})

    f = lambda x: -1 * (x[0] + x[1] + x[2])

    res = optimize.minimize(f, [0, 0, 0], method='SLSQP', constraints=cons)
    assert_allclose(res.x, [125, 0, 0], atol=1e-10)


class TestOptimizeResultAttributes:
    # Test that all minimizers return an OptimizeResult containing
    # all the OptimizeResult attributes
    def setup_method(self):
        self.x0 = [5, 5]
        self.func = optimize.rosen
        self.jac = optimize.rosen_der
        self.hess = optimize.rosen_hess
        self.hessp = optimize.rosen_hess_prod
        self.bounds = [(0., 10.), (0., 10.)]

    def test_attributes_present(self):
        attributes = ['nit', 'nfev', 'x', 'success', 'status', 'fun',
                      'message']
        skip = {'cobyla': ['nit']}
        for method in MINIMIZE_METHODS:
            with suppress_warnings() as sup:
                sup.filter(RuntimeWarning,
                           ("Method .+ does not use (gradient|Hessian.*)"
                            " information"))
                res = optimize.minimize(self.func, self.x0, method=method,
                                        jac=self.jac, hess=self.hess,
                                        hessp=self.hessp)
            for attribute in attributes:
                if method in skip and attribute in skip[method]:
                    continue

                assert hasattr(res, attribute)
                assert_(attribute in dir(res))

            # gh13001, OptimizeResult.message should be a str
            assert isinstance(res.message, str)


def f1(z, *params):
    x, y = z
    a, b, c, d, e, f, g, h, i, j, k, l, scale = params
    return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f)


def f2(z, *params):
    x, y = z
    a, b, c, d, e, f, g, h, i, j, k, l, scale = params
    return (-g*np.exp(-((x-h)**2 + (y-i)**2) / scale))


def f3(z, *params):
    x, y = z
    a, b, c, d, e, f, g, h, i, j, k, l, scale = params
    return (-j*np.exp(-((x-k)**2 + (y-l)**2) / scale))


def brute_func(z, *params):
    return f1(z, *params) + f2(z, *params) + f3(z, *params)


class TestBrute:
    # Test the "brute force" method
    def setup_method(self):
        self.params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)
        self.rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25))
        self.solution = np.array([-1.05665192, 1.80834843])

    def brute_func(self, z, *params):
        # an instance method optimizing
        return brute_func(z, *params)

    def test_brute(self):
        # test fmin
        resbrute = optimize.brute(brute_func, self.rranges, args=self.params,
                                  full_output=True, finish=optimize.fmin)
        assert_allclose(resbrute[0], self.solution, atol=1e-3)
        assert_allclose(resbrute[1], brute_func(self.solution, *self.params),
                        atol=1e-3)

        # test minimize
        resbrute = optimize.brute(brute_func, self.rranges, args=self.params,
                                  full_output=True,
                                  finish=optimize.minimize)
        assert_allclose(resbrute[0], self.solution, atol=1e-3)
        assert_allclose(resbrute[1], brute_func(self.solution, *self.params),
                        atol=1e-3)

        # test that brute can optimize an instance method (the other tests use
        # a non-class based function
        resbrute = optimize.brute(self.brute_func, self.rranges,
                                  args=self.params, full_output=True,
                                  finish=optimize.minimize)
        assert_allclose(resbrute[0], self.solution, atol=1e-3)

    def test_1D(self):
        # test that for a 1-D problem the test function is passed an array,
        # not a scalar.
        def f(x):
            assert_(len(x.shape) == 1)
            assert_(x.shape[0] == 1)
            return x ** 2

        optimize.brute(f, [(-1, 1)], Ns=3, finish=None)

    def test_workers(self):
        # check that parallel evaluation works
        resbrute = optimize.brute(brute_func, self.rranges, args=self.params,
                                  full_output=True, finish=None)

        resbrute1 = optimize.brute(brute_func, self.rranges, args=self.params,
                                   full_output=True, finish=None, workers=2)

        assert_allclose(resbrute1[-1], resbrute[-1])
        assert_allclose(resbrute1[0], resbrute[0])


def test_cobyla_threadsafe():

    # Verify that cobyla is threadsafe. Will segfault if it is not.

    import concurrent.futures
    import time

    def objective1(x):
        time.sleep(0.1)
        return x[0]**2

    def objective2(x):
        time.sleep(0.1)
        return (x[0]-1)**2

    min_method = "COBYLA"

    def minimizer1():
        return optimize.minimize(objective1,
                                      [0.0],
                                      method=min_method)

    def minimizer2():
        return optimize.minimize(objective2,
                                      [0.0],
                                      method=min_method)

    with concurrent.futures.ThreadPoolExecutor() as pool:
        tasks = []
        tasks.append(pool.submit(minimizer1))
        tasks.append(pool.submit(minimizer2))
        for t in tasks:
            res = t.result()


class TestIterationLimits:
    # Tests that optimisation does not give up before trying requested
    # number of iterations or evaluations. And that it does not succeed
    # by exceeding the limits.
    def setup_method(self):
        self.funcalls = 0

    def slow_func(self, v):
        self.funcalls += 1
        r, t = np.sqrt(v[0]**2+v[1]**2), np.arctan2(v[0], v[1])
        return np.sin(r*20 + t)+r*0.5

    def test_neldermead_limit(self):
        self.check_limits("Nelder-Mead", 200)

    def test_powell_limit(self):
        self.check_limits("powell", 1000)

    def check_limits(self, method, default_iters):
        for start_v in [[0.1, 0.1], [1, 1], [2, 2]]:
            for mfev in [50, 500, 5000]:
                self.funcalls = 0
                res = optimize.minimize(self.slow_func, start_v,
                                        method=method,
                                        options={"maxfev": mfev})
                assert_(self.funŠ+}´A„4±tãG(nfyÔ ß­ª¤¥Üú ¢C ÄhëKæàÚ™té[·÷ÛuoÔ22R¬#,ï ¬0€ïz€»Ší+ÓrDg–i@YûÓ,^ødÖ+]´rbé~ƒB¶ ç1'(¡(Æ8ê¢°|ñT9ƒ¢£uìJŠ (lşÌp,º`ª¹ÁÒgguyxúì
}™Õƒ/O!P†Ma~ıE Í{"Ç ˆs&êÚeT;†Í¸-¦ÀEUG@—±™œ`– .ß;ó4'3#è¹ëÂ©€j†…(’äF±-õ­U«{¦ìLós©ømêsØ~¿-	7l0llÔLèÈÂ–Éôuv|	 ™jª0Œå™‡,`ªµ„l58¬—Cj<Â`3€)'À¤Ò8õeìÀa†—dHpw÷ä| ¢+ğ£!¡‚‘!­¬I9ù@ 8äéšQ8	(+q$‘€±"†Àyn
m_t³ÂçI›kÔ/®5ˆæg¨|ëğš’«C )6 1Y¬Â£%+ı²}qxÚçe>qî²îeY féZª®TÈ "’ªfé>ÙÃ}EYrÁ“àw,];—ûqFr</â!±#¤ úÑ#¯°,¢{dìúº‚ @0åñĞB @ˆ häÂä&¿JeöRªpüÂP^Ã¯ },‹ôë¤f¢Ÿ `:€éBàñj=mgE}ÅsEiÜmşæ[²ºŸ¶R8td"ye¬1¢<Ğè€El½1X º†ï4'jiJx;«à „`™Ò®~‹€(	(ğEø"¦®%âèÂÅª	°Œ$|’«¢G¾×™ä1IIˆ=¨ŸT=,ÙsM/I÷wùGc’5j³¬}9}æÅ4ôUO]ëZsHrXºÅi#à!b¬"Ù^pğ¥j‚¥ ²¢ 6‚"B¥h9Ù¸qV¬0i#$k­!?ˆ—HîÉŠ-áÒ‹oÏ…ÈÂƒË=pn…O^.K˜˜ëè.ÂPƒræ3p¼IPß}Øè`8­Í+U>cÕ1”{BEd Cvdv…s#M+h:ö*¿$2£	)\Ò±’èĞ˜eNC’ğZâ¦¯H¤Ì•ˆH²ª R&,`	œ¢©SáÌ0{?p‚»¦LõiQ‹m ˆ„¤¢i°6
€j£ÂÄDÁäy¢uUõÔ;L<€ºdÏPAî/è–7ò»«ö#½zîJ‰\õ*6$àa})"‰0(o—,Î2)soAû²¹8ï$;Máõ3 3fd¢H8ı	¤©S@Â$¬1JcK$¿_€;+íÁU3ŒM((PîPf ¡HÄ Zé°ÓÉRA°*´dd]#{ÖøA©6•, ª!Ø8^ôZ» óéêp)¢­âee+‰@<ÕxÂ¡3Â MÎóE\Ÿ(ë fóHyæ•­!ç='$Që½tèùóMT	˜	&_™+ Ñ…È!Ğ 2Zû,FÆvÆùmÿçuƒGAM‰½½ß[ænIà”2İóu[g{n]®%…òoÓÏ)^ETx×´§!‡bÂ*LŠ *À3ñçÅ†JõHf\.G,eskjS€:¤„¢Şë€$»AçÒ—û¢74­Ú´ê+ó:ºM
*,á6İ?é}êàü7ÍmŞ>Ånes8ô lèQ4@”ÉŸ+¿‚¤_ĞN¾T£:A¨8 @ dKkSxˆ4=Öì¡ Šj.¦òl½4Ú‹Õg$ÈE ôî<  â'i=ŠCÄª¤0¾‚I+ë&aAP%” Ë«à-02näˆ:×H†M]5râú	¬-#bXDOA›ªPIc¸@Ê( ( àvê`@j` Á¤¡`°‰„ì$“àW`€Ó“0›ˆr·ì~àâKŞøõ¢•õÑC¸Ø‹Û|E¯H+ƒ¡İ•C¹s*-PÚ;(µçiúsåØ#G´Ğ¹¼eÍH¬`QœX$(!„h*ö5´%E ,GË<¿dKÜW•c¥PRaBŒ­ÈÅîJº¸)×¾¥€" Ä P]8ˆH ÄP
nÁÌÖ6!}rOçNKµ†±(b …a Û(jt97ô “ ’ÏpbÑA›jîó·"[)Š“S$“n³ÆaÕilg×eq[ bŞ¤‘ä¸´rî‘iò¬«†	ø° å{ñUıJP(ı8ùî
¬Š )F )&4¯2` †X£Ìx|~bë@Ogì©²1ÙAx:±ám£2FB	oô u¸–{d$ñ 6èŞ f'šù9¢°%ƒ
¯bhŞèš–¶
‚’×èaA¨"F¤WcE±ü²ÿppKø$Yfüg9Æ€ƒ„@Filı˜8‡rÔ*È èr¡+©¡ ÌæŠ­ .(9D¤cêÜŠ"z×¡1Lİî`ä*•¸²eQYg^ØN[Be–òßnêBâ¦öà}# WÙ-#ggòŸÖœq2Z­q¿¼lÖ8ÃLíC\ŠH/lî(Ì©@ğˆ&ˆÒÜn#Ni;f9´¹ ?×Š-}Áæ 2¼è’áS\(-ŒˆAcJø³ï:š´/0ĞO
1ÇâÆ ¡8«Å3º¢*ŸaM ’rõY’€`„ĞF‹À1fDàé\"|aNÊxíû_G¸}U V&. G_ŞLä/ï w{b^DeANÕ©Ÿ¨-H	FéVÄîš£§ñeµíÆVK\Op+WsrÍ¿BêFĞx±ExH^=#üÀ ³ƒ¤¸fÅ"	¿£n?E@Ì"§"…Czš~QW8@Î/0îoNH Maôºìôc1'XåV~^ºÌ, …Ö `âeÃìõ.‡xNmÍoJa?allU6å†ïtj´fz ÕQ><°¹¹/`$ø@EPîwë¸X?e ä"a0àĞaO{vñö#íÆùjw¬ii+s‚? ‚+µødIàù²Wİ#»!ş‡ÅjÅwÙ"ˆë1O|éÉ5Ó‚Ür7-@`Ÿ½¬ÉZê!¯Ö¢áKSg\÷UDb%¯ÃM!*¯ÖsMÇBãg…Gès­í5Ëy¨†¡¦':  &¸)¬ºq !iÏ?ZrÓNİ=¶9#t|Ï%ÿíÎğí/cD5˜4Š¤kôÓ ŞLß-ÇMÁnÄ œÎkqy’*âåÑôĞ‘ øz¬™İf Ãßé0SxÉ®ñÛ‹øÍÙ®©bîü¢ãWñ[%ı°}E!f(¶Is©4=¬êñoÑÂ*{*%Ê„z.J d¬æª„’hb	•E4›¨}  Êmnu€â© #`lgëiorı…Jğø0<»#ãëY{Ñ^hHğ Û’kƒ`E¬]=©"nÛ*l¤ÀòA¤s;,Ëú,¯¤NPYÛĞL¦Àõ<ÌÌ&¬:B g;5ßèN:÷î{JBÁHduR*Z!¨ëíe~‹tàC§¶è@LiÏ¢ÌQ6L{T«y„ ‚ğXËpARM\ _µæZ}x×ä~Ú`¨8²;ËCbBn÷øK´-.¾ç6™uıgçÌ’Öò$+OˆT ä:°´Œé0ò_ËJb^
D`wğéhxi®—ÙÒj!R ˜œº*-09v±S”'U‚Ù5Ñ_WkÊ5şVï{K!Lj—7ÈşüR€—†ti&€"|Û¼Ö¹İœÎ¾öTóh%S·vU…_H8A¤i×Î¤ºm †dluyZf›tÙİeOí˜‰mUhy¬ {NÚã7”wæ;¶c8jPPoI3eÙøQû»ä:DÕuqbWløEùµM8¬ì¸@6ï J$ß‡î¯R>clõÙmK×¥á’ß§o%G;ıŸ²y•ç3 Î×¥òáy!Äe)pç°8Âp›U4(Á_ënº4ù@ŞÂ&ı¤&¨ú.@$¢çaOMÙØM´nô#Ü¤Ÿ}Eç#X¨ßŒ}]I0•C~Ì}g²µ=/ĞQ¢2Œà@É»3 5Õôİïã€<¿µ.|4fOâÅÿ…oí}Buù)ÈdG!O9óÂ¬ááøè“´XÍkDrĞaÜùßËÚ¬f1ºrèÆ}ïuî-ìdJQkN§IËüÕGåºÙ7|?†Ø ÁŠö.À)kJ°HF!Ÿk%ÊäR)ôTKk^w®DÄtBşàÊl!åö‡3Tw=â~Š¿@ÕÛ¢ëìòHŒ^`ì1>Éğ*-#|°åƒÈ\M¦@KÂ˜)ì³ë!÷áE82m´•FÓğw”"&”@Ê(®mÛ –c‰lVfU,•(.{|a¥_èva1u´'Çp2a‹Wí¿Â2g@•aL(Ô1ìoÁ!l ²ÈÉáqC7ÆÑ7eAUxƒ¾Ül^¬hì §ÖAw…Ní_À¼oñM}ÃMmŞ%Û|
è	¸s­¢r9G.&®x6&
áúz<•w9²ÆE+ÌeUlqhëáÇw™^ŞGÅDÄbÀaiI©Eüyîf%pé¡ÄA®b ¬zQmòtÒe­—=zníµBq[¸Eçös?×WvÏàzÊ"VõyTH‹µ¿»:H2çm3êÂT, £âATvc|Å~Ä‡øÓGôôÀDõ€Zk-ßEï ¡F×Ô•óP#dàÚ*XÍ:	+'ÌGíjıUWmí;r-¤¯aäÎb ı"_2LÒÚİ(IÜïÎ<%uÃ^cÁ‚Ñİl]vOhŞ»C¬_’è0¡ÀeE£#ªeÆöUæÒÏw Î®
»î»!÷Î]p]aŸ†|ÄåcNƒßDm}â°¸$élqùòº8 *6$R@)‚-yş¾Lãj@Knçò¡)Jas8/``¤ùA÷ùeºRg¡ÀdìX{wÓo^NXÄÃìÖ§	z-â¼ÈpÿYp*_¨,LûhTe6p@/kê$¹¨ îÜö?ouÜQne^îzêıÆ_Û†`TMYDroaL(8ú|ÅÂ%<ÆtYAMœK›µ€Å!‹µQ&dixaF-QnyñÈJïÊ‡Ë~m5uwä÷±RÂåÈ›6Ù<à ¬÷©šãûlAtÜ"rß¬\6hkçjÌpeÜçÌHnZ h÷)[ÀEAvóË³Ğxr“lòqaA3 €¾˜\†§f]’Ÿ_|akD$ç¯~çŠ",+Qj{8êçŸ%;üIPQ34 ¨èpY6böW¡é¯koQtK, íQıü°€}èVŞ5ì¤^ÀİT:!En±ÃäáLÜ†"1#¯
jXk¶òĞûz±Io{e6' (#&‚w§áR¯L§¤hÅp}îÓ,ÖÎSJÃ¡ÂºT1ÒA}3ö,YŞğÄ$®ŠÌv ÚO¢I!¨b(Éf%“ûïWïÄ¡`<ÜúüÔ|€"Xe^Õ,1v"E.hr+*ûsG¡õ,÷ã»6,xÉÄã (¬#hïy¤r‹!ke‰D(îÆ9…8ºBÎ.cNkH»xnœ´ôg|bD?îZ$#ğS"V5Š"ö@J	8³œ³  ^Dm‚å.Xc}¿ëïló\2‘/~‘"Ëf E…„çÁ ¾LÄÅò’LC%òaö¯¦f•:†áßkëùRİUâjîç§ë§5dóùurNWİk(xO­¢„P\ëahC—2ç»a¨	 P$£RXg+×¼ƒ<‘[bß!Íéú'~½ææÚGT1JTâ,Lbh=bœES ÂvĞä|¹±áGË7dñŞZl¨÷ÌÉÕÂ{Ä‹a¸&¡l‚ñ½&{f?k*x, Ã <Bos‚ :Ú °ELµË^gsskß"íf÷€W9IDá~ôò;ª0†ƒ¸¢§"ğsòx[²{ÈJ4zdz8Æ©Ÿi9hnä-Ür»'wg¼•AîL•2¾Â¯¢ĞïB«`Ñ¡¡óá=-×gWuø3ôë„)ûí$æ¹ÜôîUÊatEÈ£}bnf{V-uÌSAEÙæh½m$ %8x I8 AÛ4õhÆüI_o_fàè²ÒÆ$(ò{’áZíf¦‰ %8pü3şn!Ít¼ÌM%€R XÂj&@ ƒ%¼à²1}yÅ}0´{å;JzN‰Yœ7†k“iŠ!½ºr˜hÚYiœXaúh-äù7êPŒãÀnÌd^oÈ<Læì¤M±N
<8aqä½mo'(q•Ä?È`z³ªgë]<trÿ‹;á¿ ğÆ:"òÒS&°HVE nà¨"!Â1U;òrfğie_ãl	õ°—fÛ_l*Èvae}u}—]#.ã?Á¶‡v[S"Nd‹o2#²{"Zp¬ÒÓ¬JIi| §äuşt|:°‰*º"ã4±†«~éÔn³írO®oËƒÚÄ,ªÖÀR;#p fÍ›N-|ÿyBÏü'ÇdxsÃmÒÃU0õB¹„c„!Úu¿§âoõ¸§‹Ö.1FŒ(ğ.*™* £ŠÎY° :66±ó+Öbw‚>¹¡ÃQã.³qt6M%qº6&¬*é ©A¦O-ÇdÁsqõÓ˜çPÊ#»|töXPï¡òCdM8%Ò*ı©¹drVÓÅêè~róx2~XÃ9NíDí|I/k¯’ı/ás‹Vö È+çb¢mÛKŞ:MÉàƒàÛ{FbUB#×ê×³O]®dÒÇ±uQğbIšn*pJê‚(¤#¶T oÓ~¥nM‡îm_\ÖæÍæÉğ\Û `	 €!eEovÏB9Pƒo3ÛhNğU%YR¢Ë»2›ª½`»:6ò‹Ï²eÅÍè”á“¼³nĞa«ËfíÇÁªİÍ·Í6ÊnÜıêÔ¡_IÉÙªcGtÊøˆìäÅ}×øGáó¢µ7±*@fÊè,I# t(.õ~#ì›àO\ ›3_ú&3k
”p¼*Ğ2‚Dt!­ıÉd‡o[)ÏQıkİé·¾MaÄñm«4nwñÓ·løs*õs¡BÔ+-L1b§S€Aƒ7k _oGmç—ˆ¤ >MEwócÑSí–„"öaé°¢:§cÀ,h}#½7;É†êßÜŸãk|ÑxpÂÎ\8YgHUR+’#@41BÚíPôv6GPº¿amsËE],§öàÓ|’7gÿ8h¢ a97•o`>b¤psıkgp‚md^B sìköÇ¡ŸcÑ“=EfRwÀNª9õÃÍH`	¡W( šVo³Ó/¿øv¬ Oecrx¬‹aa¸Šgá-<äèùFãÔÂu»‡.ÑO»t8¼áò&æ:¨(Â¾¹ê¨lÂ–jB¿õl}Rn×sp ½i2*Ë`a5dX I*˜Eè$Mí¦¤ƒ@¿â#_z1e\gñŞiåçUşuoÚbÒğÈ|<p,˜
FY]YOùóè! ~`à<§¡ã"YxŞ'.İºd¼¯ü¶·¬d-Qº4(^_ù·dM=~ "1$]2²N·vŞóŸ¤ñŞy™N÷6Âİ¨Mó™ß?ğÁ¥ÏÂ%ÂmR~Ìt 86/³ c¤ÅÎİ`NDâFéCğ-oÚM¿%H‡ú»6Ùâäg=ãŠIŒyD",4D
*ØYÆ@|}µN¨rÁö¼ôÒ}h„&òõKéwmyëÍŸyïOl]$E¨œË[=~y/2â½¦ÿï{Ëqwp	]-âR]q+"ìÒ}O¯oIˆ6dl5M€…:0Æ+t(Âg˜v­TÂø5Í¶ìX@mìHÅnh$YY"ı3i{zlÏ2nÏ`v½èlWƒ¡ö±\›5fÒgr|ı<Ä!GtxĞğ' kLO×N`ÔçlJ.Tä(È %c ¾qdĞ®\Ğ}2d*8z!A®æå—YùB[y‰Ğs-½De²<M~>êóˆmß$ç$4-Æû,J“®pÑÚÈ…a0{Kêyêı«¾ÆZimèí^îû€Á,¤”¨=ˆíe~c;­ñJÁ„cÅ29Õ$2±UUNjÊÔòØ@ÂÏ"aI3ú,1Kø#\Évâ‡hRçóYyéb$îœPÎ«¯l–—ˆ…ŸiŠ>î6ìp¥w7â—©ånëÑ¦bÆåÎe-(Äaœ­†äò<w”õï˜D%0^Î(k|YóÆnAJŸìR×átlaÅ¤ãÙzè%âtüèã%=f^ªhz$ºbJŒn@zİj’vxa„=û{uì]cOKf±<kÙœ!Ûñ(‹pæ÷d»m63jl{5®‡RÏ8F"ÃEL¢­ÊsˆÙR­‰ qÏ UÏşJÖx¸¥R½Ûy´Ñ“úÙĞÔgù^Ş|YøÄ–¼ÊêvR?3ÜpòNã#d×po(Î’¸l_¯?föşş×êØwíÆ•q8¤&i¿T˜`‹~H&„ugO×_ÇEZİ‹G•‘d”yšÓ¸z©ıå°0é#kÀTÀhg6]ma÷åHyÍ?3qsÌÆtÅWV8ä/ÙcNg ÁögP®>Eqëà @Ë€CP3ŸÏ8H
¤¤2Ä¹/İğó@€»’Lñ…D˜ ùSŒ!5pGĞ”D9+Ö[õêì:ŠwºCiMZU`¥g (¬01àyh ´Ø½Ê¬æ‰¼êæ` šÕâ¯ º-ìA	”|‚jPäw&ÓÖH)Q"ì-n¡ZE/Yuå£àaMºˆ‰#¨ü  0$êÂ†– dÄ”ìv ÿç¯.i3˜ñŒ)o€Ño©ÁÀ­äĞjsJxò®¯íiÂ  2ia¤xj0%·{I(ë×¡N"‚bghä9NÒıN1 çè¢Qƒye|6§¹À)zoJâ\?‚Æ’"*HÆ8rÍááó‰²R%g¬Âc…»*2b€Jø²ğ[Çrñù¸~	Ç¨À•8¯ jfwH­--Ç2P¦ynµ(~'PU¼Ğ¹şn,Î˜%·Ú!‡$òh4¹æ®ob…ƒ\&ˆµ4©Ï'B{Ÿmıí˜ã`ã¦«á/‡ôqÅA6é67DÍôâu
£2ê#Ã°ú¹ fïü`è.6{R5+}PjŸò@
*¥.å%ch‡bhÔ`;¼r}­ßøkWDĞş9©ì¼ÀPXËŞ³s2@NI~fŸ[zY`]2uuÉeAWcmED°—6à09¬b:èdM0¸µ¶bôd:wóò½§®@Ş`*D—`”?	6‚„"ÎFJF‘MÉuCCmLĞèoÔ¾Ég«a«9›øyc"[>ŠÏçÍ[±£$ ÚAF ĞûÄ{‰Ë§NH§:)ø ²dÍÒ ‹
&Nzay}ƒİXh;À~è>¬(P±¬0nV''È)ŠY:©ÈG¿hIK· 0"l F@éb(ø\ıê›x‡BÌGöH]iÇ?9¡1¤1*&³ğÀœ.TW(²Qm®=MpXºaÛw»úqí 
  R"i„)›Å"\Ø†éu.kˆ(\5­ŸÊMsÆ^"¢è#zĞÍş(`*l«l{çÃ
qŸc:ifÀ-4é{»êa{U¬¢‚" –1"A-˜]ç’zî	úDÂ-ï!br†U´ıÇv=`šá\GèkíÖFSÍÓií	ëÀU`¬WmH7†¶+•"Ç