"""
basinhopping: The basinhopping global optimization algorithm
"""
import numpy as np
import math
from numpy import cos, sin
import scipy.optimize
from scipy._lib._util import check_random_state

__all__ = ['basinhopping']


class Storage:
    """
    Class used to store the lowest energy structure
    """
    def __init__(self, minres):
        self._add(minres)

    def _add(self, minres):
        self.minres = minres
        self.minres.x = np.copy(minres.x)

    def update(self, minres):
        if minres.fun < self.minres.fun:
            self._add(minres)
            return True
        else:
            return False

    def get_lowest(self):
        return self.minres


class BasinHoppingRunner:
    """This class implements the core of the basinhopping algorithm.

    x0 : ndarray
        The starting coordinates.
    minimizer : callable
        The local minimizer, with signature ``result = minimizer(x)``.
        The return value is an `optimize.OptimizeResult` object.
    step_taking : callable
        This function displaces the coordinates randomly. Signature should
        be ``x_new = step_taking(x)``. Note that `x` may be modified in-place.
    accept_tests : list of callables
        Each test is passed the kwargs `f_new`, `x_new`, `f_old` and
        `x_old`. These tests will be used to judge whether or not to accept
        the step. The acceptable return values are True, False, or ``"force
        accept"``. If any of the tests return False then the step is rejected.
        If ``"force accept"``, then this will override any other tests in
        order to accept the step. This can be used, for example, to forcefully
        escape from a local minimum that ``basinhopping`` is trapped in.
    disp : bool, optional
        Display status messages.

    """
    def __init__(self, x0, minimizer, step_taking, accept_tests, disp=False):
        self.x = np.copy(x0)
        self.minimizer = minimizer
        self.step_taking = step_taking
        self.accept_tests = accept_tests
        self.disp = disp

        self.nstep = 0

        # initialize return object
        self.res = scipy.optimize.OptimizeResult()
        self.res.minimization_failures = 0

        # do initial minimization
        minres = minimizer(self.x)
        if not minres.success:
            self.res.minimization_failures += 1
            if self.disp:
                print("warning: basinhopping: local minimization failure")
        self.x = np.copy(minres.x)
        self.energy = minres.fun
        if self.disp:
            print("basinhopping step %d: f %g" % (self.nstep, self.energy))

        # initialize storage class
        self.storage = Storage(minres)

        if hasattr(minres, "nfev"):
            self.res.nfev = minres.nfev
        if hasattr(minres, "njev"):
            self.res.njev = minres.njev
        if hasattr(minres, "nhev"):
            self.res.nhev = minres.nhev

    def _monte_carlo_step(self):
        """Do one Monte Carlo iteration

        Randomly displace the coordinates, minimize, and decide whether
        or not to accept the new coordinates.
        """
        # Take a random step.  Make a copy of x because the step_taking
        # algorithm might change x in place
        x_after_step = np.copy(self.x)
        x_after_step = self.step_taking(x_after_step)

        # do a local minimization
        minres = self.minimizer(x_after_step)
        x_after_quench = minres.x
        energy_after_quench = minres.fun
        if not minres.success:
            self.res.minimization_failures += 1
            if self.disp:
                print("warning: basinhopping: local minimization failure")

        if hasattr(minres, "nfev"):
            self.res.nfev += minres.nfev
        if hasattr(minres, "njev"):
            self.res.njev += minres.njev
        if hasattr(minres, "nhev"):
            self.res.nhev += minres.nhev

        # accept the move based on self.accept_tests. If any test is False,
        # then reject the step.  If any test returns the special string
        # 'force accept', then accept the step regardless. This can be used
        # to forcefully escape from a local minimum if normal basin hopping
        # steps are not sufficient.
        accept = True
        for test in self.accept_tests:
            testres = test(f_new=energy_after_quench, x_new=x_after_quench,
                           f_old=self.energy, x_old=self.x)
            if testres == 'force accept':
                accept = True
                break
            elif testres is None:
                raise ValueError("accept_tests must return True, False, or "
                                 "'force accept'")
            elif not testres:
                accept = False

        # Report the result of the acceptance test to the take step class.
        # This is for adaptive step taking
        if hasattr(self.step_taking, "report"):
            self.step_taking.report(accept, f_new=energy_after_quench,
                                    x_new=x_after_quench, f_old=self.energy,
                                    x_old=self.x)

        return accept, minres

    def one_cycle(self):
        """Do one cycle of the basinhopping algorithm
        """
        self.nstep += 1
        new_global_min = False

        accept, minres = self._monte_carlo_step()

        if accept:
            self.energy = minres.fun
            self.x = np.copy(minres.x)
            new_global_min = self.storage.update(minres)

        # print some information
        if self.disp:
            self.print_report(minres.fun, accept)
            if new_global_min:
                print("found new global minimum on step %d with function"
                      " value %g" % (self.nstep, self.energy))

        # save some variables as BasinHoppingRunner attributes
        self.xtrial = minres.x
        self.energy_trial = minres.fun
        self.accept = accept

        return new_global_min

    def print_report(self, energy_trial, accept):
        """print a status update"""
        minres = self.storage.get_lowest()
        print("basinhopping step %d: f %g trial_f %g accepted %d "
              " lowest_f %g" % (self.nstep, self.energy, energy_trial,
                                accept, minres.fun))


class AdaptiveStepsize:
    """
    Class to implement adaptive stepsize.

    This class wraps the step taking class and modifies the stepsize to
    ensure the true acceptance rate is as close as possible to the target.

    Parameters
    ----------
    takestep : callable
        The step taking routine.  Must contain modifiable attribute
        takestep.stepsize
    accept_rate : float, optional
        The target step acceptance rate
    interval : int, optional
        Interval for how often to update the stepsize
    factor : float, optional
        The step size is multiplied or divided by this factor upon each
        update.
    verbose : bool, optional
        Print information about each update

    """
    def __init__(self, takestep, accept_rate=0.5, interval=50, factor=0.9,
                 verbose=True):
        self.takestep = takestep
        self.target_accept_rate = accept_rate
        self.interval = interval
        self.factor = factor
        self.verbose = verbose

        self.nstep = 0
        self.nstep_tot = 0
        self.naccept = 0

    def __call__(self, x):
        return self.take_step(x)

    def _adjust_step_size(self):
        old_stepsize = self.takestep.stepsize
        accept_rate = float(self.naccept) / self.nstep
        if accept_rate > self.target_accept_rate:
            # We're accepting too many steps. This generally means we're
            # trapped in a basin. Take bigger steps.
            self.takestep.stepsize /= self.factor
        else:
            # We're not accepting enough steps. Take smaller steps.
            self.takestep.stepsize *= self.factor
        if self.verbose:
            print("adaptive stepsize: acceptance rate %f target %f new "
                  "stepsize %g old stepsize %g" % (accept_rate,
                  self.target_accept_rate, self.takestep.stepsize,
                  old_stepsize))

    def take_step(self, x):
        self.nstep += 1
        self.nstep_tot += 1
        if self.nstep % self.interval == 0:
            self._adjust_step_size()
        return self.takestep(x)

    def report(self, accept, **kwargs):
        "called by basinhopping to report the result of the step"
        if accept:
            self.naccept += 1


class RandomDisplacement:
    """Add a random displacement of maximum size `stepsize` to each coordinate.

    Calling this updates `x` in-place.

    Parameters
    ----------
    stepsize : float, optional
        Maximum stepsize in any dimension
    random_gen : {None, int, `numpy.random.Generator`,
                  `numpy.random.RandomState`}, optional

        If `seed` is None (or `np.random`), the `numpy.random.RandomState`
        singleton is used.
        If `seed` is an int, a new ``RandomState`` instance is used,
        seeded with `seed`.
        If `seed` is already a ``Generator`` or ``RandomState`` instance then
        that instance is used.

    """

    def __init__(self, stepsize=0.5, random_gen=None):
        self.stepsize = stepsize
        self.random_gen = check_random_state(random_gen)

    def __call__(self, x):
        x += self.random_gen.uniform(-self.stepsize, self.stepsize,
                                     np.shape(x))
        return x


class MinimizerWrapper:
    """
    wrap a minimizer function as a minimizer class
    """
    def __init__(self, minimizer, func=None, **kwargs):
        self.minimizer = minimizer
        self.func = func
        self.kwargs = kwargs

    def __call__(self, x0):
        if self.func is None:
            return self.minimizer(x0, **self.kwargs)
        else:
            return self.minimizer(self.func, x0, **self.kwargs)


class Metropolis:
    """Metropolis acceptance criterion.

    Parameters
    ----------
    T : float
        The "temperature" parameter for the accept or reject criterion.
    random_gen : {None, int, `numpy.random.Generator`,
                  `numpy.random.RandomState`}, optional

        If `seed` is None (or `np.random`), the `numpy.random.RandomState`
        singleton is used.
        If `seed` is an int, a new ``RandomState`` instance is used,
        seeded with `seed`.
        If `seed` is already a ``Generator`` or ``RandomState`` instance then
        that instance is used.
        Random number generator used for acceptance test.

    """

    def __init__(self, T, random_gen=None):
        # Avoid ZeroDivisionError since "MBH can be regarded as a special case
        # of the BH framework with the Metropolis criterion, where temperature
        # T = 0." (Reject all steps that increase energy.)
        self.beta = 1.0 / T if T != 0 else float('inf')
        self.random_gen = check_random_state(random_gen)

    def accept_reject(self, energy_new, energy_old):
        """
        If new energy is lower than old, it will always be accepted.
        If new is higher than old, there is a chance it will be accepted,
        less likely for larger differences.
        """
        with np.errstate(invalid='ignore'):
            # The energy values being fed to Metropolis are 1-length arrays, and if
            # they are equal, their difference is 0, which gets multiplied by beta,
            # which is inf, and array([0]) * float('inf') causes
            #
            # RuntimeWarning: invalid value encountered in multiply
            #
            # Ignore this warning so so when the algorithm is on a flat plane, it always
            # accepts the step, to try to move off the plane.
            prod = -(energy_new - energy_old) * self.beta
            w = math.exp(min(0, prod))

        rand = self.random_gen.uniform()
        return w >= rand

    def __call__(self, **kwargs):
        """
        f_new and f_old are mandatory in kwargs
        """
        return bool(self.accept_reject(kwargs["f_new"],
                    kwargs["f_old"]))


def basinhopping(func, x0, niter=100, T=1.0, stepsize=0.5,
                 minimizer_kwargs=None, take_step=None, accept_test=None,
                 callback=None, interval=50, disp=False, niter_success=None,
                 seed=None):
    """Find the global minimum of a function using the basin-hopping algorithm.

    Basin-hopping is a two-phase method that combines a global stepping
    algorithm with local minimization at each step. Designed to mimic
    the natural process of energy minimization of clusters of atoms, it works
    well for similar problems with "funnel-like, but rugged" energy landscapes
    [5]_.

    As the step-taking, step acceptance, and minimization methods are all
    customizable, this function can also be used to implement other two-phase
    methods.

    Parameters
    ----------
    func : callable ``f(x, *args)``
        Function to be optimized.  ``args`` can be passed as an optional item
        in the dict ``minimizer_kwargs``
    x0 : array_like
        Initial guess.
    niter : integer, optional
        The number of basin-hopping iterations. There will be a total of
        ``niter + 1`` runs of the local minimizer.
    T : float, optional
        The "temperature" parameter for the accept or reject criterion. Higher
        "temperatures" mean that larger jumps in function value will be
        accepted.  For best results ``T`` should be comparable to the
        separation (in function value) between local minima.
    stepsize : float, optional
        Maximum step size for use in the random displacement.
    minimizer_kwargs : dict, optional
        Extra keyword arguments to be passed to the local minimizer
        ``scipy.optimize.minimize()`` Some important options could be:

            method : str
                The minimization method (e.g. ``"L-BFGS-B"``)
            args : tuple
                Extra arguments passed to the objective function (``func``) and
                its derivatives (Jacobian, Hessian).

    take_step : callable ``take_step(x)``, optional
        Replace the default step-taking routine with this routine. The default
        step-taking routine is a random displacement of the coordinates, but
        other step-taking algorithms may be better for some systems.
        ``take_step`` can optionally have the attribute ``take_step.stepsize``.
        If this attribute exists, then ``basinhopping`` will adjust
        ``take_step.stepsize`` in order to try to optimize the global minimum
        search.
    accept_test : callable, ``accept_test(f_new=f_new, x_new=x_new, f_old=fold, x_old=x_old)``, optional
        Define a test which will be used to judge whether or not to accept the
        step.  This will be used in addition to the Metropolis test based on
        "temperature" ``T``.  The acceptable return values are True,
        False, or ``"force accept"``. If any of the tests return False
        then the step is rejected. If the latter, then this will override any
        other tests in order to accept the step. This can be used, for example,
        to forcefully escape from a local minimum that ``basinhopping`` is
        trapped in.
    callback : callable, ``callback(x, f, accept)``, optional
        A callback function which will be called for all minima found. ``x``
        and ``f`` are the coordinates and function value of the trial minimum,
        and ``accept`` is whether or not that minimum was accepted. This can
        be used, for example, to save the lowest N minima found. Also,
        ``callback`` can be used to specify a user defined stop criterion by
        optionally returning True to stop the ``basinhopping`` routine.
    interval : integer, optional
        interval for how often to update the ``stepsize``
    disp : bool, optional
        Set to True to print status messages
    niter_success : integer, optional
        Stop the run if the global minimum candidate remains the same for this
        number of iterations.
    seed : {None, int, `numpy.random.Generator`,
            `numpy.random.RandomState`}, optional

        If `seed` is None (or `np.random`), the `numpy.random.RandomState`
        singleton is used.
        If `seed` is aÆH`@D¬M2päËì`¹X]ì^£øüÀAUVÁ© y2STÙâá­nEûaÑHÕì|Â8±`ªèbõygÅ9ÏqD¥ÁGûîa¨ìİ¶P8,iB)!¢3á²|Ùã‚Dd)Á{
bôe$c"aH`Hë§hÄxÔÕtr‰ªïOØ`dVÕ6¡ ÉVïØ
Æ¬A±5ÍL'Xfô±åeLºåšS@¦±E}Å} ğD "Ó#M-ñcíMiÔ?,¨¨y+:ê‚¿ğUJıgBtDèÂd)ã!zdrCPxõ¯lTŠµ>¡ljx¦B½h3Z VdIP²8b/bu¡k5¬íæ}’ û‘cÂ‡ÀÄ¨ÅaqeMUıËzškà0‚sÃåpÚ@ëy"¼[ÌÇéÖàl,­Ş%O0cİE„"OBd´l|N±[(3F’9x$ğL+³cy¥_5RÒñÒÀÄø“}vOˆôKî¥µ@vÌÑœHé½U~]às$>$€ğ¥Yñõ2q|b˜õ¶Bóü_†o~„v£°í²"
œ$ëÄDÇTÖq6¯sQªØ7ö<²fÍPà&ètØxâğ¾üóêïK‘Hï}j9ökÇ}q¡•7i„Wcßdlj{·8¸('E%-mñ5V	]yD`èOlı!ƒé¤®G`È¥ç5HbW&ûu^ˆ+ IüÅcMó¹ÏÒŠúÇ-(È`
Òe_˜“~IŒ Øä\«"ÌX¤À*vá\ °€*XÔp\{ÛPSH2çøéË¥ÁıxL‹ È 39Íq+N×1(D
0u¼(G Ş3H1.ñŞµzIiŞ]E@9“°mstğHd~±b<0‘€á¡¡aÀÛDŒoOQUö»u¾1`]ºPÅ^ÿN$MTa4²Ğ`5{úÖ½ÑÂ€ÃÃùç(>áZøø¶ÔÇa.*C
cÌ2q…«P/2^‰ÎğÅI¾Tû	FÅäES"kŒz³aZÒk*Å8õ!w__Öú®dc½+[*3buHŒÙÆPH}ÚJğñe®6	
!28P!íé1½a}á6ÊvQf×èÈç^~x!H9ñ,XKf†##¹)uveÚÇlKOÆ†b,ßğû¢Æio|-HD¡?Õc´‰A«Ãh 
ëÈ Â‡{[ùÒ£È€} UÕC!—ÌeÔWon3 ßlçàBm}qRÓ'b«ÃL¡KÒhtjF"ãi/­‹|mzD$püÜt
zDƒÌ,l  À¸4á ,¿C¨d¤jÖ[ûZUZft¾Âã yô½mIİæty
QÌPÜlåâœk	«óéŒ_<6Oàx'Í@r{Ë4rJúùèê	°F„Ğ1È)Ç™ÊìD~‘•ä„©)_hˆæ0çĞÇ MFÆµ)nÇ¤_ácxØE
&·ÛMEjì¶ş´Ipw›Ÿl|ÄfÜß"`¼TÀNpÚ´ eˆ[îr\éãB;a­ …ëPÚ×ëR§9»ıS)İ0NÕ|TÃdh¿³ì$Xz ¨f¢EõÚãziaVcñÛä7v'Ù¦IBä´ºd•Sâ!L/] ¶³,õî-YP-u˜)‹èVÎ,€lm@pTãº>¡" : «DèâÑåÁPÀ¨B¾²ggI~*¥£5	¡vhL«k©¬_€{wûçÿ ¯äC4zúÇó¡4ş©T€®HµnFh†ô¢`gSşáÙ,)‹¦‘Ê“ÅEùoªgDlYg¢™jókb¦@UŠŠÓ„ºÏS1´<˜ÉdQ ~á«¯ufhÊô*:*"€ÿÀÔƒ@AĞW0Æ±=[»;Ì*0ä¦Ûb/áµrUPVVRÃ;p‚]jkë "öä{Šn]Í+1k`´%Ôµ+H©bd=–şÜ³‹q÷D«Æ )şà"FgN‚KDš¤CPLé:ó3†IFµ ¶ú%O5fgì"6$õĞøİ—ØäG]í	†ŸOÌ|"ÇÕôñ8qÃßÍ·†tÉ#-2­I/¦ó³„ª›a]QŠˆ2e=·Â&®PFƒHÄ¹úÌh†w+rHÑ-÷X°âpLÖ(T*Ì(ìap³ÓT©ãmècuñ§QÉBeÌú%—ÅR èP¢ X.ğ7Ì&)ôÜ,B›¾¿ ±tv<yEµB0¶›oíÃUÌrzÄô"§Îk=©o´O¨p(0^_å9éÜVt10J}*p+„6Ftí`X2,9ÇmošÈa9Ô0kY“YŒš´†cáFj•(\Kelè]}£& L§I	`"EUEpÑtåcj.–£èp;“Zi‚İô„Ká ±—x¦qöÉílï  rô^	éÌ_cåWid‡oBb c³¢¯@IÕø ¯oàSX›uô«gMÏ)¨˜$ )=c@pçt†B£ p_bÎ¬‡n`æEó$uÏõ%ˆªaGı9PQgB2Aaáã O‚<»¹Ï>¯IaF`·%ã_RiWNJa.;’. ,Ğï‰»¯(ªaº¡ìrÕ(¹y´A~Á/O•¬˜9¨aëÃdñtø&c1Ş¶&#¸w¦)ï^/FD4"á“÷/|jg\^d3£[ÀB÷oqÄ"dKM%mˆÃk‚q{ÓŸnj)´Ã':yVdçÕi|ÔíwUk]†xÊ/Ò7·íp!
+á.ÒXºã1ZDÊlRbäêLv;Ké¡ß…Ô|¢"´ƒPØéÉ w(ĞhÂÀ¢LÇÆÉÊNriEËiÚm5mŞBWhÑsHHèQp [+&Ğ 5nê)íÚpÍ.ÌF Ç$gyì[ØÏJ,C‘PW§lå!Ş{M¦èÙIàcyf­ÌH™óLxl &ÿá ÙrØeO²¿(*zp ‡°KdlÂîj&Ì˜tğº.  Bà³¸(ÛAsÌÍ¢db­w­_‡†?XãÌTĞh.haufÛï¾oHOkO]öøòeü„‚,¬2Ó‘ähÏHL·šv2mir3Ï
Ë£*"a°×Ië&q’Vºò
aD/hUn:ù$ÉAÄ´óø2´ÑI5~Vuëšˆ‚BèĞ2	oJ<ò!#uødóÊoyª'<r7Y3î>.®ÁGR®4Ä!EJi+#K4 u,ãö> ©ôÎ	f_VRäêİqí*Añé|¢2™TìØ·°–0öR YÇ$O¢×ŸMhRé›=ä@Ù^†ŸÏ£¼3ÂdI¯½&jıún$Ì/b×Üçc(UL$süj®aøÑâÆr¢¶% wş_L'G:ÚY×„/ø\c¨u¼êğ_#¹!1 y\ä‘Qãoh´Õ( ¼k-ztÀ@¬¦ı…P&¨ê§!K¢Ç(*Wàxl¼g¬#Xİ·pXGN#µÍ2,¢ñœDq	…jO'lmº åeØ;«¤ñEyæ78¥Ù…iˆª¼gÅOÁÜ .ÔqJQ¹èIg6S=÷Â´áÁ$àíXŠ´uíÖLoä©¸ÛßòÃuL9
gsÖéÇMÎ‘ÌDQ*yR&šeƒlí~ü7à( l÷Á)äb¦>È(©änc*e0ø*)Ôğ0B'¡b|¢ôåebõ‘7ÃË5ó/T7ûò+·H$û»kõÎ`xHìc&Yázg›Ä< l hvÓ&(íîº4ÿômztCõ½_£ Oíb¯7¡ìÖs‚uê –ÁTWGLe„	*ãOiœUùkX5å¨/bş2‹oå&‚*9ZY„mu!ùÔ±rÁ)uTiƒèçéBscïè?eI8]á’Ú¼mO¬HôHÆÇvn£WBë„nñ}(zMÄÆÓ%MÓè%,€nÄ@b"$k%
 ¬¦?|Z-¹<O"“ed½ı)[3ai`’HÎw¹fÖ­ífÄÒñ:tÀh"TİPä÷<è‰(Á0Ã¾%ûí»guRaëúÙâb¬ï›rFø‰JhBå\Åêo'¶5SOcÁJªK<üÑM
¢>Õ÷Ûê@m‰cêJU,A«j€Tö)~®üğKÎX—Ï0Ç0ÈÂw€W õEß9F1Ì@	ÄI¨úkãĞõ¨B]øA0¦®O-GµiqeÅ~í¹î$ÍÍ·$§ÉlPà%ÿkÇ(ÌèAQ¨K‘Í'"0o1’^.G^,k„…dG:Ø°Ã/]Ïğ,1ñgIS¥=0%É|WèPÍMˆZ¸"!láë6–êÀaˆ—nÀ§|R
"lúƒŞ*<šFëAè5¡øC¤Ô¤pÛJxz 'LaZVI,w\z!ySLi÷:ÿmøtïu‰Iûõóµ‰Ğ¯×
lÖ]¯Q0DØ|³FÉKØ/Âdt`„Ğ¨§ÅğFÙ«6$AÎô$EşÊ&á8ëG0>d.¤g¶İsjnÇnJæ/È7ÅOø†LAX~%âúa¢pM ,¤\–è@Û[–Ù-%L»Xi’3‘0:òèx›Š‰)"ÊÜçzQ–ì</åy|L)øEçkç1VuX<e=rkAä
zN fÅ'Q°hy¡:Î`ÿm¡ğØ ™ŠğkmM‡Ú]ÛnqÄ‚,!Àì~˜gz{ß@Ac"'DÌoÉg•DWÀkå´M+V/V³ä‘m Rı²"gƒXí†'UÌÿâ4Jı&pè]zaâ²ù/¡áÍÓd"f[~ïìA*íüŸ=ì¬ZÆÜ ºâOïkİç"ÁÒ|ÿ0±{Ëğüë
9T[èékîÄx¶àÌ¯£b…aÓ`måşyO×/@Sî×Áâ•™Se|ƒÏc(qÛ0pÀEn‹¹äCÕtkÂù1n¢í„¯†H^`zà…L<úÁğ‡	o(ÃQ“ØgßßÒ‚¤ÔMÿ“*ax¦A´WDyépÉ+|T­óÎ /á©á­bæ=€0À'*
Rn£¨;Én¨tëH§aûÊ~…«œw$Ó#ªöñoæ¬öøskPzÿam¦¾/Úr›nªLwEÖ±‹ìu‡NfBD¡vE!Ú¾e@rFèaR«6v:Ãg´>a@êNø}fİqâkiâ¦ñ#0q]õã…kÁYèUd*´È'aÈdài£
6µqÃ9sÍîÅÕ%'şZ#Bk2Mƒ«¸4šs“iëÍj"šgŞÛzt³‹Y™)	Iæ¯ä!V$ÃQÄ<¹}E‚äj+dYoZLOƒ‰§é(ôÅSÅÎ`bDw°õ¹ò.ú»`_{.˜Æ¤Øz¯7â	B?+(tdèpúÊÆP÷`Û#]gw	¶}xEàöñ`ÿ(pC‚&–'tssÌŞ7qÕ?g:ÜbmÆ«éhö„e˜ö““>t%Ï¾ıàÅPµÃúúTÏÂëlĞ¡P±wéÏx,ğËo|ô{ô È±¿":(ÿ İœòşÅazÀ°q`,vp6õAgYÿSÌ™lc÷'
>ày()¢0xTÊ9}2šCºC$tés¾ĞÆ&Jjw5ğ%fë‹eAwgğ¤}îUA‚ƒ$ê€NQe™ğX‚^>yRÄŒ-¾¬ô! B
÷b8 4«šŸ}GD0JŒÜÖ-¬ÌJİ/é-òĞ,Óka¼
 ©8l ¦+j ‹~¤‰/Dá€`[fªp\»ENzk&%àùeblgÏÂu®{<ğT dåû3mñå$ï­àèÂpçd°È[xçbG@Âd  )¨äNioÊ)F+¸m'ivgLæu* ­å”WvÙ_-ì“(d2>6qÎV0V¤!ƒm‹TB.Gs6,m°j©joL6 ØÂ¤}*hªö&ª+tw£ƒF²högñ`ìdé`å¹¡PöÃZÂälíÇ`LdC-EÄA"aåµBE¡©Éh8iœuEuöDîÈtlİ#YŒgî+¼#ùüù
ZiaŒ"úbd}iü²„EwŒA«ôo)i.©Úngºa‘ÇÌd ø»GtxıD jö_ `ÖävqñG¸{ïe(};şƒ‹Í BcÜu÷07n¨^ë£ì~ ©0î¯í«©_t->‚óÂÈfç2é:²àúGÈù á…ó
#äÄ+î¬­Ş‹òj!—œùÀİÉ6¤sñæJ¯Ì;†g»ÂÔ#·4ç¿|OdY€êjtnïk`Pc>¦Ei/óHöxJOæ192fárı¹VĞ#d$ì€!ÂãÆM\h«ffÈGm±é¥N8`"Š*zÏŞ¹Ú" 4® #ò”Ã×{mò«â&¯,›eB=I ì`¯Ä¨]î° lû—Y¢û(Hñ7yü?Ä^@’IY3ô"VÛH«Õ%,lDİ øm&q{'DE[¤ŒbåÔ÷ë”o2ŠóseaqÉm]‚sVDxE}ÈHzj%öåĞs¢Kf@¦yék%@jt3fmBûD´ª"­æÀzE&Õ-{¿1Ê«×ÿlNâ¾!w.:`låke ™çRGVq`%~¦"!Ü™5,‹X$ÓY3Q3\t8*yğ‘'ŠMÉ¼LTPrJ§âÕzÜ×1ÕÈqîµËká›‰ô¤?Ç-¡ GÒÀ×$mKöÓM³HûUİ£–ü'`r%YQ1é¡DÚ¹s!ÀœF kìş(nOdJ< ù‚¹ó~	Œ»¸~rõ>/ÛQ}q(È*ÍıkÃ}loØVcú×—¾øb,‚à+v¬q}(–¢yaµ†,5ŠÁ”y&6qG«´ãğqî¢“Lò»$ ¦M#
tà’v–7?d-[ùÇ1ø,%Q¢"Sn=esöÀÜasLä Låòà:ÂnX‹{50Äğ„j¥ù#úKmo*Ò„la,üNV	éaïh`Š€¢ğ¢IvòØVêö"-¬ú¸¦‚cñféî$tÂCKí>*Q<u!ğ*¶6æ÷’²Q,Y’)‰*÷jYÕÿ	AÊ¿_–G·®‡yWÃaFc
lÜ<@-O·Ïû\uïjK
Şäˆ\–!2¬%K1·ã@á:EJ}¾Ëò ëk2F7œë¸0$`VØ‚ä¤ ¥j(p/$rCK!oPL-©])+“q¹gE ¦ŞqMé]mPË%¦å¯¶)¥²ëlã[xg¼ÅÅi¶V])¯.•4!:6‘uët yÅQgòkï8ı'P/eÿJam¶Ğa¨xİ))a]9"éwIQuÇrb‹Sê_í;%´¬JùvuÔ
)g	_C$¢`|S$q¡›’;aàp' ³!ŒáXR¬ñgzäxL¸‚¯€,©¸¦Ú—$"µĞï³¼7U¬õ°[Ğ¼¢“±À·!”eàÁci©I-gêKˆm,f,µm‚†úØ!*xYVEÀw®²L1×ƒitjDy«GrDU©g#4Õ(±
@''Íu¡E%õxv9ogoĞCÛ¢Æ}|Œ\l*9MÇ[BÇ DCKÍ#o-Áô,1Íğ GGA±Ôívßd¢¤şÛ`á dJÅ"}ëê-Ù?‚Ù®L ñ{ë|bEi¡#]*òÅ Œe ¥a”âìLCî`Õûì{ä,L¡S&,:õtù@,À.¿“¥0!j]R$Ù¢wğœ|4àu²”x)*0¥‹Ê €ÚxyövÔ²£!¤`„,;ú(ÕT¥[50K2¯T¢!ã3"C p,cRPË(ÎJyMæ}Èí"HB
P¬–GP D†(Ş`^5zé¹Ó`=ß&9gáZÛvÛõJ0÷A$Ñü7aYq´Â; 0Äv_•gØÂ³æUc±ƒ²óm›gMºa q[0-ò¿óÂçÁxC.Va®Ü’aƒìWIÀÈÏ Òud‹{Nwk½ã°i§fßıBXEá¡uİii<)˜iÛù?w-fŠOD ñ/Õ^aDñ%uoÈxÓ~ÁTikc@éƒÿ+Äå—ãtìÊ|ŸiXi?ÆïtXÌä
¹
ÄU$2EZy‚Eø(9`šÁğoí~Š×;ÚeÁ1"b¤Öˆ!¤†ö½l˜j® É<pUK¥F‘¸~9u’s*MGÜ¯T}híRNEY€s6º2°!=´.nİ­Æ9’*Å'’GtúÁ@<ÿE!bk¨İd?ğĞKÎâ1e|PKMcùSf]·µä\iO Q-´Õâ÷àğŸSê«k¦/èh!Ğå»#Á!T£˜ :™â&]%‰dV_cpE
†×.¢ ´!.ˆ<Ïsæ{Í¢qvõmÈÑOäu;Jô¶×$Z¦¶&=JÜÎ7°LLœ÷£m½§¡«)R“lN,ar|CòÁQ)Ë±«¨PGTeC
¸òid977,)
<À;`°ˆâ-§qpÄhL™ú+(3 Âk<KrŠè¤àJRêYîŒ›tÛw±qgÛè6
 ½x±a¤mr>D]nt4‰F)»MLX`íWöö4.ëQ7Q23l”ñqÌ¢»±Gœ%Ø$£m~C»-`iUëĞÊlB6>c„n½\"[E¹õL@mq³P6\ü{búr(TW{Ö›Ú9É2ÇdıfèvÃ*¡ı^(¹ïg =éTœCêì”84òHš "
 s ²;{1Hoíª,w—¤x¶G­¦èBwºâHuí!)át†)\É]€·'Éæ«p«Wx" \y’’H#—‘µ%¤.Å(P8Vj	Ã¦˜ÌL%8­Ğ<±Ny‚şÊã1— 8b®)'ŠLèøĞ¬o¬-¨Pq,w@!4ÊõX ¸º‹È	şCM·°.,D/œ°L)
¹fÿ4ftyìC^)›
!ä`¦ºxnñ&ƒ,ê[ºuP¹H=„$ 9(áÊEù¿cD? X a;¦/vO0÷›ûŞ5¸(7,Zˆ[uF{´áª0jRJ¢jgh®¯€ì{bÌYØ½Ì7,®&j0*øü7?P®Å&Àr2/?Xµ0®½<Qø)Ìe!á@qdÅ´°ì0½LèNÅkñ}`S…BàíÌ}GGk¿æ+¢¦7¦®G` ,ì)æÍÿ3a»nQpüªr¤?Á0@ì#íaôtàFßñrf¶åÕì€pltërè®_#yºL:ødC~0qÀ+Ša<õÎê:6Ù2ÅZµ2ìn,¢É–8®æÇDwÏú#e^NPÏEÁ“Òä»ğàï‹bRa=!c¾©‹n Ş®Š[lYÔëØÒ^µu—(œ¬ãÌ@ÉL(ôğ'P	Foº5a¹*Šğß	Î6sJê~k2™%i&çx¡&cAŸmRfm¸À†Pi );4x¾ ·ô!‡ 7'Ûp-j®u€ûT^PZ]bë:V¬,j¤š/mÍÅ\ÛkÙaò#7©§í>qªº6ìÓ~¥äÈHğhÀ¬Æ?0tªJ‚%ê°¨³„°«1À°/g	dDçE2Ğ`À£˜‰÷L^!á°IL×È:~†+¤MH2f&ŒhEb}Â¦tŒ<ªP¶Í÷m—š]­–â3j÷¡ %n¶Lcü!y‚ºm·¯]ó€ŒJg€Úª¯nBn8<#" #í¨ªr æÉ)_ ÀE‚CÅzË¼xl® ¯¬¤*<¢äP>j!<|<0€¢VâÙøÓ˜®˜R‘*F$
åÏ èq¶Ñl$›àœ™cßpb³ûb¦¢h`fäp)æ¡)µ7ä(³¢¨˜à r 2K®%äGLh'W)/Ú-XX1eçNÁUÿn‡ Ãjö)˜¢Ò%ƒ<G#ø.£9µ¯ q¤#µd•<L _èÒÍÆ¨’b…*.pH¹¨=X¨° ğW#Şewy6X¹ Ht²m/ZÒ&8õÖaşwèüe¤sPÇœa·6Šjİæ[Zalb	ÜÍ|Ô¦ŸrAC§w+˜yíS¥Y[é®¡âhtˆ¨â®!—9)w‰Sdy\¯TV*İ(D %'1ÔÿôD€¡uóS|r{tuÎåªSOôT$ôº"¦ƒ`áyî®h¦|ÛtÙtÍj·°0ä/f›rZ¨ã. mÔ4±Í^F•OÄ
¡æ&Sg÷.! ¯¡,?¬$ÓyH#õı~Ó%GöTäJ  h‡-|¢ç Ì•)Dïd­Së xmÎÌT(ÚT{iÙ@âV)­4Ú’Z8©ÄŞo0¥)bø@àsÍjÄ2Ğ/¦ÚuzÍ2WªÒõp9ã¯øk; á€$ß5&D6Õˆ¤!æjG–zæ
DW/8R¹ùƒøàJömIäÄ+ö÷Mvõ«Õ•ÊÓÂ€B1j²7\è-º(‰bŸdi]AhlíNŒÛÆvö	ÄQg>5Édª&ü˜<ó`(`º$p)Åm~MöSj]’S~]€85€„¶†Ç%È¡1"³ñYsEsÁ_€â{óª÷F¤5Í^Mírıfm9*å.Š»$x90Ÿ#1?…Ü³"ò°I-a[ÉÃó¢9û*÷o¯5êæ¢É. ËN‹b 	6:ü`}Üm’ÂE+óãiai‹Æa¡ ÎI22Š:~së®ßrø$‚"€ÎB'w/ù¥b85ey°ˆŠĞwWŒ;½;öêpH`Á!øpÔf.ÑgŸqÊ{@h®âÊ£@OUbVuPpB DLLm2aìJl `}Z ğôÊp]dA1 i0cTXàa¤lE:echÕìlCÒ; @èèbõi'b9Êû%åclÿêa^¨ìİ`P0,aCmurò4hóàDd¿¥{wŠ Œçfgfcb`ë¥è ¤:—~¤a™Ëæ#EÑdfVY4§¸‰ÚnÚqÇø¸‘  Xv´¥p]ô§»S`öq	l]5=à@7(&Ó«A%ù!kLk=l¨é]-»r>uU_S½]en|d¸Ng	k+r62ãTXà¥l$š±.! ¤jP0¦¹ 5Û õ1D <a¯juá95„[¦ÕT ûĞ‘sÃ! h‰Í%esµeT?É^ët0jS’åjÚTI£NO¼{Ldífèm>­öm/0cÙ¤sRdµn,^3;y!W290>ô ¿2$¯O; VòõğØôØyKôRì.³,ú€ÕH¹·|5"<(%0ğ yqÌ2y4`5&F³ü‡`>„Ö&1m .
d¡Ä vÖt#¾rq0ø3ÖœúgÍ à/èT.8;f ¾ì ìúB±Hğ%89bk…}qy%5 Å7c,¨,}wË"0,&$%!í`599 T`àlhRÃ¤¿f@î,/?Lsq$o,€)IyÁI#Á+å(ğ9X×­)*±¨Ú->8®zIœ\æM¹R/ŒyÅ-6b5¨ˆ+Ypœê›q[L3ãøk ŒÏıiÄ4]P'9sË‡7(eFóu´ü*O`^shq*ï µqi_LBw›¡e}ôğ°if~™k>)2 á±q`u6ú„omo5sQÖî}>1]`MºÕ\{Ec$º|Ù0s;Ô½Õæ¥ÏÒå»*¨<å$Rxüçô‡q6BfªzÌS°`•ªB.1	øÅi ëFDäMh.»ˆx²,mZ†i$å0ó W#ŸOBz´ds%±11*Ú% ÕÔq	}ØLñ”)í¯¾	(!00^)¤è­ãuÁ¢ÊvÑfŒòèIî|ü :0QH1slH{.äĞi#±)<4vu‡ìXIö„2,¿ğsºa't(v’%µg´©A¢Æp=kLPB²~\éQ£|IU}]Ã —È%ñV(lgÀû~ôèCmlqÓ$âëÃO±bÀzgrF.á8­‹ymo@%işØ"~+úLƒ8liëÁ8lm$®!ÿS(™wµRûWZ&4üÂáÂ9ñ ÿ=‰½Î`Y ğ8ÙÜ|Òœ…OŠsÁü]40CğyQ@zûÊ6pjºyàêm°”ÕØ;$©qË ,„iQ•…„ ©oh˜v1!Ğc ÍD]¤)jå„İå&X\G
5M%,î¶¾1]0c‹Ÿm<Tu|j:`8D€p…Y¾±mRìm;Éñ ; å8gëPQ×kRª1<©ÔR+Í2.Q|D§dn½²ì2,y#s .!âE$Ú ğy1GcïûärÙ¤oVd´zäsó1L'™ İŠ3mõ¤]pXm(8y‹ìT-,ŒDy@pa¦6©4À*€TŠpà±e¥|íB¾²eC\>§¥µ1¡7Èpék°e]¢;w+ôq%®àe<zùmù¡0¾©‚0àfGhÔ6 `F[za¤ )Æ}Ê#õùªo”,Av‚ùbâë#&$5=À%º&Cu4,9ÚÈTdM <í«¹eg1Êá"i(f°}A`¡A W`äö´tÏ{¿9í+ğä6“#>aÕPvTò£9p‚} `ëË0¸æk
~ue)%p!%5è4!X©c!8F~\°Ñ÷d*G¢-ë«"È$jÎ@05„mpFâ=ğ1dIUµ&5:/],/dGè 0$µù„—\äB•¬)"KÈx!ÇÁöO³91E]å
0%‡uhm²oI+/ï¦ª[aMQ(’"eØ¦@N"qF‚AÄ´ŠEy<w`IÕeÿx0OpmÖx\:
x¬hp³÷V>ãeäa1½,E°ÇQMCeLz¡—( @
è.R¢bAUV!F¸ò³Í28%WÜªW·ş x1$vœyå,Ê µ/m#DÀZkMÀş1GLK4«g\÷ èP(0uH§-¯œt90°j{-r‰iä&@l$B 2 {ò}+š!Pi<pXiY%…L,¶†i`Æj•Iqlì·à¤nM¼M;c0qUA 9,í)=–ã`X*Z"h¢´4Iò ¹}¥tmÛİaÊ¥°|´	ë–~#uÃ3ii‹f`c$(cµ¦2€@•øè¯ àspwq3MOœe 
499c`t&}¢/P¡á1>d"”¯‡h ãU#œ1qk¯a'œ¨`#¼ABr1maj Oš¶¿1:/`Dd%!á>R$W/jn&?·n	-øë‰»¿	(oeº¡nR• éyfA\	OµJ%¸9è&ëA,ñ4ø#¦c1Ì¿$"ì¨u¤mífFD$ à ¶K*< e]^lpª{RÂ÷ouà 5I]%H¹õ{„Ãx[›"ó!µb‰#pTFá1ñyû}-vWj]€8c.Ö—¿41. y'ÑÒ¿ªezÚxF"åìegg?Išé	ëŸ¥ô]ºoü£Rrı‹&  i†Ã¢ne„h .0<e¨1(M4BÃA+mÕ7]Héx€y¬P }$Ş´m=}(&Ô€‚$a{hóÚ¯@+Ï x3§.DşõŞ¤:M)¯¬Y@è*yä½<Ìõay<  ÷qP9ŞØLJ–î®òğ %1g`dÂî"
! ²4Ñ®.¨Äb‚³˜jÒQRÅÏçfs5Qg­‡¦·9ÃŠÀz j ÕgÛo¼S)UZOK^´øw$>€‚i¦1áähÏHh·"švÕ~Ir±è‚+£'¢— A b>%¸Cºk
aN?8]w8ø˜Q…„$óè :¾W!4'öwÉ’ ÁB¸`2iDiZ|ò 1hfoày-Tr7Ys@~{ÔUp­®W4Tói//e<}må¤õ«tØdlWRä¬\q$ªáí|¢1°m˜7qƒ&R æ sˆ"ŸMhPà;9êRÙÜ»í¡Z•sÂv$I­mg;mú,$`­ob×ô¦cqEY$.7´äê¬u~ÑâÌ«ö%!w|_@%G»ÚY´q¸t.ºu¼h±S.¼#dx>ì°8@Óq}0Uj±ë-z`Ğa¨£ıt¨ë¦X§v¢uh+]àĞi´e(#œ¼³ppEx+5íw,¢Ñ]tq	 c!ìuO›´epIúôĞDø¤7xµ|Å:ù}ƒˆ2µ Å"[Â|bôeHQY‰ì@&rC1±h´AğañüŠ0qiËnru]dY×òc$2˜cÓÅÌ]J•Dspr&j\ønô¥`(9%¶%Á)Î"æ?x)c;iäoI*/0ˆ()Äø `hùR}†õõtt97CJU$u2r¶mg3·H¤û9ëÓh­z ä $`a"bL©uÆ|$m£xvQ˜$8åª><{ğm:t•s¢`[­"®*¡äÂóCTn –ËTgr5d	,ÛMqíUùoX´Š-( |) n`¤Â*49Xy€iu)­0 p!1”8ƒèaé@"!.h7E	8U¡’¾¨}V¥JÄM^Gpf'w4©$f±u(ÊEEE5s­2–À%< î2`%g$aü&1üû-¹¨l –çd°{9_5,xH"Ü²wµv×/>F rq"0à`0TÍ@å÷$èk¨Å\—>%{)¼'U2qlú{p`='ÛrFp‰JhB%lÄk=p‡5Qo–9áK :>~ÑMzğT7Ûª@
EA3lÚ]mªiò\w)z|P X“âpE1àÎ€SoµSßqÎ%ÆL0“€X0xiâqw¨B}°É#,NC…lr¡UÌ^é˜ä1’Áõ$§ùlTp'ı)Å(` Q¨˜•Á&œ&1“z,A$$ KÄ€¤#:Ğ1/õ ‘°(0Ğ%I¡=0eÁvWkPíM? !n)0Ä´ê¤y%ŒlÀ§yV™--r >¾šf$Qh±ãøA$PtÚK.?±WÜIZIdÿLx!©SBqñ~õkxt¹q M;µ#µÃÑ/Æm2!Q1Îì\?Dùiø/h †`ÄÀ¨çÅäùª4D{AMô ~Ğ%# £A 2$O¥cµ¥ÃktE^R½ê3·e_¾øDE\`%òzó`@- Vê8A³K–Ğ%?E23ó5:óøzÓƒQ)ãÊYgRaî}'sy|M)`ä(Z¬SVeX-]y°kQD îL &Õ'E0hlùzL Ïì¥Üé¤]ˆè+}I«R_
şuÏSaHmxg{û|` #"&Š%lÌowM¢ğ†wÀwao4TïV/m$‰)òñ²"eG”­¡%UÖÛc&ı%pa{<ñâœH¶ñ/è½Ğ  ìhø¨cßõõ5ì¬[Â„8:©+Ïneb 	¾ÿ†1±b‰jtk+:IXXzĞaYoïÀ9¶€à/ô&W÷"Ñ/8 íå|z~-^QS®×€á´“sE}OC;ux´a M+«=¬P öfÁ¹ ¨àéï µ¶G B{¤!<iş?xp‡ u(Su)pë
İó
ì`ë“.ia&c”GÄqalrMk<Ô­rz¨'aéA,fg<ƒnJ"b
©9;éêueïH¦ešÁwÅ	¾u®Â3®ô–gB’V¨W3£Q:~ao#Ò/ØôûnÊluL”±+ü1`ì@ªbT!#Š®a@ğ`@Pëfr;ƒg¤C©`úIù}vØ5bù à S#¹ wpåã¥kÁÎ,U&j¤(.)áØoñùã( 6 cšÁ=sú…Õ%7~öU+ªp,¢T4w›5
Í"¦şdÆÿøWKQ©	HXk¯æ\av-fSÕ.¼=A¢æ®mUnZ,–Ù¡ ğÅ_Å†`0 M²Á´ ú³âs%Ğq¥Æxr­6b	?;($d PëËârtzØ#]fw¶1áMàüqjÿ+0C'˜*§-$S2Í7`Q ´:ezÜ"!"»©`Âu,£÷[“B¥<yÏü` ½FØòĞiÀëjñáóõéÿy$–«{j3/=°³´¡±m£^	ş B¼\R|Ôa~Àx(hnvxõl[]Ì¹d Ù&:ài*( C0<tò<ı0»y¸I$W~}á.Pç& jğ5q;¥ ª¸óAuğ¤(>AQÃcìî‚§Qu°°¦:<{ôŒ-.¤ğ5 J*õ`8å<¡š´mDpK!r/ó°ÎKt)éò€<kkeØ@¡8o¤§-ã¸¾j¤«,eó€`P¦Šp|¹AN0h4= ùej|6ß@g­{<±V)4ä#ï2-û$ï=a Â Æ$°Èrx¦bG!T lA9¢è!gÊ)b*¨g 92wDât˜@¯g”Çda}(¼2(d0naS®T`v&;4é^¤F#w$u	tªnlM7¤X=Â%q[Sm i«¶$ª*”0£ƒF¢x´V!Ğ¨e©>`e°¤¤’B"lùËbèDrm0WÃŒò !a¥4"ı!©ij0i4-¡¤wóTëNŠE]!Y˜e&«¬'ù¾yˆ¯Z`aŒ"¢` ½,ı¢DOm!«¶o){ª9?Slwšn‘!Ü
ä  ñ»2<¥G"f~D01Ö´V0`O¸Q«å`˜)÷í¡kÂxwµ0%z(]óÍtù"Š£!ü¨0=| x-÷BIgå1ı:~Ò8g)<ñ0áï aÅD+êÌg%^Y
¯CòLbW2±^èá½á0rse
9#9  G¸ÂW!sô3µ0MtAÑ4n
dn¯®`P>²U(§å4(J+rs90Æá"gù3VH&b-v$L°%lÀÿoæiX¨¯z"èGO±¥ğİB`²Úkúi&e¾ß–Ú(+'à1<ƒr!4£×Bmò«bî#IºeB5 ª¨`çL¸î°$dûjY­{Êzqt}m¿Ô`–]Yut*Ô‘[HuÄ.&dAİˆ¸a"j&tä0åÔõêÜf2Jv{´aqÙ-t‹FuvDxÅ¹ùØÌz‚m$óá‘3fkdg–5–ùi%B"5s*iB{Df +måÀ~İ){2·rÚk“»m.¦pEs>*d%¦ie£PŸçurÑGgI`%n§"#È™!$Š‡,ã‡13 p2X+ñ°æZ”ÉØ;LTU2j$ï€zXÛ1Hsªµ‹s!ã‹ü€? -! GŞ0İ$dZôÛ2M»1½¢6ü'â2%!0i¡L$’½3!€gëìô(4*dø‚±â_Œ·û²&/QUgs¨ˆ+e}3ÑlL"0¯º·º¿xÆ(š  +f>¬¿qn80§(mm5*Ky40qV» e côfƒIö* hB²}#4âÏÂ“f75b­Z|‡±è)bq²#A<=epô´\Cº N$(Léqà.%êkP‹ú9tØ{%Z¥¹#=-o"Ú`a,ÜnFTÃyÿxes€²´®+‰#òXVzr% /äú¸¤’kófyª¤$:q-cÌ?*`>u!ğ*¢M&î÷°Q<Q5)ˆ
rrUëAÊ¿q;}2®§qÿÛqFãlÜ:e-B·‰ÿZuíjC
_u†€Ü#´¬ej³óAc(Uz¾Cª$zC2F45”{\: U d¾V`¢@!%h)T? ğBI o0L“›,)S%#‘#½ag!¶÷qcmo4Ñß=£q?3?=ÚãoS[xç<Åİ[²vL-¨.°tR)js2±\U\|!=Ç‘qKzvƒï <W+eÜB`m‰¦³(EiêX=	-@Mc©fyP­Ç23n¡ª_}»=ô¾HùöuVuaeE_OŠd0S$P±r)aÈp/ñ ¸6ávGìÖ6Bd|@pÁï€,­(nŒÊ—-÷Cç³8%e¬t½YZ<¢¡ÕØ½pÏà as+M9^js eƒ¬f°kÃFzy£*xYOIÉ[ª³L1ßaöjx¹Orég'46`å
A/&Şq§-e033cc:ĞAÉ Æm ±X2a:9LB[@aÏ5 À`
}f>aô,|£EA°„­V?0Öè¿Û|å¢eJÅ#>ÆÆîmû67ûªY¢ 1$î{”<"%Š`!#Y&òä  f%µFaµ²¼D ®xÑ³lSô¬“lás¬jÕ0ëu ld*—“¡y-k]5Y ñä´|ysä`°Tx)j<­ëÊpˆ[ø$±yöõÔZR÷¢±¤İaÄ(;øhõ\¥ 0+0­^‚ñ£1"@00lcDqÏ8ÜêlÕMæméu2
E,GøFh¾;ş"Gµ8h »×05[2?;gñù_T"4·s$Á~{X!°Ó+²FtEV;µmoQĞ?îuC1°·9Ÿb\°A@ù[0=j.ñÕáœCÉ.¤—s!0¨W ‰ÚÏ%ÓÕd²Öv+ñc3·öOµBØ é1™iIi<+¸{KzwdNRE Y3+sñ+5	Trîi3óÊd`+#@.	yÀP¢cd¤ºz Ÿ(X%yÄTXLäI»ÄG&p~yÚG\Y9°‘Ùáàø4ï÷2IeÅ‘"`¥WÉ9äªx=(™6ª0©<pC%N‘¼s)ldwzM]ˆ2-4}*íPn]y€s6¾2à#a´*O