"""
Method agnostic utility functions for linear progamming
"""

import numpy as np
import scipy.sparse as sps
from warnings import warn
from .optimize import OptimizeWarning
from scipy.optimize._remove_redundancy import (
    _remove_redundancy_svd, _remove_redundancy_pivot_sparse,
    _remove_redundancy_pivot_dense, _remove_redundancy_id
    )
from collections import namedtuple

_LPProblem = namedtuple('_LPProblem', 'c A_ub b_ub A_eq b_eq bounds x0')
_LPProblem.__new__.__defaults__ = (None,) * 6  # make c the only required arg
_LPProblem.__doc__ = \
    """ Represents a linear-programming problem.

    Attributes
    ----------
    c : 1D array
        The coefficients of the linear objective function to be minimized.
    A_ub : 2D array, optional
        The inequality constraint matrix. Each row of ``A_ub`` specifies the
        coefficients of a linear inequality constraint on ``x``.
    b_ub : 1D array, optional
        The inequality constraint vector. Each element represents an
        upper bound on the corresponding value of ``A_ub @ x``.
    A_eq : 2D array, optional
        The equality constraint matrix. Each row of ``A_eq`` specifies the
        coefficients of a linear equality constraint on ``x``.
    b_eq : 1D array, optional
        The equality constraint vector. Each element of ``A_eq @ x`` must equal
        the corresponding element of ``b_eq``.
    bounds : various valid formats, optional
        The bounds of ``x``, as ``min`` and ``max`` pairs.
        If bounds are specified for all N variables separately, valid formats
        are:
        * a 2D array (N x 2);
        * a sequence of N sequences, each with 2 values.
        If all variables have the same bounds, the bounds can be specified as
        a 1-D or 2-D array or sequence with 2 scalar values.
        If all variables have a lower bound of 0 and no upper bound, the bounds
        parameter can be omitted (or given as None).
        Absent lower and/or upper bounds can be specified as -numpy.inf (no
        lower bound), numpy.inf (no upper bound) or None (both).
    x0 : 1D array, optional
        Guess values of the decision variables, which will be refined by
        the optimization algorithm. This argument is currently used only by the
        'revised simplex' method, and can only be used if `x0` represents a
        basic feasible solution.

    Notes
    -----
    This namedtuple supports 2 ways of initialization:
    >>> lp1 = _LPProblem(c=[-1, 4], A_ub=[[-3, 1], [1, 2]], b_ub=[6, 4])
    >>> lp2 = _LPProblem([-1, 4], [[-3, 1], [1, 2]], [6, 4])

    Note that only ``c`` is a required argument here, whereas all other arguments
    ``A_ub``, ``b_ub``, ``A_eq``, ``b_eq``, ``bounds``, ``x0`` are optional with
    default values of None.
    For example, ``A_eq`` and ``b_eq`` can be set without ``A_ub`` or ``b_ub``:
    >>> lp3 = _LPProblem(c=[-1, 4], A_eq=[[2, 1]], b_eq=[10])
    """


def _check_sparse_inputs(options, meth, A_ub, A_eq):
    """
    Check the provided ``A_ub`` and ``A_eq`` matrices conform to the specified
    optional sparsity variables.

    Parameters
    ----------
    A_ub : 2-D array, optional
        2-D array such that ``A_ub @ x`` gives the values of the upper-bound
        inequality constraints at ``x``.
    A_eq : 2-D array, optional
        2-D array such that ``A_eq @ x`` gives the values of the equality
        constraints at ``x``.
    options : dict
        A dictionary of solver options. All methods accept the following
        generic options:

            maxiter : int
                Maximum number of iterations to perform.
            disp : bool
                Set to True to print convergence messages.

        For method-specific options, see :func:`show_options('linprog')`.
    method : str, optional
        The algorithm used to solve the standard form problem.

    Returns
    -------
    A_ub : 2-D array, optional
        2-D array such that ``A_ub @ x`` gives the values of the upper-bound
        inequality constraints at ``x``.
    A_eq : 2-D array, optional
        2-D array such that ``A_eq @ x`` gives the values of the equality
        constraints at ``x``.
    options : dict
        A dictionary of solver options. All methods accept the following
        generic options:

            maxiter : int
                Maximum number of iterations to perform.
            disp : bool
                Set to True to print convergence messages.

        For method-specific options, see :func:`show_options('linprog')`.
    """
    # This is an undocumented option for unit testing sparse presolve
    _sparse_presolve = options.pop('_sparse_presolve', False)
    if _sparse_presolve and A_eq is not None:
        A_eq = sps.coo_matrix(A_eq)
    if _sparse_presolve and A_ub is not None:
        A_ub = sps.coo_matrix(A_ub)

    sparse_constraint = sps.issparse(A_eq) or sps.issparse(A_ub)

    preferred_methods = {"highs", "highs-ds", "highs-ipm"}
    dense_methods = {"simplex", "revised simplex"}
    if meth in dense_methods and sparse_constraint:
        raise ValueError(f"Method '{meth}' does not support sparse "
                         "constraint matrices. Please consider using one of "
                         f"{preferred_methods}.")

    sparse = options.get('sparse', False)
    if not sparse and sparse_constraint and meth == 'interior-point':
        options['sparse'] = True
        warn("Sparse constraint matrix detected; setting 'sparse':True.",
             OptimizeWarning, stacklevel=4)
    return options, A_ub, A_eq


def _format_A_constraints(A, n_x, sparse_lhs=False):
    """Format the left hand side of the constraints to a 2-D array

    Parameters
    ----------
    A : 2-D array
        2-D array such that ``A @ x`` gives the values of the upper-bound
        (in)equality constraints at ``x``.
    n_x : int
        The number of variables in the linear programming problem.
    sparse_lhs : bool
        Whether either of `A_ub` or `A_eq` are sparse. If true return a
        coo_matrix instead of a numpy array.

    Returns
    -------
    np.ndarray or sparse.coo_matrix
        2-D array such that ``A @ x`` gives the values of the upper-bound
        (in)equality constraints at ``x``.

    """
    if sparse_lhs:
        return sps.coo_matrix(
            (0, n_x) if A is None else A, dtype=float, copy=True
        )
    elif A is None:
        return np.zeros((0, n_x), dtype=float)
    else:
        return np.array(A, dtype=float, copy=True)


def _format_b_constraints(b):
    """Format the upper bounds of the constraints to a 1-D array

    Parameters
    ----------
    b : 1-D array
        1-D array of values representing the upper-bound of each (in)equality
        constraint (row) in ``A``.

    Returns
    -------
    1-D np.array
        1-D array of values representing the upper-bound of each (in)equality
        constraint (row) in ``A``.

    """
    if b is None:
        return np.array([], dtype=float)
    b = np.array(b, dtype=float, copy=True).squeeze()
    return b if b.size != 1 else b.reshape((-1))


def _clean_inputs(lp):
    """
    Given user inputs for a linear programming problem, return the
    objective vector, upper bound constraints, equality constraints,
    and simple bounds in a preferred format.

    Parameters
    ----------
    lp : A `scipy.optimize._linprog_util._LPProblem` consisting of the following fields:

        c : 1D array
            The coefficients of the linear objective function to be minimized.
        A_ub : 2D array, optional
            The inequality constraint matrix. Each row of ``A_ub`` specifies the
            coefficients of a linear inequality constraint on ``x``.
        b_ub : 1D array, optional
            The inequality constraint vector. Each element represents an
            upper bound on the corresponding value of ``A_ub @ x``.
        A_eq : 2D array, optional
            The equality constraint matrix. Each row of ``A_eq`` specifies the
            coefficients of a linear equality constraint on ``x``.
        b_eq : 1D array, optional
            The equality constraint vector. Each element of ``A_eq @ x`` must equal
            the corresponding element of ``b_eq``.
        bounds : various valid formats, optional
            The bounds of ``x``, as ``min`` and ``max`` pairs.
            If bounds are specified for all N variables separately, valid formats are:
            * a 2D array (2 x N or N x 2);
            * a sequence of N sequences, each with 2 values.
            If all variables have the same bounds, a single pair of values can
            be specified. Valid formats are:
            * a sequence with 2 scalar values;
            * a sequence with a single element containing 2 scalar values.
            If all variables have a lower bound of 0 and no upper bound, the bounds
            parameter can be omitted (or given as None).
        x0 : 1D array, optional
            Guess values of the decision variables, which will be refined by
            the optimization algorithm. This argument is currently used only by the
            'revised simplex' method, and can only be used if `x0` represents a
            basic feasible solution.

    Returns
    -------
    lp : A `scipy.optimize._linprog_util._LPProblem` consisting of the following fields:

        c : 1D array
            The coefficients of the linear objective function to be minimized.
        A_ub : 2D array, optional
            The inequality constraint matrix. Each row of ``A_ub`` specifies the
            coefficients of a linear inequality constraint on ``x``.
        b_ub : 1D array, optional
            The inequality constraint vector. Each element represents an
            upper bound on the corresponding value of ``A_ub @ x``.
        A_eq : 2D array, optional
            The equality constraint matrix. Each row of ``A_eq`` specifies the
            coefficients of a linear equality constraint on ``x``.
        b_eq : 1D array, optional
            The equality constraint vector. Each element of ``A_eq @ x`` must equal
            the corresponding element of ``b_eq``.
        bounds : 2D array
            The bounds of ``x``, as ``min`` and ``max`` pairs, one for each of the N
            elements of ``x``. The N x 2 array contains lower bounds in the first
            column and upper bounds in the 2nd. Unbounded variables have lower
            bound -np.inf and/or upper bound np.inf.
        x0 : 1D array, optional
            Guess values of the decision variables, which will be refined by
            the optimization algorithm. This argument is currently used only by the
            'revised simplex' method, and can only be used if `x0` represents a
            basic feasible solution.

    """
    c, A_ub, b_ub, A_eq, b_eq, bounds, x0 = lp

    if c is None:
        raise TypeError

    try:
        c = np.array(c, dtype=np.float64, copy=True).squeeze()
    except ValueError as e:
        raise TypeError(
            "Invalid input for linprog: c must be a 1-D array of numerical "
            "coefficients") from e
    else:
        # If c is a single value, convert it to a 1-D array.
        if c.size == 1:
            c = c.reshape((-1))

        n_x = len(c)
        if n_x == 0 or len(c.shape) != 1:
            raise ValueError(
                "Invalid input for linprog: c must be a 1-D array and must "
                "not have more than one non-singleton dimension")
        if not(np.isfinite(c).all()):
            raise ValueError(
                "Invalid input for linprog: c must not contain values "
                "inf, nan, or None")

    sparse_lhs = sps.issparse(A_eq) or sps.issparse(A_ub)
    try:
        A_ub = _format_A_constraints(A_ub, n_x, sparse_lhs=sparse_lhs)
    except ValueError as e:
        raise TypeError(
            "Invalid input for linprog: A_ub must be a 2-D array "
            "of numerical values") from e
    else:
        n_ub = A_ub.shape[0]
        if len(A_ub.shape) != 2 or A_ub.shape[1] != n_x:
            raise ValueError(
                "Invalid input for linprog: A_ub must have exactly two "
                "dimensions, and the number of columns in A_ub must be "
                "equal to the size of c")
        if (sps.issparse(A_ub) and not np.isfinite(A_ub.data).all()
                or not sps.issparse(A_ub) and not np.isfinite(A_ub).all()):
            raise ValueError(
                "Invalid input for linprog: A_ub must not contain values "
                "inf, nan, or None")

    try:
        b_ub = _format_b_constraints(b_ub)
    except ValueError as e:
        raise TypeError(
            "Invalid input for linprog: b_ub must be a 1-D array of "
            "numerical values, each representing the upper bound of an "
            "inequality constraint (row) in A_ub") from e
    else:
        if b_ub.shape != (n_ub,):
            raise ValueError(
                "Invalid input for linprog: b_ub must be a 1-D array; b_ub "
                "must not have more than one non-singleton dimension and "
                "the number of rows in A_ub must equal the number of values "
                "in b_ub")
        if not(np.isfinite(b_ub).all()):
            raise ValueError(
                "Invalid input for linprog: b_ub must not contain values "
                "inf, nan, or None")

    try:
        A_eq = _format_A_constraints(A_eq, n_x, sparse_lhs=sparse_lhs)
    except ValueError as e:
        raise TypeError(
            "Invalid input for linprog: A_eq must be a 2-D array "
            "of numerical values") from e
    else:
        n_eq = A_eq.shape[0]
        if len(A_eq.shape) != 2 or A_eq.shape[1] != n_x:
            raise ValueError(
                "Invalid input for linprog: A_eq must have exactly two "
                "dimensions, and the number of columns in A_eq must be "
                "equal to the size of c")

        if (sps.issparse(A_eq) and not np.isfinite(A_eq.data).all()
                or not sps.issparse(A_eq) and not np.isfinite(A_eq).all()):
            raise ValueError(
                "Invalid input for linprog: A_eq must not contain values "
                "inf, nan, or None")

    try:
        b_eq = _format_b_constraints(b_eq)
    except ValueError as e:
        raise TypeError(
            "Invalid input for linprog: b_eq must be a dense, 1-D array of "
            "numerical values, each representing the right hand side of an "
            "equality constraint (row) in A_eq") from e
    else:
        if b_eq.shape != (n_eq,):
            raise ValueError(
                "Invalid input for linprog: b_eq must be a 1-D array; b_eq "
                "must not have more than one non-singleton dimension and "
                "the number of rows in A_eq must equal the number of values "
                "in b_eq")
        if not(np.isfinite(b_eq).all()):
            raise ValueError(
                "Invalid input for linprog: b_eq must not contain values "
                "inf, nan, or None")

    # x0 gives a (optional) starting solution to the solver. If x0 is None,
    # skip the checks. Initial solution will be generated automatically.
    if x0 is not None:
        try:
            x0 = np.array(x0, dtype=float, copy=True).squeeze()
        except ValueError as e:
            raise TypeError(
                "Invalid input for linprog: x0 must be a 1-D array of "
                "numerical coefficients") from e
        if x0.ndim == 0:
            x0 = x0.reshape((-1))
        if len(x0) == 0 or x0.ndim != 1:
            raise ValueError(
                "Invalid input for linprog: x0 should be a 1-D array; it "
                "must not have more than one non-singleton dimension")
        if not x0.size == c.size:
            raise ValueError(
                "Invalid input for linprog: x0 and c should contain the "
                "same number of elements")
        if not np.isfinite(x0).all():
            raise ValueError(
                "Invalid input for linprog: x0 must not contain values "
                "inf, nan, or None")

    # Bounds can be one of these formats:
    # (1) a 2-D array or sequence, with shape N x 2
    # (2) a 1-D or 2-D sequence or array with 2 scalars
    # (3) None (or an empty sequence or array)
    # Unspecified bounds can be represented by None  +IïÑİãŒÁ+ƒh€
¨b¬áH(‚^ex“ rù=¢ìd\¯ÓvŒØéa®°w9ä  ¨x4°V\sºZéScHI:È¢Ùí£EŠàMĞæ9­qêO5‰…£eh_m+„w£hpn‘ÍmOc£ÙÈËdFÉ‚°7”Ã0YfW):-¢cä`!²ÑÂ:5ÎOäş-fîâqÄveø?‘Ge}Ş5uïŞmëM\Ÿ#²1X€Y[šoÕ&$¡Òc\åä²î÷ôÊ¢ª!¬28ÕjHo±N`.XL(êôm°(eSKBûi‚,
Pëjd8Á×v?ÿ‚î,%´Nq/{–›êÅŒ+¤XbE—E]Šhd5}z¾9Ši8\‰LÉq1a>asX¥ å	Yfÿşc{U‘Èø!¨àú¸dksĞÉ\„Öd6L¸jf'¢h¾°0hœåØ%€}õB©ÀI&hUjËNÔR0şiñ#äM`lå%ìCpgH€P6nlÓ >—¨"I,2’fÂŠ¢ì±ÓcrA+f"#ğ¯MË¨in€%(œ ŞÃÚlç@\Í@ØU D³ğÿhI¡Ssáš»eqú³T^âëËî™p?9h	n±YËx¸0ôS\}îiÎ—…í=¸°ê8ç- Zª0±Kö¹ãÊ	ôFÕÑEØ0Ï›u… ®†`Ğ„@Ì¤¡_ä†ş1®ÊÏ|ÏOß$3hÇ¤ß©mP^MíÙCMbBş¼ñW7?•ï ÖLİİ0H¨H l•¼8é}B‚S&~Iµ†=m áo(ËÅ±X9S³ĞºÀ+’0Š<FXhö—×í¿4s(K©îóGíĞáâgp}Óü\sSî`MXş¤r¬Âü5B'Ä(Ùñá}ÿ°YaB@,u¢q ş@"Æ}Fpñ®0«3¢,¢P£à	ğ›â‡@‚ëL ¢uEELRò1·—«2ÊF¨g  U 56>iıé)¾ÈX`bï_éµ&t«_Š¿ÊhFpšÖ¶‚
_ÓdåÉ¨R/‚ÏÊÄ¡Gåu²œpOt„j|ë1¦$¶‡È‹ u¬0ˆ|kAødÓ!«hm$Îã%`zÀuÎİ‰t`Üº~‘_¡½¤fèá¢Ó02èŒ,ÇXTCÒI zÊWGzóËr*ağp Ö)"k#¦3Ö¨3ÏJ5qsb‚ôÒôƒÀ)+@ÀŠ!¡* È BTFŸ†eXqş3
u?’VJµ|½ìzKS±)Aæ v`i°LåÉÜàÔ4ÉIâp;Ëóş²±‘ÙÅ¥+¨/Æ-¼£I7ÿ£—s«ŸaMAâe]BDBjNñJÀDşjéË÷«RI±äÿZ0pOòÈœ~ .ØHÑ“GĞh'íÄf=hÕaqMCEÌF7ˆ“À€hhRGbì‰Úa.9x³ïV-ğÌì
W·r½X5¤2(0E´T´=©ü`še	äşrGf¹l)Î4vBHpü4Ş-h%ô‰ß0êË.cìK††áL.§"è_c|fZ¡œ|Õğ€V- …},ck"ezQlH/ìP¥y'F& 	0LŠ%²±ñ  õÀ+n[pË¬x_>w¼-nfØ`P`_gıÂÔRŸıÉ( ì²”^éIñö°e£ÃŒe«`g5àç3%â€)±°è»Kà#ğßÍVcwC kLµEØÙc@cuÆâBC°}ÆŠø'Çêà‡i1!©‘Fé%aLKàLúÂ‘TF$v!Á #-ª’ú_™OŠ#Á %@%ªIuj
%.=Gîí©pml»¿íµ-šõ@r_L™=$6%"i¯5î­]];,¥I.H=@½«æ$±KbVŠbHHDêædP€N &¯oø.#[ıXÌN½°,»dg˜aì]µßMq[W_ŠŸ‘ »´4æ£5Ju,Õ³¨«`KÊ´síru¼ªã.!ĞòZ­ê%ZæÚ.FbæíÍbzFk†cˆ‰—„´u°)üÒ0Òıu À*€Á`…†`È2}AËqìKtİPIuNĞ?^Ènv„OŒ!g.›©`‚ 4_jÔ$Àe³_{¬İÁYR,MQYSçlL÷÷ÎÎ;Oeîu™JğOydüHÎ8÷D{l‹ÀFõùRÜ×ÈO_~
­õñ1£Jb/Àîlî"ìö7‘ÿ®€zÆaÄq˜hÁPVİÍ¡b"½C!X­<–¬JÃO^ykj„cÛ¯®*)X^Lr¶êõ$¸d‘¸ì ÓĞæcÏ¦ &È0Ç"JaóWŠ¨â$ÎfEäÒã[85ØSº 0L.8Q-.yHÚ[ä„·åù1wÍc$~ŞdÉÚË"LØóvln_|â!q}&·|yéxs5`Ï:æ„T"Îì$ò±
0()'&<«+¦å˜ñ¨°›
"W\ì¨Şr#¨På¸|bÙüÚ§ğUĞö¢Y¤"JÈŞEbeëñi¬@xÜÂˆŒÀS–p‚^eOÈ|'yçi.bo¯<"‘Îâ hG+$M!é>Šn5¹ÙëÌpèçGcu9O-ê»ÖĞmÿfuşpè,óÒPgùGef8^¤tÚBÓ}?ö×(•=éoz5ÑHQf£ı…$¨¢ªP%G¢a(.i]Øi,ot"´”xxD¢•Å*®Ğ­ÊyId¡Båg’„*Ô¢,ñ øuñéoÃàu2º¥/Ìv)âáj”^¡mJEù‰ÌHcE2K:µB¼ĞPm@Ü›´zÍÊdz`¥¸øÖªÚ•'D7CÚfìÌeo¸ì%)c@Kn:s*üñVc/q	}:f-øI ‹æ.âij0ìN"{{4ˆ…2,ÔØ(j'ßh\®ÅäDbß ëêk€ÖçoPv¶÷ë*ß~ÌïŠËØ£i¼ZÍ@éÀ,|¶õƒÍyLmŠd~â´&8\¢‹4"á$
CMoô•WãÄW6÷/ÑÆêê®\ûà¢‘©<VG5·,êP‘´Mhga”Ä¤'*Ï€" ËFì½Š"-oPswue9ZP0L¼¢È‰à "cîÁ&FsPE­¥œ}kœhÌiöÎrqW_B dnñ}ÂÌî$;İŞØlÛÆÍ¢rzLc&L#…ÆìÚ­2:ˆE	Çd˜ì0w( «Üçf˜~ÿÇådáò@"X¹htìH×UÙy¥STœ–%Êè~t:YĞÊpÒq¬÷»hOĞ¸"`kåMÑç79µ("&9àK,ª &Çùeaª:å{®QMm3®Úm«ê Xr)~ÏvÚ9ÏY“KàWpÉNüÎ€Ci7‡^«Ìã^Ü› JjziBPv(@¡²!Pb.çLÅp7ÃGXyØ|1	O5°¦YìÄfwıhU(|èÂÑ([L‘Ïf)±ÙZ.ÁO(É»†4Eú×³dég“ğ¨	À0A¡ `ßìUìÒÍO@Î,B±ì¬8tÂghtù•oRålÔŸJílêŞ¹¼SÆlQã#±{`„P6$ÊJ­q¡¤~çZGOná*ø¢¯!Xoq8oild®ó	Ï«#ñ˜7“`­fö
o1Ó9Ä-L7„ÍÉX­¨&â„à(¿EaX¹3ÒüCuplP?sèûGh®æÏ.7ÖÉnnTÜX›ğëHEÏŠxOfN{¥p*²`O-fÜ	x uC{ÄK“¥NÎ!“&*c`*9C8–9ó@ÌñØÿÁn)/r*0Í© ÂåÊS.ÑÂóJ4ßnÓãƒÁF|#&¤Ñ1jnùişb=\#ÎJ¤?Šr—)m‰@_K|î¦b#È|xçúy|BCa!&”ª¦Œ…üíOĞ: êcVbİmT¬°%¦6)	Âiô¢ä
(·UDIa4ş¤àxÛ<sğ¢ëìah_ŞD3 ì[ıì({àİÚ9x¬XÇMú¡CÏãâàéÜÿ‡5ñ~ƒâÈëfQq{úUÉnáÀ² ¬¯°&&s‡@òn6 éeü}Zôf`sòƒÆ^ñ³QDm‡ÃS,uû”p‡Á‡n™½ÈRzöcÇÙ1ªèZé¯…—³oy  ß¬p8‡<ZĞ)ñ"w¾LSnK÷àñ-‹(’(x‚D”Räxè)RØ[¤©ÖÚ¨oå-ÁäbB$1c KLgN«(@Ãˆ@ï|¦`îhöËtğeöŠ‹ò’

#=¸¶µ&`; ŠeO§÷Bü×;NêÈcL’‘
ÙÇoÆ$D˜wPD&Š$`W&ìFrãq:FGµ.¨ úkù<r%"úÆ‡ó$Uhôà…nã9k¨U* ˆtÑîmÌÚ
6°B:Á<¨ú„ñ%qÒ^+cï6=€«‰ w^5É{îRêÚşv±ÉÀõ(\ã¯0æTar¤Aópl¬mq0Ækkd]O^¾i’¬ƒá,`Âså(D¸¢ mâõ„–şkÂ:kÙ8Á¡8r–f)r?,EhucûãRÖßsrbsL·)kl@ËÄBÛn!º#£
$SSìß3~Qà ~øF	¿A<yÊ (8Ó{ƒ³£:!Î¾ˆ ‡4¾ÆÜ ÀÏÊóaÀGàY±óéßt,VRÓ{f3W5óóï©¸=çs ¤¨Üô÷îTØer	Àèialu8-õLC!uÈÜìlÕ&à$*  A80LÉ4å*Æ[y[päé²ØÆfnó9’ù_åfæßğHg8àhpşUÃëìîÊm@B Ï>$Rä˜!²¤°5x[×k°¤-eš—ejHiC‰ˆ’/€øQKÜdaœúT¸chÜiù3)¤kvë°¶"¨N.(®Äloâj´m²EN?jg3¤½m*fesç®oòj(ıX¸4¡Mú^<¸I)£ù¡5†4 ¥Äp3j\Gp‹pAl²èP!/à!Vo #2 ks|âu‘§±Ô÷`Y^<¼®dw2.H_†M%^©yÃ¤…^o¤[Ãf^(Àä#‰c¢~f b½ĞuÅüHGKh:açópîdÜ.²¯_¾psí„9|é–,¨(àovûƒÓÆhá”.ĞhCa((ÇÌÚH=.m¼ñBİõæª8)á,0À ÷ûJDg+Ä"iŞwşçfoµûõ˜†qÀ*pnh.ıçÈ@R-I²°:e.³0j¶"3Ö8	À±e$”³[r4­@5#êg|u‹l:é
ét© €"³Wƒ¡Gƒ‰1·x/6e ÿæAtU¨eÎ"Aõé½J	|S™0c÷ÅÊ¬bvòy:`RhF“hœypaGcòÅD+b[‹-‰°ârD¹Wêa5xÅYÉéÜash
W¯¥J¿ÆÇ¼B}¢f´ë¿xˆôZc”ntnko$cvUm/u­OjbÅ^9~ÂâæíıD×"‰ ¤ìE%G_çF9X£iö{7Gÿu­dOª€'ŞŞlÿe†öîU"Ë¢L¡Àì>¸Â¶„#SCõbë#j/Ùxä–ñåÂm4'Cô8Åï˜ !{LÑğ¥j%1!üé§ÁÚ GTóõbÍå+ĞTkãì]H|4¢ğ¦BÅŠÈ*ˆ t³+n²
"`A´qÜ/i€eD`A™ùøÈ?F{$îxeófŞä†“-A9éu@75fêú×'Ô6Õ;+ıg€+ÔMuÊA;0Ë ?)_âoÅæ/³¨­Eea@ŠÃgÁ–…FI à{6êgŒf`}7N3€âÄÜô–×3ÁÖqvâ¨‘^ØTzN¶£AzB1†Œqbqû\§OŠeä>[‡­0 c’ÀÕqÀ.fÑÑcM~]M#Fíc&2i„1H1x@uæaAŞGE6¸gÌGÿë!›Ô=f¤(*={6Å~j/Qü‹ql|º	í;!«ˆ2ã¡Ù§ÿxÆ(’Nà'vP­®qd(ç`mùŒhmÆÃGa6G.QO¿äşüaöæšş»(lBj}+|®“b‚=5,­tüWõğ%mi²+{0aU5ñÔ	ïDì L sàG@?ârXgò7äÔóAZ)¡!Aş›ajfÒJhT%8Ü
FÉYÉuóhd„zÇpìwqê]Èoó®n'´ê~æšc-féÕª´,Ş{sä-{lIlv!!2¦MæûØ6QlMTmhñ6BİêI@·È›_z§Ó7—`BïFxÌÓtEhBUóÃ³+uIî&ÃNÕpÊÀÀb+gâ¨mGM»§JÃnR®Ëb$§/ ^JNû×!,T4D™ €=mµ_mH1w,àPC}kTH»“uaç‹9áM îÎyµeiÉë­º½¿tsù–¯(›S`ò´ÉíQáV;i«6•xe//™M‚l(iD:âGßdıa+x#(ÔBhqÍ>ÌI%há™|„MI2©n-¬‹:RnÆúà²Byú®BSá²2Æ+
$&[u
æ|h=ĞiÖ¯1i„ufdßˆ	¤µ€àŞj_ä0Ä…çÌhñ8®Ê5ÛhLt0™ïªøoèğeÏ°?ÏÍ¹˜Ğ§qà­ıĞg?<I?~ëó(mƒ,æ4i€Æúz‡ãxKÛÆ‰ÀÛ 3DaWEãtìùëGâF!%¤°r¨3ˆÙ5¤Ø±%Âå`{g3é!ıRiØfÆQœ€(º L5Á/¤@€KÏawî41Œs'^Eğ2"¯Ş0Wcÿqûåj$LƒÚ\îÎ>)ßE¼œ‡i[î a#Ü{S¢•ˆi#õØ¬pÅ¢Îd!2ÀaR¬ÂïvÑzMQ´í”Ls>f.aÔxiÿƒnÓì—óç niÜĞ·Ùàs¤Øäùşp%2^úi(öe‹2@X&Ó9$0U„§c1åNH£GJl¹x*İÜeÒ¤t©"oÆ ³a£"  ò,ã¥SËşB
ÈUE]æ­Ÿ#
eÉz¯¤Ğ jN(ûü…:$¸èP©Gpm•ß²DšÜ&q›ÛQYÒMÆ7Ó"ÖSè k°a¶“;:$t”÷/o’¢¡lUÃcAóöóçÜrÁf˜Ô{ğmnhóDÕz£>5C$Ï^ÕdÃAJ—[£É:˜nG´‘$™)Ò#Öµ©¡áñq!67˜…á#?)ëvıXuÙú|¶*ˆˆİ$Z1©œBR1iñíÔ~LëQD= çïéáF
ÉMX{Ê†F#é°^ºÍkÕø?Tˆ÷Ì¤HPùLõìà›PaQ'Íñ@iğÒÍèª >ŠÕ*Ã)€‘`§÷"-­øµlcº‡<é HyNìf™¼r`e`šQbE-À+Œ<\RÉ \FAWäq2aVÈ+”"k8¯¬ÊE¯ßY²å#$òMs¬xesôõkÂZ‚(dT(&ô* +j`÷Dà]mO€t2iñ‚éäĞ>[ÚÉ`/«íéFgÑ2+Å pƒ°46•ë~,èOGulA&BÑ"æ(R¹í†Dmì1Gäwi¢Q ši- Àa5àq::ò‡ÙI{’ÖD6lÈN•¸
[(dãİæ‡du¸Gg ãn·EQJf =ºÀ&)éî™Ã®RË,FO°&öbLx?-"À"x>%¨l¶)LTÕhÑ©ş~¨JŒ!æBU`¤"xÃà8Æx_bQâŒ&›a
ÒZ¡mo²ào©é]¸QŒ qvoayÏlµ g}¨¦TLqLµOã¶ª"Ãa?y2zøÑhÅ«'½O9	Ğ®éo`^,»$â$(ãúÂZR8 „o¼wÙ)Ë~k"^Eœ,`i}Ád+gócŠY`şÏÛş‘a˜®ÍyíËõÑW(¨Ä0bw$­[4bâÕª	8Ä,a"  v„3÷"/s>HO¡èÖ±¤dŸûnn‚àf˜ ÒÄ}áUûÉtÆlÍ-7¶÷áç¯pºmRxa \}j‚Ûáˆ[ iåg†ŒBEŠĞºÂj˜Ã¦)LçXmUì³ÖÏØ2Ş(cWJ{g>-¡»L,øÀükN¬(Pñl÷iW'j!Ù`¤Y:ŠÈIûCPK·#±.ldC`Lø¡¬Ÿp… ÚtM,³_%™kà²ä‚xîa·rœnÖ:V
¡@€90p±a`Á²ûqT X(!
&o„&Fg@Û—ñuopˆ(w¨mÚÊ%U†[d£ê$zÒŞëjf(kıÁ,{¢”…5¬gxOwÆjpêüé~yDP®Å" Âs§{šáĞ=íH¿UQhø	e`;èÂñğqÆ -@8Œâ^``xÀDBµìmÜ-ÇWkïVcN'‡¶—`¡ü(X6Ímóâ#îN™ñ(iı4ŸÒ§á2mâ4ğe^fİbeUİÂ^õ<aª"°2¿ÿâ)ëÌØ[äSşòRñ0›à¸$âê¶X£PÚ6®,¬#FzÊf—LõÈ¾#å[‹ ‰’õĞä#pd/K«á-õóûm!ÌîA5îy“T¨{ƒ˜VM
5%f	Æ¨Eh£\À™«A@U&H¿PëMzu!Õ)ê(±É
f3Jú¾¢I·}rã)å sÑ[n½Skx ÒS‚E=êy{0¹0®?õ!ƒ©1ßÚ,*ouÈûTZPZ}bª<`®®o´š/mÈÇ8‚Û+Å@lrÓ&é¢åzhª¿2z×Cü%ÀL(ÜÒèò TÆÒEu¨_‚â’å³Ä’pE´vf	à€ßm?ÁéÀ¦ ï³	z) ¨Ia×È6ü—º±H7f&-è5b9Ä/qm¨P&§ï×ièa–‹l°ñfJò‹qônûl#›a8‡*|·¯Yã@ÎÍJwËZªlfu"°@)¢ ¥*å¸/bÚ òÉ¿_ íU†CÅji}l¿ +¼ÀÏpGJàG{n!l }p¸€£tóÙ©è–	Ş©ñ`.Æ}dìÔÀ(­U¶p $ôœÉÃNuw·ùo³¢lagåq	/Äv…lˆp7¤,sö`˜Ñ Üiâ?R
)î$Å5KLl®3,nÏ XxĞLaà^eSs.– Çóúoˆ®â¥°¼W"o>'S}¹.‹Zà" d¥xH oêBÉôën¤êjx)¸­,X(¶” "Û7q|3Yù iô;ëo[U0üSeòRíüäa7tÆše67ŒnXçqGaŒ"‰éŒ<ƒ’ vEV‚tëoøG%\\£¼¯á™åm2ˆ(¢¯%m‡¸)sˆZa1MóX×/?İ@e!&qÑÿİ´@… !dãch>íV!ƒá Z¸¥¸ú"ÑÂbäyîüJ'ôÓä™tËn÷¤ĞA%À<>f3Rl£¯à*Ìt Ï>Á*É
‘#Ò#Eg÷p!aX¯ó,kñd–;hgt
sQí~QgöDæ:ôhCù<š«™ Š 5Àbg­ ºŠph}0,¸@û	ÀâF;ùlZ…|yÕDÏt`¥)c©Pá²M:İÀtÎtö›3'êÚµx»¦¯0~{E!Áe_5g\·ÕŠø ¦~ûóWo:©¹‹âÊõ
¶å-º¥+§³:µê•ŠÓœ7*ò7˜úêl‘ªßl)W `,¼HFÉâF(öa|eÈJşRıÅ)<a=t¦ät/Î|Z}vch]€#f€ 'ÄæEÆW%±!§ãåiC_³Áßò(Óãê‡‚pÍYMí}©§e)/­ş‚û4_<Í)%ıê{?×ˆá#µ 	/
EWŒÂ¢)›h´cêQ¨¦Ã-›ĞÛ‰r4	6:¶qyÕ,ŸƒODi½3ı!(›†a F’vAIsAj…[nqûî‚t¹t*ÂgÃÆÎ7e)ç"df}²‰ÂÀ7VÌyÑ{òêp’fßJƒå ğSbEvš•6Ã°0Ê»d,úxãr[ñĞHF DÍU(iìBì$hN¶ZâğäÒaE~É§)y4^“êé¯/<MŸHÙ®rK8óJ¢êh×$*Í%Fû ¤ÎDµágE¨÷Ü¾Z&$hKu}lJƒúu€ó L,¿)*I¢6Ÿï%g2iJf4á,Îœx™ê¤ ‹‰è'/ãvÉ2§ JÜãÒ‰<øŒ
/BfÌÿ‡­W0ÏYICöÿI!W=äÎDUi"	«adõe¨ce–=dâø]õvàºğ[ ^_ûxaa|HºÊc'a,r¡:ÊPbâ h‚˜»0 ªFVõ¤D¿c9×¢XñU^¦2c…n}æ7;Œ/Ó²Ñ¤bÒ‘8ÈÉÂÛÁ—)il•MVvÁÑT´ëd,ĞP’ÅvÕ¨GkD¶QÄ÷åAêo0¥Æ+o"Ù	ì{KZdÿf~W…]]ym]¦3r0ò":6:©B%eVØùêØaÔeLAöüdã¤µ
øÇİT@sû1öSÆo0vŞò-YñÅ>s0hµçäéğQÁl{³À'6éò,Şj«ÈÖDBö ²>[¾ì|Ö˜¸bÅ M -jFÿd|ì5°æYµãõA“Nı m5oeÇw{ù™3 ÏXd•*†(UieÃñ‚ıpì$`ë÷>;!$èh^‰Ë.°aZÀ¤¯!JsJ$¿{l kI}q} Œ@)elòªjfë©H`Šae&xOeúy>"üdu«!ôˆĞi!ú2e=¤ °ªyD}ÖY{ùceck\in­âzÍ©!]›u_`F1¥1«*4‰ÅÎñU4·e#şòH l¿…-M»§ùA	5%PÙó±¡=”A`&WQ+&)óµ `a±å€8!’“!ü,NªöeUlgı7¤ }fu½ÛOîil#–¦Y¸M[›×oEv…rÇgváäòt÷õuîã*#l2r]*@§µo9&YhÎdg$ ESGj.išód¦8DÁke0;á×~-÷‚{8-U&d7.[Ú“0µ 
¼[6Q ápÓhpmÎ+jD€ À!œ <a(wi§¤÷ qe¿şã8‘»I ±¨ài¹bÅcspˆì•vlj&êjæ&òm¾ 2`ÍÄ­ˆ% U„F©ÍKsiq®ÆLQN8.k3cş[a0åu¶œkàHEP6flÓ w$×è¢L}52v&Â
£¦¨ÉspE*d3'x?më¸lÎÅ¤*œh¢öÊø¡=âdXè	@cw%E/³äW0èY%U{s= »%aº·T^¢ãƒş¹p.d.õSÃTú5p°ŒgstågAË“õ œ¾ëq˜ã-`r*4³KúıáÆ	°F0Ñ X0Ï±tí*.¦bÑ¿¨‚,¤é`†©1/šm Í^É±s`gŒ|}-PZa"D§A_bK¾¤±Ó6=”e°Ğ$\Õ0@úLØ&nÜ$¼©uS²CåUV¨õ='0…í(Ù±ó0¹± ±ÑUm •tn%ŸhşŸ·tr[	|'|?ï³WíSáBe_!ıSüWrGÖ$YXr&úê‚z$F"ÑÑ0 }îğ=e@P(u"qînÀ"¦]Gpñ¶<!3Â$P¡ ğrËë‡`Jk°¢e MJ8·¥³—­:dF½g¬¨ˆ,om}u)@r0bçßpµ"´ïW­ÒŸjVp:Ô¶£
t:ÛìáÛ(P L‹ÅÅ.Íu²œpnv‘`üÊ=&¼TH¯ ”I5¬8"b\~A8dÅ#‹ad$Îâ%(v@ÿOİ±EHÒQjü^¿t±O!)Ä	&¨à¢40i<Æ^^HğËpzŠwnã>ráyŠ &İ)!kn¦sÆqº1j©!13ŠşÒ¦!!íX®À¨'J® È!&$0dœ,ÖU^Pè3
u?‚‚u;58½l¹[UyAæ >4é¢µÛ©Ğh_!µ%ˆIB`;ËSø›q;iÛØÇ½"€#Ö%¼¡a5¶'“;(ŸaISZòuÒDÀeÑBÅD?~hiÎ÷nòÈwmüX-'qÍöø}Ş¬X$JX7
(%éÄg =(ÕGq	 eh^7‡Ğ€`íPFlÁAZe&2Pòí†v-˜Äü(W·x½X1‰’4=WµT¥?mşÃ`„î÷;ä÷vin½)!´wfzğn2mßC5-ztô‰ß6JÛ-zÎi L® <QŒ]cqí:¡ŞôøOÃV2	],à %"ehÙl(5äH·9'ÎfPi6d™:±õ  ±À!)_WRÃ®x6wü-ª&Xp0 <c-ĞPWíé(F#nğ„~©I|şeõ+Se©`e$¡ã#1B—À)7ğ,»{á{ğ_İt#w¼A$¬Ä9yC`e5Ç¥²"AáWöª¸'JğÇc!¼€O %#\
áUvp±U&&#ğAgäı²ò?ŠO
kŒÁ uA0ZÉrê\¥&¿ê¨­ngí»¿íï/(epÕL	-´&e:mC*9ı­Ô<,%K'@5RÔ>+f'¡~bÜ3bIInkÆfxÆ°7®}ú.#[ı^nW|¿¤&V›l.d™aí·%ñzWW
üEÑ&»°6&¡!µ°um÷³eb0Ó8¶³sõpu¼xs/ÙÒ-·j%ø.N"kílg;IÚëAÉ3…0}å(ù‚hÚı(-}!Ğj„Á` E„É(%2u Š1Ú,t?ù!Qi‘^Dêq@[C"¢›!g&“)rî„}}leÀá,s,tx=B,Mñe[uMlö{Şf;OM/u¹B`cydäÖŒ!lyl"€&dòRÙ×ˆOOõş*«pñ!ÅîJf/Rî`Îuìâ6Aû&`ZaCÂqj!QB}Í¡f 6W%Z­D„ Zã¬|(m ‘gRï<x!. T	1ùõ$>Ä`v.póPæc-Lõ P4Í,Ipóİ¢Šãb&Aà+i185ĞS2²xd>:T2ûH˜U…„³,û÷kp~T4ÍIdL¼“2ew~|r#0tó.¥¹|9©5a4
1é>8ô T0ì(20V°
Xiiwq<F·-§qBõ(´Ø4/-}äås/¬Páı~"‘ó%üÚ—ñÔ0ô¢ZbZ¨‘oEhY"Ñ1¤uqüæ˜ì sq¢Vdjí¼'yïø&&Î%>c•÷f!h7-fM,qüşál,¹Ñêãpi5CKe½1m=Ez¹;÷ø}û]e0t<¤3Ó1a¹Egd83^&Ğ2Rò}>öÖ +µíoz7Q lÎ3ı…&¨rªp G¢eh/}ypa´m¼
°ŸxX%Ö½á*$ªñœì[G õAd]d8„ü*ô!" ¬0D`Ÿ0¡õñyo£ 6¸¥.D6wâÔà.åmBañ¡ÌXGA{92Ê½¡ØØ<Èô3{´;Í$:àä8ûßÚZ'M9²cjæ|0î­L$	jP(²c¢ùõFå§ù	5\"®'øèähÀ)kO0¬nE¦~;ˆ…%Ô¸8h[zE®õä`n3 :¢ê€ô"3Pw6å'¨`Dê‹ÏPáy<@H@ áÃnl¼5£Åtm
A~b°lü"©<îäeI'l•&³Ğu3/.áÆÚz¦Û ƒ­8Vdu-µ!àT!´èeA”¤'*Ç!2`Gü½È"=fE•auÄ´¹vğ0NüóàXáAJ æÄ&Ta]©#Š4mg”hH!¶ô"U£]H°¬lñyÂMMå$û)ŞÈ/|FÍ"rZ<cD&¾X/­o_íÚ)~4GYFd°ìA0u?.`‹Çsnÿ…å`äâ@"xéh,‰tüh_ŠÑé E”‚$@vu:yRRáRp¨¶"zOØBp[!DEÄ#1>‹Ÿ5sf3èe.."0Õ}egRÕŸû.Qrum3æZU|y¡«ê `v)|üÚ‘‹Ø°I`g°èJı¢€1a7÷©Ô¡nÜ‘³ x:céJÒv `O<AP"iÎG¬ÿpwWxm=ü9+K50§xìb'÷aG°LèÒÑ([œ•ÏÏv|-3·r.&€©«D0E2Ú±a#I’ğH!@uCá?âgHìUàPÍO
´­b±má/0äW`ThµngÂ¥lÔ¿
¡mnº¸l
ElAè¡±r €P2 ÊBåy!¥ZÅ[Fql}x#ïhoq8kxh®÷ï+#³_5³Â=v=²9àlL5 ÉÉÙ½l&â¤Ğ·E`RY*4FıM\d0~R7rèûK¢+e6g6İÃnzTvXğéb GÏydc]x%p4( ²oÏĞ-&ü	zTQY¤k ›e oÊÊ!B$*cjh	{9óhÌõHÅnm?w{|œ¡`Jã>Ú“,QT÷:¾~-ÚëñEŠ,^$E¥‘0biy<Vnı¼¥ŞÊ¤:p–+>I(ÈN	tóD"m³ |p›åxy\fc/	f!¨®cNÎæılO`·WPkc~$İåp­0%$8+K)°"`…,7u]xa6¦cx[<{ö¼
°á-#h]šq  $Yı¼¨{ìAúmì¬^fİ» onÃbA †8±c‹èØërt{ò‘Mgoé¶ .ï³$v‡ ò$$ ée8~ö4tqsÒ‚Ã ´³S}’Ïa,aı”pÇÁç&ƒ½ÄZpÖHgù1ªæ(áí…•³b^w{ !XL>yğ8!DZ,qu´@a*[`‚àÔoë:š(y¦d´V$y )PÈI°­&2 -a‰Ã¨fD¤sã J. N* èÊœcXë|ç`¶êO¤«4ğsÎôŠÁt	Hçw¸t½bˆ1: òeM§s0×2—*ë`sl0±‹P1!aFdDØsR&šecÖ3ÌBré"s"†gµ>èbãkÿ}"õhuHÎ§«
¤txôâdb8a¨Ejè&TÑ\'AĞ$H&°B»=R,3¤qô\"c¦7‚ã˜P›w¾5OHS‡ş	BşÒ¬t±ËĞ—,(Iâ§9êar%b7ğl¼=d¢Äï/d}ON(ª±’l!$ğÀ_ä¥ ¸¢ l²u½d¾F3~#ø8 Ç€¼r7æi2<0EhqëëcVÒKûmycsA3)h*àÚÄBÛU&#.4'“+$Vàü3~[î5;D^úFƒ3Í8iª  0`*±ã #!m¶°Ä‹¤îó¢ğÏÊã(ñG¡9»÷áM<l–×ëg ø²4!©?o6`6è\´òöøireèù`l'x/ôÅS wÅ]ejmwà5b8¨c80M[5õ(Æ[şKitdé6ĞÇv.j°;’J b¢¿1Xv2 è1¾_5bïmnN}Àp!Â.dPte¾¤°= 2[_{0¤)Í
eJDi#z’z¸ÑO}e­<ru,ŒbiTK1¸r)®ëvj!¶‚aÏ. 'Ä`à¨øO²mN7ic'¤½e`7pqÕgÚjpy¸%!_mt<½Ïy£ûå5s<Î !°„`±jOBsÈ0)Ad¢øVeg@!W)°#4 ku]æ}å£°”_!Ù_,¼ˆaw2'%L[†!néhƒ‡^?¤9%N=Ûí‰K }bb½ğ8Á¸H[l: ç25lvq"ò‹
ºtãvõU¹|é”$½¨pM>;ÙCˆ(á–.@0)&!< ÇÌYL/	ü°B(ı¡.0%ãuA`÷Dûg¤'Ä#QØaÿçáo5ğµ!¦qeèjrbh,ıçl M²´:d,â±j–"3Æ0¨ƒç1Ed‘3Zr4­D`1¸G|t
ì/kyéôëÍd 2óW¯a'¬ˆ1·(=4d)ùãCf_*eÀ*!õ©±+,±’~2vÍÇÈcv¶]jvp‹8FRL_ùl`cA²d!ê_/Ú P ËpŠnó.VaKyÁYÛ§ÜósfU¯C?†$ò» W£d¼á¬xüKAn*t$ë¨$”!¾¶!,(ûg­ŒâÕ_pöÆáâíıtÿj© ¾ì%\WçB	 ‹(´x7(oÒ}¥u_¨â*>/şIŒ)ŞyÚª"M¥`á{ĞGö†g“B9b¡ãm-éÿe†áA‚í$/bô0İîö$;kLqÕ!{J=pcì©& ˜‡\=çôfçÕ½;TbÂ¬0/`|<«q{:%Å˜ê$ŒfL£+4ò
bb´qØ.İ ‚wDx!½hÈm+DytóvÅ¡bÎ5e5=Ayéñ@?t`îúÃ=Ä4 ;+üf *Ô <âƒs¡a«w)_ã/æ/³¨¬g6sQd’Ã9wAî¡KŞ	à0²6"gˆdà)¼=Œsá#Âõôd\+ ßPTâqğ# Tr*¶¡Ap 1’Œ1û`>ûT%_©eh6[£¥#`£ÖÀÅs€gòÑ#M®]H1xcf4aŒ 1Y1	ØFa¦e@\EI>*~ÌF¯é ›‘=Dà·A"1y2à0vkQıqlDz	õ;1DÛKRç§Ó½xB(‚(`#vP,ke0º%`%=­dæÃ”!> &AO¹¤¶<avæ˜‹%~»(,Jº\cZ|¬´3¾|Âl%vl÷×ğ#m(²kyt!A7ŞŒ€I¢9ml lã´`Gp?îc(Çà14T£ÑZa!#0ş8agdÒ#Hh]e<Ä"fí]yÉyoxaºÇ`¬wsêQÜ\ò¤s:'¬èüó2c¤#iÕ¨4$ğ} çnjD61aœ2¶]?nÿ¸vQ`5ş!Õfó7b¯İëEA–µJM—~¿÷ss=na¯DxdutEiV]rQ°tI«&BNôÂäÌÆWp­mM)çHànMBz¶Jbf"o"_Hã”$,44E„<Ø™‚B¼(µB8DQ3( P`}oP˜·+o÷[-g‹xé)M9>Ïk	åDmÙë¡²©³7ù&ù!ÿQ`æ<ŠìWâ^i« •\7d?o™.o‡l(y©eº2çï|5È#"˜@(uE¶ÜDI%¨<Á >ŒMK*kg|)‹j~Ísº[à#Hix§rsa°1^
5#%M7æ|2>Øm÷ai”4"lïÌ%6´µ Cè¶bNNgxä­güh*°¾ÂÀhhv³æ©Ğ¸;,è2å3Ùd=ÎÍ1Øµ å=¶'u5	?zêsˆo‹)d, i€öú(X ¨{O{VÈ@{h7LpsWa<jù¾EòÆ5ie¤´^q³íae®Ü±%Äıe:g3á!ıSÁ™"†&Ü¸,è¹l5s^bK”  ÂÇa}3ö$1Œğ#LC:­2f¿úåy…ƒZ]Ìî.dÛ…–¬—yzî qH{v>¢i+C9®8Å¢Ä`%&de”V¬TbfòùsÙ°î‰lc1>Ç*b¤pkÿ€f|ì—Sb0o*ÔµQàg¦sü0ûhu2~úI(ödÉH `xš&Ñ4<””¶k!d_L«GMn=p#×üåÒğc+<ïf ói«   ò,c'K:L
Èeelf5ï"
Ä[`Ÿ„…~Î(<Û¸'å5¸<Pµwr?•¹˜Ô;œåñÊY4È’7â&BC|7ca4ó*%|G„}q/nš…1iw sq»wwçizá™õSj-bxsDua{ƒ<–C&¯Dóc a „)iœOP$¨yÓÓÖ·¥=¡ñ9¡61 ˜…a!?=)¡¾¡X1Ùzu·nDˆ}E"Zpí”gB3kåÉÔndës=â¯mi`HEx{Ë¢"'!ä¥Zª cÕù=Bˆf¬Pp=Uìğ”'y0Ø q Ò8ñj$&‚Ó:kÁ/“a% 1¬ú¤hÊ¾†x‰D4y5k¬f™´z'`dTBeoÔ;UAÁ FqQ w4³Ğ!„"-ô#ìh E¯
Q²e#4óO&
a#xülôtkâv8dDxnôgıK*k÷$p,O€u2!ÑÃéäğ>Skív¾/öma5ÑA²iå x‚07ë& ëOW%d0evÂÂ&æ(À–@í9Îe`wì Q0ñ-ì`cuÈu>q
ò—LsšT6fÊf×¾.Y(`³ö
w¬'¡«n7°DQBlf0E*Á1p(n™®PÏQ:F?°$ôc<+/jÀ2q>5²ìà]TÕhğqò.aNÌ%îJ¤`8«à¹ zVàQì.›q"Ò\µ E2Â©9P ¬ s6oq?gtµgm¾dTMrnõ_óvª7aq>=2~üÑxÄ*P/—µE¹pw6@z³7ëemcâËHp80€{¼>‰)Á|zE´%8l}P%0:górÄqM:ÿßÓş‘á¸€®İ1å¡Qw((v;Ãf,½X”vêÅœ)Ô$`r `| ³·"%s?Bo¤íõ3²TŞû
)jàfšÛÆu {Ét–xÌ”/§3ãi×«y)9ŸRêOc UmÒêo 5Åm¦œBE€P2Fb™Ã¦(§[-qş(1¶Ï_Ø®c{k>m£ç8l,~À|o~¥9P Œó0)T3
%ø'9:ÀM¯AOk·-°.lŒdc§`Lñ89 Ÿn…B†Êt&]s“9¨Kdw¦¸` ñ®ój÷T*µp ˆ=$pY8cÚA¹sTïDXh)Jfgn¿ögÛaxuLx€(T5¤újo5epä£  xÒÎè*e(kçÁ|{…²œ%(uœf|wÄkpbV8ìwxd¤LG` ğs&~óå>í).íhù	easÀGñ|Õ""mmœâ^-coıàfR)‘àí­ãWk¦\{I&¶` <, 6ßOr"+î~™ñ$"¬4±Ò0Ä3iñ0ôaFr4vÍjeGİÂ~ä<m«"üfwßa)oÌ:¤#şrzq0+"ñxerê÷Y-TÚ5/< ,ë	&øÊæ×”íkú#å^‹@…’½#S£÷«p4/k,µ­ğóÿmtE®`ßnĞ±u,{ƒˆ4MV5%FÖHNe£\Â9™CÏd$i'çD0y!e9ê
‘NH&f3*b÷:²™·9be(õ&cQ;ÕušCmp(òrKGmÚh84¸a:?–ô ƒú3ßR.&(x‚iZPr"j>Vönkç˜8e.I‡|nÓ
m5vòw&é£g~jr«>"ìÑ$%„Ä©ÄpàÒ!"Ä7Ÿd`Š^ƒGë²­!„ÿ1Õ´w	 ÀÏe|K  àº¦8®3`Z)á©I@Sß=p—º1^h2f'Lb1¤¯pm¯T$1ÍóeÀ Õ»¬<’06hr+¥nøL"ya}€>t6²Yâ€ÆjwJÚª©öUFh8`9£&¥oo,­r‹°ò1Ë _ Á†a`jÏp|l½ £( æpGJ)àlsn	!8)\ø€§Sãğğ	¸	T01`Ç]d ÔH(í$6wQi$±?Y£~ps¶{n³£d!ggqoÀD%løğ%ä,²bìÁ üM°'rBKo4İKLjâ-lš @Qp ä~Ä'û.†dÃàx'™¾ã5¡ºc"í,§6¸¯"‹Rà" $5 H _:BÉæ¡–n%èj(aR˜a=Yh´	ds#Ù?ue3(¸cå¶k)[Ó)xRa¸lü ¡&t°e¶3¯bğç[WeœfdA$<C“šr F€u+˜uøg¥\T“)-5èÙæh6À,â¯%“~—s+~Œ[a!*RÕ.;İ®  "!ui/İ´ ¡ tãG642¡t$Ï¥¨~- ¥¾ú*§¢h$yê¼J¤àÛä™tÍn7¤İAD.6f-2Rì£®d(ìt°ÏtDÁRH# Ò&Swó|u`H¯ò,.¸$Ö9H&ô*[`ùn“²lg (¡=º§ˆ
V9Àâ¯u¬1jŠxhlşüP%šHû)yhòF1ùyÚ„tñUDi/`$!`>‰Qà°Í*”PyæJdæ™1%"Ú!p£§,°(e£%Ç5fTÿ×‹v!¶ .{ódUo:$ºùëÎğh6á+ú„{¦s~µï•
ÃÆˆ72s3¨ğ$ªm™:,!T h,¼hl Ğf¦	ông|w™GüUüÄ™6ç94ªt0)E}^^öhà vmÀ gäö†×%õ!ç³daS_yAßâ;CãîÃ%ÍMàMu¹ÿeD)/eş’û4G4O9$ßkquó#µ I+)_ó¦)²b¤oéu &`!ŠÀ[¼`A6:´p}4%Ÿ¢k—Ec;³½1k†)%!`Î€îEtAn‹ousf‡t9p_Âa¾DÌ%wo)e"e$i(bwVÌ{É;úúp
Úaş}¨A(ñS0õvşµvÇ±zÊ(uìøRã%rY'ñğHb@DÎMrXìÂ®$ß@ofjªõüÂX%i§(y$%O’ïë¯fEšOŸ ]¦rKQSólâîhW%/í2G÷M%ÆE,şäc2iní¼|8$iwyìÃú4@cll¿¥zK 2Ÿm4Bv`h`á©j€x¸ú$}3ël-¼# b1@0£"oxæ’Å¨°½)/Pf†Ÿƒ/o¼Ï“)av÷9g“}ävD Ñ©A%#õeioa=pâ¨}$µVd…¾şK}aXa@}^²Àc#áor´:nTròeh•ü0¡&"bS•¢L·f)ß¢X±Q^¦6al]'7?ŒS‚A4sÔ•sIÈâ¯å±5ilUmNuA1 œïà,ÀP1Åx|œK«D2QÆUiÊâg~¥ö+w>fù#Œ{KBn¿ftV—9;i”!r0v"¿>;£S3!FøéZÊPÈ5(Taº°Tá¦¹J|DÍ°`ó;÷Y ?$vğ)|ùä>s4hŸ1¦FuàQ¡e{Šô§±ù² ˜j è2Õ]Òö!2{´|3Üº"9 ìiê$$ì°²ô{½âô`›Lõ =7êaçuké:9&KYe…o†<yw±—°(¯ , êw*8 5.NdhYHß¡î®)ijÂ´¥1ja[$?{ot np.allclose(residual, 0))):
            status = 2
            message = ("The problem is (trivially) infeasible because the "
                       "bounds fix all variables to values inconsistent with "
                       "the constraints")
            complete = True
            return (_LPProblem(c, A_ub, b_ub, A_eq, b_eq, bounds, x0),
                    c0, x, revstack, complete, status, message)

    ub_mod = ub
    lb_mod = lb
    if np.any(i_f):
        c0 += c[i_f].dot(lb[i_f])
        b_eq = b_eq - A_eq[:, i_f].dot(lb[i_f])
        b_ub = b_ub - A_ub[:, i_f].dot(lb[i_f])
        c = c[i_nf]
        x_undo = lb[i_f]  # not x[i_f], x is just zeroes
        x = x[i_nf]
        # user guess x0 stays separate from presolve solution x
        if x0 is not None:
            x0 = x0[i_nf]
        A_eq = A_eq[:, i_nf]
        A_ub = A_ub[:, i_nf]
        # modify bounds
        lb_mod = lb[i_nf]
        ub_mod = ub[i_nf]

        def rev(x_mod):
            # Function to restore x: insert x_undo into x_mod.
            # When elements have been removed at positions k1, k2, k3, ...
            # then these must be replaced at (after) positions k1-1, k2-2,
            # k3-3, ... in the modified array to recreate the original
            i = np.flatnonzero(i_f)
            # Number of variables to restore
            N = len(i)
            index_offset = np.arange(N)
            # Create insert indices
            insert_indices = i - index_offset
            x_rev = np.insert(x_mod.astype(float), insert_indices, x_undo)
            return x_rev

        # Use revstack as a list of functions, currently just this one.
        revstack.append(rev)

    # no constraints indicates that problem is trivial
    if A_eq.size == 0 and A_ub.size == 0:
        b_eq = np.array([])
        b_ub = np.array([])
        # test_empty_constraint_1
        if c.size == 0:
            status = 0
            message = ("The solution was determined in presolve as there are "
                       "no non-trivial constraints.")
        elif (np.any(np.logical_and(c < 0, ub_mod == np.inf)) or
              np.any(np.logical_and(c > 0, lb_mod == -np.inf))):
            # test_no_constraints()
            # test_unbounded_no_nontrivial_constraints_1
            # test_unbounded_no_nontrivial_constraints_2
            status = 3
            message = ("The problem is (trivially) unbounded "
                       "because there are no non-trivial constraints and "
                       "a) at least one decision variable is unbounded "
                       "above and its corresponding cost is negative, or "
                       "b) at least one decision variable is unbounded below "
                       "and its corresponding cost is positive. ")
        else:  # test_empty_constraint_2
            status = 0
            message = ("The solution was determined in presolve as there are "
                       "no non-trivial constraints.")
        complete = True
        x[c < 0] = ub_mod[c < 0]
        x[c > 0] = lb_mod[c > 0]
        # where c is zero, set x to a finite bound or zero
        x_zero_c = ub_mod[c == 0]
        x_zero_c[np.isinf(x_zero_c)] = ub_mod[c == 0][np.isinf(x_zero_c)]
        x_zero_c[np.isinf(x_zero_c)] = 0
        x[c == 0] = x_zero_c
        # if this is not the last step of presolve, should convert bounds back
        # to array and return here

    # Convert modified lb and ub back into N x 2 bounds
    bounds = np.hstack((lb_mod[:, np.newaxis], ub_mod[:, np.newaxis]))

    # remove redundant (linearly dependent) rows from equality constraints
    n_rows_A = A_eq.shape[0]
    redundancy_warning = ("A_eq does not appear to be of full row rank. To "
                          "improve performance, check the problem formulation "
                          "for redundant equality constraints.")
    if (sps.issparse(A_eq)):
        if rr and A_eq.size > 0:  # TODO: Fast sparse rank check?
            rr_res = _remove_redundancy_pivot_sparse(A_eq, b_eq)
            A_eq, b_eq, status, message = rr_res
            if A_eq.shape[0] < n_rows_A:
                warn(redundancy_warning, OptimizeWarning, stacklevel=1)
            if status != 0:
                complete = True
        return (_LPProblem(c, A_ub, b_ub, A_eq, b_eq, bounds, x0),
                c0, x, revstack, complete, status, message)

    # This is a wild guess for which redundancy removal algorithm will be
    # faster. More testing would be good.
    small_nullspace = 5
    if rr and A_eq.size > 0:
        try:  # TODO: use results of first SVD in _remove_redundancy_svd
            rank = np.linalg.matrix_rank(A_eq)
        # oh well, we'll have to go with _remove_redundancy_pivot_dense
        except Exception:
            rank = 0
    if rr and A_eq.size > 0 and rank < A_eq.shape[0]:
        warn(redundancy_warning, OptimizeWarning, stacklevel=3)
        dim_row_nullspace = A_eq.shape[0]-rank
        if rr_method is None:
            if dim_row_nullspace <= small_nullspace:
                rr_res = _remove_redundancy_svd(A_eq, b_eq)
                A_eq, b_eq, status, message = rr_res
            if dim_row_nullspace > small_nullspace or status == 4:
                rr_res = _remove_redundancy_pivot_dense(A_eq, b_eq)
                A_eq, b_eq, status, message = rr_res

        else:
            rr_method = rr_method.lower()
            if rr_method == "svd":
                rr_res = _remove_redundancy_svd(A_eq, b_eq)
                A_eq, b_eq, status, message = rr_res
            elif rr_method == "pivot":
                rr_res = _remove_redundancy_pivot_dense(A_eq, b_eq)
                A_eq, b_eq, status, message = rr_res
            elif rr_method == "id":
                rr_res = _remove_redundancy_id(A_eq, b_eq, rank)
                A_eq, b_eq, status, message = rr_res
            else:  # shouldn't get here; option validity checked above
                pass
        if A_eq.shape[0] < rank:
            message = ("Due to numerical issues, redundant equality "
                       "constraints could not be removed automatically. "
                       "Try providing your constraint matrices as sparse "
                       "matrices to activate sparse presolve, try turning "
                       "off redundancy removal, or try turning off presolve "
                       "altogether.")
            status = 4
        if status != 0:
            complete = True
    return (_LPProblem(c, A_ub, b_ub, A_eq, b_eq, bounds, x0),
            c0, x, revstack, complete, status, message)


def _parse_linprog(lp, options, meth):
    """
    Parse the provided linear programming problem

    ``_parse_linprog`` employs two main steps ``_check_sparse_inputs`` and
    ``_clean_inputs``. ``_check_sparse_inputs`` checks for sparsity in the
    provided constraints (``A_ub`` and ``A_eq) and if these match the provided
    sparsity optional values.

    ``_clean inputs`` checks of the provided inputs. If no violations are
    identified the objective vector, upper bound constraints, equality
    constraints, and simple bounds are returned in the expected format.

    Parameters
    ----------
    lp : A `scipy.optimize._linprog_util._LPProblem` consisting of the following fields:

        c : 1D array
            The coefficients of the linear objective function to be minimized.
        A_ub : 2D array, optional
            The inequality constraint matrix. Each row of ``A_ub`` specifies the
            coefficients of a linear inequality constraint on ``x``.
        b_ub : 1D array, optional
            The inequality constraint vector. Each element represents an
            upper bound on the corresponding value of ``A_ub @ x``.
        A_eq : 2D array, optional
            The equality constraint matrix. Each row of ``A_eq`` specifies the
            coefficients of a linear equality constraint on ``x``.
        b_eq : 1D array, optional
            The equality constraint vector. Each element of ``A_eq @ x`` must equal
            the corresponding element of ``b_eq``.
        bounds : various valid formats, optional
            The bounds of ``x``, as ``min`` and ``max`` pairs.
            If bounds are specified for all N variables separately, valid formats are:
            * a 2D array (2 x N or N x 2);
            * a sequence of N sequences, each with 2 values.
            If all variables have the same bounds, a single pair of values can
            be specified. Valid formats are:
            * a sequence with 2 scalar values;
            * a sequence with a single element containing 2 scalar values.
            If all variables have a lower bound of 0 and no upper bound, the bounds
            parameter can be omitted (or given as None).
        x0 : 1D array, optional
            Guess values of the decision variables, which will be refined by
            the optimization algorithm. This argument is currently used only by the
            'revised simplex' method, and can only be used if `x0` represents a
            basic feasible solution.

    options : dict
        A dictionary of solver options. All methods accept the following
        generic options:

            maxiter : int
                Maximum number of iterations to perform.
            disp : bool
                Set to True to print convergence messages.

        For method-specific options, see :func:`show_options('linprog')`.

    Returns
    -------
    lp : A `scipy.optimize._linprog_util._LPProblem` consisting of the following fields:

        c : 1D array
            The coefficients of the linear objective function to be minimized.
        A_ub : 2D array, optional
            The inequality constraint matrix. Each row of ``A_ub`` specifies the
            coefficients of a linear inequality constraint on ``x``.
        b_ub : 1D array, optional
            The inequality constraint vector. Each element represents an
            upper bound on the corresponding value of ``A_ub @ x``.
        A_eq : 2D array, optional
            The equality constraint matrix. Each row of ``A_eq`` specifies the
            coefficients of a linear equality constraint on ``x``.
        b_eq : 1D array, optional
            The equality constraint vector. Each element of ``A_eq @ x`` must equal
            the corresponding element of ``b_eq``.
        bounds : 2D array
            The bounds of ``x``, as ``min`` and ``max`` pairs, one for each of the N
            elements of ``x``. The N x 2 array contains lower bounds in the first
            column and upper bounds in the 2nd. Unbounded variables have lower
            bound -np.inf and/or upper bound np.inf.
        x0 : 1D array, optional
            Guess values of the decision variables, which will be refined by
            the optimization algorithm. This argument is currently used only by the
            'revised simplex' method, and can only be used if `x0` represents a
            basic feasible solution.

    options : dict, optional
        A dictionary of solver options. All methods accept the following
        generic options:

            maxiter : int
                Maximum number of iterations to perform.
            disp : bool
                Set to True to print convergence messages.

        For method-specific options, see :func:`show_options('linprog')`.

    """
    if options is None:
        options = {}

    solver_options = {k: v for k, v in options.items()}
    solver_options, A_ub, A_eq = _check_sparse_inputs(solver_options, meth,
                                                      lp.A_ub, lp.A_eq)
    # Convert lists to numpy arrays, etc...
    lp = _clean_inputs(lp._replace(A_ub=A_ub, A_eq=A_eq))
    return lp, solver_options


def _get_Abc(lp, c0):
    """
    Given a linear programming problem of the form:

    Minimize::

        c @ x

    Subject to::

        A_ub @ x <= b_ub
        A_eq @ x == b_eq
         lb <= x <= ub

    where ``lb = 0`` and ``ub = None`` unless set in ``bounds``.

    Return the problem in standard form:

    Minimize::

        c @ x

    Subject to::

        A @ x == b
            x >= 0

    by adding slack variables and making variable substitutions as necessary.

    Parameters
    ----------
    lp : A `scipy.optimize._linprog_util._LPProblem` consisting of the following fields:

        c : 1D array
            The coefficients of the linear objective function to be minimized.
        A_ub : 2D array, optional
            The inequality constraint matrix. Each row of ``A_ub`` specifies the
            coefficients of a linear inequality constraint on ``x``.
        b_ub : 1D array, optional
            The inequality constraint vector. Each element represents an
            upper bound on the corresponding value of ``A_ub @ x``.
        A_eq : 2D array, optional
            The equality constraint matrix. Each row of ``A_eq`` specifies the
            coefficients of a linear equality constraint on ``x``.
        b_eq : 1D array, optional
            The equality constraint vector. Each element of ``A_eq @ x`` must equal
            the corresponding element of ``b_eq``.
        bounds : 2D array
            The bounds of ``x``, lower bounds in the 1st column, upper
            bounds in the 2nd column. The bounds are possibly tightened
            by the presolve procedure.
        x0 : 1D array, optional
            Guess values of the decision variables, which will be refined by
            the optimization algorithm. This argument is currently used only by the
            'revised simplex' method, and can only be used if `x0` represents a
            basic feasible solution.

    c0 : float
        Constant term in objective function due to fixed (and eliminated)
        variables.

    Returns
    -------
    A : 2-D array
        2-D array such that ``A`` @ ``x``, gives the values of the equality
        constraints at ``x``.
    b : 1-D array
        1-D array of values representing the RHS of each equality constraint
        (row) in A (for standard form problem).
    c : 1-D array
        Coefficients of the linear objective function to be minimized (for
        standard form problem).
    c0 : float
        Constant term in objective function due to fixed (and eliminated)
        variables.
    x0 : 1-D array
        Starting values of the independent variables, which will be refined by
        the optimization algorithm

    References
    ----------
    .. [9] Bertsimas, Dimitris, and J. Tsitsiklis. "Introduction to linear
           programming." Athena Scientific 1 (1997): 997.

    """
    c, A_ub, b_ub, A_eq, b_eq, bounds, x0 = lp

    if sps.issparse(A_eq):
        sparse = True
        A_eq = sps.csr_matrix(A_eq)
        A_ub = sps.csr_matrix(A_ub)

        def hstack(blocks):
            return sps.hstack(blocks, format="csr")

        def vstack(blocks):
            return sps.vstack(blocks, format="csr")

        zeros = sps.csr_matrix
        eye = sps.eye
    else:
        sparse = False
        hstack = np.hstack
        vstack = np.vstack
        zeros = np.zeros
        eye = np.eye

    # Variables lbs and ubs (see below) may be changed, which feeds back into
    # bounds, so copy.
    bounds = np.array(bounds, copy=True)

    # modify problem such that all variables have only non-negativity bounds
    lbs = bounds[:, 0]
    ubs = bounds[:, 1]
    m_ub, n_ub = A_ub.shape

    lb_none = np.equal(lbs, -np.inf)
    ub_none = np.equal(ubs, np.inf)
    lb_some = np.logical_not(lb_none)
    ub_some = np.logical_not(ub_none)

    # unbounded below: substitute xi = -xi' (unbounded above)
    # if -inf <= xi <= ub, then -ub <= -xi <= inf, so swap and invert bounds
    l_nolb_someub = np.logical_and(lb_none, ub_some)
    i_nolb = np.nonzero(l_nolb_someub)[0]
    lbs[l_nolb_someub], ubs[l_nolb_someub] = (
        -ubs[l_nolb_someub], -lbs[l_nolb_someub])
    lb_none = np.equal(lbs, -np.inf)
    ub_none = np.equal(ubs, np.inf)
    lb_some = np.logical_not(lb_none)
    ub_some = np.logical_not(ub_none)
    c[i_nolb] *= -1
    if x0 is not None:
        x0[i_nolb] *= -1
    if len(i_nolb) > 0:
        if A_ub.shape[0] > 0:  # sometimes needed for sparse arrays... weird
            A_ub[:, i_nolb] *= -1
        if A_eq.shape[0] > 0:
            A_eq[:, i_nolb] *= -1

    # upper bound: add inequality constraint
    i_newub, = ub_some.nonzero()
    ub_newub = ubs[ub_some]
    n_bounds = len(i_newub)
    if n_bounds > 0:
        shape = (n_bounds, A_ub.shape[1])
        if sparse:
            idxs = (np.arange(n_bounds), i_newub)
            A_ub = vstack((A_ub, sps.csr_matrix((np.ones(n_bounds), idxs),
                                                shape=shape)))
        else:
            A_ub = vstack((A_ub, np.zeros(shape)))
            A_ub[np.arange(m_ub, A_ub.shape[0]), i_newub] = 1
        b_ub = np.concatenate((b_ub, np.zeros(n_bounds)))
        b_ub[m_ub:] = ub_newub

    A1 = vstack((A_ub, A_eq))
    b = np.concatenate((b_ub, b_eq))
    c = np.concatenate((c, np.zeros((A_ub.shape[0],))))
    if x0 is not None:
        x0 = np.concatenate((x0, np.zeros((A_ub.shape[0],))))
    # unbounded: substitute xi = xi+ + xi-
    l_free = np.logical_and(lb_none, ub_none)
    i_free = np.nonzero(l_free)[0]
    n_free = len(i_free)
    c = np.concatenate((c, np.zeros(n_free)))
    if x0 is not None:
        x0 = np.concatenate((x0, np.zeros(n_free)))
    A1 = hstack((A1[:, :n_ub], -A1[:, i_free]))
    c[n_ub:n_ub+n_free] = -c[i_free]
    if x0 is not None:
        i_free_neg = x0[i_free] < 0
        x0[np.arange(n_ub, A1.shape[1])[i_free_neg]] = -x0[i_free[i_free_neg]]
        x0[i_free[i_free_neg]] = 0

    # add slack variables
    A2 = vstack([eye(A_ub.shape[0]), zeros((A_eq.shape[0], A_ub.shape[0]))])

    A = hstack([A1, A2])

    # lower bound: substitute xi = xi' + lb
    # now there is a constant term in objective
    i_shift = np.nonzero(lb_some)[0]
    lb_shift = lbs[lb_some].astype(float)
    c0 += np.sum(lb_shift * c[i_shift])
    if sparse:
        b = b.reshape(-1, 1)
        A = A.tocsc()
        b -= (A[:, i_shift] * sps.diags(lb_shift)).sum(axis=1)
        b = b.ravel()
    else:
        b -= (A[:, i_shift] * lb_shift).sum(axis=1)
    if x0 is not None:
        x0[i_shift] -= lb_shift

    return A, b, c, c0, x0


def _round_to_power_of_two(x):
    """
    Round elements of the array to the nearest power of two.
    """
    return 2**np.around(np.log2(x))


def _autoscale(A, b, c, x0):
    """
    Scales the problem according to equilibration from [12].
    Also normalizes the right hand side vector by its maximum element.
    """
    m, n = A.shape

    C = 1
    R = 1

    if A.size > 0:

        R = np.max(np.abs(A), axis=1)
        if sps.issparse(A):
            R = R.toarray().flatten()
        R[R == 0] = 1
        R = 1/_round_to_power_of_two(R)
        A = sps.diags(R)*A if sps.issparse(A) else A*R.reshape(m, 1)
        b = b*R

        C = np.max(np.abs(A), axis=0)
        if sps.issparse(A):
            C = C.toarray().flatten()
        C[C == 0] = 1
        C = 1/_round_to_power_of_two(C)
        A = A*sps.diags(C) if sps.issparse(A) else A*C
        c = c*C

    b_scale = np.max(np.abs(b)) if b.size > 0 else 1
    if b_scale == 0:
        b_scale = 1.
    b = b/b_scale

    if x0 is not None:
        x0 = x0/b_scale*(1/C)
    return A, b, c, x0, C, b_scale


def _unscale(x, C, b_scale):
    """
    Converts solution to _autoscale problem -> solution to original problem.
    """

    try:
        n = len(C)
        # fails if sparse or scalar; that's OK.
        # this is only needed for original simplex (never sparse)
    except TypeError:
        n = len(x)

    return x[:n]*b_scale*C


def _display_summary(message, status, fun, iteration):
    """
    Print the termination summary of the linear program

    Parameters
    ----------
    message : str
            A string descriptor of the exit status of the optimization.
    status : int
        An integer representing the exit status of the optimization::

                0 : Optimization terminated successfully
                1 : Iteration limit reached
                2 : Problem appears to be infeasible
                3 : Problem appears to be unbounded
                4 : Serious numerical difficulties encountered

    fun : float
        Value of the objective function.
    iteration : iteration
        The number of iterations performed.
    """
    print(message)
    if status in (0, 1):
        print("         Current function value: {0: <12.6f}".format(fun))
    print("         Iterations: {0:d}".format(iteration))


def _postsolve(x, postsolve_args, complete=False):
    """
    Given solution x to presolved, standard form linear program x, add
    fixed variables back into the problem and undo the variable substitutions
    to get solution to original linear program. Also, calculate the objective
    function value, slack in original upper bound constraints, and residuals
    in original equality constraints.

    Parameters
    ----------
    x : 1-D array
        Solution vector to the standard-form problem.
    postsolve_args : tuple
        Data needed by _postsolve to convert the solution to the standard-form
        problem into the solution to the original problem, including:

    lp : A `scipy.optimize._linprog_util._LPProblem` consisting of the following fields:

        c : 1D array
            The coefficients of the linear objective function to be minimized.
        A_ub : 2D array, optional
            The inequality constraint matrix. Each row of ``A_ub`` specifies the
            coefficients of a linear inequality constraint on ``x``.
        b_ub : 1D array, optional
            The inequality constraint vector. Each element represents an
            upper bound on the corresponding value of ``A_ub @ x``.
        A_eq : 2D array, optional
            The equality constraint matrix. Each row of ``A_eq`` specifies the
            coefficients of a linear equality constraint on ``x``.
        b_eq : 1D array, optional
            The equality constraint vector. Each element of ``A_eq @ x`` must equal
            the corresponding element of ``b_eq``.
        bounds : 2D array
            The bounds of ``x``, lower bounds in the 1st column, upper
            bounds in the 2nd column. The bounds are possibly tightened
            by the presolve procedure.
        x0 : 1D array, optional
            Guess values of the decision variables, which will be refined by
            the optimization algorithm. This argument is currently used only by the
            'revised simplex' method, and can only be used if `x0` represents a
            basic feasible solution.

    revstack: list of functions
        the functions in the list reverse the operations of _presolve()
        the function signature is x_org = f(x_mod), where x_mod is the result
        of a presolve step and x_org the value at the start of the step
    complete : bool
        Whether the solution is was determined in presolve (``True`` if so)

    Returns
    -------
    x : 1-D array
        Solution vector to original linear programming problem
    fun: float
        optimal objective value for original problem
    slack : 1-D array
        The (non-negative) slack in the upper bound constraints, that is,
        ``b_ub - A_ub @ x``
    con : 1-D array
        The (nominally zero) residuals of the equality constraints, that is,
        ``b - A_eq @ x``
    """
    # note that all the inputs are the ORIGINAL, unmodified versions
    # no rows, columns have been removed

    (c, A_ub, b_ub, A_eq, b_eq, bounds, x0), revstack, C, b_scale = postsolve_args

    x = _unscale(x, C, b_scale)

    # Undo variable substitutions of _get_Abc()
    # if "complete", problem was solved in presolve; don't do anything here
    n_x = bounds.shape[0]
    if not complete and bounds is not None:  # bounds are never none, probably
        n_unbounded = 0
        for i, bi in enumerate(bounds):
            lbi = bi[0]
            ubi = bi[1]
            if lbi == -np.inf and ubi == np.inf:
                n_unbounded += 1
                x[i] = x[i] - x[n_x + n_unbounded - 1]
            else:
                if lbi == -np.inf:
                    x[i] = ubi - x[i]
                else:
                    x[i] += lbi
    # all the rest of the variables were artificial
    x = x[:n_x]

    # If there were variables removed from the problem, add them back into the
    # solution vector
    # Apply the functions in revstack (reverse direction)
    for rev in reversed(revstack):
        x = rev(x)

    fun = x.dot(c)
    slack = b_ub - A_ub.dot(x)  # report slack for ORIGINAL UB constraints
    # report residuals of ORIGINAL EQ constraints
    con = b_eq - A_eq.dot(x)

    return x, fun, slack, con


def _check_result(x, fun, status, slack, con, bounds, tol, message):
    """
    Check the validity of the provided solution.

    A valid (optimal) solution satisfies all bounds, all slack variables are
    negative and all equality constraint residuals are strictly non-zero.
    Further, the lower-bounds, upper-bounds, slack and residuals contain
    no nan values.

    Parameters
    ----------
    x : 1-D array
        Solution vector to original linear programming problem
    fun: float
        optimal objective value for original problem
    status : int
        An integer representing the exit status of the optimization::

             0 : Optimization terminated successfully
             1 : Iteration limit reached
             2 : Problem appears to be infeasible
             3 : Problem appears to be unbounded
             4 : Serious numerical difficulties encountered

    slack : 1-D array
        The (non-negative) slack in the upper bound constraints, that is,
        ``b_ub - A_ub @ x``
    con : 1-D array
        The (nominally zero) residuals of the equality constraints, that is,
        ``b - A_eq @ x``
    bounds : 2D array
        The bounds on the original variables ``x``
    message : str
        A string descriptor of the exit status of the optimization.
    tol : float
        Termination tolerance; see [1]_ Section 4.5.

    Returns
    -------
    status : int
        An integer representing the exit status of the optimization::

             0 : Optimization terminated successfully
             1 : Iteration limit reached
             2 : Problem appears to be infeasible
             3 : Problem appears to be unbounded
             4 : Serious numerical difficulties encountered

    message : str
        A string descriptor of the exit status of the optimization.
    """
    # Somewhat arbitrary
    tol = np.sqrt(tol) * 10

    if x is None:
        # HiGHS does not provide x if infeasible/unbounded
        if status == 0:  # Observed with HiGHS Simplex Primal
            status = 4
            message = ("The solver did not provide a solution nor did it "
                       "report a failure. Please submit a bug report.")
        return status, message

    contains_nans = (
        np.isnan(x).any()
        or np.isnan(fun)
        or np.isnan(slack).any()
        or np.isnan(con).any()
    )

    if contains_nans:
        is_feasible = False
    else:
        invalid_bounds = (x < bounds[:, 0] - tol).any() or (x > bounds[:, 1] + tol).any()
        invalid_slack = status != 3 and (slack < -tol).any()
        invalid_con = status != 3 and (np.abs(con) > tol).any()
        is_feasible = not (invalid_bounds or invalid_slack or invalid_con)

    if status == 0 and not is_feasible:
        status = 4
        message = ("The solution does not satisfy the constraints within the "
                   "required tolerance of " + "{:.2E}".format(tol) + ", yet "
                   "no errors were raised and there is no certificate of "
                   "infeasibility or unboundedness. Check whether "
                   "the slack and constraint residuals are acceptable; "
                   "if not, consider enabling presolve, adjusting the "
                   "tolerance option(s), and/or using a different method. "
                   "Please consider submitting a bug report.")
    elif status == 2 and is_feasible:
        # Occurs if the simplex method exits after phase one with a very
        # nearly basic feasible solution. Postsolving can make the solution
        # basic, however, this solution is NOT optimal
        status = 4
        message = ("The solution is feasible, but the solver did not report "
                   "that the solution was optimal. Please try a different "
                   "method.")

    return status, message
