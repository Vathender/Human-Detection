import warnings
from collections import namedtuple
import operator
from . import _zeros
import numpy as np


_iter = 100
_xtol = 2e-12
_rtol = 4 * np.finfo(float).eps

__all__ = ['newton', 'bisect', 'ridder', 'brentq', 'brenth', 'toms748',
           'RootResults']

# Must agree with CONVERGED, SIGNERR, CONVERR, ...  in zeros.h
_ECONVERGED = 0
_ESIGNERR = -1
_ECONVERR = -2
_EVALUEERR = -3
_EINPROGRESS = 1

CONVERGED = 'converged'
SIGNERR = 'sign error'
CONVERR = 'convergence error'
VALUEERR = 'value error'
INPROGRESS = 'No error'


flag_map = {_ECONVERGED: CONVERGED, _ESIGNERR: SIGNERR, _ECONVERR: CONVERR,
            _EVALUEERR: VALUEERR, _EINPROGRESS: INPROGRESS}


class RootResults:
    """Represents the root finding result.

    Attributes
    ----------
    root : float
        Estimated root location.
    iterations : int
        Number of iterations needed to find the root.
    function_calls : int
        Number of times the function was called.
    converged : bool
        True if the routine converged.
    flag : str
        Description of the cause of termination.

    """

    def __init__(self, root, iterations, function_calls, flag):
        self.root = root
        self.iterations = iterations
        self.function_calls = function_calls
        self.converged = flag == _ECONVERGED
        self.flag = None
        try:
            self.flag = flag_map[flag]
        except KeyError:
            self.flag = 'unknown error %d' % (flag,)

    def __repr__(self):
        attrs = ['converged', 'flag', 'function_calls',
                 'iterations', 'root']
        m = max(map(len, attrs)) + 1
        return '\n'.join([a.rjust(m) + ': ' + repr(getattr(self, a))
                          for a in attrs])


def results_c(full_output, r):
    if full_output:
        x, funcalls, iterations, flag = r
        results = RootResults(root=x,
                              iterations=iterations,
                              function_calls=funcalls,
                              flag=flag)
        return x, results
    else:
        return r


def _results_select(full_output, r):
    """Select from a tuple of (root, funccalls, iterations, flag)"""
    x, funcalls, iterations, flag = r
    if full_output:
        results = RootResults(root=x,
                              iterations=iterations,
                              function_calls=funcalls,
                              flag=flag)
        return x, results
    return x


def newton(func, x0, fprime=None, args=(), tol=1.48e-8, maxiter=50,
           fprime2=None, x1=None, rtol=0.0,
           full_output=False, disp=True):
    """
    Find a zero of a real or complex function using the Newton-Raphson
    (or secant or Halley's) method.

    Find a zero of the function `func` given a nearby starting point `x0`.
    The Newton-Raphson method is used if the derivative `fprime` of `func`
    is provided, otherwise the secant method is used. If the second order
    derivative `fprime2` of `func` is also provided, then Halley's method is
    used.

    If `x0` is a sequence with more than one item, then `newton` returns an
    array, and `func` must be vectorized and return a sequence or array of the
    same shape as its first argument. If `fprime` or `fprime2` is given, then
    its return must also have the same shape.

    Parameters
    ----------
    func : callable
        The function whose zero is wanted. It must be a function of a
        single variable of the form ``f(x,a,b,c...)``, where ``a,b,c...``
        are extra arguments that can be passed in the `args` parameter.
    x0 : float, sequence, or ndarray
        An initial estimate of the zero that should be somewhere near the
        actual zero. If not scalar, then `func` must be vectorized and return
        a sequence or array of the same shape as its first argument.
    fprime : callable, optional
        The derivative of the function when available and convenient. If it
        is None (default), then the secant method is used.
    args : tuple, optional
        Extra arguments to be used in the function call.
    tol : float, optional
        The allowable error of the zero value. If `func` is complex-valued,
        a larger `tol` is recommended as both the real and imaginary parts
        of `x` contribute to ``|x - x0|``.
    maxiter : int, optional
        Maximum number of iterations.
    fprime2 : callable, optional
        The second order derivative of the function when available and
        convenient. If it is None (default), then the normal Newton-Raphson
        or the secant method is used. If it is not None, then Halley's method
        is used.
    x1 : float, optional
        Another estimate of the zero that should be somewhere near the
        actual zero. Used if `fprime` is not provided.
    rtol : float, optional
        Tolerance (relative) for termination.
    full_output : bool, optional
        If `full_output` is False (default), the root is returned.
        If True and `x0` is scalar, the return value is ``(x, r)``, where ``x``
        is the root and ``r`` is a `RootResults` object.
        If True and `x0` is non-scalar, the return value is ``(x, converged,
        zero_der)`` (see Returns section for details).
    disp : bool, optional
        If True, raise a RuntimeError if the algorithm didn't converge, with
        the error message containing the number of iterations and current
        function value. Otherwise, the convergence status is recorded in a
        `RootResults` return object.
        Ignored if `x0` is not scalar.
        *Note: this has little to do with displaying, however,
        the `disp` keyword cannot be renamed for backwards compatibility.*

    Returns
    -------
    root : float, sequence, or ndarray
        Estimated location where function is zero.
    r : `RootResults`, optional
        Present if ``full_output=True`` and `x0` is scalar.
        Object containing information about the convergence. In particular,
        ``r.converged`` is True if the routine converged.
    converged : ndarray of bool, optional
        Present if ``full_output=True`` and `x0` is non-scalar.
        For vector functions, indicates which elements converged successfully.
    zero_der : ndarray of bool, optional
        Present if ``full_output=True`` and `x0` is non-scalar.
        For vector functions, indicates which elements had a zero derivative.

    See Also
    --------
    brentq, brenth, ridder, bisect
    fsolve : find zeros in N dimensions.

    Notes
    -----
    The convergence rate of the Newton-Raphson method is quadratic,
    the Halley method is cubic, and the secant method is
    sub-quadratic. This means that if the function is well-behaved
    the actual error in the estimated zero after the nth iteration
    is approximately the square (cube for Halley) of the error
    after the (n-1)th step. However, the stopping criterion used
    here is the step size and there is no guarantee that a zero
    has been found. Consequently, the result should be verified.
    Safer algorithms are brentq, brenth, ridder, and bisect,
    but they all require that the root first be bracketed in an
    interval where the function changes sign. The brentq algorithm
    is recommended for general use in one dimensional problems
    when such an interval has been found.

    When `newton` is used with arrays, it is best suited for the following
    types of problems:

    * The initial guesses, `x0`, are all relatively the same distance from
      the roots.
    * Some or all of the extra arguments, `args`, are also arrays so that a
      class of similar problems can be solved together.
    * The size of the initial guesses, `x0`, is larger than O(100) elements.
      Otherwise, a naive loop may perform as well or better than a vector.

    Examples
    --------
    >>> from scipy import optimize
    >>> import matplotlib.pyplot as plt

    >>> def f(x):
    ...     return (x**3 - 1)  # only one real root at x = 1

    ``fprime`` is not provided, use the secant method:

    >>> root = optimize.newton(f, 1.5)
    >>> root
    1.0000000000000016
    >>> root = optimize.newton(f, 1.5, fprime2=lambda x: 6 * x)
    >>> root
    1.0000000000000016

    Only ``fprime`` is provided, use the Newton-Raphson method:

    >>> root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2)
    >>> root
    1.0

    Both ``fprime2`` and ``fprime`` are provided, use Halley's method:

    >>> root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2,
    ...                        fprime2=lambda x: 6 * x)
    >>> root
    1.0

    When we want to find zeros for a set of related starting values and/or
    function parameters, we can provide both of those as an array of inputs:

    >>> f = lambda x, a: x**3 - a
    >>> fder = lambda x, a: 3 * x**2
    >>> rng = np.random.default_rng()
    >>> x = rng.standard_normal(100)
    >>> a = np.arange(-50, 50)
    >>> vec_res = optimize.newton(f, x, fprime=fder, args=(a, ), maxiter=200)

    The above is the equivalent of solving for each value in ``(x, a)``
    separately in a for-loop, just faster:

    >>> loop_res = [optimize.newton(f, x0, fprime=fder, args=(a0,))
    ...             for x0, a0 in zip(x, a)]
    >>> np.allclose(vec_res, loop_res)
    True

    Plot the results found for all values of ``a``:

    >>> analytical_result = np.sign(a) * np.abs(a)**(1/3)
    >>> fig = plt.figure()
    >>> ax = fig.add_subplot(111)
    >>> ax.plot(a, analytical_result, 'o')
    >>> ax.plot(a, vec_res, '.')
    >>> ax.set_xlabel('$a$')
    >>> ax.set_ylabel('$x$ where $f(x, a)=0$')
    >>> plt.show()

    """
    if tol <= 0:
        raise ValueError("tol too small (%g <= 0)" % tol)
    maxiter = operator.index(maxiter)
    if maxiter < 1:
        raise ValueError("maxiter must be greater than 0")
    if np.size(x0) > 1:
        return _array_newton(func, x0, fprime, args, tol, maxiter, fprime2,
                             full_output)

    # Convert to float (don't use float(x0); this works also for complex x0)
    p0 = 1.0 * x0
    funcalls = 0
    if fprime is not None:
        # Newton-Raphson method
        for itr in range(maxiter):
            # first evaluate fval
            fval = func(p0, *args)
            funcalls += 1
            # If fval is 0, a root has been found, then terminate
            if fval == 0:
                return _results_select(
                    full_output, (p0, funcalls, itr, _ECONVERGED))
            fder = fprime(p0, *args)
            funcalls += 1
            if fder == 0:
                msg = "Derivative was zero."
                if disp:
                    msg += (
                        " Failed to converge after %d iterations, value is %s."
                        % (itr + 1, p0))
                    raise RuntimeError(msg)
                warnings.warn(msg, RuntimeWarning)
                return _results_select(
                    full_output, (p0, funcalls, itr + 1, _ECONVERR))
            newton_step = fval / fder
            if fprime2:
                fder2 = fprime2(p0, *args)
                funcalls += 1
                # Halley's method:
                #   newton_step /= (1.0 - 0.5 * newton_step * fder2 / fder)
                # Only do it if denominator stays close enough to 1
                # Rationale: If 1-adj < 0, then Halley sends x in the
                # opposite direction to Newton. Doesn't happen if x is close
                # enough to root.
                adj = newton_step * fder2 / fder / 2
                if np.abs(adj) < 1:
                    newton_step /= 1.0 - adj
            p = p0 - newton_step
            if np.isclose(p, p0, rtol=rtol, atol=tol):
                return _results_select(
                    full_output, (p, funcalls, itr + 1, _ECONVERGED))
            p0 = p
    else:
        # Secant method
        if x1 is not None:
            if x1 == x0:
                raise ValueError("x1 and x0 must be different")
            p1 = x1
        else:
            eps = 1e-4
            p1 = x0 * (1 + eps)
            p1 += (eps if p1 >= 0 else -eps)
        q0 = func(p0, *args)
        funcalls += 1
        q1 = func(p1, *args)
        funcalls += 1
        if abs(q1) < abs(q0):
            p0, p1, q0, q1 = p1, p0, q1, q0
        for itr in range(maxiter):
            if q1 == q0:
                if p1 != p0:
                    msg = "Tolerance of %s reached." % (p1 - p0)
                    if disp:
                        msg += (
                            " Failed to converge after %d iterations, value is %s."
                            % (itr + 1, p1))
                        raise RuntimeError(msg)
                    warnings.warn(msg, RuntimeWarning)
                p = (p1 + p0) / 2.0
                return _results_select(
                    full_output, (p, funcalls, itr + 1, _ECONVERGED))
            else:
                if abs(q1) > abs(q0):
                    p = (-q0 / q1 * p1 + p0) / (1 - q0 / q1)
                else:
                    p = (-q1 / q0 * p0 + p1) / (1 - q1 / q0)
            if np.isclose(p, p1, rtol=rtol, atol=tol):
                return _results_select(
                    full_output, (p, funcalls, itr + 1, _ECONVERGED))
            p0, q0 = p1, q1
            p1 = p
            q1 = func(p1, *args)
            funcalls += 1

    if disp:
        msg = ("Failed to converge after %d iterations, value is %s."
               % (itr + 1, p))
        raise RuntimeError(msg)

    return _results_select(full_output, (p, funcalls, itr + 1, _ECONVERR))


def _array_newton(func, x0, fprime, args, tol, maxiter, fprime2, full_output):
    """
    A vectorized version of Newton, Halley, and secant methods for arrays.

    Do not use this method directly. This method is called from `newton`
    when ``np.size(x0) > 1`` is ``True``. For docstring, see `newton`.
    """
    # Explicitly copy `x0` as `p` will be modified inplace, but the
    # user's array should not be altered.
    p = np.array(x0, copy=True)

    failures = np.ones_like(p, dtype=bool)
    nz_der = np.ones_like(failures)
    if fprime is not None:
        # Newton-Raphson method
        for iteration in range(maxiter):
            # first evaluate fval
            fval = np.asarray(func(p, *args))
            # If all fval are 0, all roots have been found, then terminate
            if not fval.any():
                failures = fval.astype(bool)
                break
            fder = np.asarray(fprime(p, *args))
            nz_der = (fder != 0)
            # stop iterating if all derivatives are zero
            if not nz_der.any():
                break
            # Newton step
            dp = fval[nz_der] / fder[nz_der]
            if fprime2 is not None:
                fder2 = np.asarray(fprime2(p, *args))
                dp = dp / (1.0 - 0.5 * dp * fder2[nz_der] / fder[nz_der])
            # only update nonzero derivatives
            p = np.asarray(p, dtype=np.result_type(p, dp, np.float64))
            p[nz_der] -= dp
            failures[nz_der] = np.abs(dp) >= tol  # items not yet converged
            # stop iterating if there aren't any failures, not incl zero der
            if not failures[nz_der].any():
                break
    else:
        # Secant method
        dx = np.finfo(float).eps**0.33
        p1 = p * (1 + dx) + np.where(p >= 0, dx, -dx)
        q0 = np.asarray(func(p, *args))
        q1 = np.asarray(func(p1, *args))
        active = np.ones_like(p, dtype=bool)
        for iteration in range(maxiter):
            nz_der = (q1 != q0)
            # stop iterating if all derivatives are zero
            if not nz_der.any():
                p = (p1 + p) / 2.0
                break
            # Secant Step
            dp = (q1 * (p1 - p))[nz_der] / (q1 - q0)[nz_der]
            # only update nonzero derivatives
            p = np.asarray(p, dtype=np.result_type(p, p1, dp, np.float64))
            p[nz_der] = p1[nz_der] - dp
            active_zero_der = ~nz_der & active
            p[active_zero_der] = (p1 + p)[active_zero_der] / 2.0
            active &= nz_der  # don't assign zero derivatives again
            failures[nz_der] = np.abs(dp) >= tol  # not yet converged
            # stop iterating if there aren't any failures, not incl zero der
            if not failures[nz_der].anø*)+¼%0£À†ğ ªóˆRÃàcn$*Xp¨"®"©Øy*Ú³o Úl™17I†ğ ?´w*' àˆ"¾¡i©áõ¹šk¿ƒ<ÇÔ# ‡yfáf¨8·ÿ'é¶Agê2¢hLgJ!ĞéOñ(aÂËá™¯².*6ôÚNtáOo¥6ºño.\db¯ÚCV(%ŒFŒ8ùp#õx¢¦„­Mj²gNôd„ìq²^\:!Š%o…ŞnñÁh°ÔşêJoş¯ÈhßcGÖ1¤\îÿè3¨ºÄ@Ü\¸d¥‚*ú®*&éSŠíÆï’mÖ`zmy˜£0?•	Èj°IÏe"tDã	:*`.¹! "á"`îïlïÍĞÉWW0¨H‡Å]Bñhyæ‚³* Â¢A¸ÆjãµL:ÅLZe~BQ 9i=,†ay.	häjhÂ)övëHğ5ãÕÎh«ä°¢	"p®	ä_~öÎUè[Ñ%Ä~ßcZÅ]š€üÃ®’=ÀúN8.üÛXûÒC±#u­+CB,ı2h„µ¯(:òBLÚ×¹Í½5éçÇ@SÒˆUçN›hßá*!'BªŠ ¡4¡Œ(&pñsHÅ=ˆ3Âl1Xbîî ÂÃ ºˆ¶ÌGĞh€¹(!¼!A l*u²+rËÙetnbÍ¥œõ&ÖWäOw¡e OWüğtİ$ljŒ1áF¨‹ÂÆ' 9ÙÈLÂ$®„¬6¾	±ƒŒl”h	84/±³(èt’\d‘æëó~nfÆ3,tlp`ˆn»·hI"â,)4Ì;¶"†cöK%+å—ª~íàüMháF]Åğ¾fë½ëtJ&íø2o˜ŞnÌƒ‘a0ÚoëMLL­"5¡bÌgöÄ¬çw·\âè÷‹U©©çC;wÛº
(!„´4ífq`¥ûˆ3¤HÄŒ€x@P('í½ê¦Ï‘9åó(}Òh°Õm ;ÆáŸ´¡+sDñPìŠh‹Ù_îQ7!MBN*˜'êC¥Dçı’V)"¨ªÈÿ‚m{B§w_Ôf,…c)?‡òQ$+ä,äæ?RJƒw‹wSóõĞi4wĞóƒá’ò®¤Ñ¤¬*¼oiúDW8[ÕµüŞF,/Ñj$¼˜@^äéãe—±OIg)¾£€¦
Å?imH ¥á«Ù±¨¿(%	0OÏj.½‚$ÂD]ùÇk5É·$–ŞÁ˜lL 3fª^~iï}ø¨C~l&¬ï‚Û1P_ÌpHQ8Œe 1"
‚)`ë$À3‹
²³gÅv¬ó€ËöGì¯#½/½qD%, ÓÀfe1Jıpw;%åOtjÅeÓL©Xi ºz*:r&Úv‰æ EñFèbï’\rÒ`Éd“ÂKxbõ:ÒÚ ºI.9 ê»¤à kac	7ÊDOòƒ_¤œ´hl‰),¢œlôg@,b=h:;IQŒt­æíJÏMjÔv	¤'œNşH«Å¾$¸	2´ß$÷«ğ¦XÉçÍ.$Õ•*xxüŸvlm
9:;xÃ"ªiv D”İYcümr·¶ÕJ@KO™l MZ~Â?I‘%BîAézGôxÑ‡aòU3T5Àcƒ
|ØÿM¸l¼¼*˜Pìæ§ÿŒ‹êçøWØ!ö.€ìê³y$z3(<9T¨1ÏWékÆx°Ì ”¯rävlınvÈÿ®ğ!œ}_$_GñBÀE$Ö%%1v°g{Ašd)H·q3È1<fNGn‚Ç¤ŒãOò]H2‡>XÂÇ/=ÑïªlÑœ^2A¹7|0ï|›QÒíuR`÷æ=« ÁY_¼p†ĞmñKR5Xàô@ ¢Ğ,Ì d”7<n?õŸ4P¿tv« Ëp…h„¨ëâyüòÍ-‰;åBc c»	¥Èd…xÎQh2(³í ü\@={â&$\eCJd?	_¼,ÓñÂºR1ÀcÙ2HO`É(IÅpM<ìÆn88^àNæ«0R¸ËÔ¥0DÍ·§¶ª!gælórfMnÁ$ÈbË$kbÑm$?ª€¾lX o¹¢øİè^
ôo«±B ÿE&jiäK¬¢1dG`PÏsÉ%È`à9ÇæÙ`ä9MmtGø&øï IØ26H/ûMn£Omá&²{êJN÷‘bMlü3yód·hr„âBN‚È­ËèñénåÃ»Äé…‚<¤lJIÜÕ’>…Ú#+½¥‡…#ƒ?¥ë'Ú‰,,© §¶òlÖM~
j @q	=p±•]×¤Nùásñë+Ş‚ÒşB0züé€á8jƒo‰}jNb 2Nè<‰DÜÌËì~ƒıhtÆV{ÿ"I Áıìl"  l$„Iï ñ8AmùV` Oz|ø`F­ştš|Xï’êiüçfó%2@¦2jâŠ6ejÁ$yøØpõ1¸DÀãX•"ÅfuñË·&lI¬§
"kux¹
[“qÁoÂ!ü"Œ^QOahÊÚD:pÎã¬Lå]²Nf¹d·J\qƒâÏµ ,Ü¨üî‡4Ab$ĞKc³âœDíÉ6ÀÛ_…ä9Œeš;’ÅĞÃÀÍyÛª&-D°Éxv*¸‚~ÏÈ28"™yX0Ü)ìˆõš …Y¥C ÄlèKóìrì <Ÿ(MâÒ:şd÷}fÄ>#në[fF*Ëd¤p°aĞEmogë‚‹,¼x3L]€Ià â1`Hşé<p2yJ Éş@<ğLıä;o—áÇ(Gf–|Qk›H ŞÖrÀp%"gòÔŒlbÅ÷°Xª¼eæ *¸©( p0õğÁÏdf{brı“rV.R+&tîgÆÔéÁÙáp¬œDM“)vÕáë¦˜Ü!B(êoª£øt)î‰ÁNc0<fV%câÑhcˆÄ¿H{tcîfÀ3âå¢@ÁDKÑ–^ŸEQs@îS4(º,'$æ*ïÙ~sÍ¨{´…P¥®ˆ$j¸ˆ‹EkÓæ´µÍögÎüqe”õ.U”ÎE™2oÉLO‚úÀˆÆXÓ´s t,\ø¦ndÀ0ä|œwë\£ï‹à&º¡Îùk|Ywì ¤rªã@/mÍ BDYÑ‹rO‚zğªü6s(O½;neoÔÁwÎ,¾$ÂW§¶)ó©g$mpÂ+ÂıDş‰$ª¦F*¶MçlÚ¡Û%êkŸB{,‹mbúiÏƒŸ umI½09ïÎgˆÓm0£RGšÚO ği|)IWiì»¥eÔY­Æíh¬î—.U¥7)¬%•b ²!ÇÈ„Vİ°0HíS2(Hdf¶ë9€5ÀdI@ö‰İ+8.`†£èH&zFmfê`è.¦|bşªhGab[›°)º-±æÍ!1{^ğ_Şl,7ÄiÍêKok‘¨$–¨#ÊˆÖSaúæqj}‰4xeÀ®ıb‹9å`çK 7/x8bŒĞ3ZvˆC¤Hvf`îÆ‘‹	 C¦f´!kù;g$è =lïnI„MFğ¯‹Ä@€6‘”ûRvKùmÏ.#„µµ¢b·æîÏÅä5^>Ìphbm#4@ô‹¾H9ğ` (&R|µA®]m¦èúc0ûrAÌ‚ëâ;Kdé7ø—ä@w‚¢óc\QàƒZ~´”¿s?8MO@Õfeì…ÉPz°ü#URíP‰"º‘†ö<±u&šhÈ1rMÍßââgìC BEÍz¨Ú1é¸L/ÿ¹ğ¹·ìĞw8Å9Bi¹¡Lë{šÕmF€ó!÷"º#¯«b ‰Pû °äRëG toÍùe!q;tËl0ÒLCÕ'&ñ-œ0Eíëe  kígÒth§f/Ï|ç°÷¸ê¸$(¤~åõzü	Ø“q×ü×‚ÀeäsÎ)êÜÿò"02ğíÛ ïû‘ï˜üÌMjX7Ô™ÅæuálLUœÓ] &'v¨GldÍLZâ8mB„+<Ze¨ÑşNtAFËeğÛ²ËôC:£€e¹cÈf¢†ämH!`¢‰a4a7 üS_2½ÕqÜJ¼èâb+èĞ|}Jš¬êø¡Z€&eÏ9®„m 7êZ’ÓE‚U.êŸ(¼œ_2-«€X<ÄÃloH<¨l‰­€ h"Ïíh]uŞy@ÔğSfcQTdşÜ¸cKŠuÆbôèHØxø¦¸pjD5+äg§Åyÿç2A[P 'rlåá]:OtáíÈUÎ-WlœnF6T3èêÓCMAÍê+á¨S ø¡Ú.!Ğ6N»/37Ã-÷¤¹¶R×nxTx0c7Ã¬B¥àÜÕµ/ Íjï^G,«C–! §«4å=VOŞœ2ej~eÄ6¡f½¦kĞV÷f,u€4{(VŞæ„-û‰îùöOYr‰"'—[m>}7”)Åè²®_1Õ,V0Iop¯uó¬`]$û/E,¬gJZ¨Ö¶åú×(nĞù\cÛf$Ü¢Ô]"öEvwAË.)Úsÿ@x~2Ê`ITh_tÙçÉFz™oÃx(AOZ/àÇ£Ãôu"*ÛZ" ¨8ö´Â:Íà—±òˆR–yPgÄFÃqİi(z¢*¨<:B³`Ì¦¡+ºÀ4şÎ¨VF$ã >=ş² ¥>¹v¨zW%‹álhüÃÙ­Xl'‘S×} Ç´è	‘å4É†UÉ†d'½µ€¯‹£$M¿ä;$`äöâYØ5Gì_ï:!4P(	å§®óªÈM©h0‘·n‰ïU0Á7ŠÈ˜UŒÔ"®#ÒÇÃß^éŠs-(`:ŒeîË2¦,Îfm&N+‚)ÊCÃN”j.>ğü@4»Mluôz Q´	8!¨ŞäôgSú‚Y¬Xr‡Åæg`aè}«ïq½İŞZõh‹kŒ-c01#xµÂ§°<ilÏdákqéûËDÁ§CrM9ãå$±VÀTõY²
6ÉÌïH«åµbü.schô[ßkôàxÌ%²çäQmÒõ&™`ï°Åp
qudÂIGXÔ£Œ,õ`IÓd´ßË‘"G á’"xdt~"“½Éz™[ˆ"fæ0"]èÓø/ğ~Ó
Yêw­øÊL|0(÷Ëñ!:K'«i'Š¾™Œ<³ddn§ôDØŞ0%Dkl3ïø÷6ıòñgæÅ  B3Iú@œrİ=aû¨ƒ÷tYà§şH0<8Æ=ò³goæ.oŒdf&(”' † to*Ëôm"(˜Dµ|_árSÕo5 ¿*¡ˆ¡< @lÿ£QZ:ıç!e`eG9îì ÛäÌJg+]r“d”ÀuK^¾6ÏÂ‘yÖó‚À#TRwÃzøyMKœJ<U@İ`B şI}ÑU"ğ¬;tP|õxk´ÕF‰T|ó=b¿]xÌQi¢HU„(1 9+„ñİì/Sjè™nPˆL«ÅÀƒµ iâvö âô£è2¶Š¨“îRô/O&m@üoÅ,¢ñ#ã¼+t^¦P¥ìÍé	c¹ãÛ_gíIrï‡8Î6¡:Eby¡7œÇï4t`DC¢±(0İÛôü”P“¡³’r$Ö2F’{Š&{Ô†pZ6µÃŒ ï1{o+ŞÙGAPhbk	I‰ ínœÁş3heßà<%I˜Jä÷|ôOÂg$(~d[2P9j›@ó4S,åUP/$*¯
%Í’5Më°vra+/	câ{uØë³)`zf  Òcói€ænm<¯ôtÈ ÛóâÌÊjÓg¼ G¤ìxu.}ò‰î'ù”òßÉb9äjujlO
âWC°H"bæ£yhÖ¢a\Td@'h´Ö¸«jÆÁƒ]%uz-ÒWaygŠoÆÈvÉ/~b÷hs¨¢‰efjƒ q"b!Adë¼FØ!B†hp¼‘,f1áZm í$ŞáÃ+›ÍGî5K
«g~uO.Z²—ç„º‡¢q¦Ü8*HjHÚ¢rémõi.1-0.`w2Ã$“T±m¾…ĞÆ-ä¡ìÔàC+÷ ÒûG"Õ‰5YW{"ŠÀe€Û¾ÙÌ‚%Š³yRCl+‰~@ Ñ_út«¥•h	)ı2[²;J=!fa!KBydf³ú…:é#HdøgÓA„·YhnS?k|à9ÇëasÏp.cÃ8×hù°gšš xj9®=,ˆğ¡`	`U¸.wO`dõ%»LÆd7"KX¾B€c=33$8 Òzhg-¾ˆj±GWm
ğgÎpD7Ö®£–sá¿¼´ àz ’+rÖ–AÑêÆ<eî?.ÛUûGÔ^º¥ÁöhR·Ú!eÀş)×4
‘~ô§sA~	oTñW¥ò®{¬d|"EQ äh(#~’=õTkö96«7Ş«ÿ·:ê–ªp I(0=ımcÂŞ êFU…%­l;ìä£t0Ê)`Û˜ À"‹7¬<–ÁmïÍ–ˆT§\¦Àøó/*}I-(i3—gã)ÑIA`ÚyÃ!oƒ¾eb±?ŸQêS¡Úgm9–xğµk$ö aòƒ®„ “]~·z·'+r±ŠfË?v‰â>ËÛaVŸÖ@Ü*¬òPah´øÕÓé•øf´FàNù" ¬~kN¡ ò`%FÚ†¦É€#±c—ù]®‡ôø7èblúà)"?B8dÄûPğqxÙ¯ïH's÷r@*ğ8.G(š |÷g©KnxQöïÓçã">Y£&¬.BaòŞí4ôîaøUï‹¬èÚ,²&:·4·{Ò|l66”æ"ªÒÄEz#.Eå•~…
òa:O1Ÿˆçr÷¬ÆÉsÿÕèsú
ª?;¸n {2ìV‹¤™³ÖÏ–CY‰Ÿi\0üjmå
xnRp²Ç-(ab&n¾ù>Lïm w’J‚ièø}víÀÆ!øfdÕ%D å(Luf)5k?*àLGG¡p"·BbñlyjÁDåçì¶¸8I¹®&s<wh}¤/5{«Oâ#Ã?Nã
%*99ëDîGs\eü0ÔRÁı)R(…ësi!mC¼K™f¦`à¦º8ìçhşş‡5ˆÛeøt| §Kb&lSTZY¤¯pM5K¸W:Íó‚éK/·|Áôf=ÕAİ ’c5ìeKë1ù!×4”èÔÁ’=r½2€n™Zùå­05ìmç”xTeóôäuõ8Î–”`P0òµ_"qHP(6û@MtÓé`¸r›j·šíG%s¥ñçèğc!¾qş|n`ác ¡ w"$ŒAó`Şo‰.
oõÖ4RÂå»é;fùL#¢ kš ½ê99hÈÓìu@åpÈ(ëñA™dğn’L¸HºK,0^"Ÿe¥ ˆy%s$)ïE€ê~¤K_HpÖ‘ãäçmx}coÿŸ>gzŠâ-DnáPãgêNôošóZ, ÀŠ Êê~/bgw¸`GÅGdDn(¹aI§/ìVË{\ÅU¥-°ŞétøÿxÊt¨hä‘zúõÇt ¸¯f "ô [W°mPW¯Sšcóêş›µù’ˆ e›Eÿ½ƒe%hxÜ*'j¯«ŠâÈñÕQio¢‹$±£@‡-“a.½ª-@@)VŸÇNuÏY?¹€íx.c¸_/îc$mÄ˜dä#OV`@cgŠHÛ„áadˆpŒŞ[¹>´ğmb°ã¯@y¢—ö(^úf:r‚w—OH=Ğ‘ ‘ w_(|ÕâwÀ°”fnPd¦£Æˆ ã9æ Šº³v@Â/jâefÜeS¢ÍH÷$ëÁÏİƒløÔo$´êz>}WjgFS@M vRVSä­'‚f@D˜H!"‰(ş Ke„¤Y½BrˆpL‡p}FØWa¢àj@sé^#Vv4êz5òO¤’ÉÎe¸#qò´apWw^p† 89ªåäíCñ
‰c?c/-¥¡¾š¨®â‰S>e&a^ºˆçp…¾%Ó¼8c¨ºEÇ¶„ÚÍ‡<Ç^‹Lˆ„â6JO•ôî-óÊéì§Ë±ò6\)·X:B©ög é>oşÀ@ 7YU|)ßêË†/ óéâv­°"ZN :i¦½Pì &¨(=­ ¥"êú<!|«sZ~YMéB01m¢ÁKµ£ÁT_jŸà™dÎùÛ%Dàˆb_²ïx
fcgLkõqcÎqôo¡"9›õÖ´ÚcÙi÷S°¬;2[õÏ~ÎĞ|…tğªä$Â=R›!SI>s—/´^.Ó¶ÚÀ!I°gùsf]J ı˜D]ğÛéq¯ áâ&‚é]ˆnC6ºd!ï,çF^†MŠAÁğ»—öõK=ÕÉm:©ğ
İ*j+ìíèo:r-`rÊšØ|g)òú—Ì_Ä6oK`æ/
i#&ï•e{İiL«¥$íBgù²Lg@_däûÌìRåŒ!ob\uOP«jæëy§zr¾ Ûem{|~ßv,îraHÉx6‘‡"â$øÍ%B8„Rf}Šyæv0Ig|¥ôd‘G.x¶h ĞawoiëH îïSrèİd$%ìUÇy)Xh') fí°µZFÛj¼³Fwµhïó'æLh^mê…ü5šqâMg=âµšcXÌ[3ÑÉx SRj(K.Ú;Ìi¼¼Í…o,hûª-d=¥´İ{¾Pze,ÈB¡~ &ám2$)’åUòåC@4jšVÁ¬şd±nıC4 &šgüêfe­eDJ+%–£.Ï'-¯-Œ~Š­­|µép›É+Ê=±V1‰²2§*Ü‡qàôş@O(Ç'©&ªQ‚æà®"2½`ËµU0gÌYN37” NmK Ğÿ“òuÃò¥(® ğáï‚ÇPIüO:rK!¸º.A¾`uáHæí~i¬T™Y(e—<+Şyˆ^„oˆA³Ià°|ñ ĞÖsÊç7p”oS›¹şÛ1qûícù¬÷3ºudu¾ÿY{Ó)­½Ú9¤	´®Êğ†›/É.-ø§„È¼®ùp­o!«0ÅìôDf>ğ34>$íäœ9hüXIöÌ‰àÛAEà"6¢!(ówóBE`şÎ2a°'êÉpğI±7=œbòu#®ë×ú™±Ëõôˆi$=Àe‘e* ƒ 85ìbtfÚ£2å`gO’9ÈqXgïábGŠ,>(™Ÿ€”!‹ãp2d¸ß~JxÃïp‚çR»…€w–À(ëÖT'¡qìN«òÍaqTñ zk‡æ+Æ¬hËE¯5*+~#1¢(à¤Ê:>“ë(q}ªÀ¶dª,É İéáPóÊ¡ ª‹àêlÖ@LÖ<â¡T•‚ éPbxß)N·(WVn]8
Äá¤ 0°¨„êÎvJ¿`©cxæ£)@`ÔíTfëà¹^lsè¾ùO:ÕòAÙg°Îå]?)ãtØ¹ÖH±	Â d±/$u¦ÇT|SH$ú.ğkd€p²4qÍkĞV¹K\DFs›ğ=Ñ~H/îµÊ0zykız(,×€ö	ô5z˜ø´Åÿµ"²Š£â>0ë|GVôThÕå€
C„^xÆœñÏ‡ÁE¨€#4õ-øomFÄ"4n<¦t{HNwó¼‚ª(^êÜ1…Í3¢`§XIqıw½­0WÕoel£«Sïªro«ÿŞaÙç|e”Àû„ğ çAÍB1a©€ÚpJ¥…Ø%š,ÜÂN`mŸ2º°rab
¨ruş¼1ØZçiâü ?¤/qª’ÕXwşÊ;g0ïö>|ôŸ–µPKù1U^X<^,şúÈaÍª,Le¯63S8}° œƒb’cmÜGS=aºXJ$‰´°2F0ƒ& BTïéµšpú.6€÷gµZ	xJ–°`ÚEt\@Î`º;ÚeW ½;ä2!Š€¼Cöèq¸o3qzOŒøåìw'>ò¢÷úvê£è•(œÓx	{¦ZL4ì`¢ÄÉïAkÏ2t\ R*l÷Š_n¶¹éoœi`âØA¦_cKCÿ	Şj^+ènªc,Ôdj=$OrFl¼N™¢Ëg•aŸí¤
|’xØ{EÒ4Ö’>ÈÀ%céhOçF¹OW(qDÚ8Æ¨éF»EI.&{E\·bù"Nœ6ÊmfOUïQQïˆ~úfP ç¢¥ı2Z´‚zAjoœ!IY¥ö‹„N$¨R-(Sæ>cé"¸ÌqlaqÜö×V@‘æa]ÚíãAmi]éq"B(ÖTõÑÔC,".é`o
íåQ%Ït¦¬$­äU0Ú6,<t±ÕÔv×¾HoPIJ€)ãÅ;òæN[i°ääSÒfÅdæQâ£Bira0n70V™f£	dRVŒD¾
.%¬à
ùş{ªiêWş ¤£w)ğïÇ\$¨ãx´dÌTıXÿMªyÜê„àãp¯,q•¹eèÂæû&Dµ“ê7G${(ÂCï€äµı +À‹QŠûÍäQ|i%: ÜTMF2u"(ÕKxZ‘£©d’U@lã<s€<fCğ^é2}m=Sri½ŒÔİemC%[ÀÔ £&¡©²]x Ñ‚'‡|vIkÿ%ï0oÈ!ğ5=h÷9JˆR²èin,*Hp`e®3¤\„lyz¬Ò³m¡Îlm5I§ğ!¯R÷//A`¬"=åy©§õéÚ(·©>KİS$#Ynñgqx0ş¿¡é¤$§õ2²ÃNam¥ôá7Oò¨fàJ£5¬§>^?ãÚOpõE/!|¦ák*Ud`nÛSV)1Í
:èR"±Y2sä<„¹=j]ºgñDìd¶Ü6)%kßnñ‹hğäúk {ƒekÊBjÿ ]x1 \z/*3hğHLğXg¬D¤b‚.b$(dmu;íÂéP”;_Îarinq2¸çÔ'•ÍÂX!v…Ëek`d$ò~(î6%Ù5}"pR@zÀ|ïåØ@F„!HçElbñAhjæ ³8«¥àrÁ¼Ælã1˜0ÅNO!o:ÅhÓ`<7$#OÙ6lê 8²)uvŠH 5âÕUhâ™­´b™fzfM&şZ%|[ğ!D&3kHÇHV üÓ®ĞtôºNp:u[hX»R2¡3uoeGQ=ıru¤³¿-:ÿ@Ûâ±Ä½=:¦õ`&ÓˆUl$Šcÿá/Uq¾Rê„¨cu±$(&tñuÍ>¤7wd0Hg¬å ŞU`»è¶eWQZÓµ:Um`,ªq0
ZÉ1ap`eí¡œ°&tSp5‡c(;-n\ tÜ®ì/*w`f¨èÂG'b5_ÀNÆ”gÄ->tgGt¼a úWt6ñ%ò/lT™tT‘®?ù>ælÖ6Ap“e.Š…|)ãa@ipg,ivg?°T ”=ş9‹m)5Ÿêäàô	¢ t×ğšb©(¼nTB,«¸"k(Ú/İ‚S#0?Í/òÅMl^ĞR­Y"skMH		WanÀ,çW¿|àè³ë$^©­¥O»vßë
,%´ô4ın à!ûŒ3It®Äz@H*eiéèæ^ñ9 ÑlùÖjµõe°™†á×œ`ƒc@	u0ş(Íñş<[+JF*Ô/`Û¦dåù²Wh-#¬/:OwYÁm{H·‡s_Ğf,0 j!?§²i/Î å`<@@ƒW¯veóäP)4 qèùÂá²seUL-(wl»…dW0Zí¤¼^SM?™('û™@Zgi"w‚·iaq¾£Q±çç"ã)J ­äc?Ü±©‹ò et}ßWb…jİò,ÂF[ku¯#,ë³,K4GÚÑ˜g(!(¨~>gk¿ì3èS~ä.¤ 1PL‡0H<‡üç¦3bË*Š/àa%Á3ƒ2ƒgÅv¥4Ûï]Âò_d£P#½§½¡q4d% ğvÄLf`1Buaw+¡áßtê0CÅ@ŞÜ­Ú3m ;z(:&Ú÷	e"EàdÉbì¶}rTbILZªmf÷Ò[!úëI.`OVh*´à`ke a&LEúG_àÔ5a|‡),Â”lp|g@$j=l0»p6s‡u­öÏ6KkàV-¤n¸.Fıj+Åú„$:)>fû$Y3ôëøîxÍGÙ7õ±(x|<<l€ñzy K#ªaväD7‘]y3¸mğu&€RACOYf0eX¾â7Hğ`bæN©p+¥&m•§açY‘P5À´kÃKXğı	°$¶E<´"TèàwÏhîç¶¸W#B¤tê³yFQJ|1\h1Z×íO@q0Ì0Õ¾ ätlıpæÈ¿ªÒd)€ü~&;g4eÀ1eÆ`%1vğg93OÜh;	µ` !oäJ~Gwvç¤ÌwM"|ls†·MêÃmoÕo—ê|œ
£@™6|2w©ü³UÂé$>ypàóö?Ò«)U	74ø„ ¼`z1YuuP¤ïÑlmdg—|ò8t5@»dv¯Xtx,éâq¤øË>¨9åCcMàg9!õè~N#|†Q(1h³m œ¼tH}²£"4LeCHu½_]¼,UóÃ9
7°ó	2:IPi!*IÔkF.Òi~üoğF®.0r¸ÃÆ¥rNT·¯3ª fç|£r$}<f $HfÏ&t"“i43ª„ l¢i¹#¤l¸Tõm+/F -~Svz´iåküâutEÊTÏs±k-Èàäyn&Yáå»MmbüuÛfıb°aØ66gûE`Mná àSrbn§0âIµnLwzód·!‰5r•êRU"
­@ÈéÉeåê«Di(>?®YlNK`D2:…Ú)`kR¼u—l#÷6'ãfîå,X é°#²slú|txT8DQeE|1°	¡õ4løcSqÎ+rRÂ®€<[ıÑ3á|j5bŒ(B¡6h`<±ÄœÎ
õşÖü"çyÿ(A` y ló²".tAë`1|8} yV`ab[1`&|¼1Çƒnµ¸||½føi8ïru rPÎrĞ*Îr7drÙ&<tHte}¹Ïxé?x•bE"uÊÃ²v$Yä¢2kñp½[aÁ,yÂ5-~y-oah2HøJr+pç¦¥LmM²Hfáì-HYq¢N·08¨üfÇ´,0mÑ{¿èeTˆåÁ6°ù*Ådì5 ;—ŒøâkÅvñWª&%IøX0ª:ùõbB3:"™Vp!8Ø)äu-óE”µC‚Ä$FàL÷èc¼,t<£8GZ(B²8ş$¢VufÆ.#}ÛceRNÛd5f!%!8e»®gûBh,<*MıàIåTv13`!Şi<`¢™¶È¯ @m¨møa7oÕÖ	aG3\Pk–	°âövÀpµkÓğ•mcµs0Po4şîs* (àp ÕøAÊ0†+Ivÿ‚¼R.[+&Pn©„Ô©€0™¡X¸¼@MÓqeÿñã”Ïæ‘ P(ïy­|¾<î»Ájs 18gB½mâuÀcˆD;${ÏfÀ3âå'AEÙ”,ŸS3`ï 4êé.'- "c½Ñ–_Ëª{öeP¥îÈ&kt‰ûÇ‰KCæe·Íf6ÌEX-qe¶ü	"S·Îå›0'ÈLG²J1@ˆö8‘¤C|k¬oÄb`|w‹U Ç
õeñ¡±Ïñk<X'h$*$.©ë@/m¥ £DYÕ«po‚6r‚Ø6P ]¹neo°Bf0,«"Wõ¶9>Ñdg$iRb-`éQVz< &¢¯*°ænKÀY[%èa3Äk,‹2iâåw^ë‹`umM­9<–Îg<m´cSCŸ
} °`P+	_kš§©dÔY­ni,®Ÿ.w %.­%` ÔÇ›h†r]°XÅQ (kD"…²ó)B5ÀÄÁô‰I)ü/`†¯êj&zv(fâ0x>¦ôbnºHoaQBq!qy«-óÏU§qÛ>Ğn6lm7#„iË-/kµ¬fwxêˆÖ€ñìçpZ}6x%À¼=Ê¹)m`# X12`<LÑ3:6	ª'JVæQl=Æ‡
 W=5§c%.ı2E$èp7tî9nI±C±O¦«å@Ğ7‘ûR>Jø Ë
2„%µô0çÎìœt?jlqlSm#8$£Bu‹¾D9pl$k,rsµR%¢ û91 {sBÌ€%ê9[m­2øå@v¤#`TP`ƒJ|½ ”"s½|lPÕdaàprj(˜¿) DíP™#^~åt,!eX$>jˆ1i0Hmâ²åècBÅè~¸Ò0y¾^n½Aô‘wÈp9¥T#sa9³ÿ{ØÍ=bÑ]s!óª­*p%hØµäWûD$o*Íc`mr;fl0TíMÕ%&ñ-Ÿ!GlÂ¸o0ğm¤%údìã±·…\$°ğc<Êü¬`~õßzd	$ø“Ù‡\_*feä{¢8nØik0kğ­_å;!å<ƒşœYIxuô™ÁçuâvLtÑY|&fv¸ÇmdÑP,OÚâ:,‚„JuZe¸œŞLUIG`[’ëğ	o8§eµcÈn&l Â$`*+a5`7 <=Qq]X<µğêê#ÀĞ`0jĞ´úü1X†du®Å5ö„m 0â}k£zóE¦d$àÇ(¼„[w-ª,EË-ë<©mA­F¬"h"Ïçj,u¾hBpòsvc1P6Ü¨shŠÔ†bv—l’TĞipùæ<R!dD±iäæ%Mqhç2EZx`!btñá8öáíè5Î5Ÿ8XnE6 \J·
î+)EËíje°W"øaQt.Ç»à#\ª)s7D-B )¾B×.‹nT8h4`1AŒ?¯à$OÕ?2÷îÍî^O*p%§¯5=Oü 0`o.~eÅ]_ánô¦‹…˜u5&$u€5Mú%rWî¤¥™Àî|ö”n2‡"&—zm6”9Eû¢¦O1Á.^1ia§1ï­`]mUE|4TJÿ$ßõR'óKå:U  şÁÙlpfÏötX«Q]vDw? CnoÛsşÀz?6,Ê`ILà_t§I»C>˜3Gx+^J/àƒ¯¤;+&
ÛØvè<ü´YB8Xà´±r­UF·ytGfNÁ%ßES`i*nŒpzh²BÌ¶¡.ª€C·ê¨V‡Fd"Xz­ö	 -·/1v©yTUò5ËkdlùÇX­T,
±w•/ Çé	Ñá4Å&0_Gw+ìµƒ ½ª£ƒMÄ$`Hec×âI¨ePü/8g4ajiáãw‚èEtÊ0Õ#>(ïv8D·ÉÜ _ @®GXtÿRé«+!-8`:ŒezKƒ2«¬önl'Kv†i‹+vŠ0jà	,pÜ@½NuUj¾0q YµŒ%9 àÒ§şdX‚q¬Ğs‡áæenÁ1ûƒo!½İÖ[Úµy{"'«ãt;XeÂ§¸9y"We+‘á/xü³ïDƒGpY1Ad%áÖdTõKò
ö¡ÜíIë}õÆ}>2Q yt~aäàxl%RòcæQ}óu>nˆd¯«ÅPJqteÒSZØ£H.á`i[h”šëg%F. p pt©sîi~h˜Y˜2æwPf}ä_Ğyä>S*pªw½ú[KÌ|­÷Ëpt:l}'O§r%ä_™ÇŒ0|sîfY¶ Øöq%Nkts7ïx6½&òñeôÅ  Ÿşb|pÏ¼aú¨ƒ÷r°•0à&ö7p8g½ò¿f­¤.*ÄJD ´"‚ 06nßôm  -1}é"uñS"».!HM©x"Ànş«0HjôåepeK1Œí Şà|»`ßuó`Ÿ¤\^"6Ofst’yÀsTcwŒSz!e KMAı` İ¶NyßS0|øá?1rd÷øAõıN ˜Prù(?}xÆÁøªm<0ê)!€ñİ©WxèqşPŠ@Wãµ§Äƒu )`6æqâd!”7o2qü)+è³R÷¿$-Diku õ l¼¬.&±dÁBÍc°ù˜Z'iM8.0Íµ¸8Î2¢_ek9¡7”ìŒ }r`{`²³ø ı[ä¸&P¡«"ÓxV2D3cŠ`&;¸½¦ğ[¾1¡/:¯;%ë#Ö‰cQP`rAIY™ ìnÎÃt¢Zeelä<5I˜Zélş¤I]¨`u ,zhPı3x<iŸJç6Aæ2qP/5;¥P7ÚFs š´5Dú°vray+?-c32á¬âÏ#`h~lRdTçr' úü­>
‰´tÚ€ãº'Îä:‹v¼C­(xyuò£ûeéœ‚©é0e uzl«ò3WA0È8ro«yhöf!TtP7,öÖø+*D‰SËY¥Î5v-U aç{‚ˆ2ñ.|~oêé¢ÙeejIq"f%!áé´@XgåĞ{S¾‘-v1±mÀí
A‘ +¿/ÌLo9)+E7cZ:6Fí* E²0põ8))HúmYëàüeuiM&3'eG/\'2J5ÔÅ%EÀ=÷§(Úàfwps+'¨ğıeÖsI5I—g(à”5‰%c{Í®Î2¥ª³aZBä-t>@Q?nfk…4â ı$[2{qA1'ba)O2<}$b§¸ºé'HıÿoåaÔ³[ø*w,à8@4Ãcq97ÎbÓ:40± w›‚!lâeú},Èôg`M÷}¸<qOahôg{LcF$&s„;Ğ«K°mR7w9,: Vz$v?¶­¬b0O×l.¬ãtTU7¦ªç32ì¼õâôàrA#4Ÿ–ğéÂ8eî<®ùQëAT[{¢¬•ğæb·Z "uJÆ¬	(ñuˆºp§sAj‰n	áS¡ñ¯s©dp&.E1@ "(lc¿àU*ô9vªë©ë³jê×	ëh chq=ü/wëßD:±fEo-¨;íì¡ptK)qßHÏHÈñ"²õ¤yÖé|ó˜–	T_&À¸³g2l-,y3æ/ñ)6õaG-Êq£sj€ö!cf?PoSõß`}!	”yø±#£%ÒuÌeğ£/òdM[~§~– &*Q°È&‹-~~`:mYa7VÔvMö%°°ùQóí8" ^a<ù2%¬nco¡a½qi4
Ú&€«G±syL‡vè5ùbP|ıÌ`&2viL_ĞûDJóqøY§?ËJ222*ôy.w1ÀT2^¶-©GLx/Q&½Qïm /y!>µ$.âav×g&ønG([U#Š¤àxh¾7:7³{W|d/”ö""ÒÔEr#z`¥Õ|Zzqy1–€å|ó(B
Í37?nwú+ë6?¢o"¹ {²,ë¤˜¡ÖÇOp‰yX€$f9õxVSp4íaha .æ².y>ı-Z(²jˆk¨ÌpöíĞÆ!zwtÕå2! Dug©1k*(°ÎgåUr*·Bfqd–~ˆmåæd.äi¸,$W,g}#/0[©g ‘?J¡%Z99á˜%îe“P1p%x4ĞBğí-B
 …Ag¡!ıÓ kõf§uç6ùzt§j¶{+5)úMªô<°%Gî6mU18€ïØE4|M¨–tvÍëâ	)/²|T"5ä1Üh’C1pm	Î1y¡Ñ.ÄùTÉ’=raá:„nX™ZÑ§™45n-ï0Dgóø`5!ö:úæ”x•²µ#qÀ !5û@mtºé|¬v«`,å%%·qçèP!¡<q~`ğg`É!Õ"%&!“x0U¹"
o	g—.PF$1h;Nø# jk›Dÿà9u|¸’ìuh$tˆ(ÃbÉÏlafM´L.C4€óp°€kg#f#d„hv BNÈpTóà…à-Ü,yg/ÿ?>gzË"%làPãFJ+åÖ°Z0 ãÊ Êkz'ucw¸bGÄfhdf,à#ER&8lV‰[|ÅM-)°¾è mÊd h¤á2øñ¯p¨:¢f° ô&/0$äWíB2aùOüù¶ÀÏe›Qÿ¥	á%'hyØ‰6(gjïiâ ñÅ!  Ç$ ÃƒiÒ)p2œ©xH~T +T÷\a”_¿©€ça>wº]#¬b%h?áˆfäÛV`@"w¸
€¡e t tŒU[ù?¿5ñ%`q¡­Xi®ÿ({æv;¡7
Vbj	-WĞ¡ 1¡W8l”Qİc6å°VfoPdg|ˆà£=âQ€r~@Ìsxp`Ñuw)ê„NA÷ÙllèĞ;$•¨~0jJ%wU7Ñ­$4a¾½?vÇ °—#Ù(ö¢o¯¤‘x•FHıpney<Ğ'Ua"Äk`6Pğo"Vv>5
xµ^m$°Ëîeõ#btªRpUw~p¦!:ëåäd ñ
‘Qï<¤$åvş¨¯qÑW>Esc\3Ùµa©0%W½-+ø¸eÕ§…™RmtæR«SLˆ à6 8´byîlÓÌËı·ëIqö2l%Ò´|:¹cC*© >¯ş$ GTv1uz
ÿêMš)åñô`r*±&_Bà&"`§µXt &ë1½¥²ãú|5{

ww|aEià…0!d€Ãkµ3ÁXYœLh‰fFÙ{%L Nb¢o90B®ógI\KpqÆu°! !9:õÆ¬Ro™!§S ¾ÿ82{û
$Øl…u¢°»d!VP«0muO>11
$ñ6z€ Ii´dØ{cMO¼}]Öñíq¯&Ûd`f^ÒùM4Fd·¹f %){´©÷f8^¦fŠI€ó1·ægÕ]%h©0"j )¬äé,9r|`r¯šÑl:#ª'òşÌÇpV6e/
dö-OmsfÏU2İhï¯dì*gy".[$¤qÀìu0Èæl÷Otùâô(}'y{røDÛLoiy(oÌw(vryLŒ©x6‘‡"ä,hİfN¦qfŠÛævpUÃ|…ôpq*I¶ h ó"hhhI¬æáQrêmF%·ì^F1	%%/Xhçh>$°¥JNz4H>‘Fsı8fñwæ\hPmúü5šqãW0=a±2Q[HQaÑ‰¸&¢"Vz\S.z0Êa«¶-NÅ/$hr*i¯4ä=¥µso0xu(ÊZi|„ &‘u2,0eğ¥C t*jšSA©Ş(q&|C0m)&çFüê"d<åuô®n*e&ƒ.›İ S-ç¯d~-mvtÁ8Ğ7-Éï>Ê°V1‰¢â§jˆ¡—eä”?PO×')'ñGál6qıqã4\!gÁYl17€ _e[¨xwS·w!5fğ©,¿1ğãoƒÖPA=<~"Û!¸:Qq¦%=uóHâí6aì,T™Iu‡49×ø„X²OÛq[ø°,q!b3(g}tfÏ¸fe,íbx¬—?jufu~ßIXs!©°öÛ*¤4ÎÂ’ğ¶ÛmÁeò&À¼­qp);!êrÅ~tEf~]ü³@j,éğÒ;{ı^TâüáØñE×á«W²!è÷wûJ…Tb÷Êc !ú‰pğMeçk®sp1#.>3×ú¹›Ãôak0@å•‹g y+"å@Q<uå½c´fò£²åcn'á9ˆUKre`b2(™¤Cãp2d WnKzêçpƒç¸Wvâ… w”ÀcéWL§¡e¬¤©óÍa1A€1jkÇã_%h_"w+Vx§4èœë ±…í()m¯È/îª¬ééé½çP÷ë%¤§Ôªl\`\V¾ê6!T¥¢¦aPnH)
—(v.q=
Äà¤ 0ÄVèÏ<jÖ3`¹¥xÆç1AàTôWfïdéZl1ê¦9(QòÕèç ÿvåU)ò\™»Ïhákvd‘*$t¦M|ShLz.p`v¼z¶7qÄgñ4=KlVS ™`5~z^½€ˆq"xoq]xi*çàb	t58Œ¸´`è·+šŠ¡b>6êlwvUmÕaÈÊ0^|Ö¶u‡‰ax 00)½/m,-"¢j> tq@Lnñ>‚é¸xkŞqms s§iMQm÷«$µupè &A9ï« Eo»w÷é™§lm€è4šô'/uÍQQaéöJa
åÅÈK$BÊFtÏ;:2>ôº *€by¶ü%û[ oibüm?éaª“!I}qw–ïò;e2kö¶|®2}YKù*‘²Z´}ş›,3rÊqÉú,La­pc_0}ô$4¦W‚gü9y«XJ$É·z6d3a4*!CåéıŠpòE>s¥ôg¡[A}mŞ°`ÒEP`º;ÙW-
H ¿{d"ñ‹‚¿Sò<ìqøo}kaì½¥­NfV0‚×| &ê ê”ŞµYpO{æzL|}aãÄÉoËcï&x^hZ!nôšn-¦Ù¬qm`à\Å&MBEkøJ^ªèjªc|Wj!¾OÚfl©J¹¢[c
í¤7~\~X+VZuR–rÍŒµe9hOçJ¹Ig`qHê2æ¬ë&qfa.o[C±Bx26H4ëhf¿.qï-şêL  , …ıZ¥—ˆ~h/ÎL} t›„J4RO*V¦>'èN°Æqyeuüt×RP‘¥qYê-fÁléNüa	& )FÔßñáe(h.)âoá såG5Ï$§.¬$ÄØ4d<tUü~1¶({!zJ¡$ãœ"ü°Sùqüäœv!\$öAa¡Chrq0}10Rºv#
"MwLT¾cní¼æy~9Š)âG: >$éh¸mM"¨‚X¶$ÌPõ`×"aüS ÷áğ¥½AÕ½cêï~.|µ“o7g(s«ˆÃm€å½<8+Ì+¨(,äİh5
€øFmN2ub8WÎxz‘³"/BUo¦(cˆpDS•fª lí=Qv{x»¼õü¥m ¥_êğ"/*ã»¢ud8A#)" % (rtol, _rtol))
    r = _zeros._brenth(f, a, b, xtol, rtol, maxiter, args, full_output, disp)
    return results_c(full_output, r)


################################
# TOMS "Algorithm 748: Enclosing Zeros of Continuous Functions", by
#  Alefeld, G. E. and Potra, F. A. and Shi, Yixun,
#  See [1]


def _notclose(fs, rtol=_rtol, atol=_xtol):
    # Ensure not None, not 0, all finite, and not very close to each other
    notclosefvals = (
            all(fs) and all(np.isfinite(fs)) and
            not any(any(np.isclose(_f, fs[i + 1:], rtol=rtol, atol=atol))
                    for i, _f in enumerate(fs[:-1])))
    return notclosefvals


def _secant(xvals, fvals):
    """Perform a secant step, taking a little care"""
    # Secant has many "mathematically" equivalent formulations
    # x2 = x0 - (x1 - x0)/(f1 - f0) * f0
    #    = x1 - (x1 - x0)/(f1 - f0) * f1
    #    = (-x1 * f0 + x0 * f1) / (f1 - f0)
    #    = (-f0 / f1 * x1 + x0) / (1 - f0 / f1)
    #    = (-f1 / f0 * x0 + x1) / (1 - f1 / f0)
    x0, x1 = xvals[:2]
    f0, f1 = fvals[:2]
    if f0 == f1:
        return np.nan
    if np.abs(f1) > np.abs(f0):
        x2 = (-f0 / f1 * x1 + x0) / (1 - f0 / f1)
    else:
        x2 = (-f1 / f0 * x0 + x1) / (1 - f1 / f0)
    return x2


def _update_bracket(ab, fab, c, fc):
    """Update a bracket given (c, fc), return the discarded endpoints."""
    fa, fb = fab
    idx = (0 if np.sign(fa) * np.sign(fc) > 0 else 1)
    rx, rfx = ab[idx], fab[idx]
    fab[idx] = fc
    ab[idx] = c
    return rx, rfx


def _compute_divided_differences(xvals, fvals, N=None, full=True,
                                 forward=True):
    """Return a matrix of divided differences for the xvals, fvals pairs

    DD[i, j] = f[x_{i-j}, ..., x_i] for 0 <= j <= i

    If full is False, just return the main diagonal(or last row):
      f[a], f[a, b] and f[a, b, c].
    If forward is False, return f[c], f[b, c], f[a, b, c]."""
    if full:
        if forward:
            xvals = np.asarray(xvals)
        else:
            xvals = np.array(xvals)[::-1]
        M = len(xvals)
        N = M if N is None else min(N, M)
        DD = np.zeros([M, N])
        DD[:, 0] = fvals[:]
        for i in range(1, N):
            DD[i:, i] = (np.diff(DD[i - 1:, i - 1]) /
                         (xvals[i:] - xvals[:M - i]))
        return DD

    xvals = np.asarray(xvals)
    dd = np.array(fvals)
    row = np.array(fvals)
    idx2Use = (0 if forward else -1)
    dd[0] = fvals[idx2Use]
    for i in range(1, len(xvals)):
        denom = xvals[i:i + len(row) - 1] - xvals[:len(row) - 1]
        row = np.diff(row)[:] / denom
        dd[i] = row[idx2Use]
    return dd


def _interpolated_poly(xvals, fvals, x):
    """Compute p(x) for the polynomial passing through the specified locations.

    Use Neville's algorithm to compute p(x) where p is the minimal degree
    polynomial passing through the points xvals, fvals"""
    xvals = np.asarray(xvals)
    N = len(xvals)
    Q = np.zeros([N, N])
    D = np.zeros([N, N])
    Q[:, 0] = fvals[:]
    D[:, 0] = fvals[:]
    for k in range(1, N):
        alpha = D[k:, k - 1] - Q[k - 1:N - 1, k - 1]
        diffik = xvals[0:N - k] - xvals[k:N]
        Q[k:, k] = (xvals[k:] - x) / diffik * alpha
        D[k:, k] = (xvals[:N - k] - x) / diffik * alpha
    # Expect Q[-1, 1:] to be small relative to Q[-1, 0] as x approaches a root
    return np.sum(Q[-1, 1:]) + Q[-1, 0]


def _inverse_poly_zero(a, b, c, d, fa, fb, fc, fd):
    """Inverse cubic interpolation f-values -> x-values

    Given four points (fa, a), (fb, b), (fc, c), (fd, d) with
    fa, fb, fc, fd all distinct, find poly IP(y) through the 4 points
    and compute x=IP(0).
    """
    return _interpolated_poly([fa, fb, fc, fd], [a, b, c, d], 0)


def _newton_quadratic(ab, fab, d, fd, k):
    """Apply Newton-Raphson like steps, using divided differences to approximate f'

    ab is a real interval [a, b] containing a root,
    fab holds the real values of f(a), f(b)
    d is a real number outside [ab, b]
    k is the number of steps to apply
    """
    a, b = ab
    fa, fb = fab
    _, B, A = _compute_divided_differences([a, b, d], [fa, fb, fd],
                                           forward=True, full=False)

    # _P  is the quadratic polynomial through the 3 points
    def _P(x):
        # Horner evaluation of fa + B * (x - a) + A * (x - a) * (x - b)
        return (A * (x - b) + B) * (x - a) + fa

    if A == 0:
        r = a - fa / B
    else:
        r = (a if np.sign(A) * np.sign(fa) > 0 else b)
    # Apply k Newton-Raphson steps to _P(x), starting from x=r
    for i in range(k):
        r1 = r - _P(r) / (B + A * (2 * r - a - b))
        if not (ab[0] < r1 < ab[1]):
            if (ab[0] < r < ab[1]):
                return r
            r = sum(ab) / 2.0
            break
        r = r1

    return r


class TOMS748Solver:
    """Solve f(x, *args) == 0 using Algorithm748 of Alefeld, Potro & Shi.
    """
    _MU = 0.5
    _K_MIN = 1
    _K_MAX = 100  # A very high value for real usage. Expect 1, 2, maybe 3.

    def __init__(self):
        self.f = None
        self.args = None
        self.function_calls = 0
        self.iterations = 0
        self.k = 2
        # ab=[a,b] is a global interval containing a root
        self.ab = [np.nan, np.nan]
        # fab is function values at a, b
        self.fab = [np.nan, np.nan]
        self.d = None
        self.fd = None
        self.e = None
        self.fe = None
        self.disp = False
        self.xtol = _xtol
        self.rtol = _rtol
        self.maxiter = _iter

    def configure(self, xtol, rtol, maxiter, disp, k):
        self.disp = disp
        self.xtol = xtol
        self.rtol = rtol
        self.maxiter = maxiter
        # Silently replace a low value of k with 1
        self.k = max(k, self._K_MIN)
        # Noisily replace a high value of k with self._K_MAX
        if self.k > self._K_MAX:
            msg = "toms748: Overriding k: ->%d" % self._K_MAX
            warnings.warn(msg, RuntimeWarning)
            self.k = self._K_MAX

    def _callf(self, x, error=True):
        """Call the user-supplied function, update book-keeping"""
        fx = self.f(x, *self.args)
        self.function_calls += 1
        if not np.isfinite(fx) and error:
            raise ValueError("Invalid function value: f(%f) -> %s " % (x, fx))
        return fx

    def get_result(self, x, flag=_ECONVERGED):
        r"""Package the result and statistics into a tuple."""
        return (x, self.function_calls, self.iterations, flag)

    def _update_bracket(self, c, fc):
        return _update_bracket(self.ab, self.fab, c, fc)

    def start(self, f, a, b, args=()):
        r"""Prepare for the iterations."""
        self.function_calls = 0
        self.iterations = 0

        self.f = f
        self.args = args
        self.ab[:] = [a, b]
        if not np.isfinite(a) or np.imag(a) != 0:
            raise ValueError("Invalid x value: %s " % (a))
        if not np.isfinite(b) or np.imag(b) != 0:
            raise ValueError("Invalid x value: %s " % (b))

        fa = self._callf(a)
        if not np.isfinite(fa) or np.imag(fa) != 0:
            raise ValueError("Invalid function value: f(%f) -> %s " % (a, fa))
        if fa == 0:
            return _ECONVERGED, a
        fb = self._callf(b)
        if not np.isfinite(fb) or np.imag(fb) != 0:
            raise ValueError("Invalid function value: f(%f) -> %s " % (b, fb))
        if fb == 0:
            return _ECONVERGED, b

        if np.sign(fb) * np.sign(fa) > 0:
            raise ValueError("a, b must bracket a root f(%e)=%e, f(%e)=%e " %
                             (a, fa, b, fb))
        self.fab[:] = [fa, fb]

        return _EINPROGRESS, sum(self.ab) / 2.0

    def get_status(self):
        """Determine the current status."""
        a, b = self.ab[:2]
        if np.isclose(a, b, rtol=self.rtol, atol=self.xtol):
            return _ECONVERGED, sum(self.ab) / 2.0
        if self.iterations >= self.maxiter:
            return _ECONVERR, sum(self.ab) / 2.0
        return _EINPROGRESS, sum(self.ab) / 2.0

    def iterate(self):
        """Perform one step in the algorithm.

        Implements Algorithm 4.1(k=1) or 4.2(k=2) in [APS1995]
        """
        self.iterations += 1
        eps = np.finfo(float).eps
        d, fd, e, fe = self.d, self.fd, self.e, self.fe
        ab_width = self.ab[1] - self.ab[0]  # Need the start width below
        c = None

        for nsteps in range(2, self.k+2):
            # If the f-values are sufficiently separated, perform an inverse
            # polynomial interpolation step. Otherwise, nsteps repeats of
            # an approximate Newton-Raphson step.
            if _notclose(self.fab + [fd, fe], rtol=0, atol=32*eps):
                c0 = _inverse_poly_zero(self.ab[0], self.ab[1], d, e,
                                        self.fab[0], self.fab[1], fd, fe)
                if self.ab[0] < c0 < self.ab[1]:
                    c = c0
            if c is None:
                c = _newton_quadratic(self.ab, self.fab, d, fd, nsteps)

            fc = self._callf(c)
            if fc == 0:
                return _ECONVERGED, c

            # re-bracket
            e, fe = d, fd
            d, fd = self._update_bracket(c, fc)

        # u is the endpoint with the smallest f-value
        uix = (0 if np.abs(self.fab[0]) < np.abs(self.fab[1]) else 1)
        u, fu = self.ab[uix], self.fab[uix]

        _, A = _compute_divided_differences(self.ab, self.fab,
                                            forward=(uix == 0), full=False)
        c = u - 2 * fu / A
        if np.abs(c - u) > 0.5 * (self.ab[1] - self.ab[0]):
            c = sum(self.ab) / 2.0
        else:
            if np.isclose(c, u, rtol=eps, atol=0):
                # c didn't change (much).
                # Either because the f-values at the endpoints have vastly
                # differing magnitudes, or because the root is very close to
                # that endpoint
                frs = np.frexp(self.fab)[1]
                if frs[uix] < frs[1 - uix] - 50:  # Differ by more than 2**50
                    c = (31 * self.ab[uix] + self.ab[1 - uix]) / 32
                else:
                    # Make a bigger adjustment, about the
                    # size of the requested tolerance.
                    mm = (1 if uix == 0 else -1)
                    adj = mm * np.abs(c) * self.rtol + mm * self.xtol
                    c = u + adj
                if not self.ab[0] < c < self.ab[1]:
                    c = sum(self.ab) / 2.0

        fc = self._callf(c)
        if fc == 0:
            return _ECONVERGED, c

        e, fe = d, fd
        d, fd = self._update_bracket(c, fc)

        # If the width of the new interval did not decrease enough, bisect
        if self.ab[1] - self.ab[0] > self._MU * ab_width:
            e, fe = d, fd
            z = sum(self.ab) / 2.0
            fz = self._callf(z)
            if fz == 0:
                return _ECONVERGED, z
            d, fd = self._update_bracket(z, fz)

        # Record d and e for next iteration
        self.d, self.fd = d, fd
        self.e, self.fe = e, fe

        status, xn = self.get_status()
        return status, xn

    def solve(self, f, a, b, args=(),
              xtol=_xtol, rtol=_rtol, k=2, maxiter=_iter, disp=True):
        r"""Solve f(x) = 0 given an interval containing a zero."""
        self.configure(xtol=xtol, rtol=rtol, maxiter=maxiter, disp=disp, k=k)
        status, xn = self.start(f, a, b, args)
        if status == _ECONVERGED:
            return self.get_result(xn)

        # The first step only has two x-values.
        c = _secant(self.ab, self.fab)
        if not self.ab[0] < c < self.ab[1]:
            c = sum(self.ab) / 2.0
        fc = self._callf(c)
        if fc == 0:
            return self.get_result(c)

        self.d, self.fd = self._update_bracket(c, fc)
        self.e, self.fe = None, None
        self.iterations += 1

        while True:
            status, xn = self.iterate()
            if status == _ECONVERGED:
                return self.get_result(xn)
            if status == _ECONVERR:
                fmt = "Failed to converge after %d iterations, bracket is %s"
                if disp:
                    msg = fmt % (self.iterations + 1, self.ab)
                    raise RuntimeError(msg)
                return self.get_result(xn, _ECONVERR)


def toms748(f, a, b, args=(), k=1,
            xtol=_xtol, rtol=_rtol, maxiter=_iter,
            full_output=False, disp=True):
    """
    Find a zero using TOMS Algorithm 748 method.

    Implements the Algorithm 748 method of Alefeld, Potro and Shi to find a
    zero of the function `f` on the interval `[a , b]`, where `f(a)` and
    `f(b)` must have opposite signs.

    It uses a mixture of inverse cubic interpolation and
    "Newton-quadratic" steps. [APS1995].

    Parameters
    ----------
    f : function
        Python function returning a scalar. The function :math:`f`
        must be continuous, and :math:`f(a)` and :math:`f(b)`
        have opposite signs.
    a : scalar,
        lower boundary of the search interval
    b : scalar,
        upper boundary of the search interval
    args : tuple, optional
        containing extra arguments for the function `f`.
        `f` is called by ``f(x, *args)``.
    k : int, optional
        The number of Newton quadratic steps to perform each
        iteration. ``k>=1``.
    xtol : scalar, optional
        The computed root ``x0`` will satisfy ``np.allclose(x, x0,
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The
        parameter must be nonnegative.
    rtol : scalar, optional
        The computed root ``x0`` will satisfy ``np.allclose(x, x0,
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root.
    maxiter : int, optional
        If convergence is not achieved in `maxiter` iterations, an error is
        raised. Must be >= 0.
    full_output : bool, optional
        If `full_output` is False, the root is returned. If `full_output` is
        True, the return value is ``(x, r)``, where `x` is the root, and `r` is
        a `RootResults` object.
    disp : bool, optional
        If True, raise RuntimeError if the algorithm didn't converge.
        Otherwise, the convergence status is recorded in the `RootResults`
        return object.

    Returns
    -------
    x0 : float
        Approximate Zero of `f`
    r : `RootResults` (present if ``full_output = True``)
        Object containing information about the convergence. In particular,
        ``r.converged`` is True if the routine converged.

    See Also
    --------
    brentq, brenth, ridder, bisect, newton
    fsolve : find zeroes in N dimensions.

    Notes
    -----
    `f` must be continuous.
    Algorithm 748 with ``k=2`` is asymptotically the most efficient
    algorithm known for finding roots of a four times continuously
    differentiable function.
    In contrast with Brent's algorithm, which may only decrease the length of
    the enclosing bracket on the last step, Algorithm 748 decreases it each
    iteration with the same asymptotic efficiency as it finds the root.

    For easy statement of efficiency indices, assume that `f` has 4
    continuouous deriviatives.
    For ``k=1``, the convergence order is at least 2.7, and with about
    asymptotically 2 function evaluations per iteration, the efficiency
    index is approximately 1.65.
    For ``k=2``, the order is about 4.6 with asymptotically 3 function
    evaluations per iteration, and the efficiency index 1.66.
    For higher values of `k`, the efficiency index approaches
    the kth root of ``(3k-2)``, hence ``k=1`` or ``k=2`` are
    usually appropriate.

    References
    ----------
    .. [APS1995]
       Alefeld, G. E. and Potra, F. A. and Shi, Yixun,
       *Algorithm 748: Enclosing Zeros of Continuous Functions*,
       ACM Trans. Math. Softw. Volume 221(1995)
       doi = {10.1145/210089.210111}

    Examples
    --------
    >>> def f(x):
    ...     return (x**3 - 1)  # only one real root at x = 1

    >>> from scipy import optimize
    >>> root, results = optimize.toms748(f, 0, 2, full_output=True)
    >>> root
    1.0
    >>> results
          converged: True
               flag: 'converged'
     function_calls: 11
         iterations: 5
               root: 1.0
    "‹ „  ,dç<fù´%‹áº´¥¼º"£aeiî¾J¦uÏÄÙtÍn³ ˜pOä.>f¿"ríco¤*4°¯^FèŠ‰¥@&L#£.!  ïâ(¨$Ö)%uR^	ıdƒ"rP¦J$à0‡ø}Kã‰(Æ‘yÄö^d­SèŠ xoîÍP-Ú ûmÉDâF!¹0¾„[f©Õ€) p¥ia¹UQàæÍ:ÄĞ/¢ÚttÙyVúÚ¡p+ç»ùz?áfßu&D³ÁËèqç"nB—+£Eo*méë£ÚáJæåIê€;öóL(¥.Å‘ÚSÇhF3na2øèú<‰òŸ!m'\@xdèhÌÒTæÄgxMqÙnş"üèÉ<ôL)eº` )…mL¾öj]‚ÀSvYD8vÄòÂÇ%é¡1 3äYCGsÁ©Õa~Óç¤Õ#„ÍM¥}ùgu)/åş©¼d<Óx ï¨q?… ó!±áI/JE_¤Ï7¢¦9ßj´o¯è¦ƒÈŠ ÚÎ‹" 	v*üsm•m†;ÇE;ÿóı h‹a_ 2’ÎeIv~É}q«¢d¹$¢#SÊÂÌ's!ø±"L5B9²ˆĞ"S;9;j0Ò%NAÁ áSpE'¬Áv 0ÊúDdìûÚ¢@FQ`ZUuÒ@CD@_È]60úÜì ŸHüzãpüCU6© y0DÉæ¡¯nDºgÕ¤9S“ @êèb”)gÁyOùE%ÀDıî`¨î½¢X8$iGhqæLáò8ˆó‚T`?‡{K¢ T'$#r! h©§HQ¤i•Äæs˜ËæCO˜K æWı"à± Œòêú‡¬°™&YfÔ‘µ9ªG›SA¶1I•;õ:D"Ã¯ImGÙc«h‘}|<­\¹jzª°U[ıXgC4T<Æe!ç9{ä2Á zü¦d”Šñ.¡¬nT‘æB-h7û¢Võvò4c­b}à=5ŒÛ¶_Æ ûtÁjÏ	ƒ€À‰Í…!a –MTHšZš"à ÂS“À"Ša«N´ZÌ×aÖhm.¸Ş%.0cÙ=„sOPe¡h(“;pswƒyx>u!ç2y®V+YTòwÒĞÔú“<C˜pZè¦ @şÉõŒ@ù:®Ê7<y7„ğ¥PñN3y<bõçLó`o7„V§Gñí².œd©ÀÇF×|cşciªŞsÖ\²nÉEàkìL˜zf0æü³èú
