"""Revised simplex method for linear programming

The *revised simplex* method uses the method described in [1]_, except
that a factorization [2]_ of the basis matrix, rather than its inverse,
is efficiently maintained and used to solve the linear systems at each
iteration of the algorithm.

.. versionadded:: 1.3.0

References
----------
.. [1] Bertsimas, Dimitris, and J. Tsitsiklis. "Introduction to linear
           programming." Athena Scientific 1 (1997): 997.
.. [2] Bartels, Richard H. "A stabilization of the simplex method."
            Journal in  Numerische Mathematik 16.5 (1971): 414-434.

"""
# Author: Matt Haberland

import numpy as np
from scipy.linalg import solve
from .optimize import _check_unknown_options
from ._bglu_dense import LU
from ._bglu_dense import BGLU as BGLU
from scipy.linalg import LinAlgError
from numpy.linalg.linalg import LinAlgError as LinAlgError2
from ._linprog_util import _postsolve
from .optimize import OptimizeResult


def _phase_one(A, b, x0, callback, postsolve_args, maxiter, tol, disp,
               maxupdate, mast, pivot):
    """
    The purpose of phase one is to find an initial basic feasible solution
    (BFS) to the original problem.

    Generates an auxiliary problem with a trivial BFS and an objective that
    minimizes infeasibility of the original problem. Solves the auxiliary
    problem using the main simplex routine (phase two). This either yields
    a BFS to the original problem or determines that the original problem is
    infeasible. If feasible, phase one detects redundant rows in the original
    constraint matrix and removes them, then chooses additional indices as
    necessary to complete a basis/BFS for the original problem.
    """

    m, n = A.shape
    status = 0

    # generate auxiliary problem to get initial BFS
    A, b, c, basis, x, status = _generate_auxiliary_problem(A, b, x0, tol)

    if status == 6:
        residual = c.dot(x)
        iter_k = 0
        return x, basis, A, b, residual, status, iter_k

    # solve auxiliary problem
    phase_one_n = n
    iter_k = 0
    x, basis, status, iter_k = _phase_two(c, A, x, basis, callback,
                                          postsolve_args,
                                          maxiter, tol, disp,
                                          maxupdate, mast, pivot,
                                          iter_k, phase_one_n)

    # check for infeasibility
    residual = c.dot(x)
    if status == 0 and residual > tol:
        status = 2

    # drive artificial variables out of basis
    # TODO: test redundant row removal better
    # TODO: make solve more efficient with BGLU? This could take a while.
    keep_rows = np.ones(m, dtype=bool)
    for basis_column in basis[basis >= n]:
        B = A[:, basis]
        try:
            basis_finder = np.abs(solve(B, A))  # inefficient
            pertinent_row = np.argmax(basis_finder[:, basis_column])
            eligible_columns = np.ones(n, dtype=bool)
            eligible_columns[basis[basis < n]] = 0
            eligible_column_indices = np.where(eligible_columns)[0]
            index = np.argmax(basis_finder[:, :n]
                              [pertinent_row, eligible_columns])
            new_basis_column = eligible_column_indices[index]
            if basis_finder[pertinent_row, new_basis_column] < tol:
                keep_rows[pertinent_row] = False
            else:
                basis[basis == basis_column] = new_basis_column
        except (LinAlgError, LinAlgError2):
            status = 4

    # form solution to original problem
    A = A[keep_rows, :n]
    basis = basis[keep_rows]
    x = x[:n]
    m = A.shape[0]
    return x, basis, A, b, residual, status, iter_k


def _get_more_basis_columns(A, basis):
    """
    Called when the auxiliary problem terminates with artificial columns in
    the basis, which must be removed and replaced with non-artificial
    columns. Finds additional columns that do not make the matrix singular.
    """
    m, n = A.shape

    # options for inclusion are those that aren't already in the basis
    a = np.arange(m+n)
    bl = np.zeros(len(a), dtype=bool)
    bl[basis] = 1
    options = a[~bl]
    options = options[options < n]  # and they have to be non-artificial

    # form basis matrix
    B = np.zeros((m, m))
    B[:, 0:len(basis)] = A[:, basis]

    if (basis.size > 0 and
            np.linalg.matrix_rank(B[:, :len(basis)]) < len(basis)):
        raise Exception("Basis has dependent columns")

    rank = 0  # just enter the loop
    for i in range(n):  # somewhat arbitrary, but we need another way out
        # permute the options, and take as many as needed
        new_basis = np.random.permutation(options)[:m-len(basis)]
        B[:, len(basis):] = A[:, new_basis]  # update the basis matrix
        rank = np.linalg.matrix_rank(B)      # check the rank
        if rank == m:
            break

    return np.concatenate((basis, new_basis))


def _generate_auxiliary_problem(A, b, x0, tol):
    """
    Modifies original problem to create an auxiliary problem with a trivial
    initial basic feasible solution and an objective that minimizes
    infeasibility in the original problem.

    Conceptually, this is done by stacking an identity matrix on the right of
    the original constraint matrix, adding artificial variables to correspond
    with each of these new columns, and generating a cost vector that is all
    zeros except for ones corresponding with each of the new variables.

    A initial basic feasible solution is trivial: all variables are zero
    except for the artificial variables, which are set equal to the
    corresponding element of the right hand side `b`.

    Runnning the simplex method on this auxiliary problem drives all of the
    artificial variables - and thus the cost - to zero if the original problem
    is feasible. The original problem is declared infeasible otherwise.

    Much of the complexity below is to improve efficiency by using singleton
    columns in the original problem where possible, thus generating artificial
    variables only as necessary, and using an initial 'guess' basic feasible
    solution.
    """
    status = 0
    m, n = A.shape

    if x0 is not None:
        x = x0
    else:
        x = np.zeros(n)

    r = b - A@x  # residual; this must be all zeros for feasibility

    A[r < 0] = -A[r < 0]  # express problem with RHS positive for trivial BFS
    b[r < 0] = -b[r < 0]  # to the auxiliary problem
    r[r < 0] *= -1

    # Rows which we will need to find a trivial way to zero.
    # This should just be the rows where there is a nonzero residual.
    # But then we would not necessarily have a column singleton in every row.
    # This makes it difficult to find an initial basis.
    if x0 is None:
        nonzero_constraints = np.arange(m)
    else:
        nonzero_constraints = np.where(r > tol)[0]

    # these are (at least some of) the initial basis columns
    basis = np.where(np.abs(x) > tol)[0]

    if len(nonzero_constraints) == 0 and len(basis) <= m:  # already a BFS
        c = np.zeros(n)
        basis = _get_more_basis_columns(A, basis)
        return A, b, c, basis, x, status
    elif (len(nonzero_constraints) > m - len(basis) or
          np.any(x < 0)):  # can't get trivial BFS
        c = np.zeros(n)
        status = 6
        return A, b, c, basis, x, status

    # chooses existing columns appropriate for inclusion in initial basis
    cols, rows = _select_singleton_columns(A, r)

    # find the rows we need to zero that we _can_ zero with column singletons
    i_tofix = np.isin(rows, nonzero_constraints)
    # these columns can't already be in the basis, though
    # we are going to add them to the basis and change the corresponding x val
    i_notinbasis = np.logical_not(np.isin(cols, basis))
    i_fix_without_aux = np.logical_and(i_tofix, i_notinbasis)
    rows = rows[i_fix_without_aux]
    cols = cols[i_fix_without_aux]

    # indices of the rows we can only zero with auxiliary variable
    # these rows will get a one in each auxiliary column
    arows = nonzero_constraints[np.logical_not(
                                np.isin(nonzero_constraints, rows))]
    n_aux = len(arows)
    acols = n + np.arange(n_aux)          # indices of auxiliary columns

    basis_ng = np.concatenate((cols, acols))   # basis columns not from guess
    basis_ng_rows = np.concatenate((rows, arows))  # rows we need to zero

    # add auxiliary singleton columns
    A = np.hstack((A, np.zeros((m, n_aux))))
    A[arows, acols] = 1

    # generate initial BFS
    x = np.concatenate((x, np.zeros(n_aux)))
    x[basis_ng] = r[basis_ng_rows]/A[basis_ng_rows, basis_ng]

    # generate costs to minimize infeasibility
    c = np.zeros(n_aux + n)
    c[acols] = 1

    # basis columns correspond with nonzeros in guess, those with column
    # singletons we used to zero remaining constraints, and any additional
    # columns to get a full set (m columns)
    basis = np.concatenate((basis, basis_ng))
    basis = _get_more_basis_columns(A, basis)  # add columns as needed

    return A, b, c, basis, x, status


def _select_singleton_columns(A, b):
    """
    Finds singleton columns for which the singleton entry is of the same sign
    as the right-hand side; these columns are eligible for inclusion in an
    initial basis. Determines the rows in which the singleton entries are
    located. For each of these rows, returns the indices of the one singleton
    column and its corresponding row.
    """
    # find indices of all singleton columns and corresponding row indicies
    column_indices = np.nonzero(np.sum(np.abs(A) != 0, axis=0) == 1)[0]
    columns = A[:, column_indices]          # array of singleton columns
    row_indices = np.zeros(len(column_indices), dtype=int)
    nonzero_rows, nonzero_columns = np.nonzero(columns)
    row_indices[nonzero_columns] = nonzero_rows   # corresponding row indicies

    # keep only singletons with entries that have same sign as RHS
    # this is necessary because all elements of BFS must be non-negative
    same_sign = A[row_indices, column_indices]*b[row_indices] >= 0
    column_indices = column_indices[same_sign][::-1]
    row_indices = row_indices[same_sign][::-1]
    # Reversing the order so that steps below select rightmost columns
    # for initial basis, which will tend to be slack variables. (If the
    # guess corresponds with a basic feasible solution but a constraint
    # is not satisfied with the corresponding slack variable zero, the slack
    # variable must be basic.)

    # for each row, keep rightmost singleton column with an entry in that row
    unique_row_indices, first_columns = np.unique(row_indices,
                                                  return_index=True)
    return column_indices[first_columns], unique_row_indices


def _find_nonzero_rows(A, tol):
    """
    Returns logical array indicating the locations of rows with at least
    one nonzero element.
    """
    return np.any(np.abs(A) > tol, axis=1)


def _select_enter_pivot(c_hat, bl, a, rule="bland", tol=1e-12):
    """
    Selects a pivot to enter the basis. Currently Bland's rule - the smallest
    index that has a negative reduced cost - is the default.
    """
    if rule.lower() == "mrc":  # index with minimum reduced cost
        return a[~bl][np.argmin(c_hat)]
    else:  # smallest index w/ negative reduced cost
        return a[~bl][c_hat < -tol][0]


def _display_iter(phase, iteration, slack, con, fun):
    """
    Print indicators of optimization status to the console.
    """
    header = True if not iteration % 20 else False

    if header:
        print("Phase",
              "Iteration",
              "Minimum Slack      ",
              "Constraint Residual",
              "Objective          ")

    # :<X.Y left aligns Y digits in X digit spaces
    fmt = '{0:<6}{1:<10}{2:<20.13}{3:<20.13}{4:<20.13}'
    try:
        slack = np.min(slack)
    except ValueError:
        slack = "NA"
    print(fmt.format(phase, iteration, slack, np.linalg.norm(con), fun))


def _display_and_callback(phase_one_n, x, postsolve_args, status,
                          iteration, disp, callback):
    if phase_one_n is not None:
        phase = 1
        x_postsolve = x[:phase_one_n]
    else:
        phase = 2
        x_postsolve = x
    x_o, fun, slack, con = _postsolve(x_postsolve,
                                      postsolve_args)

    if callback is not None:
        res = OptimizeResult({'x': x_o, 'fun': fun, 'slack': slack,
                              'con': con, 'nit': iteration,
                              'phase': phase, 'complete': False,
                              'status': status, 'message': "",
                              'success': False})
        callback(res)
    if disp:
        _display_iter(phase, iteration, slack, con, fun)


def _phase_two(c, A, x, b, callback, postsolve_args, maxiter, tol, disp,
               maxupdate, mast, pivot, iteration=0, phase_one_n=None):
    """
    The heart of the simplex method. Beginning with a basic feasible solution,
    moves to adjacent basic feasible solutions successively lower reduced cost.
    Terminates when there are no basic feasible solutions with lower reduced
    cost or if the problem is determined to be unbounded.

    This implementation follows the revised simplex method based on LU
    decomposition. Rather than maintaining a tableau or an inverse of the
    basis matrix, we keep a factorization of the basis matrix that allows
    efficient solution of linear systems while avoiding stability issues
    associated with inverted matrices.
    """
    m, n = A.shape
    status = 0
    a = np.arange(n)                    # indices of columns of A
    ab = np.arange(m)                   # indices of columns of B
    if maxupdate:
        # basis matrix factorization object; similar to B = A[:, b]
        B = BGLU(A, b, maxupdate, mast)
    else:
        B = LU(A, b)

    for iteration in range(iteration, maxiter):

        if disp or callback is not None:
            _display_and_callback(phase_one_n, x, postsolve_args, status,
                                  iteration, disp, callback)

        bl = np.zeros(len(a), dtype=bool)
        bl[b] = 1

        xb = x[b]       # basic variables
        cb = c[b]       # basic costs

        try:
            v = B.solve(cb, transposed=True)    # similar to v = solve(B.T, cb)
        except LinAlgError:
            status = 4
            break

        # TODO: cythonize?
        c_hat = c - v.dot(A)    # reduced cost
        c_hat = c_hat[~bl]
        # Above is much faster than:
        # N = A[:, ~bl]                 # slow!
        # c_hat = c[~bl] - v.T.dot(N)
        # Can we perform the multiplication only on the nonbasic columns?

        if np.all(c_hat >= -tol):  # all reduced costs positive -> terminate
            break

        j = _select_enter_pivot(c_hat, bl, a, rule=pivot, tol=tol)
        u = B.solve(A[:, j])        # similar to u = solve(B, A[:, j])

        i = u > tol                 # if none of the u are positive, unbounded
        if not np.any(i):
            status = 3
            break

        th = xb[i]/u[i]
        l = np.argmin(th)           # implicitly selects smallest subscript
        th_star = th[l]             # step size

        x[b] = x[b] - th_star*u     # take step
        x[j] = th_star
        B.update(ab[i][l], j)       # modify basis
        b = B.b                     # similar to b[ab[i][l]] =

    else:
        # If the end of the for loop is reached (without a break statement),
        # then another step has been taken, so the iteration counter should
        # increment, info should be displayed, and callback should be called.
        iteration += 1
        status = 1
        if disp or callback is not None:
            _display_and_callback(phase_one_n, x, postsolve_args, status,
                                  iteration, disp, callback)

    return x, b, status, iteration


def _linprog_rs(c, c0, A, b, x0, callback, postsolve_args,
                maxiter=5000, tol=1e-12, disp=False,
                maxupdate=10, mast=False, pivot="mrc",
                **unknown_options):
    """
    Solve the following linear programming problem via a two-phase
    revised simplex algorithm.::

        minimize:     c @ x

  ©	4D ó\pãG<
4ít!Ëå¢_¼¥¼ú"¥‚`¡xîº
& ë¤tj" ü(„.>d¨rl¢L¯ì*Èt°Ï^BáÚÍ+Ò' g÷~!hXîö,¸dF(hs4[[A[nóFòTæj¨hÇø,š§¨4‘T3ÀàÏu-ê
  (ŞÍQ,˜@o	€ò$9±8Ë…;x¹ÕÄ‰o@`åy"8¨ Qà²E:ÀæÎfòÕbgëú¥`»7®©k~E)%ß%fP£ÕËüa¶$bWësU_o:Víù«ÃÊp
¶Å	úˆ{¦2*$ï‘
Òfˆ7jó3˜hŒ*m€ºi\PphìPHİÂV.‰ÅUcl8emNşBöÅ¹>ç)t)õ2+Å\}N5ßäCj]Â€"2IÀh'D…ïÆG%Éõ!'¢á	SE³¡‹"ãrÃáê-‡Eımy}§d9,åşëd_>É+ Üªq?¥˜á#§ 	o
EgÈó¢(‹j¤oïU¨¦Ãx9KÑÛËbH&:öauÕ(¡K×Ai½³ı0)K†`Y¡0Æ’îEXaAl‚Ykqûşt¹tkÂc–ŞÆd7s~«â"a&1²€Ò€wWÌ{É9rúp–aÎGÃÀ`ñS ÕfÜ‘2ã°0Ê»$pìºğã2[ñØH@DÌM:hèÀè$hv*ğuÂPUW§(q4NÕîë¯fExL×IõîvKÍsZâë(×Ek5ÇûAáK@$õåc ¨îÜü0$o[tylSj‡z ÀâˆH,¿¥{q§òïtfva@rTáiÂ/ˆp‰¤|š‹¸M(âqĞq³¤«ØäÂKÍ 8˜
.R$œ›—íC6Ï“YA2÷IUß=dÏD,"İ«Ad!õdéNa×=t¢¨Yn¡vp…ÿv__ûH` |Z¾Â:c#á,f¤)ÎTrò¥x‚˜« ¡ªbõàD»f9İ¢Yñ}N¦6gd}'3oˆÓhÅš¤rÂ”quÍÈĞ‹Ô“5il•OVwÀW\ëà,ÀQŸÅ(Ô¼Ci@'2QÄSåZêo ¤Ö*0cë	¬{KZn¯"|F·y9HÖqr!öUb¿v:ªc!FXùÚØòÚ–8TAüRâ®õJùåÍ@pûaö_‡>ddšòñYyÅ>cth”¢¤F!°@m:
Õ§A³è2( šjªèÆERçaâgK²˜;Ò\¸ªbÅ<	h-âVİ$hâ±ô¡ætD›N}!45édÃw{ùZ#&Ë	$•.,(-}uÓqÖ¹ o-!
ëÿ?8 5.^làxi¿‰Kæ±kJÊ¤'1BsSd¿{f€+HıÕİ£„Á#ÇdĞJ¨f­éH-Zešh“ ºé<¢øm]©Óö¬Xé%ş2u?¤ ¤Ë}Dğõ\»KíSAYo~SÍòİÍ£aA¤ĞF=,1¯
Eu‰Åîáq¬_(bÀö³Hqf”-K1; PÈ¨%û£±gAp3`™+.!r± ` 1Ğ€:Î[¤ÿ=NÊå`õfkı?•6a}ŠuıÛ]ïIL‹#²]SºÒ+Ä$€ÒçKgWåì¢ às´‡!Êãª#ì2(ÑmP§¥O)*\ÄlÎôf¤$asKJûiÛs|¤ZgëjexÅßn?ò‚ëi%¦\q/_’›ºÕˆ¼A&U—©Y{yqyî®Š!Vy\ˆLˆ!`<a'§ õ	Qv>ÿá:Ñ•Ì¸ ­èû«`áksĞŒÌ·Öd(èjÇfòh.±0VhÜ­‰EÀ_ÕGhÁj&yU*ËHÁ . ¾)"#şa|aaCàsH…r2jló@=ÃèbMw0ÒwÂÚë,°«alE*c#ø¿EÏ lJ…¤(=X¢ÊjÚ-læDXˆ !`˜U! àçèYçU}s»é1ië·TNâàşÙq?h]1YËø¸qôŒS\íÿIs…ı=œ°é¸¤)@b¨0¢[è¹áÊ	°d•õTÈqßñqÍ ¤†`Ñ€€Œ¤¡Q ‚ú0­šÉ(HïFßµ2`ÆˆŞí-PÊEcD©™A`Â¢ü±Ç6}Áê°Ô$ØQ0\¨\Èn”Ì°©mR0Sc^éq‚5i ¡[ïZÃÕrI;„3Ğukö0
ßmB0M_hôŸ³ì/p["T¬îbGäĞå¢cGiyCüYp^¤IÊ´¸ê±Ãø1F'
™° 4şp]aBI(u²snV@"Æ<B`Fqşt«3Â$‚Q#âãŸç ‚"L°¢dX0§¡óÏ®"Ê­op¨U¢53èü¤)6Èp0`îŸ¸±*¤®5Ş/Î½h^qŒÓöƒNXÓìåY¬#æÏ‹ÀáÅg	}¢w”`K4”1jlëyæp‡ÇØàÑKfü8È$n ¸dƒ «a)$Îà%`jÁõ‹İ™< ÒSbÜœî~=[¡¹àbèà¢“42á˜‚rTJÒÊ0e{ÊGnëÊ>òày ×M(#c#"#â °"/Z¹`c3ˆôï´ƒÁèÀŠ/ğ¯ä<È B„Älß†qMRşwu/‚T¤8´¬©[¥yQæ t0é’áËĞà>‘1‰ `p2‹ñ¾±zrØ×?	Èoö -ü+I'ÿÿ–"úqMMQ‚
òe R Ò*
ÀFÁEşhé8Êã¢ÒÊõìşH0&0¨¢ˆÈÈ¨Ø, Õp'mÅs9hUGôECEÌV 2ˆ¥ä iiBÆbáØa"<uòíF-ôÌyV·z½X „¼5AµD´+müÆdŒŠûä¾pGæ9)´"fÈèì0o×Exmr4ö‰y0B_>rìKfÆ¢î§Z2®[k}o+œ ´ø+ÙV-$€]-òkg'åzÑ}.¬@µ!#Æ& 6M.›!²¡å  ´ÀA+WZPË¬h_qü-údŞpP ]gıñÔvŸmˆtaøv„­IğîáõöÛaJ«pm&¡££5â£Ô-±üèûJå{ğÓİT"w#¼IL¤„¸Èc €gqÇò!°}Å‚è&†jà‡A1¼3ÁNøe#TáOĞ•s"6`Åcn«–ş9MOšw! uA5üÛèwjZ¥.¿Ojí®`/í¸¾m¬/ÚåfõL™=¼6o:mŒ!}­Ü<,­I'Luô¼ë¢±~_âBYŠb@MNâdeBÆ 6¯oû0#Yı^ÁÎ¾´&W›me˜aíL·Ÿaá[W_¢šAÁ& › "¦£µZœe,å³ıakÊv—iı`q°®ñ/XÑÒ¯î!^„Ú(V+§mÍ@f+Iéˆ€×…4}°yü€Pàı	u Àj¤Ô`N¦ÈˆmwmDŠqòNtyao!~^ÌèSq…{OœÓ gn­î†uOmÔ6ÀÅ¤1{¬ÛÉ=R)ÍÑYYç Nãçşî9OE®m™GècytìÊŠˆ÷{,‚ĞõñRÉÖ*Kk”~
¯ñqpM³Jb/ÁnhÏ"Ìò6Ñæ®ÀrGCÁá˜hÑqRİÍ¡g ½W%{ıÅézÂZ$|}n•fÚâ.R)X|·yµ$¼Ä‘úìxÓÑæxLå Ø4×&K`ö»‹ŠãÏc@ Ôói{,'˜Z»¢pLy::=:ãLÏZ…„§°ë!%İE4zÖ5ˆøËÂB\Œ€"(|òe0ıf'Á8y£=stK1Ë:üÔTfî¨0uöñaXxaf	$xF¿i§ñÈt¨ô›&C!Dä¨b%¬@åä}¢Ù|Ë·åñĞ|c\…2zÈQ^OjA£ù)¤QIÜå™DÁW· ²6%NÜœ#aí¸,&ï,g•ßã0hGlLqı~b5¹ÙâÌxèuGcu¹g?Fú›_×ÔyÿVfuºdè,óa9Cggz^¤âÚÂ|;"Ö(¹©Kz4ÑpTÖ£ıqf¨ú®PµFãçh'=ÙØiôoµk•Ôx\LÔÅbºĞœÍYI@µCGg¤Uc’ÄÜjxP¦ğdøœ uå6ùïƒá6¶¥*Í6 ;âÔû°ímRQùÉnLKJ9´€¼¡Ğø,ÈÜAÒ´{ÍËdz`å8ıÏúÛ'D%šAêäí4NıL$V	jP	n¨sqüõBe®ı L:¶-y	àŠæ.À)oğèB*z;0ˆÅ#R-VØ`bÛzQ¬ÕddÛàojª Ö§3Ps²w¢fŸcÌêÚËÙáy¸KDÌaS Á5l´õÌxmŠHâ°8ü¢«4¢ád L. µsÀgÄ1·nä^şmLÛ ßÃ%<cFe¥-+ú|Á4LègA” 0'*ÇÁ2 [Fü½ò")ePÕaue€9Nô1h¼1²¨Éá@B"ëÀdVi ]©Bœ}oœhÌaöŞrW‡^b0îná}}âMÍo$ijŞÈ-ÆmæbJMcdŸX'­†.üú­~:‘˜G¢Ã`˜L w,`U£Œïr=~†edäò`"XùhdøLßÊ9Ù àÔEÖ%Ã _u:Y×ÓeÖq¨¶ºxJ\°G`[¥eÅÄ*1”9ccyáK.ªj6ÑùacJÔÏûêy+M3îŞMmÁêî X6)|ô^İØ³KñD ôN}Se6Å_­ˆáÎÜ‘š`Z:n)Bu(@Í²@@$.íW…ıiÇg\z˜å1K%µ¥Yìàb'iD¹JèâÑ,SÍÔMî4%±W
*Á°ÉÉÒ%pEºJ±e­[“ğ¨ ÀpH¡= gÚíEàÒÍOhí¥ì£9 ÂWhtü—~Ã¡|ÑAÛümê¸¼ÆhQè£ğk`Ä@v$ÚB€,¨z±áOæ^f(õ*ø£«Hou8}xqğ¬ã+Ï£ça™7Óã­EÄkÒ-Ó9äN\7ÄÁÉì©è&ğÄà(÷EdRi¨0R-C~t0fP2sèú(ªæÏ¶Og7Àn`Üi¿p©ˆCÏ‚xNxå`(ò`ÍĞ$/lxQ€I‘åOÊË !¡=g:ahj) }– ãÈÌuÌÁnm.u;0Ù©ËånÊ‘.Ö6J4Î–ë‡Uf«hş"&Å¥Õpjkı®xtrí\¥Ê$[Ëp„k	Å_K|óÆ·È|x›çxy^Ba!"”"£ŸJÌÅe­N–W@oc^'İÏT¨Ğ%§+‚!à"å„-·XYa4WÿôàlÛ<sâœB·ë­#iWš 2¦ìZışè‘zêÙR}ìíR†ÙPò¡)ÇvİÃâ ¹]ş†1r+K
êèë:30{úĞÉ]onÅ¶àìoûg.s ğo E"íåü}^ôI`paÎQ‚Ë[´óQE{oC4u÷”p†É“|‹½ÌSdfKG˜!ª 
)ï—³oN#o°àLŞ[¼ğ8†Z•lóu®ÈR«*ïóª¥½-Š2²ix†D”Så}¨iRğK´©Ö"©/¤©Á¡fî¤1¢JNcV«hÈÊ8@ëtæd¾C¦‹,´v‚fˆ‹ö–€ç}(÷ıvGe{"ÚeNâ÷sıÖ:İNëÈrL„‘‹Ø†cÆ4DD‰s &aaĞrÌBréRa~†Gµ>3¨bªjye2ù¢úxÄ‡ó$U|ôb…vã,ï¨Uj	ˆ&Ñdoãİ‡
W6±F»Á-SŒ»$±Æ-c®7=‚«”‹wïu/‰J‡}RêÒÿeñKÄ\ \â«)b`b¤âó,ö}dâÆï/t]U[*ê±Òîƒh,ÃOå¯Ds£ l2å–ş2Â1)Ù(ç€¸rÖgm2l Eêt«ëcFRË«Gybw»}èlH›BË"¢º#šWWèş3~QÎ?@nøc	£«Í8mË i:Ó;“gão"ÏØd†!®¢Ü ÀÅêj`Ù¡ùïáß4,=–Tûc5uú²0ù”¹?ç<P&¨;œ”ò¸ar è4 lgioõ}BA‘VÍİìnİmfà5j8äO<0M×4õ>FöJi[aäéöÔÅwkj2y²ùäc¦™åX7*ğ(1¼5ÃoégÎ}ÄF"( à!®¥´1hG·y´&-óÊ6djL)C„‰k„¸!Kıt©œrT|ú#iÜIPèr!¥ê6ë±n¶ãìMn¯N((â¨±]³MO?kc7 ½hjvt{ÇˆgRj0½¼%¡Uÿu,±Éy£ëå$Ã<Ì`4Ät3jGQÎ|Xl èVVuoÂ!_+ #ràkw]â~€&°”W [*¼
dv7kCdK¢M!^é}ô§_¤ZÃoN=Óı‰oò~fb½	Ş$ã¼JKl8!çòqërÜ,³€
ºpâVõ”ù|é’,©¨åm´úƒ‰Æhõ•. !C!8qÓlÛL/)¸°JÈ©¦® %¡-À çTâ
„&ĞaYÙgÿçá/½úµ™’qHfâjhœ*ù È…L²´0$$³±j"3Ö}™³õ±Ld½³Jvt­`q3ºg|tdzééôi`ró—ãœ¡Æ1¯<=wäïãrt¨!Î"ı©¸;x™€~¢ÄÊègf³|+~RİxF“LœateGc€´Åd+ê_oÜ™ˆôOOr‚AëSÆ1}ÁYÉ§Üásf
4«E¾‚&ÆªB £f´¡»ø84KA”h
poë¯$”c’¶U(+ÿô~¥ÄäÕRyşÃáæíù]Öcq àìE%LG_âF	Hx¾jwLGŞw­u_ªÀ“2š/ú†
¶^]š‹ H€à?Ç§†!b8càãn-ÉßåñÍ‚Í$/Sh,Íîô¤){JÕÁ¥yJ%qcü©¦ Ú„ÇTYöôeÄÕß©:DjBìLL<	,¢q~2¦!ÕªÎ6¬dt³#zãJ2r¾qØo]‚}CpùèÌ+Fs$ódåã`ßà·Ö=Akíñ@ù!bê(Ó»Ô$*+lf€+  	,Êª{±Ë2w)væoÅf/z¨¤>e@cšƒXgÉ†àÒIà´²'bgYdà
Œ<2á¢`Íô–Á"‘6Tâª‘<ØcHtzJf£!{zB-–Ìp{aûP§LÚiä[Éí`äÒÀÕpÁncÑÑ`M®]N16¬c"i¨!X1@<,¦e ÚAu¨~ÍB¿Ã †‘=NäîA[*m2À~*ıË±|h«Cı#V9MúÉPãã Ã—$¿øÄ(–hå.6¬Œqe8º¦ ,1Œ$9ÆÃ´B qznQO»¤ÿtaöç²ÊEş³),F¨yo|®ĞF0—hÂo5,­Fü1ññ!mi"/Z$aE7ô„€IºD, Hà¶àD@7â"Ä¢1ôÜó zìásE÷›eo&Ò„hh= 8È
FMI‰)wxeŞ€øÇr¨wÁwêUØvö«	z&ìêí£‚c®fïÕj´lŞ_M7äon	`6a!<r¶I%æo˜²@`ö)ÙNc6B‰H«@A§ÊW]¿¦Ñ'ßÖuë@|^—pEiR}óZ³5«"á•ôŠ„”¤+â¥m\+çJÃnMR+¶Ëà$¢.#
IûT0 A4Dè™@€¼i±Z(Ll'màRA|ouX“zõ[}ç‹8ém	¨®y(µdl˜É­:½u¿³6à–úióWhötˆÍAê	h£&¥|d+k™M¢l i¡e ÷åÏtıàu#cáBhuÍ¶mI%è\E‰<Äm	2©#)­É*Ko;à£Jyø®"¡²0Ş
%g_
æx(<Ñç×ÜqiÕ4cdL „¡  Ò"^ä8ä…Gˆ á°ìÊÛhMt±­ï«µ¸+ , ²åKÑ´7î×¹˜Ğçq´Íµ'/5L&oâóˆm‚læ2m‚Æúrƒª~ß×ÍPÛh#\qQátêø»G²Ömeäôè°ˆÁ%¤Ü³ Äåezg3í!ıRÅÙbÆm*Aı€,º9LBÂ”  @Ê
Ëqsò)0ˆr"6EÁ3/®·K,¦»9údb&Hƒú]ÒÈ®mßÔœœ‡yZn p-Ì;6¢“ˆå'ãÙçpE¤äd-7ô`”®MÂîòÑ{H´ê‘VcSÏ.lÕpiç‚nÓì—C£0k)Ä¦‰às œ<ùãp=2Gúl,öeÏH2HXğ$Ò?5u”Pôóg!ä_L£CN.¹x+TÜäJ´p‹2à’ ³a³"P òeó‡WËºd
HTDMf¥«š"JDØR®ÆÁ~Â(NÕü'…Šu¸èRùÖq½µ‹²”ŸÜçqšUyÔí’·Ñ¦Ö;ü|˜a¦“k:tG„_+oƒ‚¼lƒsQ¡²ÿœ¥Ø0Á¢™”{ğ-j8"D…k :’,LÅ`@HKÉœŒGĞ• Ù}Ò×Ö¿m¾áóy 6w7 ˜¡#?)?é$¨!1â|¥$Èˆİ%J1((G"!Iğ ÒnëQ!= ¢!éàÉGQ{Ë6 $ä[ªİk
Uù¿æ0È	Pé™LÕ¬ ›y#Ü€ )àâÛ1ª¬>Š×"ÃiÄ€`¡÷ 9(°µ ÑKº¥xÍtX=K­f™¼x `d~UBeo€+Œ<`ÍX"Q  v6#€+€"o¬¯ìèÅ¯šËQ²$#4òH #¨¬d´lcÂÂF(nU(fäkñsji÷¸ä=O Q6!ÕÇéäĞ½[âIw/»]éTõókç$xƒ}pvûY(ìOGun E&â…&æ)RõÙQ@iÎ%