"""
shgo: The simplicial homology global optimisation algorithm
"""

import numpy as np
import time
import logging
import warnings
from scipy import spatial
from scipy.optimize import OptimizeResult, minimize
from scipy.optimize._shgo_lib.triangulation import Complex


__all__ = ['shgo']


def shgo(func, bounds, args=(), constraints=None, n=None, iters=1,
         callback=None,
         minimizer_kwargs=None, options=None, sampling_method='simplicial'):
    """
    Finds the global minimum of a function using SHG optimization.

    SHGO stands for "simplicial homology global optimization".

    Parameters
    ----------
    func : callable
        The objective function to be minimized.  Must be in the form
        ``f(x, *args)``, where ``x`` is the argument in the form of a 1-D array
        and ``args`` is a tuple of any additional fixed parameters needed to
        completely specify the function.
    bounds : sequence
        Bounds for variables.  ``(min, max)`` pairs for each element in ``x``,
        defining the lower and upper bounds for the optimizing argument of
        `func`. It is required to have ``len(bounds) == len(x)``.
        ``len(bounds)`` is used to determine the number of parameters in ``x``.
        Use ``None`` for one of min or max when there is no bound in that
        direction. By default bounds are ``(None, None)``.
    args : tuple, optional
        Any additional fixed parameters needed to completely specify the
        objective function.
    constraints : dict or sequence of dict, optional
        Constraints definition.
        Function(s) ``R**n`` in the form::

            g(x) >= 0 applied as g : R^n -> R^m
            h(x) == 0 applied as h : R^n -> R^p

        Each constraint is defined in a dictionary with fields:

            type : str
                Constraint type: 'eq' for equality, 'ineq' for inequality.
            fun : callable
                The function defining the constraint.
            jac : callable, optional
                The Jacobian of `fun` (only for SLSQP).
            args : sequence, optional
                Extra arguments to be passed to the function and Jacobian.

        Equality constraint means that the constraint function result is to
        be zero whereas inequality means that it is to be non-negative.
        Note that COBYLA only supports inequality constraints.

        .. note::

           Only the COBYLA and SLSQP local minimize methods currently
           support constraint arguments. If the ``constraints`` sequence
           used in the local optimization problem is not defined in
           ``minimizer_kwargs`` and a constrained method is used then the
           global ``constraints`` will be used.
           (Defining a ``constraints`` sequence in ``minimizer_kwargs``
           means that ``constraints`` will not be added so if equality
           constraints and so forth need to be added then the inequality
           functions in ``constraints`` need to be added to
           ``minimizer_kwargs`` too).

    n : int, optional
        Number of sampling points used in the construction of the simplicial
        complex. Note that this argument is only used for ``sobol`` and other
        arbitrary `sampling_methods`. In case of ``sobol``, it must be a
        power of 2: ``n=2**m``, and the argument will automatically be
        converted to the next higher power of 2. Default is 100 for
        ``sampling_method='simplicial'`` and 128 for
        ``sampling_method='sobol'``.
    iters : int, optional
        Number of iterations used in the construction of the simplicial
        complex. Default is 1.
    callback : callable, optional
        Called after each iteration, as ``callback(xk)``, where ``xk`` is the
        current parameter vector.
    minimizer_kwargs : dict, optional
        Extra keyword arguments to be passed to the minimizer
        ``scipy.optimize.minimize`` Some important options could be:

            * method : str
                The minimization method, the default is ``SLSQP``.
            * args : tuple
                Extra arguments passed to the objective function (``func``) and
                its derivatives (Jacobian, Hessian).
            * options : dict, optional
                Note that by default the tolerance is specified as
                ``{ftol: 1e-12}``

    options : dict, optional
        A dictionary of solver options. Many of the options specified for the
        global routine are also passed to the scipy.optimize.minimize routine.
        The options that are also passed to the local routine are marked with
        "(L)".

        Stopping criteria, the algorithm will terminate if any of the specified
        criteria are met. However, the default algorithm does not require any to
        be specified:

        * maxfev : int (L)
            Maximum number of function evaluations in the feasible domain.
            (Note only methods that support this option will terminate
            the routine at precisely exact specified value. Otherwise the
            criterion will only terminate during a global iteration)
        * f_min
            Specify the minimum objective function value, if it is known.
        * f_tol : float
            Precision goal for the value of f in the stopping
            criterion. Note that the global routine will also
            terminate if a sampling point in the global routine is
            within this tolerance.
        * maxiter : int
            Maximum number of iterations to perform.
        * maxev : int
            Maximum number of sampling evaluations to perform (includes
            searching in infeasible points).
        * maxtime : float
            Maximum processing runtime allowed
        * minhgrd : int
            Minimum homology group rank differential. The homology group of the
            objective function is calculated (approximately) during every
            iteration. The rank of this group has a one-to-one correspondence
            with the number of locally convex subdomains in the objective
            function (after adequate sampling points each of these subdomains
            contain a unique global minimum). If the difference in the hgr is 0
            between iterations for ``maxhgrd`` specified iterations the
            algorithm will terminate.

        Objective function knowledge:

        * symmetry : bool
            Specify True if the objective function contains symmetric variables.
            The search space (and therefore performance) is decreased by O(n!).

        * jac : bool or callable, optional
            Jacobian (gradient) of objective function. Only for CG, BFGS,
            Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg. If ``jac`` is a
            boolean and is True, ``fun`` is assumed to return the gradient along
            with the objective function. If False, the gradient will be
            estimated numerically. ``jac`` can also be a callable returning the
            gradient of the objective. In this case, it must accept the same
            arguments as ``fun``. (Passed to `scipy.optimize.minmize` automatically)

        * hess, hessp : callable, optional
            Hessian (matrix of second-order derivatives) of objective function
            or Hessian of objective function times an arbitrary vector p.
            Only for Newton-CG, dogleg, trust-ncg. Only one of ``hessp`` or
            ``hess`` needs to be given. If ``hess`` is provided, then
            ``hessp`` will be ignored. If neither ``hess`` nor ``hessp`` is
            provided, then the Hessian product will be approximated using
            finite differences on ``jac``. ``hessp`` must compute the Hessian
            times an arbitrary vector. (Passed to `scipy.optimize.minmize`
            automatically)

        Algorithm settings:

        * minimize_every_iter : bool
            If True then promising global sampling points will be passed to a
            local minimization routine every iteration. If False then only the
            final minimizer pool will be run. Defaults to False.
        * local_iter : int
            Only evaluate a few of the best minimizer pool candidates every
            iteration. If False all potential points are passed to the local
            minimization routine.
        * infty_constraints: bool
            If True then any sampling points generated which are outside will
            the feasible domain will be saved and given an objective function
            value of ``inf``. If False then these points will be discarded.
            Using this functionality could lead to higher performance with
            respect to function evaluations before the global minimum is found,
            specifying False will use less memory at the cost of a slight
            decrease in performance. Defaults to True.

        Feedback:

        * disp : bool (L)
            Set to True to print convergence messages.

    sampling_method : str or function, optional
        Current built in sampling method options are ``halton``, ``sobol`` and
        ``simplicial``. The default ``simplicial`` provides
        the theoretical guarantee of convergence to the global minimum in finite
        time. ``halton`` and ``sobol`` method are faster in terms of sampling
        point generation at the cost of the loss of
        guaranteed convergence. It is more appropriate for most "easier"
        problems where the convergence is relatively fast.
        User defined sampling functions must accept two arguments of ``n``
        sampling points of dimension ``dim`` per call and output an array of
        sampling points with shape `n x dim`.

    Returns
    -------
    res : OptimizeResult
        The optimization result represented as a `OptimizeResult` object.
        Important attributes are:
        ``x`` the solution array corresponding to the global minimum,
        ``fun`` the function output at the global solution,
        ``xl`` an ordered list of local minima solutions,
        ``funl`` the function output at the corresponding local solutions,
        ``success`` a Boolean flag indicating if the optimizer exited
        successfully,
        ``message`` which describes the cause of the termination,
        ``nfev`` the total number of objective function evaluations including
        the sampling calls,
        ``nlfev`` the total number of objective function evaluations
        culminating from all local search optimizations,
        ``nit`` number of iterations performed by the global routine.

    Notes
    -----
    Global optimization using simplicial homology global optimization [1]_.
    Appropriate for solving general purpose NLP and blackbox optimization
    problems to global optimality (low-dimensional problems).

    In general, the optimization problems are of the form::

        minimize f(x) subject to

        g_i(x) >= 0,  i = 1,...,m
        h_j(x)  = 0,  j = 1,...,p

    where x is a vector of one or more variables. ``f(x)`` is the objective
    function ``R^n -> R``, ``g_i(x)`` are the inequality constraints, and
    ``h_j(x)`` are the equality constraints.

    Optionally, the lower and upper bounds for each element in x can also be
    specified using the `bounds` argument.

    While most of the theoretical advantages of SHGO are only proven for when
    ``f(x)`` is a Lipschitz smooth function, the algorithm is also proven to
    converge to the global optimum for the more general case where ``f(x)`` is
    non-continuous, non-convex and non-smooth, if the default sampling method
    is used [1]_.

    The local search method may be specified using the ``minimizer_kwargs``
    parameter which is passed on to ``scipy.optimize.minimize``. By default,
    the ``SLSQP`` method is used. In general, it is recommended to use the
    ``SLSQP`` or ``COBYLA`` local minimization if inequality constraints
    are defined for the problem since the other methods do not use constraints.

    The ``halton`` and ``sobol`` method points are generated using
    `scipy.stats.qmc`. Any other QMC method could be used.

    References
    ----------
    .. [1] Endres, SC, Sandrock, C, Focke, WW (2018) "A simplicial homology
           algorithm for lipschitz optimisation", Journal of Global Optimization.
    .. [2] Joe, SW and Kuo, FY (2008) "Constructing Sobol' sequences with
           better  two-dimensional projections", SIAM J. Sci. Comput. 30,
           2635-2654.
    .. [3] Hoch, W and Schittkowski, K (1981) "Test examples for nonlinear
           programming codes", Lecture Notes in Economics and Mathematical
           Systems, 187. Springer-Verlag, New York.
           http://www.ai7.uni-bayreuth.de/test_problem_coll.pdf
    .. [4] Wales, DJ (2015) "Perspective: Insight into reaction coordinates and
           dynamics from the potential energy landscape",
           Journal of Chemical Physics, 142(13), 2015.

    Examples
    --------
    First consider the problem of minimizing the Rosenbrock function, `rosen`:

    >>> from scipy.optimize import rosen, shgo
    >>> bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]
    >>> result = shgo(rosen, bounds)
    >>> result.x, result.fun
    (array([1., 1., 1., 1., 1.]), 2.920392374190081e-18)

    Note that bounds determine the dimensionality of the objective
    function and is therefore a required input, however you can specify
    empty bounds using ``None`` or objects like ``np.inf`` which will be
    converted to large float numbers.

    >>> bounds = [(None, None), ]*4
    >>> result = shgo(rosen, bounds)
    >>> result.x
    array([0.99999851, 0.99999704, 0.99999411, 0.9999882 ])

    Next, we consider the Eggholder function, a problem with several local
    minima and one global minimum. We will demonstrate the use of arguments and
    the capabilities of `shgo`.
    (https://en.wikipedia.org/wiki/Test_functions_for_optimization)

    >>> def eggholder(x):
    ...     return (-(x[1] + 47.0)
    ...             * np.sin(np.sqrt(abs(x[0]/2.0 + (x[1] + 47.0))))
    ...             - x[0] * np.sin(np.sqrt(abs(x[0] - (x[1] + 47.0))))
    ...             )
    ...
    >>> bounds = [(-512, 512), (-512, 512)]

    `shgo` has built-in low discrepancy sampling sequences. First, we will
    input 64 initial sampling points of the *Sobol'* sequence:

    >>> result = shgo(eggholder, bounds, n=64, sampling_method='sobol')
    >>> result.x, result.fun
    (array([512.        , 404.23180824]), -959.6406627208397)

    `shgo` also has a return for any other local minima that was found, these
    can be called using:

    >>> result.xl
    array([[ 512.        ,  404.23180824],
           [ 283.0759062 , -487.12565635],
           [-294.66820039, -462.01964031],
           [-105.87688911,  423.15323845],
           [-242.97926   ,  274.38030925],
           [-506.25823477,    6.3131022 ],
           [-408.71980731, -156.10116949],
           [ 150.23207937,  301.31376595],
           [  91.00920901, -391.283763  ],
           [ 202.89662724, -269.38043241],
           [ 361.66623976, -106.96493868],
           [-219.40612786, -244.06020508]])

    >>> result.funl
    array([-959.64066272, -718.16745962, -704.80659592, -565.99778097,
           -559.78685655, -557.36868733, -507.87385942, -493.9605115 ,
           -426.48799655, -421.15571437, -419.31194957, -410.98477763])

    These results are useful in applications where there are many global minima
    and the values of other global minima are desired or where the local minima
    can provide insight into the system (for example morphologies
    in physical chemistry [4]_).

    If we want to find a larger number of local minima, we can increase the
    number of sampling points or the number of iterations. We'll increase the
    number of sampling points to 64 and the number of iterations from the
    default of 1 to 3. Using ``simplicial`` this would have given us
    64 x 3 = 192 initial sampling points.

    >>> result_2 = shgo(eggholder, bounds, n=64, iters=3, sampling_method='sobol')
    >>> len(result.xl), len(result_2.xl)
    (12, 20)

    Note the difference between, e.g., ``n=192, iters=1`` and ``n=64,
    iters=3``.
    In the first case the promising points contained in the minimiser pool
    are processed only once.À#~ıdd¨şîP¤Eòáh/yİÈ]i´o¶+œ”ŸxXQVCœÄ.\kĞ¸Y	 ± ,âyg’„üot"lğDû›4õñ$üï‡ 4º¡:6oâÕ®„í-  ÑMLG+KyôR¸ÁÄØ,hÌP“ô{Êtoàå¸ùÓºZİ' GÊ/ìtÏ½Ì$ InP.ğsï|õFç¯ù IU\z¦}èM‚Šâ.À)k0íV®z9GXÉå6-Ü8kÛzU&ÇäTfß ;ëêAÄö£{PwîwïêÖ`ÌnÎïùóy4J`Ì@WíÁ<al$åØxMŠ@z*°.8h¢+4àái+M/ô…¢ÀB•#²&„êªª\_ ¢Ã <vGu¤)"ê^‘¤¨wi†´':‡3 F¬½R", `QC5€ˆZ0DüuâjÍáT@3nĞ"V/©£š\}jˆhİ#öÀ2‡_ˆ¡¬/q}1‚O‰ş4û
·Œ5˜ÂÈ²rZc&Ÿ8#<‡?í­*˜	Ã`ˆì0c,`P*Üwš2ÿ‡ìdä² P9h	4°X_ÎÉ©°ADš‚-ÂÙ~$+Yöš¹Ò0¬¢»zNx±@ ¤EÁ#1—=cf­(àK"ª 6Àùe"‹üŸº®Y Mm3îšQi‘«ª X~)>şŠ9ŠX“°G°ˆJıˆSp'“©Ì .Ü‘š *:©Rg(@²! ".G:`%×V\e˜´ =´¡H Ğb'¿)B¨JèÒ•(¼§št/ ³[.¡ˆÉ% Fªš±@¬
“°¨¡Ğq@0 8 gËäAøÒÁJšì°ì£9°Ö3h\ù•N–:â!h”Š ¨`ê ¸¸
‚dª£°z €@2$Ú(,,i±-ZãJFlô*ø#«(gq(+ih ,óÇ¹£µœ%“Ã­„*:=÷;ÀO\7„ÉÉÚ­!¨&ê„À(tQ`Xè/ÒuGt vT73éûC ªbÎ6w7ßÁkwÜXŸ0)àGÏ xNSZz¥q$°díĞ-6ÌzDs„B±±JŞ!ˆ‰&3sn:Y—8áˆ˜ıÈÁju/wz¬Ì¡ F¤>š×/Ğ†gJºß¼’iƒÑBÊiŞv,Õ-õ!jbùxœ"ıÜ%ŞÂ¤	Š`–k~AØè3|÷ÇsÈtxšã°9FS!
2Í¦ŸNò>éOO@ğr^&<lT%”%¦+!‚k¶¢å!7\Yetÿ¤àxÛ8rö”"¢«­#iºa2°ì[ı²¬;ìİª<è¬^Æ» º¡ÏhİSæ©ÿ£=1}îè«?p{úÉmíÁ¶£¨¯1&&w' ².é¡üx^¶	dpuNƒÂÓ¼³;@hƒC,u¾”`‡‡.â½âB0ö+‡É_9ªnéï³3{ZC{0¡>ü08 Ç6Tz‘(sq«ÈS+ØsğQ-Ë*’.h9†@”vàh¨)BÈK9´-ÆZ©?äÀ("Æ¬q³F
cJ«¨[ÈÊHûd§`¾Š[¸‹8µ3†vš‹°†B§=¼ò­"q; šeK§ó|×:?
éÈbL’‘ŠX‡kÂ @%sPE6Şa!Ö3ÄRrós:¦G1.&¨jªkéu2}¢ûHÆ€ã°„Ex´"….£0ë(T *ˆ&ÌÎnÁ˜„76°F¿Ä<SŒû¸ñ3–V+k®.8‚«ˆ›wÜuÉZ‡ÿKêÚşt±ËĞ)(\â¿9¢< r¦b÷P,89!¢Æí/`]_ª³‚,‡i,Ğ‚å¿8£'n³ñ’ˆş¿Æ9+İ8€ç>f›†f)&O,PàtëëèØhibr 9èl€Z”B[ug³º7&’%WUè–32Î@¸Fƒ»Ï()Ê ,¸Ó3’ñ£8 !Ï.ØÆúåÜ¢ĞÏËñaõ§Y¹w£Ş,,4—×ûf%ø·>¨€½·ç4 ²¨Üœ²îØ$rÌø? ,70+õÏV‘eÈÍìhnG> t*( O86LÛ$å:D[ş[{/tbí&ÑG2jºy2ı#åb¢ñ(f8ph1>7Ãëìâƒ5< F¡æ>$Rô%%>¤°5(×3´¢-£šaJHi™	/”ø©
½a­œøXˆ\Šsiœk³7)¥o6k°¶€¨E.LûÎhoæº MãDN?ki3¥¼ijGdvÇ‚oêjaıt¤$áWûv,ûÉj£íáù†4 °„2`²jNGQŠ2q}¢¨R!* !W+°": {rây£° W$ØWe¼Š 72/$
¢L!VhyÀ´7¤ƒ"F8ËíÌb¢~6(f= 5¸YWch>q÷ò%şvÜf¢©
¸`¢µ©|á–<©(à]ºÛ‚
Ã ñ–/À)G-8ÇˆÛ./yüğRİxç¥®:-à= Á  ÷P;°g	Ô#YÈw¯çã/´úµ™†1Ø*ûjh™$ıæÈF °´:$$³ñjV"SÖ8™³…±]d³³~f4­e3¾xt‹¼:©åuî€f3³÷ƒ¡–e5µ8=4¤
1¿cct]¬e2}©©x‰>÷AÎÙ#r³y:~R
0f“Lœùu$
+„°Åq*ò]#jŠˆˆÀ‰r‚/Ö0yÁ9Ù"ØswfE¯¿‚'Ö»rU£&´±¿¹ô'pnë®0”"š¶U-/³,!†âÔO8"ÆaæîùTÂb"$äE!LUKgC	Xƒl¶zêH"t­QO@3Š.úkÆöŞ]ŒË Y¥Àa>RÇs¤#·B±s*án?ÉÿánüÍ’í%+BôxÜîn¤9;Ø¥{J91¡¬¨¦€Ú„‡YõôfUÕŞÍ:‘TjÂìYLy?âxn:¦aÕ>Ê$ˆ$p³*&¢2b¤aH/íB‚u#D\CùÈÌëW}!ûtÍóbßä·–uQyé©@®5"êèÓ·Ô$3*8 €+t!]<Ê™{°Û«Cny¢wÅä?ièìeUVÊÇ‘gc–tIà´¾7bfˆYdà¼=Œ#Áòb™ô†ÇiĞ}uTâÊÀŒ#HTrJ³£AzR1–„qùa>ëT§_Úuä_ƒ­!àÃ–@Õq€cScM®]Dswés'"iŒ8Uxù@=¦d@ŞFQ~¨|ÌF¾ã «L‘-kå³I(,g2ÀvkíŠàlL¹;ø+yHÓ‰Rã¢ ³—¿øÆ(’
à3vXì$1ey_§`-½Hl=ÎÇ”Gun,Qu«$ÿ<aö÷úšîy)-B°}k|®¿×~Â/!,©b¼W±ò!mm³o4eUt´Ìmº	DlàNá¶àu@+æcXÏò ô|ãäé¡'ó™a/\FÒ”Hh]%qÔb-]}‰8÷8e€¢†`¬v ëo˜zò.:',ëdæ’c¬gi”j´,Ş_F¤{o	6p!œ2²M7æÿ™æq`9ÿiÍJé&bŒÜïiE>³Ê.Z¢&Ó3ß–afªF|lÓtvlB]ã[³u(«&ƒ@ÕtÊÄÔÎ+÷ím]£æMÒeI`;öÊª$ /"^H„ûp -$D„É™‚Á½l¥N$74ğVA|.0˜“
ä[(çyyKM¹®ïy)õEmÙK­:ì»¥7é–úmÿWh÷´‰éPæGy«&å}e[?kÉK]ål(y‰eºâBtù 2 ")ÄBh4Ì¶ø@`%(@ˆ<„M	 ©g=­‹+nè2p·hhù®RCá¶19
7g'Oæ|i<ĞåÇ1iÔ4geÛì„µ àşj^3äaäÅãÌlõ6¾ÂË`Lfµ¬ï+À¸nh å˜¤ÊJ¹¹Ğ÷q¤Í¼#?mI.~îúHmã<f   Æòƒ«xkÛöÉÁŸh3MpãtjïºOò(e¤¤6è»ŒÁeä]14Àåe:g7è!mBaÙcÆjZOÖ0»µ\YZB0 Ğ@Â
ÏVa[{Aö,1ğcEá2V¯F_6ä¿	şå" ‘ƒû]ÜÎ»mÙåİy~
&u!ÌiVlªÈé'kØ®pF¦Îd!7EaS¬MÂîrÑsMM´j‘L#1…**ÕpisŠk×î—Só2oiİt³]	ôs¦Üøùp 12SºaO$örËÈr@XºfÛ;4<Pµ³q1ä_L£Cj¹p*ÕÜå’ğp‹6î×!£A³b@ ó&âWSÏŠJ
(DEMæ­c›WàØB®”Õ0zF*ÛüE5¨è{¹G`ı”©°Ğ›ç¹š›PyÄJÓ·Ò¢Ösüwœe¶Óş:GtNÄ_.oš’±lGÃb³÷}äÌ2@€‰”rğ­jxóeÕ!{ƒn¦C(y•eƒEH‡KIÉZœÏGp… ™{ÒÓÒ'é½åí8!6
7€ˆ¤á#/1(;é>¨q™ê}·fÌ
ÜE^uí<GCqKôÍÆnM{E=Cæîé'CégX{Ë#ä¤pº€+Õù½ òÌ†	pùÕ\Ñ¬qŸTxT#ÜqXğÀÊñê¤>Š–;‚IÄG‘F`ås¤9­®¸°` ¾8HuX-K¬b¹½*ab`úUBEo9=]CÍHFQp¤w6…VH+!”aoç¿îèÅ¯ªêY²d#5óIx#èíeñõTcÂ[Â}dU(gäm°Kjyó¸äH,O€U" ÅÉìçÔ¼_ÆÈoÎ#¿íé&ÑÄ¦kå jÆ0kM,êK0 rBÄ&æ(1Í·@ÍÎ%wäg¨£Pš}=nĞc%Éq~zNò—İD{Ö2nÈÄçùY(`£±¶`7¸¦'€¢.07J(Lv0gúà3ién˜®pÊQlLO¤"ôg\8?>-	"Å2y>´ìf¦\T•h9ş.¨jŒ$æKUC¥fx‹á©†:à#Œ&“1
ÒK®)²Â¨c]˜AŒ a6o!'Ëtµ¡f<¦¦UMcõVföê#ƒq>-2nğÑtÅ®fŸõO¹	€®.:J_.¾uêa=à*£ZR)Å~¬>‰©ÏvkREÜ”(8(e€°%gurŠI>ÿÿÛö‘`œŠD=®İxeË)ÑV(¨@0Br$½ZvcjÄ´1”8!ò!ànÔ3ö"-s>` ¨Öñ bÏÿK	j¦ÀfÒ†IÁ(ûÉt’8Í¶'ó¦Í¦¯q®9=Cğ_k jmÒÎç[[4åa†^GeÊĞ»ÇjÙÃ+\L§H-PôA°ÖOÙ"!
rb#,¿L.øÊıë^-(Qq$¶)\7N14n:‹ÈI/eK÷"p~*ˆ C`L(j-¬İtEBšô],“_y‹Oä£¦Ãhîñ¶çœj’0*°P*Œ=HpY<qÚÁêûoTï lh1^n.°&’ÖcÛ—á[08 7¨½Êj5U¦[a£" zÒŞº*b0kíe{„¡„…H5œf,`c`ª¸à$}D ïÅÇg Òc§›å>í¿KÙxùee{ÀÆñıEÖ2l`mŒâz…i`m€BR«N•éùˆ=ÅWk¯V{J"‡6–e ¼(2Íg¿>¢+îf™Õ((ù´Ÿ€Â‡äN2ikTuğFJQvİb%Eİ ÂNµ, +0è2ÿËâ1ïDZHOeCÔòZõráxå.ò*¶XâTŞ5¯,¬,Š BzÎæ×ÖåK¾#åJË@²ÜGƒå"p4+®¥-àóÿé
. ŞîÊÓm½X;ƒLeiF	ò¬F(£@İy@ƒT IæçD2u!•)j
ğÉ.&#*ş»¢™§8sæ(å¦cQ{d¿–Clx
‚"Â#-øi1dp:³ôa£ğ3ŞÒ(.*1 » [P[^bj<Sÿ#êk¤Ú?kÏIÇ\‚UÁU|c“vécå|xª<2à—ü¥ÄîÌòèğîG‚Nq¨OFVë–í·Ä’0U´g  `ËA*€éÀ^¦¸ÏòIz-h¸	AQÌ?øSºqH7f2‹èb9À/` ,­P$³ÏÇd —K¬] ¼2JS¡Š¥fû(c©!e‡¾}şÿiçœKwË¿ªk÷[ `¨`9¡¥+í¨+s‹°ğÉ»} ÁE†SDzÇø|l¿ ¡¨O|Ç^ğWxn	)8}|ø€£wsÉšèOÆ¹›ÚVğUaÆWdÌ(”È(-U´Qi$å˜YƒZpr¢ªk1¢hpdåa„ä„hØ07 (²æä˜Á ÌMò/rMï4ÕL(ª-*Ú(XiĞ !¤^Äû.Æ Ãòú/‘û#¥¼c2î>å¹nZà"` 8@ Vº¢ˆfª‚nú"dmBxí=Yè¶ÄS"Û#m}2Y¸Iô´«)]Ã1øP!ªÓèøä #TÆRe·7Inùç[G%œf‰ÉÌ,ó—šrAF‚5
0yøC¤\X­­à™ål6®âïeS}Ÿù)s[e1>»R×//Í` `'!Ñ¦™´D„!dãG8
2ùô%ïåâ_¼¥ ¼ "%Ã`¥yî8J¦äÚäd,§°ñAÄ./V™2Rë£	îd*ìt°Ï~FáÚÍ
ÅcÂD.÷~! ©s${¸$€:H"ôS@¡g“òTæK—:âh‡ø8š¢˜<† 0Àât­ªŠ hmÎÍp,š@{ıÀ2EF9ûxZ…x¹ÕÄÏ/ (¥)c¹ ¢I:„PåÎfæ'êÚ¥p»¥®¸sE¡%Ÿ'&d·Á‹ü!¦(‡û°Wf:©yËÁÊ(O·Åû„9¶²µï•‹ÃFˆ7ó3‰ğ
i©º­m)\ hlıŒÉÂB¤‰À1bxt™_öR|Å½<g9u¢õ kÏ}Z=öChÂ€bMÀxgä…fQÆW%Ùñ!¡6åIWB³ÁÊâ3Ãâªƒ ÌmíM}¯£eD8oíîûë8_<Í9%êqõØg#§ 	.
EŒ*ó¦)›b°*­U¨¦ƒ,kĞÿšãbpI":üqaÕlö
•Ea½ ½1)†m^,dN–ÎEyrej‹[oaûîÛt¹p_Æa“ÿÆÌ7w{mâ"e&q²Ò€6WÌ{É2Òâ`’aÎ‚Á q Ôv´2O°ª« elúöâ,%2IñÄQBPDÎm:(¨‚¬"H[tjªà´ÂPD4É¦(y0
Fê©¯fE²RLİîrKãKâîj×!/M%Åûm¡(Eõ¤c ¨(¼Z0$iKtmlƒâ0@óL,»z!¢³ïugw)Hbá©Êˆ(‰’¤!‹È¨M¼(âÉ2£"‹˜ ÒÍ¨¸œ(/BdŒ“‡¥S·Ë“YaöæW¹=âD"Ù«a%	aeé)a†=0"¨Y±bğªô[1_û@ @x_ºÀ!#á-2°:ËTràåhÆˆût¡WêfVÑåd¿o9“âMña^ævc,=¥3-ˆ…Ó ¤ñÒ•}YÈÂ‹åƒ$}i”MVwÑ1RœëàlàQAÅxÔ˜C¡ ¦Ä“å:êh0%Öj>gI	ŒKZl¿f}Vò9h}\„qr09ö"ï6+ëE1	WyùÚÈğ˜…|PAªü â¢¡NüUİ°@q+ò{†%00®ò»YhÄ.g4h‘·¦FíğSej
ÔóQ3é²,Hj«Š†U ò!¢vK4Ü;Ö0Éª"Å	$-êV†45èáğ´÷âä@>Oı!.5kpÅvé;#vÇQe/ï,}w‡İ„¹ ¥/aëõ;) 5
^`È\hÿÉ®±	JÂ¤§1jsc$/h *$IıÁÌãŒÁ+Ç~Ñ‹ùd½¡
H(‹Zmx‚Azé4£”ü`Y«’æŒ˜­ º‚5 ¤  ªyváÎ\{û[éSeXM>
ğÜiã E´]ĞÈye0‹JuòÅÆğA¼ï( €úòhqh”%- ø€ƒeFÙ÷rÍ5ÔP0©dS™*?dò÷„`!!Ğ!2‰Şù¤¾)FÎòqàroı6‘%!wšu¯ßOêK\Ï#œ²1MXTZšÏ_mµ
$ƒÒ&^åä²ücôåUŠãëcí18Õj@¯±G)'Y‘hkô+f¤daLCÿišó,ä^VëjehM×~?ÿ‚:8 ¦N-/p’²ºÕ¬*í{7‡Ù][lz0lÍ®Ê!8LÈ1ÜD eKwI¯°ô	Y&¿şâ:„Ñé¸±¬¨ø¸$bksĞ¨œ°Òe&:jn"öl®°2h—Œ-ˆ%ÀOÅC©k')ªÊÕHt¾i3c|Iamåe”GäwI„B6jnB =R¨"<2’#ÂÎç¬ñ‹gyEkf'à¿]Ê>lN€¥(<X ŠŠ!``DÙ	b˜EeDK'àÿCş]tUzs¿š¹urº=DFãeƒş˜0;h,%€ 8¸p¤CWLmÿiÅü-ˆ ëPs¦-@pª4 
¸©áÊKôfÔÄ`1ËpM¨`×M„€„ ¡à¤¾!(šÏ(ÏNÏµ3bÇlßí-PJM¬™@	"Â$¸±a6eï1Ô4Ì÷01XºLØn”¼©hR²S§ÉuÂgï1„ïHaÔûX©„‹ğ+³0
Ïp"	hş·ì0{";4¬ï2FïĞáâ'2)<Òì"¸¤YXú¤zêñÂú5vg0•Ù%¡}ï²]%(u¢q Fà"¦ÎwFeñ«4«3Â}‚EP£ğêïŸD‚êMa¢tEeL:·¤2¯2Êf­oôªU
5ìıõ)½ÈR0dëï©?"$¯fŠ­ÊhVp’Ö¶‚*^?ÓmåY©R+ßÎKÔæíu²WœpKt” jü«)¦EÇTÈ¯ K%¼8¢È<o ¨dÂ¡«(l$Î¢% ~€´ğ	eDRGjÜV¿~ƒO¨¹×"ì,à"“ 2hÃ^TJÒê z"ná‹*óä}‚`ÃÙ("*"¤3„¸2¡
­av6ªô{´CÁ}PŠ@šg`® È!F$ÔD†E]Pú1
u.âÒw_µ<ı¨#[~¥iAç ebé–õÊäá~•µÊ‰BMBq{ËSşŠ°3ÑØG¨ oö,¼)]1¾£—Kê÷iM-QòeLr@`jRèFÀ@~xé(ËçªRHõmïX0pIö¸ÌÒ¥Ü.HØƒÔ+'íÄg=hsg±	QÌ^7‰„À€haÆbÁ™z%n-0³í€,°Œè
7²!H0„¢¼)±P°1áød€Ú?‰eîdÇî=-4w@Ğğìb{Ï/x$t™ß0
ß/r$K´‚ l¤¢6¬_c|å œUÄøİt=•^,cjE"djĞl)+ìH´9'Æ6A	2M.›%²¡å  ÷Ä ;_[Vëhx.7ı/®fØ0 IbıÔWŸïŒioí¦”n©ğgáµ£e3pg$!ã+%Ó„(µ`è?[àsàŸÉG#wÍc¼Il(äTù9s"%Çâ±WÂ€¸'‡Êà#‡C5¼Å/¹%c\
¸À‘"6!ÀAgä«’ê=˜ošk™Å
5%¬Úá6êJ¥.£k©¯0oí»¿áé/Ušá r„L™=°&e:mƒ5ÿ­İ<(I'H1T¼Šâ¡rbdŠbIMnâ÷dPÆ 7¯:¸*#JıJÍåÎ?°&W»deÉaí\§%áG_(šHÁ"º´&f#µ[u-×³íbkŠ¶—sıquşêñ/XĞÚ£¢%Ú,F æ¬ÍEfcz‚É‰©—…´-°)ü¢Pzı[uĞ+€Á Nä†ˆˆ	2uŠaJKdWÙ€PIoM/WÈêaTKŒ"'.9˜¡f‚$5r,ÔĞÁäc{¨ÛÛ‰=B'ÁIKçuLæ÷Î;I¯ü™`ğaifü_Î÷J+h!ÀõğB¹ƒ¢OL•~
eáó!Åójb+Àï(Î#lâwÑûïÀX†`€ğˆ(‘!RMˆ£v ½s%ìÅ¦ızÃNy-n•fÏk¿V)].LX	<·ûµ¼ ìì`ÓâiL÷ GØt×oKp÷ÊãÎ'AáÕiYlsØwº2pLW?rW->IL‚R„„0°ë1õİJt~Ö4ÉØË‚B\:2	Ke¶- ig·|=©%q4!Ê4z”T0¨25Ôñ%hmhgs<n¿/§õÜåèxÛfW\t­Ör¯ètåø}¤‘İüŠ´¡áğô³Y¬&jÈŞMjUçù9¤QÑÜF™ÌÁS—s¢TeJÍ¿'søn&L¯=b¼Şg!hG/!]yıüŠ¨58	âÍxè÷Gau>]L)OúÅÄ1ë|fwºdı,óÕa½S&&(¤rÚBÓ}?òÖ2µ½wz!ÑTF_ı…S&¨zcP%G*çb/,Ùşi´o´y,Ÿ(P!ÖE"ªq¼-{ 3CW.v]e’¥ÜkÄv¢¬°Dé7t8õåùïa 43º$,o6ãô{•}ímB1ù)äLG!
9"Â°ğØ$èè0 ´qÍÉdzàô¸ø_êR'5‚CÎæ,¬mÎıÌ&4Aby	.:2«(u ¥§ñ 2^o¦-úE`ŠänÀ)i°ìnG.{;Kˆ… -ÔX0n/~zU®W¤f0 +êb$v!1Pu6÷ëª‡h­rŠËiaz¼^@o@ëE=n¾ÿ©|e"`>â 8|¢£rfâmM'>×?³ÀW…3%,&äÚj®MÛ0c­=vGuWµ)r\ñ4.ègA”¤¯/vç£2 ‹g|)Â"5 g!‘!uÄä™~ĞiL<rèÍáeB3æQ&~c
]©£œmoUhÌcvÔrWÃ_Jğ¤nsÇMÏ û¨(Ş`-˜E"rZ# &ŸP&­¢{Úí:™‰G_2Çd–Ìw?&`Q«Çg™~ÿåDäÀ"péh‰$üI×Ï÷ibåTÜ%B'o~u:yòZñ°p¨´³zbĞ0B`[§EíÄ#9ï·|so‡9àH&("0×ùef*wÕŸ{YWjm?ìÚUmL+è \v \w|ê™Ïú¢IxG°hnığ€Sa7WW)Í±Êm‘:u2hiBRs @Ç²A "7ÌnG„ÿpUW_lü5	k5$¥Yìdbwÿ GºDêòÁ K”ôÍt\m3“Z,ğl c‹Ç'0MºÚA­!¢ğ £ğuI)?agÓl5èbÍm(¿­±,8°ÂW`TyµG—|Â%lTS¬/ª° 
†dQj¨³j äpr$ÚjMŒ-y¹¥Zç*fJlõğ£tHoq8 xô.óÏ!1¸5“B So°?Ğ9`NL5ÂéÁĞmì&b$à/7O`2Y 4RıATt2A|y7rHûb  æÇ¶e'ß
nTXğ È GËxiCOrer=(p²`åŞ%vü-x Q[¤k#‘µÊÌ)•"&8k*h* Y¥)#ÈŞõèˆ^e?wcüM© BãX“.QGwB¾U­°ïkÑFŠlŞd&E¥Ñ0kkı`ŞbıÜ¥ŞÊõãp”)vMñê0ó„ 9³È|z›íøn^BC!r!u¬¥>FıëoĞWRéc^"]íV­p%¦)àiğ¢å….-1·i|ya4m$äxÓ<q÷|
åã¥#a_Q" äsı´ 3slÕúì ^Âİ0#ÏlÃbÃ ÿ†4±)êXk;Sp{ú‘I|oÉ?¶ ¬.l&w… zo6 éáş}ZömvpslS€a*´³sD}Âïj,vœpA£&4‹ıÌGğfCßÙ1ªæP©o…³K^!s ¡æşğ<§5xğ,3s u?Ìv‹*{g‚b×$Á8²,iyÆd’Väyá+pÈK4­@z /dÉªbÆe$!;¡@AsLi(ÈÎupªt¤`¾J`¤ƒ4´s¦ö
êv?Eçw°ü=6‡q9"’eC¥ñ+d×3Ÿf«lsM’±ûGjJ$D%¨s$˜eaÖvÌf-zks:€v74 `zk(u"}âyHf‡ó°UxæâÅfá8ë¨Aj!¨&MscÜgØ†&°»A¹¤áÇ^fcî5=¢)8›w$iy¢~b¨òòtàÃ@K(âk9far¢Ê±ğ$¼<`¢hç/d]_(*3Rl"é,ÀX_t¯t8b `²u–‰,>B;w+Ù0g$¼r–f$0>,EjuéáãNĞËûy`s³9èl@aÔf[Ub¡0$“$GWmö0~pÆ ^ıF	ƒ«í0aê (8ò;ó¢ ¥¶jÄ£òFü¢MËëhÑ2¡!¹÷aÏ<,;Õ{g%òñ´`„=¿g6n·¬´”p}1ğ@rÈø=:lux$'ñÅ W,ıìj-o'6`5j8 K0MÛtÕ
ÆrşC1? ä©¶Ñe &o²y°q;¡bo?qxw>pèi¾/gÏdî"m@b¡.B>4Ræ…i¾$°5(D{PyàæmášmHmiI‘ˆš"8±Aİ ­ºE˜ca4K7¸0)$i$ê!®²€¬Í#?Ìh"¨ M³ml?jas¤ımn7vs_oújxí<%¡Wwvm5hy£yá½&<N °`1 O'Q¢0-If¢èVc+@!Wk°/6(k{uû}ƒæ0®ÕdÙ[,ü®w2'FS&A!^é!0(  f>5k~©cb}nz½RÒ%Ë H[n:aíg5ìvx÷	Nº`ãVõ¶±à–$¡  A ¾Û€‚Å(ç–oÀY)b!. ÃìÈL/düñbÙıo…®8.A}˜áhÿT{J„&!d#yø`ÿdá'µúµy¦>q-È:òl`í.uåIvM²d8e$²3*¶'3O8™«ç O`±¹Z24(Dt1ºgptŠä0é0éoüVë!dˆ2s×!¼¡ˆq?8?3ä_mãÅC|](eò ı¸¹|‰°`£ÅÈÈgvlz.vPƒzF÷LŸùtiBc¤²eD)êg	F/Ş‰€ğ-Ëe
dûvöuiy Y@§@ó#d
U/*?¡v»Bu*fìë¾ø²t*I´f(|fël$Ä#¼¶q,/ó{­%®ZâõOyöÄãåmùTäb  ¤ì%%Lu3çV	Xl®~·(OÍt¨uF¢Ğ“3š/bA„¢Ö8Ø!¢M…Äa~°M¶4Œ"“B¹a«ãn-É_!†aÍ í4¯oÔ<…îô®;LñÙ%k5pã5©¦€P„‡\upfAÕi‘U\jæå]L|O<¢ù=&İ’Ïlf  +$~¢("b ´!Ø%İ‚$!DxAıÈn«v{(ótM3`7ä—–=Cyéñ`?ubìøó·Ä6”:oüo +Ô!<J	;1¨£w(Uàg€æ)»¨¤<eyf’Á™bA×¡cVmâ4¸6 dˆdà”$Œ!Á¢`ñtÇ<+Áİt\èŠñxpTrJ·#CsB3¬Zû!±t¥_še$[-! ¡`ÀÅq€>góñ!I®}Hw©c$6)„„3^1[ø@^=&}rVGU>`~ÍF·Ã ›‘;Dä·I"%{2@0v`, ıñhL»	±;9hÓ¨Rá£Óœ$èä(’à#dX(qe8š¤`(½Œl=Æç”g5q>C.AO{$ß´mvîšö»),h*[k|¨–” ~"?4l)vx×¹ğ%mi²([4aA54€IºDì Lá¶ G`?bgrÏr1|Üóñ[ée!Yş½a=&R•Hl]$<^ÍYHyspe °¥à¬w 1hYı^ò®=:g,ãü§²f¬`i‘ªd$ş_MdklMD61-66M?fõóöS`ş)]s2B-]«M!¶è,¿? Ó5ÿa (D<Ì#tir]£Ó²pH)$#NõôÊÄPÆ)¢­a>Q«çHAn]Bs6Ëb$¢."cHŒëÖd-U4DÚ" ¼%µH0q",àR@}cp¹1.õ[-e‹9ùjm9üÏyåe`Ãíº°¿17ù×ùiSbg´	íQâ@9a«4•le!o9.§, 1¡‰E:tç
t|@6#)B u­´ü K%¨ÁÉ4Mh"©e--,‹:mÇ4¸â1HiğnRfáš1Ô(5 -Qæ`8<åõ kv4idL-6F>å€+â|j<,dxä¥gMhq°>"rhLt1l+R¸/,è±í5ù5Îï¹™S5yÏ=Ğ/s=I?vêóˆm€oæ0a€DrZªpQ×áÀÛh3L}Sã|ê{³GóÆko¤µvk1‰Á%¤Ş±Dåe:g2á ÷BÁ™jÌÜ,²¹lK\BãMàDÂÏa~(ö,1¬ğ!4EÁ0§g4fÿ~ío$L%‚ÚÌF¦m[Õ””({n pí{&>è—éécãú®påâÎa%1Äm$dÀjğÑ{$[5î×Lc1Nå_jUxiïÆl]÷ìÖQé0o)ıô÷Ñb3¦Ô|y{i=cVxi/ ñgËJ:@Zš"S145” ”3cfL)g|d)x:ÕÜåÆ´p‹2ïÔ 0a#"@ ğ$k‡#Ë¸FjÊmEIä­ƒ!ÄÀr®„0rÆ%(
S}'%¸hRé_z½ò\Û<%ñ‚›UY„è7¦öSü70ša¶›û:dG\ß/o	¹lwCqQ³rÿ‰çÔpál”Y`¥jx`DQ!{ƒ>M.\Ue‰AP—[ƒÉ-OĞ•$¨qÑ†·)½añ9!-6ˆZ… #5-è¾+hxÙû}£nÈ
ÀåZ1å¼fB0KqI÷dNëP=ş/ğaR®ÉGxy‚2%#ä¬x;¥]k8Õ}¿.ˆöì¦	XiœlÕírU¼4q~Øp#qšÒûñê 6¢2çiÅ&q%÷ i¤€ø `‘+2	KB<y=K$&¹¼r `aº}bDo„;­<_aîXFsq¢w~Ù'Q” aü¯î1JE.šéY0å34nEa#¨şl;eök`à8dT)floñKnit¸gx-OU:©!CëæP®kL)tş/¹íi%ÑE²kå p07‘ënU.ëGWuNefÂ`.¦  ¹–Hí;Î}Îwh"Pºù ìğc-Àu>;²ÜlyšÅ&nÈÆ°k[ `£™öƒ w¼'#«n7·Dqhl 0gêÁ3qMîƒ®pÉq:B°&öep7-OC"`2y,µìîîMTÕ`Ğ¹~. H€%fBElrx«p¹Çz{âQ£¤0q
Ğ^¥)GòÊi½¹]˜I®ls"oe?çt°Qg}¶nP)pHõ[óv*"?ãq75
0d|Qxå -^µW¹IP®'*@Z»5he=ãúÃZ }<6¡„üiEŒ”/8i}ÔÆoñr€Qk:ÿ_}şÑarŠ¾ıye¡¡ÀW,*0T`Ãr$1=Zœrêå¼Ô<	ò0!à |¤3ò"|s-@d¤¨V³ t+û	`‹)f,ÚG}í Ép–xMO”/7§Áç«a«sRØc ](’âW¨|5µae#DŠĞ"æ*9+¦L¥X%`| ±RÇO:n
c *s`>$»B,øà°ï­0Pó,÷²+T%JmØ A:‹ÈC¿bMC&¸pl©NC†@Nù¹,Ÿu¥BÖüL}!“1»kd3¦€h.Ñ·Sajæ0t"åpSŒ>r9`Za¹¹sTodXl!kfo¤.ŸÒgÛ–áZuNxÄ 7-úè.5ES¤£* xÖÎù*m(kï!lo…¢œ…%¼g|wÆk`ê2¸ìwld.Çb ²s ~˜Úå˜<i)4Éhù	ga#ÀÆñğÔ†0+ -œê^…ëiıjFC&³hí,-EUk¯a{h&Ç¶,g |$X6Moı¢)î|‰q *ı¶±ÒDÄ^3eñäxF^vıbgEÍ Ò~·<a¯!ğr<o]¢	ïÎHˆ[¤~rRñ°»`Øåàêöy"Vô=ç5ì,Nbxæf7”ıë®!åVë@í…]oSm«`4,K,’¥-qûÿífM®AßìZ’U88y¨M,=dFYÔ(Ld£À™AÇH$H§o :u!Õ;`
aNéf3@Jş²0£9%b#*¥¦aq;İ}cmpBRBg-şx;pp:·ğ%ƒğ9/_ğ,.ªw€zzPhbèyTòéc$š=oçIM\‚Ùílr“&¨«o>	pª¾2ì×3t%lì="ğ ĞŒä/GLwª]€ë6-³¤šı1Õ¥c	àÀİE7Ié@2&ˆ$ókZ!i*I`ÓD>°7¢32H7f ­t5`9D¯phïP³ÇÖMˆ é»]¬’ä>cğFƒ%dğlbys}¾>ö¿Yó€…\OZª+öWuj¨J1£¥(í¨'sƒpr É?_pae„rÈjÏø|h?f+¬‚ÏxGB	à^{j	)8<|¸ ªQ-£XŸ°‚	»e±`VO_nÄ-TÊ)ut¾wSgi&¡ŒÙŞ0q¢úd³"Hqeaq	ÄÆ l°ğ7ä,²gì(Â TOôq*Kî4áuiLmh®3mlT(XYâ)ä\Äû+†&Çbú.¾Ã¥#¬c2í §#-µ¯V«jèl l—8jäU:ÂAæ+–nÅjj]Irºí=[èU	S#Ó7wm09¸Au¶ë+Nó9ïR!¸Óìqôd¡7Vî’e´?/nØw[Wef±Ém<ë•ºr!f‚7!˜}øo(7‘)¯à€æh4Š¬î¯%“_Wù){Œsaa<»P_.ÕŠ   !u±§´a„¡|cG~,>2éü Ï`¨]O<¤,z §K`çyf>J¦ôYæ›~mn·¶Õ@/ ..d™2ì¢¯ä*ìt°H^FAÒÉ+†ú.Ngu| `h/ñ,n¸$Ô8@7ô
{kù|'öTë> x§m=˜'™4„1V9Èbu­sŠ(`lŞéP$š@{!Ù@òmFyyxZ+|¹ÕÄÏ/`¤)w¹$P`0í:´Ğkîîdò¹3êÚõp¸§­°ie¡€%5ftwÕŠt#¶&!·vs$UWg*&)ùŠÀÈp"¶å	ê†}¦³z·ï…
rÆ€p:s;ˆú­ªmÑ¨?l)'\@hhü`lÉÒfÁTQgh9n|`t¡<ç)dªô8.Å}şöCj]àp	bmÀ*cä­ö{î×e	©#g3åAsW#Áßr3Ãaj¥Ó°Íoåmm¹¢e 9$¥¼²*4<m1$WéqÕ s#· 	+*A_Ìƒs¦1˜hµgïUü&c-
Â[^©cI6:´}}×-ß‚K•KK­³}1)»†!d¡ LúÎEqAn‰yop{gÏt±t_`c£Äè/wg©ã"efq4K‚uWÍ{x;Úúp¢aEGÁ$ss0uvş>Ï;8\J»täğÚg`S%ñ0`B@dÈM:xèàì$,@WöZªğöÓPTÉ§h9`|‘êéîdMºMŸI]ïrkÑóJââhÓ%"E5ÏgA¥îAÿöiúä}¼^0niK}yä¡ú4ÀåŠln}…{I¡2ï6oviHb ¡J' xÑÔ¤}këëM<#*àUÙ2ƒ""ğæò€¨8u½/RdüŸ%W¶†³xCp÷	G±=æêDU+Ù#a%	õeéMq”=p¦¨1vv….ş[_ºPa@<\0Àc#é/rô:kVsrõh–”©0¡¢bvõ¤D¸d9×¦X`u^¤"c¡d8'3?ˆÃ Àš¤óĞlÉKÌÂÅK%hl‘MDu¡‘Pœë`, `VxÔK)BöYÄ÷åÚoo0­V+}4gQ)„{Kvl?f|V09´1r0~"¿>;ûQsVú¿úXğP—e\c’}Tâ¦±jøÄÄ@ó³ä[? vœö-PûE6c4`µ$eÿôS€m(
Ğ' ³)2 (’jªÈWpòã!2Z´1˜º Å2)ì-hvt$°:ôX5ftL›Z÷)>5êqçw{é›9&SYe(ywÃ1²1 ­%,aêw)Au.^dèYh÷€Ã¦0I*Â¤§3B~[$¿r€k.mİÁ_ëŒA;ÇlÀ
¨f­© H(ŠJe¾pÏ‘Aúä<jüd]«óöÎğü!¯5¤  ŠyTğÖx{9SmaaPiz+MâMM!	nõ}Üf=­uë"/6‰åÎw]:*!bşzHqf­,M-áÑh+%`Ù3±5åÃaÉ&_»+&)3µ `!±É (ÿÛ¤ö%nÆöyõvo}?›i}>w¿_OæA\¯218][
u8g•f…ÆÏ2e(^åäªr÷¤¯Êãğ#n28”*`¯¡O(.„hÎ`g´$mSOJùi˜û-\ébd8A¶~8ÿ¢{,%3&N=/[µ›ºõ
(Y6U×ÉMÛhp5mÎ¾/J 8\¨JÈ!´ <`CwI'ìwKYn¿èãs‘É¸1¬èº±$Aks€¼•–d
&(ò*Æ&òh> :sh‘­ˆÈ]áFI©ÉKaiUªk@Ë
L0>:i3cvIahåe”ÍIà7JP6n(Óa?÷¨ªm}Q2&‚ˆ£¬°«#xA*d3z¿eI¸lÎ€¥(t¢VÊú¡làfpm	H˜U%E³àßè}¥]{{±:³7iª”t^àá¶›r3hõ1Ëğ¸p¼¤.SlíéI‰»Aõ= k0 %@r"<3BúyáÊ+ğdäQX9Ïf‘qÅ ¤&bÛ € ¡]`¦&1¯€Íh.ÉMÙ½'`×,gt-`Øe"F­‰AObã<¸±Ó0=Iî°ô$ÔU8|8NØNnšôv¼©|’wçy~Eõ‚=å …2ïHû•q0»;“¦9á50“0Ü|FO˜`şŸ7l5[!tì5î3Gíxá`e/gaıÆürwŞ%Yxr´új‘Áú5Fc0
š0¡}òğLeP(u0qîWÀ4Œf_@p3á 4)1Æ,£5p© ğòÓë/d'ëE°"wDX:¾¥3—­0åF©g¸¨E¢e{mıõ)¼ÈR4bÊOø1(4._‚­Š Vpf¶a*~:Sìayür+î+ffÍub^xEtJôé5¤–ƒH ”k5şz‚ĞTa¸dÃ!kce$Îà-$v uÍÕ©] Òcbœ%<q™^¡)æ&àâ¢³40é¥Ã~TB"ka~ŠSnëÏ>ráy^(™İ)!k &"f¸3@¯ 32¢åÒ4¡ÁíX@(%s, =ä!$Õd†uHx(3Jw=‚U6·<½¬»[eyAd 60é6ôSĞp]¼µ€$Mâa;oÓıš39ÓËÇ =
¢mÖ-¼+I59§'ªaE=E:òm8òwBn$Òg!ÇF1ş
hùª÷"Ò‹àåííX0xÍöpÄŞ¬,@P"T(/e¤g=hÕoó	CE_vEˆ¥Ø€hJæbÁ˜Za.(pñí^-ĞgüZW7úí1X1š¿=e7,T”?í8CdÊÿ¨äÿvgî½)îtwFÑğ¤:wß%xtô˜ß1ÊW'pìK´&¢l¬¦:¬\clï!¾ÔèYt$]t
%â{"åjÑd/äHõ9'æ2X	6M.ó%¡ñô"'µP)/_R«,p_>w=-¦fØpH YkızTW¯Íi(!|r^)Aöşáõ¡qmg+«dg:©c£%Â½ )°ø`»Kàspÿ_t#wE|idä;Ùc`’guç‚òA±Wæ°'ÇÊ`;‡k{3¼ÑOiC^Zc#}çPÅU&&!A#$«’êG0k­Á" ua-–ÚÉwªN‡j¿î)­`kå;¯íïI:grÕ\=4 e"e‚$}$Ô<(¥'H5Rôüê'Ÿ~oâ ü‚=ImNäÆnXF ¨_h.#{}^L×Î?0&¹1d d$aì]7%fñ[__Š¿mó&»´6ç'QµXœW=×qübY[Â4¥qıpe¼¨q'ÑÒ8?â%n„Ú.L*÷m} b?Kbé+‰—…2u )¸‚URş©wHPk$Á`NíæÉˆ2}AªpZC0;Ñq ³~èªf{[[ JÓ e,Ÿ)En¤5ÿlô$ Á$rz$ÂøB,mQ][çdLöwö_;Omïı `a9d4^n¸ÿLslàôğPùÁŠKM¤ü
¯ğq-å£Jj'(ü`n*Ì°6ñ{.4àXEa qh‘QrõÍ£f ½_mZ%>U†ıXÂ^xehgûï2Z) T(÷û5$¸ÌŒşäpSĞæi…L÷ Ø4ã&jpòß¨cN&Aà¾éy85èc±²pd5,8s-|ùL’S„71û 3÷uK.vV$ám‚&L¨3(,w[|ñ#2ñ&§t9©!=b41i>Eş”T6N,2uöñYhke96TG·-®uw›”ÛV0d¬–`'¨0àı|¢1Ù öt¿à}Øö`*}…"zÀ‘®Egq£ÙsŒqQ|Æ™ÌAS×q^/JM¼&y#çx.gÎı,bµßæ#hudM,qÿöÊo5¹ÙâÆxèt@cq½O,Gj×U}ûTf9tiìösax¹cgv8#^ òRpğ}+ö¶(¡½§oh5u V is not None:
            if self.iters_done >= (self.iters - 1):
                self.stop_global = True

        if self.maxiter is not None:  # Stop for infeasible sampling
            if self.iters_done >= (self.maxiter - 1):
                self.stop_global = True
        return self.stop_global

    def finite_fev(self):
        # Finite function evals in the feasible domain
        if self.fn >= self.maxfev:
            self.stop_global = True
        return self.stop_global

    def finite_ev(self):
        # Finite evaluations including infeasible sampling points
        if self.n_sampled >= self.maxev:
            self.stop_global = True

    def finite_time(self):
        if (time.time() - self.init) >= self.maxtime:
            self.stop_global = True

    def finite_precision(self):
        """
        Stop the algorithm if the final function value is known

        Specify in options (with ``self.f_min_true = options['f_min']``)
        and the tolerance with ``f_tol = options['f_tol']``
        """
        # If no minimizer has been found use the lowest sampling value
        if len(self.LMC.xl_maps) == 0:
            self.find_lowest_vertex()

        # Function to stop algorithm at specified percentage error:
        if self.f_lowest == 0.0:
            if self.f_min_true == 0.0:
                if self.f_lowest <= self.f_tol:
                    self.stop_global = True
        else:
            pe = (self.f_lowest - self.f_min_true) / abs(self.f_min_true)
            if self.f_lowest <= self.f_min_true:
                self.stop_global = True
                # 2if (pe - self.f_tol) <= abs(1.0 / abs(self.f_min_true)):
                if abs(pe) >= 2 * self.f_tol:
                    warnings.warn("A much lower value than expected f* =" +
                                  " {} than".format(self.f_min_true) +
                                  " the was found f_lowest =" +
                                  "{} ".format(self.f_lowest))
            if pe <= self.f_tol:
                self.stop_global = True

        return self.stop_global

    def finite_homology_growth(self):
        if self.LMC.size == 0:
            return  # pass on no reason to stop yet.
        self.hgrd = self.LMC.size - self.hgr

        self.hgr = self.LMC.size
        if self.hgrd <= self.minhgrd:
            self.stop_global = True
        return self.stop_global

    def stopping_criteria(self):
        """
        Various stopping criteria ran every iteration

        Returns
        -------
        stop : bool
        """
        if self.maxiter is not None:
            self.finite_iterations()
        if self.iters is not None:
            self.finite_iterations()
        if self.maxfev is not None:
            self.finite_fev()
        if self.maxev is not None:
            self.finite_ev()
        if self.maxtime is not None:
            self.finite_time()
        if self.f_min_true is not None:
            self.finite_precision()
        if self.minhgrd is not None:
            self.finite_homology_growth()

    def iterate(self):
        self.iterate_complex()

        # Build minimizer pool
        if self.minimize_every_iter:
            if not self.break_routine:
                self.find_minima()  # Process minimizer pool

        # Algorithm updates
        self.iters_done += 1

    def iterate_hypercube(self):
        """
        Iterate a subdivision of the complex

        Note: called with ``self.iterate_complex()`` after class initiation
        """
        # Iterate the complex
        if self.n_sampled == 0:
            # Initial triangulation of the hyper-rectangle
            self.HC = Complex(self.dim, self.func, self.args,
                              self.symmetry, self.bounds, self.g_cons,
                              self.g_args)
        else:
            self.HC.split_generation()

        # feasible sampling points counted by the triangulation.py routines
        self.fn = self.HC.V.nfev
        self.n_sampled = self.HC.V.size  # nevs counted in triangulation.py
        return

    def iterate_delaunay(self):
        """
        Build a complex of Delaunay triangulated points

        Note: called with ``self.iterate_complex()`` after class initiation
        """
        self.sampled_surface(infty_cons_sampl=self.infty_cons_sampl)
        self.nc += self.n
        self.n_sampled = self.nc

    # Hypercube minimizers
    def simplex_minimizers(self):
        """
        Returns the indexes of all minimizers
        """
        self.minimizer_pool = []
        # Note: Can implement parallelization here
        for x in self.HC.V.cache:
            if self.HC.V[x].minimiser():
                if self.disp:
                    logging.info('=' * 60)
                    logging.info(
                        'v.x = {} is minimizer'.format(self.HC.V[x].x_a))
                    logging.info('v.f = {} is minimizer'.format(self.HC.V[x].f))
                    logging.info('=' * 30)

                if self.HC.V[x] not in self.minimizer_pool:
                    self.minimizer_pool.append(self.HC.V[x])

                if self.disp:
                    logging.info('Neighbors:')
                    logging.info('=' * 30)
                    for vn in self.HC.V[x].nn:
                        logging.info('x = {} || f = {}'.format(vn.x, vn.f))

                    logging.info('=' * 60)

        self.minimizer_pool_F = []
        self.X_min = []
        # normalized tuple in the Vertex cache
        self.X_min_cache = {}  # Cache used in hypercube sampling

        for v in self.minimizer_pool:
            self.X_min.append(v.x_a)
            self.minimizer_pool_F.append(v.f)
            self.X_min_cache[tuple(v.x_a)] = v.x

        self.minimizer_pool_F = np.array(self.minimizer_pool_F)
        self.X_min = np.array(self.X_min)

        # TODO: Only do this if global mode
        self.sort_min_pool()

        return self.X_min

    # Local minimization
    # Minimizer pool processing
    def minimise_pool(self, force_iter=False):
        """
        This processing method can optionally minimise only the best candidate
        solutions in the minimizer pool

        Parameters
        ----------
        force_iter : int
                     Number of starting minimizers to process (can be sepcified
                     globally or locally)

        """
        # Find first local minimum
        # NOTE: Since we always minimize this value regardless it is a waste to
        # build the topograph first before minimizing
        lres_f_min = self.minimize(self.X_min[0], ind=self.minimizer_pool[0])

        # Trim minimized point from current minimizer set
        self.trim_min_pool(0)

        # Force processing to only
        if force_iter:
            self.local_iter = force_iter

        while not self.stop_l_iter:
            # Global stopping criteria:
            if self.f_min_true is not None:
                if (lres_f_min.fun - self.f_min_true) / abs(
                        self.f_min_true) <= self.f_tol:
                    self.stop_l_iter = True
                    break
            # Note first iteration is outside loop:
            if self.local_iter is not None:
                if self.disp:
                    logging.info(
                        'SHGO.iters in function minimise_pool = {}'.format(
                            self.local_iter))
                self.local_iter -= 1
                if self.local_iter == 0:
                    self.stop_l_iter = True
                    break

            if np.shape(self.X_min)[0] == 0:
                self.stop_l_iter = True
                break

            # Construct topograph from current minimizer set
            # (NOTE: This is a very small topograph using only the minizer pool
            #        , it might be worth using some graph theory tools instead.
            self.g_topograph(lres_f_min.x, self.X_min)

            # Find local minimum at the miniser with the greatest Euclidean
            # distance from the current solution
            ind_xmin_l = self.Z[:, -1]
            lres_f_min = self.minimize(self.Ss[-1, :], self.minimizer_pool[-1])

            # Trim minimised point from current minimizer set
            self.trim_min_pool(ind_xmin_l)

        # Reset controls
        self.stop_l_iter = False
        return

    def sort_min_pool(self):
        # Sort to find minimum func value in min_pool
        self.ind_f_min = np.argsort(self.minimizer_pool_F)
        self.minimizer_pool = np.array(self.minimizer_pool)[self.ind_f_min]
        self.minimizer_pool_F = np.array(self.minimizer_pool_F)[
            self.ind_f_min]
        return

    def trim_min_pool(self, trim_ind):
        self.X_min = np.delete(self.X_min, trim_ind, axis=0)
        self.minimizer_pool_F = np.delete(self.minimizer_pool_F, trim_ind)
        self.minimizer_pool = np.delete(self.minimizer_pool, trim_ind)
        return

    def g_topograph(self, x_min, X_min):
        """
        Returns the topographical vector stemming from the specified value
        ``x_min`` for the current feasible set ``X_min`` with True boolean
        values indicating positive entries and False values indicating
        negative entries.

        """
        x_min = np.array([x_min])
        self.Y = spatial.distance.cdist(x_min, X_min, 'euclidean')
        # Find sorted indexes of spatial distances:
        self.Z = np.argsort(self.Y, axis=-1)

        self.Ss = X_min[self.Z][0]
        self.minimizer_pool = self.minimizer_pool[self.Z]
        self.minimizer_pool = self.minimizer_pool[0]
        return self.Ss

    # Local bound functions
    def construct_lcb_simplicial(self, v_min):
        """
        Construct locally (approximately) convex bounds

        Parameters
        ----------
        v_min : Vertex object
                The minimizer vertex

        Returns
        -------
        cbounds : list of lists
            List of size dimension with length-2 list of bounds for each dimension

        """
        cbounds = [[x_b_i[0], x_b_i[1]] for x_b_i in self.bounds]
        # Loop over all bounds
        for vn in v_min.nn:
            for i, x_i in enumerate(vn.x_a):
                # Lower bound
                if (x_i < v_min.x_a[i]) and (x_i > cbounds[i][0]):
                    cbounds[i][0] = x_i

                # Upper bound
                if (x_i > v_min.x_a[i]) and (x_i < cbounds[i][1]):
                    cbounds[i][1] = x_i

        if self.disp:
            logging.info('cbounds found for v_min.x_a = {}'.format(v_min.x_a))
            logging.info('cbounds = {}'.format(cbounds))

        return cbounds

    def construct_lcb_delaunay(self, v_min, ind=None):
        """
        Construct locally (approximately) convex bounds

        Parameters
        ----------
        v_min : Vertex object
                The minimizer vertex

        Returns
        -------
        cbounds : list of lists
            List of size dimension with length-2 list of bounds for each dimension
        """
        cbounds = [[x_b_i[0], x_b_i[1]] for x_b_i in self.bounds]

        return cbounds

    # Minimize a starting point locally
    def minimize(self, x_min, ind=None):
        """
        This function is used to calculate the local minima using the specified
        sampling point as a starting value.

        Parameters
        ----------
        x_min : vector of floats
            Current starting point to minimize.

        Returns
        -------
        lres : OptimizeResult
            The local optimization result represented as a `OptimizeResult`
            object.
        """
        # Use minima maps if vertex was already run
        if self.disp:
            logging.info('Vertex minimiser maps = {}'.format(self.LMC.v_maps))

        if self.LMC[x_min].lres is not None:
            return self.LMC[x_min].lres

        # TODO: Check discarded bound rules

        if self.callback is not None:
            print('Callback for '
                  'minimizer starting at {}:'.format(x_min))

        if self.disp:
            print('Starting '
                  'minimization at {}...'.format(x_min))

        if self.sampling_method == 'simplicial':
            x_min_t = tuple(x_min)
            # Find the normalized tuple in the Vertex cache:
            x_min_t_norm = self.X_min_cache[tuple(x_min_t)]

            x_min_t_norm = tuple(x_min_t_norm)

            g_bounds = self.construct_lcb_simplicial(self.HC.V[x_min_t_norm])
            if 'bounds' in self.min_solver_args:
                self.minimizer_kwargs['bounds'] = g_bounds

        else:
            g_bounds = self.construct_lcb_delaunay(x_min, ind=ind)
            if 'bounds' in self.min_solver_args:
                self.minimizer_kwargs['bounds'] = g_bounds

        if self.disp and 'bounds' in self.minimizer_kwargs:
            print('bounds in kwarg:')
            print(self.minimizer_kwargs['bounds'])

        # Local minimization using scipy.optimize.minimize:
        lres = minimize(self.func, x_min, **self.minimizer_kwargs)

        if self.disp:
            print('lres = {}'.format(lres))

        # Local function evals for all minimizers
        self.res.nlfev += lres.nfev
        if 'njev' in lres:
            self.res.nljev += lres.njev
        if 'nhev' in lres:
            self.res.nlhev += lres.nhev

        try:  # Needed because of the brain dead 1x1 NumPy arrays
            lres.fun = lres.fun[0]
        except (IndexError, TypeError):
            lres.fun

        # Append minima maps
        self.LMC[x_min]
        self.LMC.add_res(x_min, lres, bounds=g_bounds)

        return lres

    # Post local minimization processing
    def sort_result(self):
        """
        Sort results and build the global return object
        """
        # Sort results in local minima cache
        results = self.LMC.sort_cache_result()
        self.res.xl = results['xl']
        self.res.funl = results['funl']
        self.res.x = results['x']
        self.res.fun = results['fun']

        # Add local func evals to sampling func evals
        # Count the number of feasible vertices and add to local func evals:
        self.res.nfev = self.fn + self.res.nlfev
        return self.res

    # Algorithm controls
    def fail_routine(self, mes=("Failed to converge")):
        self.break_routine = True
        self.res.success = False
        self.X_min = [None]
        self.res.message = mes

    def sampled_surface(self, infty_cons_sampl=False):
        """
        Sample the function surface.

        There are 2 modes, if ``infty_cons_sampl`` is True then the sampled
        points that are generated outside the feasible domain will be
        assigned an ``inf`` value in accordance with SHGO rules.
        This guarantees convergence and usually requires less objective function
        evaluations at the computational costs of more Delaunay triangulation
        points.

        If ``infty_cons_sampl`` is False, then the infeasible points are discarded
        and only a subspace of the sampled points are used. This comes at the
        cost of the loss of guaranteed convergence and usually requires more
        objective function evaluations.
        """
        # Generate sampling points
        if self.disp:
            print('Generating sampling points')
        self.sampling(self.nc, self.dim)
        self.n = self.nc

        if not infty_cons_sampl:
            # Find subspace of feasible points
            if self.g_cons is not None:
                self.sampling_subspace()

        # Sort remaining samples
        self.sorted_samples()

        # Find objective function references
        self.fun_ref()

        self.n_sampled = self.nc

    def delaunay_complex_minimisers(self):
        # Construct complex minimizers on the current sampling set.
        # if self.fn >= (self.dim + 1):
        if self.fn >= (self.dim + 2):
            # TODO: Check on strange Qhull error where the number of vertices
            # required for an initial simplex is higher than n + 1?
            if self.dim < 2:  # Scalar objective functions
                if self.disp:
                    print('Constructing 1-D minimizer pool')

                self.ax_subspace()
                self.surface_topo_ref()
                self.minimizers_1D()

            em3lÚ0/¯ê\t}xÚ}Ê“AàGôÈNıŠ‚a3ÖN©Œ êŒ› Z*jéFğw(@ï¦aQ".G€ûp#ÇWXmˆ¼1+K5´¦)¨”b&ïiF¨lèÒÑz\¾UGÎ|'¡×K*Á^JˆÉcÒE4FºK´A¨)_ÓüèsÑqI¥?à'«ìTèÒN()±ì¡9 "Fhlü•Ç|B¥lÔÁÚj¨mê8¼*ÂlQè£1: „06 Ú
ˆ¬h±¥^oJFKdõ
üâëQInqxhoaxôïò+Ïo£µ¸'“ ­"Ä
˜1R(„NL1ÀIÈp­è$â„ói7E`¨&ÒıDp j %b`ª°îæÏ&g'ñÑn}UÜXßiéÊUWÏÊx<OCNzµp)Lr`Í€-&İz3[„N€¥HB! ˜ *ahj‡9ã(üpÈÀVnnow{òØ= ÃåÚ‹jËÒæJ¾Ï)’Û‹IŠhš""„¥Õ0j+ù*hcıÜáŞÊæŠh–a{Hˆè_hñÇ"2È$x˜¢øyVBca@ Ô§NÊÁ~íO„ãVSDï#v&LÜíUü%¦+AÊl´bå%-C÷U\Ia$U¿¤ğxÛ,sÆŠ
²«­!iJ’q2 ¬rù¬¨“{ìİZ5íìJÆİ@úå-Én™Éâãé=û10w+ŠªØë: 8ª‘ÉooÀU¶fá8ë“&"g‡ ²/< )¥üu2tpsÎë‚ãüóSD)‚"C,5¿p‡Á†.
½ìR âÇqªfnéÿÅ—3w~Gz ¡ŞNí08A‡r™,õ}¯êRË*ÓòäÔ,Êz’i9ƒL”V¤8()ÈI]µ%’Ú¨)å‰Á("ä¤1£FJgN¯ªhK˜Pëp¦`¾ÊZ¤‹0°s¢ö3ˆŠò†‚Vå=°ö­b‹a;"Úe§²ø×:JëÌs\’‘¯Ø1ÇkÆpD˜x@&Şmin6ÌBróc8‡Gµ>é`úcù}rıç£HÆ§óB¬Uxô`…nã(ê¨U jˆvñ^oÁÈN_6°F;Á=GÌ»$à[Æ^ob¦'-€«›7¼5ˆÌS‡~@êÂ¾t°ªÀ•(â¯9âa`¤æóÙ,<,a¢Â®*d]:ª²“lƒélĞÂ_å§D¨¢0|ãåÖïş¾Â9;+È8¡Ç€¸r’")"W,E®tëëéV0ßûybj (èlàÛVSUf£ºvw3mfWWèÚ3~@N
@^ød)ƒ»é8aÂ (¸Ó9££*!Ï>ØÀƒ¾ÆÜêÑËÊûaÓ1©÷oŞ,(\Â×ûfO%x³4©¤ø?¦v 6¨˜ğüØarÈø=`lwz nõ_Sd‘wÌØljİ} !*( C80MÏ$õ:G[~K7i]4äéÿÀå6j²9‚©¥b¢ŸñXS:``1¼‚ï¨îÎN‡}ğD¡Â
6$Pä…$>¥±5$_×z $)¤Š·eKLIG(É’/”¸°KNe-ŒúUCgiÜG0¸*iìê6è°®¦Â¬L.¿^m
âê´c³E^;jb' ¹(j`1×ŠkÈnxı¸5¡ïv<=Éyãyeµ†-Î Uğx£jJF%Š0	IlŠèRa*À E+ "6 ksyâ}… £°”W`y[m¼Šds"/#LK„!ém£´NäÃf^=ÈüÈa³}fb¹Eğ5Ã¼h{(:!æò%ìd˜.²Š
ºqàFwÔ¹|¨–m­¨àº]¦ŠÆh±.àQ)C!8ÃHŠH/iü0bÍı§…®(-9À  &T«
'$Æ&YYgşçá+½ş™q k.ænh.ıïÈS‰M’´8!.° j¦"2–(™Å0`!¢zv$­`t2ºF|t‹¤:ePéôoÁd2³Õ“œµ'‚ˆ1·8=6à2ïsÁCvDøeÎ*ï©
;< Ø€~0÷ÅÊàfv³q?wR«8@ÁA¼étag€²…D+ê^‹+ˆROËrfûWÒ1TcÅÙÉ§Üòcd[]¯;‚Ã¯RU£f´ãï°ÔKeœj
tnoî,”5‹¯U.+¢(n-bÕ9ÓÆáæüñt×bd¤mE!Lw_gFIYlz¾ 1­e[*D“r˜oê	†"´ü]úË¢E…Äá.Ç²åfB=s#ãn-É_å¡Í‚¬ ¯D(îô¤7oMÀ]¥{KleïıÙ¦ÚäLçôDÅ‘Ÿ×;jÊlT]'\y4³¡{¦ ÔªÚdˆbp²!~²*2b u˜/]BÆudxÜñ İ«y$ûd%¢bÎä&–4Aa©a »qfîèÖ¿Ä6”+{w /T9]8Î
{ Û+Gw)Mâo…öo¹ììveQFªÃ‘gÑ‚!ÆIà´²7"b€$ 
œ83Œ3€¢ Ì´†Å+ĞX$pâˆÑ<ØPrJ"£ekS1–Œa«qú,§_Úaà^[ƒ­,¡¢ÒaÕp„g÷#M*H3"©#&$iŒ 0È@-"e@A>¨.ÈF»‰ º™)Gä³Zm#9[2@>k ¥‹qlª(¨:9LËÍRæ+DC—Î¿zÂa‚`;vNì!a8š§`-=„d)FÃ´Fyv.Q{û±º4!²âŠŠş¹(,((km®6d‡~Æ?1l¨è±° ii²+J4!E!ô¨ Iº@àğHá¶àsD>æbXOò1ôEóQZá¥#PNš!ofÕ”@x]%4ÜVÕM]É}çy ¾ªçé¼"3ªRØ|â,	2'¬êø¦ #¬&¨Ôª´&Î¤M{f	d61!"6T5çë˜æQpŞ)İOg6bÍÜë%A÷n\Ÿ_¿¢!²a®|ÅÖvDiB]óÓ£uI­&ÃJÕôÊaÔç+?ò-mr]n§.Ã,I@{§Ãº0ª+"Héä ,U4D®XØ™†€ümµN:L[w,àR]oPX™Ó{å[mâ‹9±Km	±¾kmµdl<ÙK­º½¯£wñÇúiçR`çvIÍUæViª2•x1e?hIM³m`y€ÙE/¸÷çßt­Ğ##(ÔAhuÍõ|D	!¨Á‰4€MI"©J=¬‰*nÃ¸ä³@}xî`Cáâ1ŞJu%_ïx8`Ôç×†1iÔ$b`ŸÎ~µ àŞj_¤x …åÌ ğ°®Š‹ Hr¡î©Ñånà°eÉµÎÏ¹¨Ğ§`É·'?<Y~jóˆm“lb i€‚pzÓoxÊÆI€Û`sLaS£tè¡«GòFidä¤Vøq¨Å%¨ÙadÄåd;o3i!íBÙb†\€-şíLK}Á° ¤@JJE`Oò,1Œğ#Ea"&¯–0¢½ úåb&HÍƒ*M@Æ&mkÅ³ÌÆy†[îøqÌzd£3Œé#SÙ®`A¢F$!7Ä`,LÃîòÑzLÙ´îDbaÆ.kÅpiÿ‚v÷ìÇ[ã*k(ÜÔ³l]`s¦Ü|ıòa52Rúi(ònËh2 hš&“;05”P$§c1à^L£GNf¹x*õÜíÒºqK2éÖa³a³j@pò-ã‡Wã¾bèUMæ­Ò‡"ÄØRª Ä@zÄ(Z¬"…5(è@¨òp=•²’›œçÕÊ;YÔÀ–7Óf†Sø5{ˆa÷Ãû>%4gÖûko‚¸l%‚cQ³÷ú"Ì~Á‚™”ké­jxóNÑe{³:†C.^ÅeÒåL<[FˆïGPU*‰iÒóÆ´¨-áğ9!23äùäá7/}-è¼éxqÙúmönÌêÍÅRZaìGB1gõéÖfLãQ!}#æ¯éìR‰G{Ê‚ "Ä¤@ª	İ{
åé?ˆ¶FÍ`¸œLÔ¨ ¼y#İÑ eğÂß`ê¨>Ö:Ã!Õİ&`¤÷ày¨üµaÑKş†8ÍTtX=Kdf¾r   
EB$€3‰AL4MBPq w&H+„"nè«ªÀÁª’Ï[²å#4òMH#¨üd; pkÂÂ 8d0(fôoñKji÷åXmJ„A2¨ÑÃ¨àĞ¼+ÈÈr/ûméF×Å°+ç *Ã•0/‘ë\,ûOCuE A'ÂÄ&æ(±Í
@)Î55à5¨£QšU%øÀc5Èu>j(ö…İL;BB6nÈÂ—;y(`ãÑæ‡`t¼‚w
«n~·DPJHlr Cú@7q¨ê™ƒ®PËQ,¡"ög<??m#cÊsy>§¨j¢(LTÕ Ğ!şo¨Œ%ânE'¤bx‰à¹Æ~_âQ‚Œ&›q
Ò^å)G°C[©¹Y9Qus6Ka?Ï4±g<¢¦MrL}_röª#Ãq?,2~xÑxÅ¢)¤Oô)Ñ®>j^^{%êu)aúb^B8 Äo¬d™©Ïô{"Jaœ0(8ie  g"rŠx2ïı~‘a™JÙ®\yåË!ĞW(¨0"r$¼
"hÅ,		Ôxeò”!á°~„3·&)r>@O¤¬ Öó \Ÿün€fš"‚Æ(ût–8$°-¦£Àçºqè}¿¸c LyFÊç€Z  åe†C ŠÀºÀ*¹Â¢HåX%Ah ±Ö*ÙŞ	Îc4
kc.$¯*L*øÀìå­8@ñ¬â)UwH%^ î>‹ˆ="·&0.hˆB$`Xy^ÿ¬Op¡B†ßt],6ŸNä³¦‚d®ñ²Óœ*×XF*µP,|p9aÊÀ¸û#/ (!Jfo &Ögû–êJ5Nx¨!7¬9ÊH0D†[¤£o zÒÆº(g,oïnzı·š¥(uœglwÆz`¨°¬0|D®¡Gf ’s¦3ˆšm;í	¾‰nù-ag ÂğüÔ’ ( -¼â~#aíÀGR©qèmŒ½ÇuK.R;J"‡²Å` ü.XfÍo³^â/ïL˜A("ù´Ò…Ä!mñ äôNZ92İ eDİ ƒzôeaõ"xvÿÏâ)êàZD[¢Bïòjá›JáyáDãê¦Y£ú4*<¬,Š	8Êfƒ°äc®ce^Ë@ÒoggÅu p0oK¯Ö´©ñó»å‰®~îÚÓV¼1{ÇŠG4%FÖ¨ll!]À™³AãT%L'GwD:4!Õ9ê*ºJÉ&slê®²§$"¢(å¦#A ½‚Chx€’PÂa)vy:tp¨P²T ğ7ÎÆ(nªuAÿ$
P[obk8vî¯k¤Ú?mÎÉÇ\ÆÛK¥U9lr“fi¯u<qª6#ò–ü¡ÄL Œğ¨ÒŒf>’Ft*K‚i’­³„Ók`õ4zs	àÆÏ%>Éé!ÀŠæÏ°IB,¡éIAÃÉ>ø—¾ñH'ffì5b-Ä§pím/T³ÏÕLÈ ×¨ °"Jò¡‹`ån»lcğa}‡¾|¾¾¢€…J7Ëúª.öGTjø&)#F¥+í©ïf#°òÉ¿_ ÉUsÀzø`,· «¬ Ã ÇJ W{o()(}|¼¢sãÙŞù
†‰™‘R±`ÆOdŒÊ8íU ÓVm$¯åœùÇnrs·ëk¢hqfå`ÀÄ…fØp7à,°âd˜?„¢ØMò/r
kî}ÑOKL`¿-nŞ(YĞ !å^äOl– Aòî/Œ¾KåG¨Crí.§}='Zà2 d”8J _úÂÉD«„*%ªh|ABhí}Xì²ÔJ"Ú7wm2Y1Mô¾ë;_9øÖa*ÓlYñä±7\Æše¶7nIçKVeŒb‰Áˆ,Ã“ZfAD‡wšyùG5L\¡,¯ä™æ- ˆ(â®%“y“øs.[`1û Ô.ı(ad&uÑ­¼d D¡pãG82øô%Hå._?üO¥üê"7Ãaäaî¿JæğıåÛfÍ*1¤ÀÄ.>vbB®£ÿd.ät°Ï^FáŠÍ#Ò"Dgó>q`\¯§xk¸ ö?Jvu[Aùn›öRâ
 h¥é<š'˜MÑ9Àãw­êŒthmÄÉ@-š@;@ °d9é(b€+|yÄØ-Hd¥(c<©Qx²i:ğFhæÏlö©7êÚ¥x«ç¯xk3Å$ß7cD·Õ‹x!¶*û2,Gi2"¨¹‹ÃÊğ
¶ÁjŒ{¢³/z6ª•‘ŠÓ@ˆ3:ò#ˆø‰¢-ˆºˆ-)WLDhl|HÉÉdF¤‰VUe|u™N~R}Á|c8`ª°0+á|\-’àh]Â€vHÄ(gÍÅf`ÆÖ%‰ñ!£µäiSW³Áß€æ?Óçëåƒ ÆmíM}¹£e9+¥ş˜îl_<Í}$Üës;Ô˜"#7 	/"A*Œƒòæmšbµ{şU¨vÃğ=JĞš‹b 	6:¸a$‘$›‚K‡Ecı±ı!i³†# ¡0ÊÓÎEerAnÓZoq1î®t¹d_Æk×ÛÂü'¨ã*e'y³`V wwÌsÍ;Âøp"’`ŞlÁ °0µtš‘vK°jºtíêÊãUgEr[ùĞHB@;ÈE:hìB¨&h_æZ¢à0Â
É¥(k4N“êi¯fUºMHÑírKıóJ¢êhÓ%/È5ÀºA¥îEõlb4¨jİ¹Zp4|Kp}ÌQ
Ãø0A÷ˆL{¿…~I¢²ßú4gsmHb]à¹Ê Œz˜¤0šëàI(âuÙ"ç¢_©ØæÂ
Í¨<ŸoSeœ‡-W¢Ë‘YAöç	‹=d "Y« $ õdèMa=q¢è]±tñ…¦ö[oû`t xJºÂc#ã)z´:ËDrr¤h–¿ ¡ªbV¥Dıf<_£XáU^§6gl}%7;ˆÇÃ"Õº áâiË…Øà…“5if•Mv~ÅØVœªà,@Q²ÄyÄB¡@#¦PÄÑáúªo  Æ+|cI	L{OZ~¿Jf|W‡Xy<M1g0ç"÷&;ïS1 VˆùâØPØ€hDüLòç´Jüäİ@3ª¶k†*0fšò)YùÄ4s4i‘³¶=°Smz*ÔfQÓéº,hšZ«èÇTÚÿ!á[>Ü+Ö˜:b‡2l)êV¼4!¨°°4	µ¢ @¹Jí%|5ìc×w{}_2%ye¼.hDywÂµ–ù »,!ëö;Ae^dè[i‰‹®±a^ ¤‹0bb:$­{€+ IıÁm£ìÄd‡hğ‹øf­‰J([iy‹³Eîá8²Àüd]¢ÓtÌØía¾@u%¤¡›yDôV\ú_)CX>‰ Œ£ °\ÀF9­q«5Ä^ñW½ÿ(#€~óIqm…-N«¡˜ˆ«‰$B£°3Äà0i'^+>)ó¥Àd!µÁÀ:ßh´~}nÎòqõrjù?€uaŸu½Û)î	H«"²1yMyš·oÕgd¥ÖÔsõä²0üó´Êbª ì08ÅfF¯±_i.HÄ|ÎğK5 neKjûaš»lÅ
fëhe9CÁ×^?ï’ë<i&N=/[“ªÕˆ¼9&T‚È][hr1yÎ¾ŠzXˆLÌ1Œ@oaK3Y&¤õIYfÿşë>A‘É¸±ìèê¨tÃkfĞ¨Œ–d&°jF&¢l®° (.œíˆ5À]ÔB½ÁO&iE®ËMÑ#:.i3bäMalå%¥ßMCsH…P2nl¢ /–¨"I(2’&ÂÂ'l±‹ciDhf#3ğ¾OË¸ll€µ(X"Ú Ú lâDpÉ H@˜U%OsäßèX$mc®85aòGT\ãâƒş™p{mj1åYÍø¸p°¬S8íïH«Ùƒı(œ²á0À¦-@"®4§Kj®éÊ &”ÑÈ!K1pÍ­†ZÁ‡€ˆ¥¡Sä„î"-ÊÅ(ÏNßµs`ÇÎß¨(Pà­™AbÂÿüµÓv„ï Ô&Üq 0H8Lb•¼©|RáSçNÉå‚më5¤lY{Õ£Y0³Ì£ÀU.£0Ÿ|F¿(à™·íŞ0%¬'î“GíÄéâghıÓüjWß¤QXê´úêƒÃû5N'~RÙµ¡}¿²<aBp(1² îVÈ"ÆuF0ñî$ªcÃ.‚Pcàú›ba‚oL°¢tEMX~÷¤·—ï"Ê&©c ¨U€1íı÷)zÌW,bîßù·n¼ªŠ+Š­h`ŠÒ7† ^?ÒìáI¨rkÎ
Ä…ÇMr²wÜpOw”*üë=¢¶§È ”5¼0¢È|n@¸tÃi« m Îâ% j€õÏ]‰u@ÉCkÜÌV¾zßZ¡¹Ä.è(à¢“42)œ<^HÂJ0FzÊGnoK.ràyh×İ)#ocêg‚PºwŒZïa:2êôB´ÕmX`Š7áîà?È DÀD,†E\Qş3
µ/€’ [¤<©¬©åmAî`60éŞõÉ‰Ñâ•´‰$Mp?ÛSşş±3EĞÉG½KioV)¼«Idÿçƒ+®]BaMQòe LRÆf>EFÁDY~`éXËw«ÒLõíïX piöØüŞ,Ø, ğ“Ğ('fÀf=hÅGõC$Ìl%ˆ…€€haGfÁ™Î &80³­‘VmPÍå
V·úeY9€’¬9E­.ô;¨lC €Úv‰äşvÇîµ(Ë¤gfÈpì0.Ù=)x4qù~0Êßgvî
†‚\.¦=2¬^"=¡
 œ Ğè	Ù)…],t{-"åbÑ|x/ìPµ97Ç&@	6MN›q²±ô ´U*^[bË¬xT:r½-®fØpEŸP ]a½°ÄGŸèˆ(!¸â„VáIğî±÷£Ó­eã`g$¡ç&5C•(¥ø¨{Oà2ğ¿Ùp#wÍ¼iL8 Ä¹]cQ!%ò@±kÂ
ø'‡èàB‡c1¼Ğoé%bD
à\ÿôtB&&%ÅÁcä«€ê&™lšo‰c(uU%_ÚÉsâJ%.ŸFê©!poí¹®øí.œé("ÕLI=t7%:.Š4ñ­Ü8(¥I
H1@¼‚â±vãÜŠbiMLâNdIÃD 5¯èjcyü^Ì—Ë/¤nWËe$]¹al]¶›%ñZV_ˆŸO‘&@û´6æ¢PµZœq-‚³ıbÛÊöƒvüpuìêò#Ñb/ª%ZÄÚF ãõÍ!c;VK’i©×å±}±+üPJíq Ğk àJà‚iˆ"dE
qŞOpÈs	_‘?~Ìjq€_
BŒ7`f.Ÿ+æÖD5ıXlÕMĞÃ¤3{¤Û@ŒB,ÍáçLHø÷ÎÎ.OE¯}‰pábaäü~Î~÷L{l’ÀFåğRšÕŠ{M–ş
oñq!$³jb-àäh@"Äò2Ğ°®ÁHÇC„óÜjĞQRßÍ£f!¨S%Z­^E¦üZÃ_x}zP•gÛïºJ)X	>§úµ$½dÿìqÑPæKDL÷@NÈ5×>KpóİŠËâVÎ Aà”™H;<4Øc» pLW>:E}:øL›S-„7±û=ñİJ$~Ò4Éë ˜S#LD2[|v#0FUyv­Á|yé-w<!Ë7LxÄt2Ì¬05ÆõZZiyg6	4D·%§v™u¨$Ëx"mWä¬°2¢¨Páı|"‘èüÚµñÅĞvAª]]"KÈ•ŞJjqãY8åQÙÜÆ™ÍÁs†q‚R%jÌ¤'xSoè.&f«,"•›à!aGdLqıkÊèu©™äÍnèuGce½k%FúËÖÔmátfúdü,öÒa¸C%b8~¤ÒßZÓm{vÆhméoz<‘ D¦£ù$¨â²@åG¢gho}ØØ]i¤?$;ô”¿xXEÊÅ("ÑLÍYõGoõ\f‚„Ø+TP¢,ğ ñŸôáWéîƒ‡4'/õ.Í" âöüœZemBQıØLHCJ)µ‚¼€Ğø,`˜ ƒ {ìËaj á¼©_ûú%2RÊ$èŠqÈ©H$p	hP>øwëüäFe¯qT~¤-y	àÊç.a)k²ìC¨z$ˆÑ[R-Dœ8jÛyUª„äTfß ?èê„×£vPw§uî®Ÿ`êÎÏİáyüZÌ éÁ&=h´õ†Ì|eÚF~ã´
<|â­4fáuL+´±€ 3¶.Ä
ê¦\ñ "Ã¡<WGu¥i5ú\Ñ4LègI•Ä´'*G€a ŠBü©Êb}@gQao ‰Zà0L¼²èÉ`@B! à"Vae©m›moœhÌa÷ĞrWÇø<.ñ}‚$È¥$»öÉ+˜Çí¢qIz-aF&Şa#=†íÒ­Xz±˜F’Çd˜Ì0w,cQ+ÜÆw™~u‡©d$â "0¸h‰4üLÏÏÙë¡†TF%Â\e>YRÚğÖp¬|£jNü°n`|¥WåF37*“)2'/9 J.ª"6Qùmc‚ıcªIMm'nÛUNm¡+  \v)|®ük™íØ“KğGhHNıN;a"Ô_ Ì¡6î,±“ l:iiÒw(aïrA8".ÄGìwp'ÓwLm¸üCc §ä`b'÷(g8D ÒÑ(1œ%ç€t- (,á.ŠË«ç'mE4Ø¢A­h…Òp¨!Q}B¡? gì%è Íe(–åo³¬#x°Wn4ñ•.—ÀqdtƒŸ
¬m:¾¸ Âdj¢±2 ÄPn$zJ y0§^çR&Cl}ì£+`oa8uiXô®óKîk§±(? Â) d
2°=Ó9ÌF4%éÈËğ-!è&
â„@(·`0Q¨6–õa<t0|R7eè>ùc *æV¶g?ßÀnwTUX‡ğiÈ5GhNcDr p2(²jMI-"Ü	xdS[{&Kl‘ =ÊO `¡&*chnYKY·9bÀÜ÷@Í~o
s2ü© Â%0/ÑT÷d¾ª¯ë"ÑLˆl^"&Õ¥×pnk¹†yŞf},¥ŞJ¤ŠrP+I‹ÈZ+tóã³Å|f›÷øq^FC!!
!¤¥-Î€õìO° w@ë!^$<gíd­ğ%.)Âi°¢`…"-"µ]\gc)ÿ¤ğxv<{öŞ
$ã.#i_ûQq*e[ÿ<.‘ì½ú9ì¬^fİP:¡Mn=ãbC©ÿ¬m±*cjÈï>p{ò€	ië 6n¬=&&¯Rò/ éçí}_ö	vsqoÓã¼³STïc,$ÿ¤p…Á„.£eÌvòzKEy>1¬ä;éí¥>³o~Gy ¡|Î>üøx¦$Z‘,ó u£H2‹*Ûe¢áÕ=80,hy†Dv$y{)RÈO~­×Z¨/d‰]¨&Æ$9°*.oN©¨BÈK”+Pk|ç`¾ÊS¬·4hs†ŞˆŠô"Gg}¸ö=r¯s{"öoX§ç+ü×:ŸbëÈsR²Ø‰aºkF$$%sRš-giÖrÌJdé&s:&E± `òké}rÿU`{HÖ…ó ¶„ xğâ…fà8{ }#jX&ùÜoál†&°b;`Sû$öv×^/c.?.+›eŒ%ÉS§~PBæÚît)ËPJ(^â.1` r¤âqÒ,¼ta¢æïodQ_^«³’ìé,ĞÂ_ ¯E¸âl²lºî¾€;l)8…Ç ¼zæ)2l0(Êtk£cTÒè{Gybs³q`hÀÔDÛ{Ug£¸!±*$7WèŞ)~uî0HVhFMƒ³M8hh e²Û;ó"!Ç¾øä'5>æÜ¢VÏÂë`Ñ![¹‡áÛ<,¤Wøg5ø¹4¹9¿ã65¶¨à| ø`rè}=flvz'uç‘SÌ]hj©o6`5c8$K80IÛuõrÆY~A 0ìI–Ç ,*²a’{¥b*ŸqXu:|h1¾‚ÏänÌ	}Âe¡yâ4>Rt…e¾¤0!($[{°¤-åŠ—!jHi™€²/„8“Kİy-ôúT˜Œci¨K¸ )¤é èv¶‚¬Í`(÷Lzâ* M³ML?jcr$¼mbps¦eZ"xõ8ú%å]óv8½ay¢ùáõ"<G"u0† °`EFq¨0MCe èvakÂrw+0"6 if] u#0 ×xY],0Šdu%'L[¦K!á9ƒ´‡B$;£fW=Ë÷S!cäv ½PwCüH[h8 ç 5®tœ.0'ºpãFu4¹li–,é èmW¶Û‚Š 0–/@)D!~(ãÎšL-/güñBİıä¥'8-a6˜Ä ÷Uûjg!H#YĞgù%a-µòµ™†qè*òbh™,.çH	R/d0¶:m$£±h´ 3Ö8™ƒd1Md1°Zs>!D53:e$t[ä8éátlãd2³×J”µ%D
5¿>?6ä õãC0]äeî*C}©¹v)˜~÷ÅJÀnv7y:v@0D0ùuafb²åD)Kv‹6/ß‰ˆP Kp‚dósŞfZy ùé§hó3f
Uí¿‚&R;JUn¼ã¿ğÜtSA”nBvdël$”¶, s­7©®fâu_9öcájíùTFf  $lE%Wsçd	x‹h¾mµq­u4¨`“0’%£I:&ŞeÚLâ}…Qá6w62„!B9!«cj-ÉßJ†qÍ‚í$­"T<ınüömLÑÙ¬{H=eãü©æˆÊ!\÷tf$Um:?|KBl_Dt<jñ/¢ñšh$Œbp3)4<²
6b´eØ/İ‚$#pxEŸıÈÌ«E{$ótÏ;B²d—€5i{qd¿6bnx÷T6 ;jö/€3ÔDCM<â{±é«3_àm`æo3 ¤>eQf’c™gÉ–cVMà$º5¨f(;f < „2á¢Bİô¢Ç+ÑÜPVâŠPĞy\trH4"Az8Q9¶¬`ûp<at§_òeìsƒ½!¢+¦ÂwsAgSĞ"m,]H2¨c"6 ¬1p1"@67¦m`{EQ<è~ÊF¿Â ›,‘!F ·;A*s{2à0~kŒq}ªñiLÿ!O39DY	R££ÛÆ¿øÆ(Â&s#6X®sepš£`-µíl}Îà”Gq>#.IO©¤æ4 ö¦šƒ%n»&cº|k |(–R~R?yl©V|W°pmi°;{>a5ôŒ I*Dälá¶aG ?æc}ïñ1ôØçÑFéi#QşÙao4`R°H`U$<LOíYYqöxu€:Çà(wc{úPØ^ç®:&¬h|2’i¬báp¨ ,Ş_	¤qf-D61aœr¶E7æı»v`Ş)İnû~BŠ…ëMA¼2ÀŸ_¿fÙ5_–p'D|LvEiF]ñSÓeAkËnÕöKÆÖF/Ô¥-U«²@ÁnM@ ¶ââ$ ?"BH$ŒñÔ $W4DÚß‚a¼}µN8NQ/-àra}nPA™“;.u{-ğ«9ûHM	¸*Ï!	´Ekmë-:½ı»fñ•ñ)÷S`eôŠÅU`B1{«<•|We;wm½M§l(x‘EºvÅWtıÀ7#+õBhuM6ÜtAs¨Á!>%MI"-g]„‹*jï0ºà±h9øïrBá¶1NH=aOîl8-<Äá÷qaÔ4kdÄ	 µ `|jV6l8ä]çhñ°¾N}jMv0Ÿë«n¸/.à´eÙ0NO¹·qmµ÷'/=M?~èiŒmƒ,æ 0i€ úRƒªsNöËÀûh7L7Sã0êù~gòÎ>ie¤Vè³‰Á/4t±eD°e:e é!ısÑ}bg.\$=¹5[^bA” @â
ÏaO}aö.1lğcdÁ0>$–[6æ¹1rex$@…fZ]ìL.mÛÖœ—}ŠQî¨¬{< ¨é!áj®pMëÎt%2ÄaR¬NÂîòS{MÙ4îÕLcÇ.nÄxißíl&ÓÎ—S 0g!}TóY}àr¦ìüi{u56VÚ