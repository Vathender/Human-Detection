import operator

import numpy as np
from numpy.core.multiarray import normalize_axis_index
from scipy.linalg import (get_lapack_funcs, LinAlgError,
                          cholesky_banded, cho_solve_banded,
                          solve, solve_banded)
from . import _bspl
from . import _fitpack_impl
from . import _fitpack as _dierckx
from scipy._lib._util import prod

__all__ = ["BSpline", "make_interp_spline", "make_lsq_spline"]


def _get_dtype(dtype):
    """Return np.complex128 for complex dtypes, np.float64 otherwise."""
    if np.issubdtype(dtype, np.complexfloating):
        return np.complex_
    else:
        return np.float_


def _as_float_array(x, check_finite=False):
    """Convert the input into a C contiguous float array.

    NB: Upcasts half- and single-precision floats to double precision.
    """
    x = np.ascontiguousarray(x)
    dtyp = _get_dtype(x.dtype)
    x = x.astype(dtyp, copy=False)
    if check_finite and not np.isfinite(x).all():
        raise ValueError("Array must not contain infs or nans.")
    return x


class BSpline:
    r"""Univariate spline in the B-spline basis.

    .. math::

        S(x) = \sum_{j=0}^{n-1} c_j  B_{j, k; t}(x)

    where :math:`B_{j, k; t}` are B-spline basis functions of degree `k`
    and knots `t`.

    Parameters
    ----------
    t : ndarray, shape (n+k+1,)
        knots
    c : ndarray, shape (>=n, ...)
        spline coefficients
    k : int
        B-spline degree
    extrapolate : bool or 'periodic', optional
        whether to extrapolate beyond the base interval, ``t[k] .. t[n]``,
        or to return nans.
        If True, extrapolates the first and last polynomial pieces of b-spline
        functions active on the base interval.
        If 'periodic', periodic extrapolation is used.
        Default is True.
    axis : int, optional
        Interpolation axis. Default is zero.

    Attributes
    ----------
    t : ndarray
        knot vector
    c : ndarray
        spline coefficients
    k : int
        spline degree
    extrapolate : bool
        If True, extrapolates the first and last polynomial pieces of b-spline
        functions active on the base interval.
    axis : int
        Interpolation axis.
    tck : tuple
        A read-only equivalent of ``(self.t, self.c, self.k)``

    Methods
    -------
    __call__
    basis_element
    derivative
    antiderivative
    integrate
    construct_fast

    Notes
    -----
    B-spline basis elements are defined via

    .. math::

        B_{i, 0}(x) = 1, \textrm{if $t_i \le x < t_{i+1}$, otherwise $0$,}

        B_{i, k}(x) = \frac{x - t_i}{t_{i+k} - t_i} B_{i, k-1}(x)
                 + \frac{t_{i+k+1} - x}{t_{i+k+1} - t_{i+1}} B_{i+1, k-1}(x)

    **Implementation details**

    - At least ``k+1`` coefficients are required for a spline of degree `k`,
      so that ``n >= k+1``. Additional coefficients, ``c[j]`` with
      ``j > n``, are ignored.

    - B-spline basis elements of degree `k` form a partition of unity on the
      *base interval*, ``t[k] <= x <= t[n]``.


    Examples
    --------

    Translating the recursive definition of B-splines into Python code, we have:

    >>> def B(x, k, i, t):
    ...    if k == 0:
    ...       return 1.0 if t[i] <= x < t[i+1] else 0.0
    ...    if t[i+k] == t[i]:
    ...       c1 = 0.0
    ...    else:
    ...       c1 = (x - t[i])/(t[i+k] - t[i]) * B(x, k-1, i, t)
    ...    if t[i+k+1] == t[i+1]:
    ...       c2 = 0.0
    ...    else:
    ...       c2 = (t[i+k+1] - x)/(t[i+k+1] - t[i+1]) * B(x, k-1, i+1, t)
    ...    return c1 + c2

    >>> def bspline(x, t, c, k):
    ...    n = len(t) - k - 1
    ...    assert (n >= k+1) and (len(c) >= n)
    ...    return sum(c[i] * B(x, k, i, t) for i in range(n))

    Note that this is an inefficient (if straightforward) way to
    evaluate B-splines --- this spline class does it in an equivalent,
    but much more efficient way.

    Here we construct a quadratic spline function on the base interval
    ``2 <= x <= 4`` and compare with the naive way of evaluating the spline:

    >>> from scipy.interpolate import BSpline
    >>> k = 2
    >>> t = [0, 1, 2, 3, 4, 5, 6]
    >>> c = [-1, 2, 0, -1]
    >>> spl = BSpline(t, c, k)
    >>> spl(2.5)
    array(1.375)
    >>> bspline(2.5, t, c, k)
    1.375

    Note that outside of the base interval results differ. This is because
    `BSpline` extrapolates the first and last polynomial pieces of B-spline
    functions active on the base interval.

    >>> import matplotlib.pyplot as plt
    >>> fig, ax = plt.subplots()
    >>> xx = np.linspace(1.5, 4.5, 50)
    >>> ax.plot(xx, [bspline(x, t, c ,k) for x in xx], 'r-', lw=3, label='naive')
    >>> ax.plot(xx, spl(xx), 'b-', lw=4, alpha=0.7, label='BSpline')
    >>> ax.grid(True)
    >>> ax.legend(loc='best')
    >>> plt.show()


    References
    ----------
    .. [1] Tom Lyche and Knut Morken, Spline methods,
        http://www.uio.no/studier/emner/matnat/ifi/INF-MAT5340/v05/undervisningsmateriale/
    .. [2] Carl de Boor, A practical guide to splines, Springer, 2001.

    """
    def __init__(self, t, c, k, extrapolate=True, axis=0):
        super().__init__()

        self.k = operator.index(k)
        self.c = np.asarray(c)
        self.t = np.ascontiguousarray(t, dtype=np.float64)

        if extrapolate == 'periodic':
            self.extrapolate = extrapolate
        else:
            self.extrapolate = bool(extrapolate)

        n = self.t.shape[0] - self.k - 1

        axis = normalize_axis_index(axis, self.c.ndim)

        # Note that the normalized axis is stored in the object.
        self.axis = axis
        if axis != 0:
            # roll the interpolation axis to be the first one in self.c
            # More specifically, the target shape for self.c is (n, ...),
            # and axis !=0 means that we have c.shape (..., n, ...)
            #                                               ^
            #                                              axis
            self.c = np.rollaxis(self.c, axis)

        if k < 0:
            raise ValueError("Spline order cannot be negative.")
        if self.t.ndim != 1:
            raise ValueError("Knot vector must be one-dimensional.")
        if n < self.k + 1:
            raise ValueError("Need at least %d knots for degree %d" %
                    (2*k + 2, k))
        if (np.diff(self.t) < 0).any():
            raise ValueError("Knots must be in a non-decreasing order.")
        if len(np.unique(self.t[k:n+1])) < 2:
            raise ValueError("Need at least two internal knots.")
        if not np.isfinite(self.t).all():
            raise ValueError("Knots should not have nans or infs.")
        if self.c.ndim < 1:
            raise ValueError("Coefficients must be at least 1-dimensional.")
        if self.c.shape[0] < n:
            raise ValueError("Knots, coefficients and degree are inconsistent.")

        dt = _get_dtype(self.c.dtype)
        self.c = np.ascontiguousarray(self.c, dtype=dt)

    @classmethod
    def construct_fast(cls, t, c, k, extrapolate=True, axis=0):
        """Construct a spline without making checks.

        Accepts same parameters as the regular constructor. Input arrays
        `t` and `c` must of correct shape and dtype.
        """
        self = object.__new__(cls)
        self.t, self.c, self.k = t, c, k
        self.extrapolate = extrapolate
        self.axis = axis
        return self

    @property
    def tck(self):
        """Equivalent to ``(self.t, self.c, self.k)`` (read-only).
        """
        return self.t, self.c, self.k

    @classmethod
    def basis_element(cls, t, extrapolate=True):
        """Return a B-spline basis element ``B(x | t[0], ..., t[k+1])``.

        Parameters
        ----------
        t : ndarray, shape (k+1,)
            internal knots
        extrapolate : bool or 'periodic', optional
            whether to extrapolate beyond the base interval, ``t[0] .. t[k+1]``,
            or to return nans.
            If 'periodic', periodic extrapolation is used.
            Default is True.

        Returns
        -------
        basis_element : callable
            A callable representing a B-spline basis element for the knot
            vector `t`.

        Notes
        -----
        The degree of the B-spline, `k`, is inferred from the length of `t` as
        ``len(t)-2``. The knot vector is constructed by appending and prepending
        ``k+1`` elements to internal knots `t`.

        Examples
        --------

        Construct a cubic B-spline:

        >>> from scipy.interpolate import BSpline
        >>> b = BSpline.basis_element([0, 1, 2, 3, 4])
        >>> k = b.k
        >>> b.t[k:-k]
        array([ 0.,  1.,  2.,  3.,  4.])
        >>> k
        3

        Construct a quadratic B-spline on ``[0, 1, 1, 2]``, and compare
        to its explicit form:

        >>> t = [-1, 0, 1, 1, 2]
        >>> b = BSpline.basis_element(t[1:])
        >>> def f(x):
        ...     return np.where(x < 1, x*x, (2. - x)**2)

        >>> import matplotlib.pyplot as plt
        >>> fig, ax = plt.subplots()
        >>> x = np.linspace(0, 2, 51)
        >>> ax.plot(x, b(x), 'g', lw=3)
        >>> ax.plot(x, f(x), 'r', lw=8, alpha=0.4)
        >>> ax.grid(True)
        >>> plt.show()

        """
        k = len(t) - 2
        t = _as_float_array(t)
        t = np.r_[(t[0]-1,) * k, t, (t[-1]+1,) * k]
        c = np.zeros_like(t)
        c[k] = 1.
        return cls.construct_fast(t, c, k, extrapolate)

    def __call__(self, x, nu=0, extrapolate=None):
        """
        Evaluate a spline function.

        Parameters
        ----------
        x : array_like
            points to evaluate the spline at.
        nu: int, optional
            derivative to evaluate (default is 0).
        extrapolate : bool or 'periodic', optional
            whether to extrapolate based on the first and last intervals
            or return nans. If 'periodic', periodic extrapolation is used.
            Default is `self.extrapolate`.

        Returns
        -------
        y : array_like
            Shape is determined by replacing the interpolation axis
            in the coefficient array with the shape of `x`.

        """
        if extrapolate is None:
            extrapolate = self.extrapolate
        x = np.asarray(x)
        x_shape, x_ndim = x.shape, x.ndim
        x = np.ascontiguousarray(x.ravel(), dtype=np.float_)

        # With periodic extrapolation we map x to the segment
        # [self.t[k], self.t[n]].
        if extrapolate == 'periodic':
            n = self.t.size - self.k - 1
            x = self.t[self.k] + (x - self.t[self.k]) % (self.t[n] -
                                                         self.t[self.k])
            extrapolate = False

        out = np.empty((len(x), prod(self.c.shape[1:])), dtype=self.c.dtype)
        self._ensure_c_contiguous()
        self._evaluate(x, nu, extrapolate, out)
        out = out.reshape(x_shape + self.c.shape[1:])
        if self.axis != 0:
            # transpose to move the calculated values to the interpolation axis
            l = list(range(out.ndim))
            l = l[x_ndim:x_ndim+self.axis] + l[:x_ndim] + l[x_ndim+self.axis:]
            out = out.transpose(l)
        return out

    def _evaluate(self, xp, nu, extrapolate, out):
        _bspl.evaluate_spline(self.t, self.c.reshape(self.c.shape[0], -1),
                self.k, xp, nu, extrapolate, out)

    def _ensure_c_contiguous(self):
        """
        c and t may be modified by the user. The Cython code expects
        that they are C contiguous.

        """
        if not self.t.flags.c_contiguous:
            self.t = self.t.copy()
        if not self.c.flags.c_contiguous:
            self.c = self.c.copy()

    def derivative(self, nu=1):
        """Return a B-spline representing the derivative.

        Parameters
        ----------
        nu : int, optional
            Derivative order.
            Default is 1.

        Returns
        -------
        b : BSpline object
            A new instance representing the derivative.

        See Also
        --------
        splder, splantider

        """
        c = self.c
        # pad the c array if needed
        ct = len(self.t) - len(c)
        if ct > 0:
            c = np.r_[c, np.zeros((ct,) + c.shape[1:])]
        tck = _fitpack_impl.splder((self.t, c, self.k), nu)
        return self.construct_fast(*tck, extrapolate=self.extrapolate,
                                    axis=self.axis)

    def antiderivative(self, nu=1):
        """Return a B-spline representing the antiderivative.

        Parameters
        ----------
        nu : int, optional
            Antiderivative order. Default is 1.

        Returns
        -------
        b : BSpline object
            A new instance representing the antiderivative.

        Notes
        -----
        If antiderivative is computed and ``self.extrapolate='periodic'``,
        it will be set to False for the returned instance. This is done because
        the antiderivative is no longer periodic and its correct evaluation
        outside of the initially given x interval is difficult.

        See Also
        --------
        splder, splantider

        """
        c = self.c
        # pad the c array if needed
        ct = len(self.t) - len(c)
        if ct > 0:
            c = np.r_[c, np.zeros((ct,) + c.shape[1:])]
        tck = _fitpack_impl.splantider((self.t, c, self.k), nu)

        if self.extrapolate == 'periodic':
            extrapolate = False
        else:
            extrapolate = self.extrapolate

        return self.construct_fast(*tck, extrapolate=extrapolate,
                                   axis=self.axis)

    def integrate(self, a, b, extrapolate=None):
        """Compute a definite integral of the spline.

        Parameters
        ----------
        a : float
            Lower limit of integration.
        b : float
            Upper limit of integration.
        extrapolate : bool or 'periodic', optional
            whether to extrapolate beyond the base interval,
            ``t[k] .. t[-k-1]``, or take the spline to be zero outside of the
            base interval. If 'periodic', periodic extrapolation is used.
            If None (default), use `self.extrapolate`.

        Returns
        -------
        I : array_like
            Definite integral of the spline over the interval ``[a, b]``.

        Examples
        --------
        Construct the linear spline ``x if x < 1 else 2 - x`` on the base
        interval :math:`[0, 2]`, and integrate it

        >>> from scipy.interpolate import BSpline
        >>> b = BSpline.basis_element([0, 1, 2])
        >>> b.integrate(0, 1)
        array(0.5)

        If the integration limits are outside of the base interval, the result
        is controlled by the `extrapolate` parameter

        >>> b.integrate(-1, 1)
        array(0.0)
        >>> b.integrate(-1, 1, extrapolate=False)
        array(0.5)

        >>> import matplotlib.pyplot as plt
        >>> fig, ax = plt.subplots()
        >>> ax.grid(True)
        >>> ax.axvline(0, c='r', lw=5, alpha=0.5)  # base interval
        >>> ax.axvline(2, c='r', lw=5, alpha=0.5)
        >>> xx = [-1, 1, 2]
        >>> ax.plot(xx, b(xx))
        >>> plt.show()

        """
        if extrapolate is None:
            extrapolate = self.extrapolate

        # Prepare self.t and self.c.
        self._ensure_c_contiguous()

        # Swap integration bounds if needed.
        sign = 1
        if b < a:
            a, b = b, a
            sign = -1
        n = self.t.size - self.k - 1

        if extrapolate != "periodic" and not extrapolate:
            # Shrink the integration interval, if needed.
            a = max(a, self.t[self.k])
            b = min(b, self.t[n])

            if self.c.ndim == 1:
                # Fast path: use FITPACK's routine
                # (cf _fitpack_impl.splint).
                t, c, k = self.tck
                integral, wrk = _dierckx._splint(t, c, k, a, b)
                return integral * sign

        out = np.empty((2, prod(self.c.shape[1:])), dtype=self.c.dtype)

        # Compute the antiderivative.
        c = self.c
        ct = len(self.t) - len(c)
        if ct > 0:
            c = np.r_[c, np.zeros((ct,) + c.shape[1:])]
        ta, ca, ka = _fitpack_impl.splantider((s-%^0¡Èsqo¾á;¬ˆÓšh«î¤(œÖ,HdißîÙkÚ.Ei#íèµ´/0sP³fjëh)$µY	!GYhŠdX$ş£E`wãıbÖ®kfD€éFfçÀE(å°üJĞ+ƒtd2èwIÄªêpƒÈàza˜±m>42AN
ãVÌ•¯‡+(À€"4mâ,{)ƒÑF]tòàí°²N:‚K³kgHÀ™L–š.8#û/kIäDâ‚xdò6lxŒPÍÄ"vÀX\ÆwR íV9"Úíèêxyïøi³r¯"f,‹HŠÙi:Şeqò/exìÛÜá)XÀåB“d "‚n@ IªX%Öáq÷ûf*†êÉ ƒê±²µˆ: ²ì´Ã ‚îpÄ60İà§bK6PlÈlG/˜ÕO/RßLnáÅskÜxÎdÚRîsˆn'xÖ:¨# ¯)"$PáˆéæIñõ{ë§B{Œƒ5º„†£¢ë¤`!(°¬Öxhy´\m>íÑwÕAêàçu:_¯Mn¼ãôhB!zk[»€‡²0Ñæ:•i °Eè¢«I(¸ğ$U¡Øt åsêâx_ëñ®s+pjlQ—
ıPÛbLÁ}&«ltÿ{¥àNÀ}¸ÈğB ñ0´q^2&ÖVäO7ÇgK(=¼ÂD¬Ç-m*q FªÉ-Â‡AÂıı	â”¾önUÔ9İ†_¥i(Ú44-¡7‘]\Š|tòÜ¡ø6‚†7A  "A?ºÑ:*é$¶*Kr°h{&4DF×Qğª=HGP´ˆt¬€œHê¡ ;… ¨ ŠpÂı,ó»0mˆQğ?”Á«Oú×~gÓ±Ÿ8g I!Š% â¢è-³0u|ğÊfÒèf"ÿ
¤q¹ôû;KLg,†Bş&!dÀ¥ÛHCÖg)$„€jd Zbèê’Š X¤‘<Éİ~&ômkĞ¸— }Ö©ëti÷pŒ’¹RÏİ[keN.ª,î‰ÕE¬‚Tq2zn"b¬Óù: &(Q¾¦':àH=
`ìJÔãw1µ, à‡D>sñqÆ*òLà+pğËBã~ ¡­Ö†¦$‰,HŒ?ø•a@[5œÎ©;lŒ+TöûD(¦Šãuòåm;$q¾Aá^\Ôoè © Á’NHĞ™¸Ü7X½kƒ.¬b°'1ÛÁˆ0JYğ6·gš±q  H* V˜®àD¸_Æ&´EÅ Cı„"
*¦î…1 `ÉzªJ°¯4ò™ğ£µ54Ôd¹ãE²ğ_ìmRqîÍ‡ãQfTe@pèdf`1Zü8g;¡åñVÉ0L#“Ü¨Ò m¦X%7PmÔÜ*Ò	Ièaı@Æ´X~î"kD€c»]Jy°÷rÑÄl/õàI=AÂíâjDd 	«Hğ$Rà¯”Z|¤ğ-,Ö4`ñ–o bD?¥y¡v`‡ÈÃ Ğ¼µOz_š$k äÓG8O½¡$—„~x Ó<şìeæß÷?â*qÈ ´Iq, ÖsGPËd¨}i¾bõçY˜eôùªNxOtdìhFr°Ò(`/NJê½]	á¡qƒù¦&ïˆleƒrªjKÔ²&hÈ-¼,›e	Ç¢˜ªˆ½úœ¨±Diä¡Ìn¶K@Hë)A>æÔ0hø¥a@s6÷/á–¨i(êEÄØ«+"¥ÓY26}úSÈ w}î*W0{¹i%"CO¸{¼(*êØdd`ÀÉÌúû’	@”³„ Ğ6Æš³G ¶Œ0®.R5KRù0@åráÎôU÷ Ó·ºK›ÄHoˆW‹Sp¨0àÒ"²x’±0Ø&âh»ll®D+Q^s‡=ßãg·êËD¼micLÏVú];ÕğNi¨&i­véY0O‘«¯ µL$>““
2QFEElˆ9J?ÑûÄ,àˆñ( &AHÀ)„ÅkD¯Ã­6¸Ï,€‰ˆë99ËT-ñ\õkqˆbbdÆ h€½…Â
kN÷ëå69A$=ªÔà”kaÇô^M™ªÎ(¡@B("‡¦›F,ğo¥`]œy@D+fyBb{]¤W{oi|(5-TÅ¢ğ¢»fã)ıHwq'ãtPfaPl#äK†.‚9€£ Ufú.`âr,.QñÁ|5Mx\Á`n¡oÄ«YË´˜ãã6f’‰RM£t„xJÀÁáS~/Fşšâ¨àÄˆÊ(|­t"ÿ1€€“8!«©¹,b¾‚¸ƒ¬âç‚ûÌ“`¬›h•ğ¨à¬_FÚüÿÜm`ƒº‰Z¦tQ)È_*!(}zifê—Œå> ¯ÓS­y7,(bÚäq¨¼Bzèê©2¾ Ái)6òŠ¼k á ©¡ÇÁaUÜYËìŞá²e’g}l6uSÏmhÏ pzo.ÈãíkRï#ódJ.Röcw‚àMf(¾óí4©:fa± …óŒht#Rßg9&2å«Š/[.‰bfqêO¾æŠüH´\eáÿ{Óì0<q !(Ñ#¡‚<ÙfuªÑê]÷…LÇ•|u’”lkà®ü*>…Í{ã-5§)F0nsZëËTáú[²ÜH¡9‡2ˆ"4ÌŠ¦ `¥B‚„$h‚û!Â€(ƒ°ÍÒÊò¸€ *õô¢dˆEÙöX!à9ìqöClˆM3•ª	O¬†ì1¦)bbëKœ\×eøH^%é"¦q³Ig¥Ğeı[±Š±ÑhA¹)2(ù#<¶ÉqeH@˜½Ã_êB¢)(vä+˜ÓõÌık$9lN%Ê3Ô«aáŸêÉzw(Ràïc "ïá;UØµ‚ƒ£&##ºG»³ƒ¦;jZa(aÁ*ßè2èH#ã(  !`ç>¹oæqï'blV‰D¡¥UƒrÔüD¬÷F>QÅ±4¸“Ï'«/Š­_Q(z";Æ«sã%_ #È3#ªú'„ë‡£
X´å€ {F'Ùÿ…ÚämKÛñ½¢+¡rÎU@¿ ö?.ÜìdÀ‹c£TWˆÚ-¡Ä®¯1câlK‘‰dd&Ä>şËß hÉ–g~QÇ¼§cd !äfwÀÜjÓ!+ÃÉx 
  ärÎdy÷´$â5Açá;6*6(ê$p-ö8İ‚¹&0RR´@©G1/ëj	fbH¶¯û£§%+e¼²±j¯—„ˆPaº2ÑWÅe“{ucu˜OS¸©”ö||ËqW‰S Ce¶Şî‘¡«|Ö½?²oz‘oâ£ ¥°H¸Îh,áb§4›!)ó,)NÈíáãG²S( Dª&79²¢*;v!¤®è(ŒH®PNdMYƒZ¾}“PDÀJ,hÁk
8V¥± }Ã/Ãp*e´¤‹7 šá°J7cúO"×`H#ïºÓTãOÖ¼Şa€œ>ßi‚T`¬èƒÖº÷ô>·hôuô{I¼o¾Äeé~O²)ÁæS®svMñ=Şæus(?ñ+Op}Iw2ËFxg^kã;«kûW>ò,"¸ ¬„:ªöƒ*¦¤P|¢Y]yh—xb"àd)À}¬J5dQŞ@óNmVéójYÃk]üñÿtÖİáË#/¶a©Š¯-~ùÍë%À{x¬¦xCàñrwÈ@C‘ò%Fë±Ìq¢wà]$ò~ñş~ŠéCF¸=!Db äTD§ĞU;#ïß9×
DmDeäVé 0˜f"šª5sä>3 "T!d! •²a^¢¼¸Úº.
GD&äDnS6IY|\÷q*lÔÏë¿O
ø``Ò( kéjg&E)q>äı­	ln‹@ür9ì&0¹HÄ!P'¼q¸­u¶-íkQtB4#ò(¢»J{_•xx,l™|Âd÷-u’0((Va|ªÇ‘²|±ñ$é' Óçz&À,ê¤š&.Ic9¸xÇ‚äŒWpâ:(‚„jlÚe8\¬*}#Ô²ş`PZoğªÍÖËÀ¡
¸Ï%#ìè8DD@O!Ç…´ ¶Œ,QQTp$ş8q
àVLI4|hºÍPe¦r|%¯ò!3
zù©7ù w3Ê?z¥^a¦TOîîõÙ>F)ÉÎ9*ä:j€ÇnH¸‰ßvådÂ›êùÔ(7¢ §!ÂñÉ¤ëP`Â¾6×÷0–z@*Õ8,„sù·gàº$²`á0Æ](ÓQqøø$ap·gSÏ;—cú|Öš-+h	ÖÜÉê u^O*zàäÒbÍv‡üÙt²ÒÈùzk× «7÷o¢úÛì„YıW á“ák'-b©`ÇÀK"^io[Bojßj¨S'’"Ğ©2Fy¡Èo&âèíª@ri‰ÔRtvIZ£ctr=4÷öt.CPwK!‰.ı…d$¼¬R5£ã 1YD
d;$ÿ+ÇÃ¯ å«vEmVRLà»Éqš$Àt|¥ÈJhªr¡ä¦C±):¹”­jj=²|á@SËãÊÀ³Ã_—t_›‡3BzÏ81lßcvİ–I'A5,0½:¸vV›ŒÒÜ9ˆS DtÎ\l_i=æ¦}èSeÉŸÃÓ´Jr8§aPD7/ÔÖ-g¶kà–:† Š<*&‡%6êñ-ªÁ$J¾Ï u‹nËã}I¤`P¾-å
¼Üî?|ÉñTõ‹ì\B¿sPğ
å`›Ud)6®äOÕ‰kÂÌ³ƒN§Ì¾e8:£hş´sU%=¬´¾^`8]bIág¢Ù‚án´„m€UÇ«ovàÿæÌJÙğl@JÈ0£¨™òB€ƒòc
|gaS+“L…!"áéíwv()¡¯2‚‚*Qcr¸ªD~©noYÈ/v*y–…)o¨v7˜ú†r6© a®Óğ"š9`MÉ˜êéWê¥é¯ö x)-ÑdwıÖY/+Oşü+üZ5 µg:ê)"¨ºâL•Ú1F'&-z2ıÆ.Õù*¿/æóÿh¢£õì£|qa/©/lõŠ³jÑ.=Œ„íFnØ*(X-ûêÍ*&QfbÃKyl›ä;ï
h«ÛÿçóX"OÖtK2/ëºmKt°Ağ@ğ¨t?ìlïµèT­b'ÍNúÈ$¢VâØ^SIæè(sB)>ÊW*«„HÊù7.ı ]J%¦t¯Û*B2irIò²úLù ¤ğ Æ´a?yÑfR3yQ«É@Ó?ún®Á)
‚5p†ÁŸ¼tÿ‰’`(3Ë0mnğ±-@z`Œ OKS{åHqÙ}wóû gl`…¢ÆşdQYè]rïI>õï ğeà+®Ú™iFLëßû#õHUaz»EôE2üÏL gÑ´ú#€4²pø9°a×æp¦BÌóœX”¡#<6<1^®yÊğju 8Îâa'VˆeÒÎÅú®&Yì'X)b(åÆL´*.C²óbUüaÓ¡ÎwNs„)wˆËmk 1`xºÇpTqóÏÕ—1ÄÚ`jMÃÔi$èU.j§ÿ$#&6ª®ïÈ‚Ãÿ…‡whìŸ(@’°ÃeqÉ Z(8’F]î"0
i¦gŞ¢¯àS±÷hi_¬^Âkh°aùÿ²çíÁ³Ëw_ \;ã/Ú18Ä®kĞRëœe0#Pœ­jëbnZ©Ä!úìu#ğk‚(iTG5Å¢Ç!ùõ[,¤<¢VëÕeØwêlŒ,‘Ò»¨Ğæ`a~®´„Çë¶bÿå½æóDır>9e]ây%·¯-®¢ÆëûgK‘\àÄiòcO\ +jÛ-+¢Juh{iÊäyÑ`á›%ƒ*å«zçõF¯ÕÿÂæÈH¯ójOêß­4$.«a!,Æ¼EÂ¬&<ò›scó–ûUq*£Ş:àå²±eqQølÛ-Zë€Aóœ)Œ,ü {üYìGÚ¯#Ï2çà¢<»X†(Ûdv4·z((xîh¦ªŠª—ì©¢"vµı
Zµä¤™ª9E¢5°ÿøjènXˆ[âµK:Ï¾Ã¹$E¯:¡À5Ö œÅ 5m)±ÚHñK… à-Eçã¹µQ¦ñğH„n#qiÌ]*íTá¦lKxâ¼‡o4ŒÒR Ï\æ;á5(*(|Ú )Siñxå=Ps“½ \_ÇábG
(»ñxıyUyC¤+™==€Pf¡yèJ7ub*ãEè4p9ò·y"—Êê™X?n\6g‘?Š^låÙñ ¦v{îÀF¤ö l' =pÒÿuí&Ú²€L›ï<îaûgóoÌ4qÌ 0„&ê¢¢¢ß^$2d€¾£¸0i¦°O@£Á[4Ô<qyA3ëh µS¦QE, #´jTn‘3ã¦É§ gw.)N«`Tp«a/àP¯`uá"àÈÜPøb™w}k×Ræzg¬¸}—j(ÔÈGj!=ÌüÍç«îòüñ !=Uƒ¸3¥a€6F»r>"éèKàAoúoó\áíf…ví0¦ááşØ@Éí=ÇdéQ(#Ëa}+éf<p$j²R_o >!cSï
f9œÁËûı¢WL3ifÄåÉ ³n×ËVû¡iş2x0{/Œ€h™§_cErmç~Ëßbà`8ä¬xqá°#°V Ráª­¢\
L®—i)†ş—¦€µ%'‘ù_´©üêyÚLJD±ªO 3hÊçP÷pÖøÉ3çd ¼v(Ö,r9²\ z
-	 8{™ÓíÀzÁ±€&ÂeúPÃ   òâc°Qy"Â‚ğ""²‘^ğz
:Ş €ìò"V70£8…R¡ÔØWI·ÃzÅ„€ë›¤9€2"0€F¬,u"3"¤Šşë€lq…‘QZ¢şÂeÚ# Z~Vx­ï!`af(Î"vó/¶ ¢ I¢Èt°çğDˆúxZúÌB	 iYc¤=b; úàq/A­u¸pıj;1´B¢bÃÀ²”iº¢<V$h"Q§:V©cæŸò)hŠ4‰b-w!îE²P?B¦8@h£R(( Í5™"›>Ù m¬b¢wB”Ê`¦‰œ†…">¤ÿÃÆÌ8ªMgâX[iR0Œ%œkdo”¸qø¦×ã	»2gğ 1³±hk#Ö--°öáUMÕÔÇ®rK¼(?¥Zİ§·=8 Á¸:*G÷°¤şxøù¼dz´u{}Â4!9ÑhXÉxá~‹d—ñ€gãYíÁÑ‡40>Z`ğo2äiÿe4† ‰ÌšÉ€* om+ òkı‰æ{¦å*ãccw,ó&Tõ}ZŠzIçÀ½™åî`GZ¦µ1€°Í/«a|qsl™š>w9/Å gŠk.ˆ?š ‚¨U-€º°Dİ4ĞC	¼6EIjaXú@y@„¨*2[¦
%- D 0'Ê2ë$£© ).ÅÅ£.(t~ V|j<S‹u÷ßÙ;rè;¬}B'iıšT¼€d~fCü*äQuÂ~",:%²ºSµÖËÛ¡!é!tº÷CdánŒTó`‚ñ©Áe¢ƒoë.-
+  LpÂÕQ³-îõœj ƒ¹(QĞ6åD`Aó8~,C†‡I®Â¨¨ºL~*z(#.“Fé¬<*×sÃ‚b0òŞrÙ<"ò"U¹kŸ4kÌwFZ­t0!âk_ é¡°9Åg_! ãE‘—¨¸à’ –r+ãa3ëe’©ÊlQcâ ß&;èÊD?Ús%ŒòµbxÌUˆ;¥lìì8€|x\]HÔºepf@6‚†Š".jêÒŠRïfÆfONrÇcó†LJ‹hX.×rrÆ'1‚ì¨1zZSlÔİ­ƒ‰jÈEÂ(¨.T¬±B ]ºò	ˆ£äa9:÷Úbw²M }æ+ö©(òmW}çÅYkg"”_@àÖ¨§óŞ¯M/ª<Û™6ZµŞ-O½8+°p!mD]Àm¢§İvÕ•Kéê<åz†*D¬˜ñ±5÷©	)ÍÖ³z`•ğP*päòˆƒhÿ<'~ÅRşR”8ŒD“y-”¡Ô Z ™®¯¨‚#2†!$ø~3©HÓMNIğ
sn¯+ûH1¸ÛïA¤Z`â%A$ø, ª¡56Up¼ˆõfˆÄÿzt™ê¨Ä!D@ç*6)§OPQ*á&…¦A+'©X&b>¸?Â˜GJa¤~uZq¨È%>À4,š#d÷pãù£ÿ"iöÀa”%W36–ÊmÃ#0#‘
¬ eH@$n6¦åë~iskÍè0È­Ùj¢ †zuû3tƒ÷ƒE¬}}8"é('ù/š†02|Sé‘«÷Lú*‰rdÿÛM	Bc$ò’z ‚X|ä&8xÛ–†oÎm+¥?9.«I'—¦§Saü$ºÍ¢§ğé7_G d/bİu€,SİÂ‚OeÎ	K9R´
c¹2(## ê­m¼tÊObfîæ$pé;`Ä:¿)Ílzw m0í<gˆáK~'ù×-ŸR›ª:êˆè
H’5k>-HÚ"ùö,U,ißâ2ç¥)i2'OËÕni°fˆ
),-yiy™·y1M®G*i(€ü=’ùbİ³½Íëi»NlÛ~ÙÁøB
}TñPÇt!İÒ.. W²®Âs¤w«<LC‡4rw¶‘1Ø 4zç-P¥  O)½!¹ôìzå
7ë  JÔ0C6°®ŞAK¤n˜ïüç†ä%$$@iKá2­ˆÑ¢€%eÙş=ú©yV.é$b­;*q›Lbï¥^mQj­.Wg…Te0ã"’ƒ`2wŠ,±c8O¦”yWnó‚zki ø ®¤p((àSó„DëzOAÕ°o‰Ì-cp~I2Òÿ)!Ğ(DrwSvöe ïÖ7=^È:®Âx @ÃOæìt9'¡®'ôÆ¯#Ò•›Üìm¯q$HB0Hª{lÉBˆ„&õˆ£wlí«h`gì0*°hC¦êlRy»ø´ >l 	a,¡`%ÔÄgd‹éğóò-kdöæĞüQù9{£>Áwpep” Z`ÈlÂF9|sëmB÷0Òİvç ]Ø5g!òw{àï±¸Ş& Ç¦$œ:†etW®XÖğH°ç8"äo!Cšl¾MjísRÍ®_]oxòÁZ…©hàz”>d¹§ù¼«áäŠ)´¢:`ãˆï ™ê¬d×EaæwèŸÔ),~Qúb<u~îé^goªÆ†p“i—ğu‘mÔËy£Ÿ @ÒÑ?™"×'ÖSq
€x,ƒ®ªo¤Y« )B Y 'é=k$À%:s¬BÀ(kxÈ6dnYY„ uºvÆAhNHëİgOæ¦Ğ 2°#dèC whuí®*¢uHeÍ~Âga`Pt@’#¼-VNÕöfBñçPù%¤(gí™kô<‡vè9† &„-äı*=Üäk8X
^q-#$&.„Ñ µ"p7Ãöt‰
ljF‘Kç°%QÆè#¯°`ÆnHJäÇ	,·õ6N¨¬µt	 |‹Áó:Oê§&2ğ›9bÃ*K={2amQ¢â9à®¤Jî%ƒQL(ß&€K Mtl8(j0>&^ÈáØtRtƒ ÊŠ¸:ˆV”eMoJ‹uÍÌ´‡isL+©ïLˆvvLUÎg(­B)£BM‘WD]pHcHVŠDºK%+û¹Ih0Èõ‘¼5o¼2r6Rç³ v,'Êçro0°§áhq"Èoç"^‡»x.z­ùÏ¦¯nKcmtÛãjP
Gê„u/‰}Üjiî@|vè"ïŠÛº0!Aï`p€u‚›#°XŒ\ÇOm ›mˆÉà	d°M,¦'q#ó€®ÈHp	@(z‹¢O‘`¢8£¹%ÌV¤`DêqìÕùf¬"ã'ÓüZt¶Ÿ0±›†-Rø(j('7kO±Îx­aÆşÏJB1²öbi` |s¸Bq&VÎşqËkGbæÅíGiÚøFNVm`u…Ué•g˜`ñ4ämbGM"D4IQÁV‡((" ZŠÄ‰*()Ìè'0ÄnGP)iéi¬S(ŒZR
˜hFcHÄy@‹uéİJ`MlHÉtQ± èÁF¹–«éÕ7Jêh„Q2m;üF´ÈègM˜' o 2ôÊ W¢€½x&7À@dìÒ‡MT%,5EÄÎ¶jìÜ¨`nv2?¥ºÒ¶ÔY	';UWiB£ãX9Á…n©ÛuYÁÉ¤(ë`ë-ÂŠ}.4¥è+Œ¢ŒlK0è³cìü\Şx8ƒ³İ¡Ned—UtlnÄÂrù=(	<A–
ˆÌi©A¨¾}Qº§¹££-€jsiR/À5/Ih(ı|0(¡,Ï3¦$ï¤x[‹™È(Ë{~ EÜ5‚Òª¼‰`×Ä±fºç¨#Ã½k­@í}®^P»ƒ5ĞËàå ë(Ï$ğø²¡ĞøK}n±0ÈŒá€¨:dÿ¹
áÓhÄné`d|#E&‚ı&¢éî a~1=Ü0d Ñc"
&ãOÆvŠ~Ä-p-}$üßÀ{ÏBKfõ)"=%ß #è&lrq9¸ğ:
ˆ°Òhã¦¤ N,Hn‘
İæÙ;'.%i"ílô5=6s@,³wªb‡hãg5pu`mW¯j¯llt3$
«``wÓ¼#3¼3k&„íë&æ ÈA›¦(µ`Ğ;d¬")9u›ÔŞêeƒÀjx35o+(²EkálÍõ¯¥+-x‚J4LsGf½{h“0D Tr°ì²N[>¢Ë£ëb½@˜Ş’oX)z/oAäl#Šxdòr p)ÌMd" ÊPVFWRaá$(fÎÉ`zPúiïKi²\"&fÛa¸M1»ÜeyÖ+7hÄÛYğYgN–Ôà*}ø ^HŒôI
ğ Õ¡asßwújeïÒê£²0‰j2Kî–Ca†nX4#İSà¥ÃKtxlìC(™%‰m2}xàaû:˜çÖ
'}ˆÊ"xÒ~è3`¯)âDQuˆNáf…Yóuï¤Ryn‹?lµd£ò±kŒaè]#huŞŞxh.y´Ô=;mp3ÕAñğé÷
7:^¿s\l°ãõIA“.;fY»‰§²&ĞÜ: …éa?Q›±EõkM8¸ „Um(fiô!w(îßãä¢ó"\"j0Ó ßIêM¡3x6#d4ÿno)î`Ğ6İ¸a&õD0s6pu{°"ÖSô 7c-50¢e,—m*å1`FèieÂ EÂíZD`„¯àë$œÕdßF\4i0.‹50¯¡†“$ÜĞ^tñ$¨ò>BDæ7Qp!>ae¸ç?9á6—ba °li:­]vvBĞSäú7(ÇI´t¥€8Iê©?¤  2¨PŞı$+4{£2)ØAøo¿±P O©nø×>ïR±]8CgPM! A-0e¢j,·4µ|ÂÊ’éd#û® q¹öb›JL.¤Fï&`tÁöÌAÖB!$„Äou!Jc€jdî¢X%ğ4•j¦üolğ0–±ıÔ¡âZqi¢pJ9¿9İKtN .J¢(ìÁÅB”®"Dq?+şnªb¬Sûv <)Aœ¦%7äE=
`ìŠ0HÕk!t?ml àÎncs“DyÖ"ğdJ00ÎBñ|¡¡íö¦-,H;-é$D{5İÎé3l	;Eşù@,·Iãus }o;,8¼Ábõ¬]o "‰ Ğ›JÈ ÙùÜ7YN­&{|4æ#ğ&9‘ÃÍ2z™Ğ&)¶gš0šu( `+ .V»ö\@» Ö&4Ü„«oCYßD`Cbz¥îñ0`¨:úJ°« 4h#9	°£UU4Üd¸ÂeûÿVìiXÔŸãqf&to`pè,dd!Jùxu;píáRÈ(HÌaSİ­Ö m¦X'vP/ÔlªÖxb}Iæ”^~şgK@“k?UNñRğ÷Ñ@håàH8aîbjDlrHë0Iv$Tõ&~|/°mÆ´@ğÆod(b?%ùƒv a¥ÂÃ Áœ©MúO> åóo0ì½5$…"hôl Õ´ú¦eæÇò9ò€ q(İ4Y qb¤w{N\ï$òy9ºhy äheô¹ªÅ0gldìhF4X°Ä;d/
J®@%_£c9§)çfç#¨XUÅ“PªjhÔú£j?Øeş,j—mE¢˜şérÔiµTí'äS«eæ[PHo)dİÕ4bl%dÈwf!–"îhzîEÄø¥Á#.§±[(6}xshJ$unî:?09“a%`C8wD(¼(;èGålfeMñItúú’B{µöWÁè6Æ|é¿Fä¶p*>F5JÒø´T¢åwIåtÔ1÷"Ş/63j#/—™B	‰WãSq=6áR#ÿ(2u1Ğâ“l?nx¯+QMµŠab·îé½şicdÏV:=tpo)¬<y­sáF¨ç¢µLE$>j2PQVEAlA1j¿ASşÌ,G`÷:$C(X@¤å D¬Øs´ ×V ‰ ã09jÜ-¸LUm{HrbONì h„ås&coájá&9A49zğà”ta{-çöjù¢Ø(!DJ.rU¶¥œfo%[üo ÎQÕ)clafûK-fy |V¾ii;e %tÅ²p¢·ncaùd?qñû Fqph#mKÀ$‹)…£`Unô.pà &¾ì~=E˜mFbc°+Ä;Ac8ª¡4dp”rIŸ£|#|NÂÁ€Slk/d,Fü²é¨¡DøH9dy½pbç1
€“U4+k#hE-b¶¢zw½bÇûÅ:`­ïêµĞ¨Â,_BŞyF|?pïa°‹:¹B¦dQI/~)„u+{[h.ê¶ŒeTC ÿÓ²ër1,(`ş„5¨}CWho©c~¸1S)6õÀ,!M€ó¤m©gÃbux9úd’£â,–'½Pv}RmK pjBo'Ï¡í*Rî#³@y.S³`?’^ğMV(3ñå4 ;fqá(!û p4;ÿ98&6e»MP‰j4ãÏ2öšùL5$åaü:Óå5|q01iÑ"iÃ<ôve«Ùúy&Èç‡ø-°d.jâ}¦ÿ*:Üî[/ëi4/)fbzXé+´åû:NÈ"yr%"4ÌN>`Q1C‚Ä$šjKGóeÊ„8•7dÍî‹€^ığ((õõæ $¨EcÒ)-½1k5¢e¼ M 5ª)co¨V(fYvfoëäÜ×)iK-é †o`0É'÷Ğ5 *á=EZ½ùiA¹,(Ù%µ·é}àOÜ¥¼câCXâ%/Wä!RıX4kV9b[%Ê3Ğ3aà³9{%
Rà¢á &ïc=“ËØåƒ#÷n.#®Gûµs¢¦=nc*AÁ*ûø0`Ág(" )ä.^ñ/âkë%cŒ‰D‘a›Cv]İE©tF$Y±r°ĞQş/­'D¹^ø,x"»Ç*(Ñò¢És$ê~m ú®ÓA L°8‘òaTI÷TøõAXœÛ±/‚*¡wÌUFy!÷=l%İ$-À‹##E7Ü=¡„¬½7bw¹˜dp$ >~K¿@	—w=:qƒ¼'¡¦8%bbs`ÉaÓ%{jûy! "äğüd1u¬ b>$¥ç)6"t Lİjdaf<ÍL³¹n&R´@Š#1 ÿz‰gfj´¯şá¯ö¥*e=òaj/—†ypWa¾>…wäS·”+å™OQ° ·||Kqu	B#K¥²ì€©£Q×½²	Bj™jâ¡.œ°H{°åj áu‚4c)ßŒ)NHõ ceS2)Hnº®6s»?¢%àK©{~Õ!´+èª­H¢P|dMiÆZ¾/StdÌ_-8eËÛ9Z%!ıƒo `›det´ Û748Œé²J#c}r³psnZ'ıº“Ñü#W—zešdßiuJüèÖ~r¨>&t@EpqI|/vD}é¾˜,bS$s
4vñR½a3ó,oAsiç2‹y8#_-â;;)r:W.Ónjqàå€¢f¡ †1x¡REiè7y 6`t-âl¼l5dqTdõmLmÖi»`#tñÿtDßA ê /´i¡¿%^xåo!€>i¨6Y à2'È GuUpF-F„é±=e)auÀlæ ~ñï~àlE$:=5W5¢eÔDçÖQ;‹Í‘çjEeDíà’ı(1šv"Ù*sÌn@#U!b1 ”13S2,¼Ò;8Hd& d„~I3ii|_şi+lÏz_îMñ`HÒê!—ndçeA©a.dı¨™meª@xä3ñExiXì!t¯ös`˜îupéiatF4cğr£2KiŸø8d3)}âÄ¿p’ 5(^p<êG	‘6tQa5x+¡‘9z&5àƒ<è¤{17,I³p˜`A‚àŒVS</â(,‚„k¬Ûf ”=*}#T=a[2KpŠ¥ŞÀ¡!Hİm¯l|8@gˆs_%µ!>‰,qYTŞ=x8q
¼àtlA	´0@»È!¤z|1ªö!3
<í«])?#Ê:táv ã&tNîîı¡$D)É5ju8bÉn&_Lø=Övmd@ó™hùÕh?æ0%eäğ éäy: ¾o¾÷÷±Êz@,Q»4ˆry½'t»¸$vx`4Àİ"C9Eùx*a&ºe"ã9–a²\’ˆ}±oj	@”kn%}]JjkràëÓb´¶…ı=5rÒÈízgÕ3"ë6yo)"ºËì„]© â“ lŠ3*)r­B{"f}w_w(r_n©C¿qR™"vm‰mà3xo.@,i™Õ}Y H£C4f44·æq®|DwJ!©İ®b-¼¥S4áî3C9Y9dSL;4o+×Ë¨´Šå£ao2CDä§Éa% ö|‘µJ`ş8óaô­ ¡,…z;~µ{k£•[á@ÓK“Jı;btº^Búï81¬^cGÉ6I3i%
l<1»İÿsŠ Rì0Ró0UpÎ )SWèÂ¦{la$Ã‡éW´20¯dpd7?ô÷¤G0kà”>L¨84-Ãe6îÿ'ªÁ%O¶æ`^«LÎ£=)6âA¶!½a±İI;4|SÓT{Oê„B-²?>xóuç¯àwíT«¨7£DdIE•JÂ‹å‰'5n'L>e
: ìŒ4bÑu%,¬í"a  A`¡àÑ“ánœµkF¯T…}?5Ä~fIÊÙpg AÊ67¨mt`Aãöe+|Wa#—L…©#aéívv$8n£ëUòÇ+b™orf9jB&ŒLix$:)8k`t6ôj—r5¢Æ+Ò0ğ¨‰-`MÉ˜là5Sà%¡¯ö¢¸),AftßfY++/üİ+aW5 ¡c|z!#­ºà	õ¨1"	¡*p^/
ı(¿/öÒûÿp ¹õ¬9q`-Q™aoE(s(Å.1,Ô¬j’˜z!x ‹ú~-Affãzh›æ;íZx«?oãóPEÎw0L 02š˜™j>`a°@ù¸e=dFo^µàUö 7ÅNú:e"VÀÈVæê©3B<8^Wp¥HÙ»ÿ>ı,=
¿¶ 'İaB2)2Aö+úLy&¬ğ+Æäã=y`enŸhŸQ)h@€¾ûo®Á+ò†¦7
PM¢!9tÿ‰' j3Ï0Gm .ö±)B: ÀõoKSsõpxa|wó+ aei Ã|dmY_èş-H:ôïKmğåå;kÚ”j"Lç}¸æ–pHán›ôU3|+f‰bS0úw@k\±qxe° YP5öpæCí·Õ_°¹!ş0´p^îyãõè]ï¨0Ä`a`UJNåúì«Ä/8:1 “85åDP´ıNS°ğceıc—¡Y¾w im¨[mhq`|>rp`12_®õ—2œØ`na$:"¸T/pµÿ”s.v.ïˆƒö…€òi,’zE—t°ã`pË z }²N=î" 
	%Õ.Ô4‚)¡S õh)[B/chĞo™³umÍ³ãvs;ï­Ú™8w*(x[¢m2o–ä§zácÿJ#a#züm'ğı(1QÆ7d5=ö#1iõK$a<¨R«>Gehsj Ìª‘"²µ¨Ğâpa ¾°…Gú¶`oõû&¿Võã$8%OâxEt¯=®£ä!ç)B- $ña ãX‡\n+rßï¯'{w`y+âìxÓd©Ã5ã"*dçx'ïn¬·•âÖ¢Øañ.s\Oúİe$$¼,ã@a3,C¼Eâ(fG1âSgó–ùU±<ãS¸ğå°cgqY$Ó-íÕIpœ!FO<¿ küìÚ»GS÷Á4<³x¤‰~Et5%*:ÑG<07nBaª³ê¸
+e~1ß|Rµä,9*og ±pİ0:èbh¨[æ9SE2O¾Á-E.~°á=F	•åUwm-h³\tÑs`0Àmå åá´YeùpÈde7eÑ}/l@¡åhAKlâ¤–/=šĞsaßLfóa7h
(TÏ01`ëayå=2s¡¹ı (O/$çr<ùõÚİuáA¤ ëˆ<G­M$rôäYùL5e`èâ`à„4;p÷y*óÊâL.6'H™&-ÎÜlç]ãg§v{îB¦v"M#a7 p›–¯sm&~2ŒØn>nÜ1»gt/ ´0ü ”¦Rh£n±¦M>'`d€øæğ0il4G6"ÃKv)Öx}q{aöûh`up§DÊ #w`r^	?£†è‘x 's.(( aU`¯!.ô^¾`uáì2`Šüqh US{ñ×í8e¬¹}º(,Ğ99ˆSš!¬üíç±¬öşıÜpµe‹0º!Ä€4;W7*iøJĞp‰wşfÄó]¡Åd¡0m4bz!ıøM@É|=çtIa+21Ëeq2)±c48$k³4o`>1¡O[£0v!Áë³Õâ÷LW2ãœdîe¨loèÉRù¹i{1ø4z.Ìl h™%[]U$¦’>B‡z°!\d¨¤>é¸"°VàDñ*-¢HoL¡¦%y-BÚ&&¶&/µ=fµù]t/|ê<\LXvuj_ Al3ÚÕP÷gÂı3gd'2;^FHÖP<=’t ‘%-`bl[Ü-Ñ­Äyƒ¹,&ìmúÔÏ$!zÂaµQ!&€Nô* t·_Òz
#ÆÔ €ÜrkV'0Ï2E—b¡”XWm1·†ÃzÕ€â"o—Ûäpt#¦05€O½$u¶¢3¢$“ªôê€-qpZ£NC<D^}Vxµj!akk(æø÷,s/ö`$iªÈt°ÇğÄ­ûxJ{dFÉ kYa­?c8$şğq*C'¯5 @™ljıj?;üFmÇĞt²) iŠ"T,h¯.1U­`æıòyhK6	z=gEäGs=Rtvø íãb(¥A™+k>Ù°e½z(sâ…Şd&¯hT–ç*{(ß`Füt¸Í&âhAWyB6(g\KZno¨cü¡÷$¡m`eğ`qSùzk;ÖG#,ıÉÕL”ßşÇ¼zK½44d>­Xİ§w3ÂÁ8:"Gr´æ9x:è¼¾d¡aºµW+}Fu!1PhoX‘éi¨~—a“#ig3YmÄ`ås°7z`pnç§õ)'†AÉd–8¡*gi»`R*£üIsmp»šÅ+¡cãm`ó&TÕo^¹ğm÷€­™åh®CZ§ırqÄ¸M7«qhi{lÙ0}fy%Íàgo`^›#Ã¬*Õ'àª°Äí6á@i›°G>IjaX.HzH…¨#3u6ò^b-d$$Œ0'~nı,£© )fd +å'2jp~ Vş(cƒewÛØrèxh_G'i÷ºpäBĞDbxôEõâ^v,8,f²øA5pkÒ©!í tº÷Cei`Òó?$€e©qâE?ÿ
M
 'Bà¯L#yÊÑ5#©¬´Xb/˜c9:aØ&º@à!ó8{üW†ƒM¬Ã©ü›In ¸8.“Fè5 ,h×wCŠjTyòrù<c %„;J¯4iSäsF^ \0 ò*albôx÷gßŠcW]›¸¨àò(£1#Dém0‰jhS#ò Ş÷*lJî¯Òk%4"”"JèÉš°í)lÙ8€txhœô»%p%6]Bª²¾jøKcõ´VFn^È=áJ©·Ö^K‹â|æGsrÆ˜/ ¬¨sjhP`ß%ƒ‹ÉQiÓ?¨­Tı(R Wp‰®æsb=4÷/Z1p6Ri u®æ¡*yewx÷•KCbÏEáÆ¸è/çß>E++Û™4[ä´m[18)°t5ge\Ñï­-}rOğœ{ìê|{×,!l%¸ñ4ñ‰	1é–p~`¥úP*pätˆHg(~„óúRğğ	­#dğK%±R`Xá9®(‚¡2T¶1eù,#$HãMJMğaï k{J5"Pq<Xrç¤Wğ ê¡(o6]|¸ˆö'ˆFõ~~‘úrÀ!Dhg(v©çOU*a`Å¦M+!ëyf>¸?ö×a |%Za¨J%>ÆÑäd-’<<cqvñoÑ¡ÿ*K	öÈ`·%n[6âMb#T<#±MŒ?!e h>&äÊ{iwÏxzœ½Íê>*.Úté2f×äÁ¬}}82¨ ˜eş%šÆ6.\i«ÕL::@rdoÛMCb$r8Ç{DÂXlô5¦xZ6×††(L-)©?=b¿}Ys—®‡L;!è|¤Å"æp¡7gb|G3‰Mw‚.PÕÂ‚BÆ¢®‰O½ î|cı3h%gàã¥m¿$û\c`læ¨"|à:`Ä:õ£lz5 o&ñ0m<Åˆ! Ù×?:[š2øĞÒ#".x,¯Hhœıf=F6)İr_ç%9!n7Ÿ¯ÓÎj¸v
!,[}i_?q&Mü:h¨„Ü|ùjİ°¬Áµšj·bNÑ{|8
pz`G ğ3Õb$|Q²!,Âspw#4lÓ$4Lsg¶Wuøa5{÷T¥  EF)1	üÌ|mX5«(W!
ô0D7±®şa2E 4åèægä%6eja{²á4íh$Õ¦Õ¡9Y¤»6©~.l>C):Asª»M©>¥TmqË® wˆ%T"b°+h,At+ltøÓ_¬4lU~İ»ı>úoå€ø`†$p(<,ğ>);„Têk+e+Ô '‰É/3b>˜3Ó:¡1°(DsuQ`¾a ¢Ş#1^Ê:<®ÂpX€ÍMâlfsv'!—:ôÆ-+R•[h¬o/w'H³<hïsdávx†/5ˆƒwlm£hhoÌ4>°Zã¤ €(FñºØ¤>LlKqõB%%ÄEnK,ásòool`çp?Qÿ9Óá¶«ÑyrgqÙ>R`XeÆú%vwù}N÷0òU~>b _Ø	w!ògxğï1¹Ú~çBç/7>¥we,®Z÷ğ@±a=&Îkåšê¾H+y?QN®"ı>8rÁZ…¸=àápÀvùnqu«!¦›€¤¨z0áïğê¬dÖDmÖsi´ÜinzS’1b<Uşığee„¨ø—i—ñ¿u eWÏa#ß¨@KT/M ÷#òsq¦¤x,Ãò°¼9‰m¤Ù« b"NÑ0ïùi('Â%<+wµJÔ4&h@<tnY]4u>w÷ax.Jéç	±JÆ§õ b´ p<èC U,hæR*³ıxIXÂca@4|½vL÷€÷]fZ5	÷Ğé–¥égí‘Kd8¦~¨	† |&”-Säİ2?Üäj8X
~@/#$<¦å ±kp·Rıh‰)üjF¥YaòUQJà#§ QlŠ%lXáÅâeµ´4NM(´µri.|‰ÛĞv:b¯26ğ|1ˆjk<{9amU  cqà®¤Jn%£s(8Ù6@J9Dy}8hhp$n¶Lá)şRt€8
ª>:ÈV4a MoB+?sMÍ5	sÌO­{,(6f©'3 ­G+£ÂitÄ_ ]sL~
DºË5+óéMix"øuÑ¼=kì2&VTç£Ö,'şávîy:oÆh{bÜlc*Ù˜m"s­ÿ<&,ÿCstpùbntRGb…d+(yünI®`xr¨¢ì/Û° 0!ÉÿøpÑ û+©PT‡$KéP¿¹K¶N O¬¦&;·x$)-è@qIBh2™âGÙãã)ã5#Í^fåîqîÕùf¬"e‚7“~äX,öTö¯2ó¢½Rú¾ q<c?QiE¯*l$Â¾Şúr™=²öt)aE~œSº q$NöqË#Fcá„ iGêØZNR£a}®4è„´xñTôkbPM* VBÏÏ2SIV¢é(® ^¨0‰(8>	íÈ':"RrÇp)kİq¦C(¼~'+N7[}8d®ql‰Ú`"M~HÛ4CÕ }áH¹‡æ)eá5wCby[$3|9^&9´Ì)hy5o
6ô:”ß Væ=X&Á|AlhÚ—Ì%·`DÎ¶j`Õè`o¾‹68¯ºâ"8VQ';tCÏ"#ã\<=ñn$é=ğeÙÀ… (íd«m=¢n-or®¯Œ¦lK3Ğõ#¿ş0ÜÌP—8Ëwİ±NŠl`·e6|>€Ğt3}ˆiA,=oi©A
¼$P²·‘§m£jSHA>E%/``@÷~0(aoíwîdí("0cÏ“h"‰yx¨eşu‚^jµÍp×Æ¡g"í’3Ó­# d­ew0±s­ĞËaµå$c&Í$rù¢£n˜}‹ql+±°éáÉåù+dı‘
tQ›hÅnÏ`e~fMN~Š•"‡)!ñ!q8>atxÓgcjFsãv
nä-d-<üİì£OCkgıtting
    UnivariateSpline : a wrapper over FITPACK spline fitting routines
    splrep : a wrapper over FITPACK spline fitting routines

    """
    # convert string aliases for the boundary conditions
    if bc_type is None or bc_type == 'not-a-knot' or bc_type == 'periodic':
        deriv_l, deriv_r = None, None
    elif isinstance(bc_type, str):
        deriv_l, deriv_r = bc_type, bc_type
    else:
        try:
            deriv_l, deriv_r = bc_type
        except TypeError as e:
            raise ValueError("Unknown boundary condition: %s" % bc_type) from e

    y = np.asarray(y)

    axis = normalize_axis_index(axis, y.ndim)

    x = _as_float_array(x, check_finite)
    y = _as_float_array(y, check_finite)

    y = np.rollaxis(y, axis)    # now internally interp axis is zero

    if bc_type == 'periodic' and not np.allclose(y[0], y[-1], atol=1e-15):
        raise ValueError("First and last points does not match while "
                         "periodic case expected")

    # special-case k=0 right away
    if k == 0:
        if any(_ is not None for _ in (t, deriv_l, deriv_r)):
            raise ValueError("Too much info for k=0: t and bc_type can only "
                             "be None.")
        t = np.r_[x, x[-1]]
        c = np.asarray(y)
        c = np.ascontiguousarray(c, dtype=_get_dtype(c.dtype))
        return BSpline.construct_fast(t, c, k, axis=axis)

    # special-case k=1 (e.g., Lyche and Morken, Eq.(2.16))
    if k == 1 and t is None:
        if not (deriv_l is None and deriv_r is None):
            raise ValueError("Too much info for k=1: bc_type can only be None.")
        t = np.r_[x[0], x, x[-1]]
        c = np.asarray(y)
        c = np.ascontiguousarray(c, dtype=_get_dtype(c.dtype))
        return BSpline.construct_fast(t, c, k, axis=axis)

    k = operator.index(k)

    if bc_type == 'periodic' and t is not None:
        raise NotImplementedError("For periodic case t is constructed "
                         "automatically and can not be passed manually")

    # come up with a sensible knot vector, if needed
    if t is None:
        if deriv_l is None and deriv_r is None:
            if bc_type == 'periodic':
                t = _periodic_knots(x, k)
            elif k == 2:
                # OK, it's a bit ad hoc: Greville sites + omit
                # 2nd and 2nd-to-last points, a la not-a-knot
                t = (x[1:] + x[:-1]) / 2.
                t = np.r_[(x[0],)*(k+1),
                           t[1:-1],
                           (x[-1],)*(k+1)]
            else:
                t = _not_a_knot(x, k)
        else:
            t = _augknt(x, k)

    t = _as_float_array(t, check_finite)

    if x.ndim != 1 or np.any(x[1:] < x[:-1]):
        raise ValueError("Expect x to be a 1-D sorted array_like.")
    if np.any(x[1:] == x[:-1]):
        raise ValueError("Expect x to not have duplicates")
    if k < 0:
        raise ValueError("Expect non-negative k.")
    if t.ndim != 1 or np.any(t[1:] < t[:-1]):
        raise ValueError("Expect t to be a 1-D sorted array_like.")
    if x.size != y.shape[0]:
        raise ValueError('Shapes of x {} and y {} are incompatible'
                         .format(x.shape, y.shape))
    if t.size < x.size + k + 1:
        raise ValueError('Got %d knots, need at least %d.' %
                         (t.size, x.size + k + 1))
    if (x[0] < t[k]) or (x[-1] > t[-k]):
        raise ValueError('Out of bounds w/ x = %s.' % x)

    if bc_type == 'periodic':
        return _make_periodic_spline(x, y, t, k, axis)

    # Here : deriv_l, r = [(nu, value), ...]
    deriv_l = _convert_string_aliases(deriv_l, y.shape[1:])
    deriv_l_ords, deriv_l_vals = _process_deriv_spec(deriv_l)
    nleft = deriv_l_ords.shape[0]

    deriv_r = _convert_string_aliases(deriv_r, y.shape[1:])
    deriv_r_ords, deriv_r_vals = _process_deriv_spec(deriv_r)
    nright = deriv_r_ords.shape[0]

    # have `n` conditions for `nt` coefficients; need nt-n derivatives
    n = x.size
    nt = t.size - k - 1

    if nt - n != nleft + nright:
        raise ValueError("The number of derivatives at boundaries does not "
                         "match: expected %s, got %s+%s" % (nt-n, nleft, nright))

    # set up the LHS: the collocation matrix + derivatives at boundaries
    kl = ku = k
    ab = np.zeros((2*kl + ku + 1, nt), dtype=np.float_, order='F')
    _bspl._colloc(x, t, k, ab, offset=nleft)
    if nleft > 0:
        _bspl._handle_lhs_derivatives(t, k, x[0], ab, kl, ku, deriv_l_ords)
    if nright > 0:
        _bspl._handle_lhs_derivatives(t, k, x[-1], ab, kl, ku, deriv_r_ords,
                                offset=nt-nright)

    # set up the RHS: values to interpolate (+ derivative values, if any)
    extradim = prod(y.shape[1:])
    rhs = np.empty((nt, extradim), dtype=y.dtype)
    if nleft > 0:
        rhs[:nleft] = deriv_l_vals.reshape(-1, extradim)
    rhs[nleft:nt - nright] = y.reshape(-1, extradim)
    if nright > 0:
        rhs[nt - nright:] = deriv_r_vals.reshape(-1, extradim)

    # solve Ab @ x = rhs; this is the relevant part of linalg.solve_banded
    if check_finite:
        ab, rhs = map(np.asarray_chkfinite, (ab, rhs))
    gbsv, = get_lapack_funcs(('gbsv',), (ab, rhs))
    lu, piv, c, info = gbsv(kl, ku, ab, rhs,
            overwrite_ab=True, overwrite_b=True)

    if info > 0:
        raise LinAlgError("Collocation matix is singular.")
    elif info < 0:
        raise ValueError('illegal value in %d-th argument of internal gbsv' % -info)

    c = np.ascontiguousarray(c.reshape((nt,) + y.shape[1:]))
    return BSpline.construct_fast(t, c, k, axis=axis)


def make_lsq_spline(x, y, t, k=3, w=None, axis=0, check_finite=True):
    r"""Compute the (coefficients of) an LSQ B-spline.

    The result is a linear combination

    .. math::

            S(x) = \sum_j c_j B_j(x; t)

    of the B-spline basis elements, :math:`B_j(x; t)`, which minimizes

    .. math::

        \sum_{j} \left( w_j \times (S(x_j) - y_j) \right)^2

    Parameters
    ----------
    x : array_like, shape (m,)
        Abscissas.
    y : array_like, shape (m, ...)
        Ordinates.
    t : array_like, shape (n + k + 1,).
        Knots.
        Knots and data points must satisfy Schoenberg-Whitney conditions.
    k : int, optional
        B-spline degree. Default is cubic, k=3.
    w : array_like, shape (n,), optional
        Weights for spline fitting. Must be positive. If ``None``,
        then weights are all equal.
        Default is ``None``.
    axis : int, optional
        Interpolation axis. Default is zero.
    check_finite : bool, optional
        Whether to check that the input arrays contain only finite numbers.
        Disabling may give a performance gain, but may result in problems
        (crashes, non-termination) if the inputs do contain infinities or NaNs.
        Default is True.

    Returns
    -------
    b : a BSpline object of the degree `k` with knots `t`.

    Notes
    -----

    The number of data points must be larger than the spline degree `k`.

    Knots `t` must satisfy the Schoenberg-Whitney conditions,
    i.e., there must be a subset of data points ``x[j]`` such that
    ``t[j] < x[j] < t[j+k+1]``, for ``j=0, 1,...,n-k-2``.

    Examples
    --------
    Generate some noisy data:

    >>> rng = np.random.default_rng()
    >>> x = np.linspace(-3, 3, 50)
    >>> y = np.exp(-x**2) + 0.1 * rng.standard_normal(50)

    Now fit a smoothing cubic spline with a pre-defined internal knots.
    Here we make the knot vector (k+1)-regular by adding boundary knots:

    >>> from scipy.interpolate import make_lsq_spline, BSpline
    >>> t = [-1, 0, 1]
    >>> k = 3
    >>> t = np.r_[(x[0],)*(k+1),
    ...           t,
    ...           (x[-1],)*(k+1)]
    >>> spl = make_lsq_spline(x, y, t, k)

    For comparison, we also construct an interpolating spline for the same
    set of data:

    >>> from scipy.interpolate import make_interp_spline
    >>> spl_i = make_interp_spline(x, y)

    Plot both:

    >>> import matplotlib.pyplot as plt
    >>> xs = np.linspace(-3, 3, 100)
    >>> plt.plot(x, y, 'ro', ms=5)
    >>> plt.plot(xs, spl(xs), 'g-', lw=3, label='LSQ spline')
    >>> plt.plot(xs, spl_i(xs), 'b-', lw=3, alpha=0.7, label='interp spline')
    >>> plt.legend(loc='best')
    >>> plt.show()

    **NaN handling**: If the input arrays contain ``nan`` values, the result is
    not useful since the underlying spline fitting routines cannot deal with
    ``nan``. A workaround is to use zero weights for not-a-number data points:

    >>> y[8] = np.nan
    >>> w = np.isnan(y)
    >>> y[w] = 0.
    >>> tck = make_lsq_spline(x, y, t, w=~w)

    Notice the need to replace a ``nan`` by a numerical value (precise value
    does not matter as long as the corresponding weight is zero.)

    See Also
    --------
    BSpline : base class representing the B-spline objects
    make_interp_spline : a similar factory function for interpolating splines
    LSQUnivariateSpline : a FITPACK-based spline fitting routine
    splrep : a FITPACK-based fitting routine

    """
    x = _as_float_array(x, check_finite)
    y = _as_float_array(y, check_finite)
    t = _as_float_array(t, check_finite)
    if w is not None:
        w = _as_float_array(w, check_finite)
    else:
        w = np.ones_like(x)
    k = operator.index(k)

    axis = normalize_axis_index(axis, y.ndim)

    y = np.rollaxis(y, axis)    # now internally interp axis is zero

    if x.ndim != 1 or np.any(x[1:] - x[:-1] <= 0):
        raise ValueError("Expect x to be a 1-D sorted array_like.")
    if x.shape[0] < k+1:
        raise ValueError("Need more x points.")
    if k < 0:
        raise ValueError("Expect non-negative k.")
    if t.ndim != 1 or np.any(t[1:] - t[:-1] < 0):
        raise ValueError("Expect t to be a 1-D sorted array_like.")
    if x.size != y.shape[0]:
        raise ValueError('Shapes of x {} and y {} are incompatible'
                         .format(x.shape, y.shape))
    if k > 0 and np.any((x < t[k]) | (x > t[-k])):
        raise ValueError('Out of bounds w/ x = %s.' % x)
    if x.size != w.size:
        raise ValueError('Shapes of x {} and w {} are incompatible'
                         .format(x.shape, w.shape))

    # number of coefficients
    n = t.size - k - 1

    # construct A.T @ A and rhs with A the collocation matrix, and
    # rhs = A.T @ y for solving the LSQ problem  ``A.T @ A @ c = A.T @ y``
    lower = True
    extradim = prod(y.shape[1:])
    ab = np.zeros((k+1, n), dtype=np.float_, order='F')
    rhs = np.zeros((n, extradim), dtype=y.dtype, order='F')
    _bspl._norm_eq_lsq(x, t, k,
                      y.reshape(-1, extradim),
                      w,
                      ab, rhs)
    rhs = rhs.reshape((n,) + y.shape[1:])

    # have observation matrix & rhs, can solve the LSQ problem
    cho_decomp = cholesky_banded(ab, overwrite_ab=True, lower=lower,
                                 check_finite=check_finite)
    c = cho_solve_banded((cho_decomp, lower), rhs, overwrite_b=True,
                         check_finite=check_finite)

    c = np.ascontiguousarray(c)
    return BSpline.construct_fast(t, c, k, axis=axis)
