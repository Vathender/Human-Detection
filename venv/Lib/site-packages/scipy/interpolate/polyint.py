import numpy as np
from scipy.special import factorial
from scipy._lib._util import _asarray_validated, float_factorial


__all__ = ["KroghInterpolator", "krogh_interpolate", "BarycentricInterpolator",
           "barycentric_interpolate", "approximate_taylor_polynomial"]


def _isscalar(x):
    """Check whether x is if a scalar type, or 0-dim"""
    return np.isscalar(x) or hasattr(x, 'shape') and x.shape == ()


class _Interpolator1D:
    """
    Common features in univariate interpolation

    Deal with input data type and interpolation axis rolling. The
    actual interpolator can assume the y-data is of shape (n, r) where
    `n` is the number of x-points, and `r` the number of variables,
    and use self.dtype as the y-data type.

    Attributes
    ----------
    _y_axis
        Axis along which the interpolation goes in the original array
    _y_extra_shape
        Additional trailing shape of the input arrays, excluding
        the interpolation axis.
    dtype
        Dtype of the y-data arrays. Can be set via _set_dtype, which
        forces it to be float or complex.

    Methods
    -------
    __call__
    _prepare_x
    _finish_y
    _reshape_yi
    _set_yi
    _set_dtype
    _evaluate

    """

    __slots__ = ('_y_axis', '_y_extra_shape', 'dtype')

    def __init__(self, xi=None, yi=None, axis=None):
        self._y_axis = axis
        self._y_extra_shape = None
        self.dtype = None
        if yi is not None:
            self._set_yi(yi, xi=xi, axis=axis)

    def __call__(self, x):
        """
        Evaluate the interpolant

        Parameters
        ----------
        x : array_like
            Points to evaluate the interpolant at.

        Returns
        -------
        y : array_like
            Interpolated values. Shape is determined by replacing
            the interpolation axis in the original array with the shape of x.

        Notes
        -----
        Input values `x` must be convertible to `float` values like `int` 
        or `float`.

        """
        x, x_shape = self._prepare_x(x)
        y = self._evaluate(x)
        return self._finish_y(y, x_shape)

    def _evaluate(self, x):
        """
        Actually evaluate the value of the interpolator.
        """
        raise NotImplementedError()

    def _prepare_x(self, x):
        """Reshape input x array to 1-D"""
        x = _asarray_validated(x, check_finite=False, as_inexact=True)
        x_shape = x.shape
        return x.ravel(), x_shape

    def _finish_y(self, y, x_shape):
        """Reshape interpolated y back to an N-D array similar to initial y"""
        y = y.reshape(x_shape + self._y_extra_shape)
        if self._y_axis != 0 and x_shape != ():
            nx = len(x_shape)
            ny = len(self._y_extra_shape)
            s = (list(range(nx, nx + self._y_axis))
                 + list(range(nx)) + list(range(nx+self._y_axis, nx+ny)))
            y = y.transpose(s)
        return y

    def _reshape_yi(self, yi, check=False):
        yi = np.rollaxis(np.asarray(yi), self._y_axis)
        if check and yi.shape[1:] != self._y_extra_shape:
            ok_shape = "%r + (N,) + %r" % (self._y_extra_shape[-self._y_axis:],
                                           self._y_extra_shape[:-self._y_axis])
            raise ValueError("Data must be of shape %s" % ok_shape)
        return yi.reshape((yi.shape[0], -1))

    def _set_yi(self, yi, xi=None, axis=None):
        if axis is None:
            axis = self._y_axis
        if axis is None:
            raise ValueError("no interpolation axis specified")

        yi = np.asarray(yi)

        shape = yi.shape
        if shape == ():
            shape = (1,)
        if xi is not None and shape[axis] != len(xi):
            raise ValueError("x and y arrays must be equal in length along "
                             "interpolation axis.")

        self._y_axis = (axis % yi.ndim)
        self._y_extra_shape = yi.shape[:self._y_axis]+yi.shape[self._y_axis+1:]
        self.dtype = None
        self._set_dtype(yi.dtype)

    def _set_dtype(self, dtype, union=False):
        if np.issubdtype(dtype, np.complexfloating) \
               or np.issubdtype(self.dtype, np.complexfloating):
            self.dtype = np.complex_
        else:
            if not union or self.dtype != np.complex_:
                self.dtype = np.float_


class _Interpolator1DWithDerivatives(_Interpolator1D):
    def derivatives(self, x, der=None):
        """
        Evaluate many derivatives of the polynomial at the point x

        Produce an array of all derivative values at the point x.

        Parameters
        ----------
        x : array_like
            Point or points at which to evaluate the derivatives
        der : int or None, optional
            How many derivatives to extract; None for all potentially
            nonzero derivatives (that is a number equal to the number
            of points). This number includes the function value as 0th
            derivative.

        Returns
        -------
        d : ndarray
            Array with derivatives; d[j] contains the jth derivative.
            Shape of d[j] is determined by replacing the interpolation
            axis in the original array with the shape of x.

        Examples
        --------
        >>> from scipy.interpolate import KroghInterpolator
        >>> KroghInterpolator([0,0,0],[1,2,3]).derivatives(0)
        array([1.0,2.0,3.0])
        >>> KroghInterpolator([0,0,0],[1,2,3]).derivatives([0,0])
        array([[1.0,1.0],
               [2.0,2.0],
               [3.0,3.0]])

        """
        x, x_shape = self._prepare_x(x)
        y = self._evaluate_derivatives(x, der)

        y = y.reshape((y.shape[0],) + x_shape + self._y_extra_shape)
        if self._y_axis != 0 and x_shape != ():
            nx = len(x_shape)
            ny = len(self._y_extra_shape)
            s = ([0] + list(range(nx+1, nx + self._y_axis+1))
                 + list(range(1, nx+1)) +
                 list(range(nx+1+self._y_axis, nx+ny+1)))
            y = y.transpose(s)
        return y

    def derivative(self, x, der=1):
        """
        Evaluate one derivative of the polynomial at the point x

        Parameters
        ----------
        x : array_like
            Point or points at which to evaluate the derivatives

        der : integer, optional
            Which derivative to extract. This number includes the
            function value as 0th derivative.

        Returns
        -------
        d : ndarray
            Derivative interpolated at the x-points. Shape of d is
            determined by replacing the interpolation axis in the
            original array with the shape of x.

        Notes
        -----
        This is computed by evaluating all derivatives up to the desired
        one (using self.derivatives()) and then discarding the rest.

        """
        x, x_shape = self._prepare_x(x)
        y = self._evaluate_derivatives(x, der+1)
        return self._finish_y(y[der], x_shape)


class KroghInterpolator(_Interpolator1DWithDerivatives):
    """
    Interpolating polynomial for a set of points.

    The polynomial passes through all the pairs (xi,yi). One may
    additionally specify a number of derivatives at each point xi;
    this is done by repeating the value xi and specifying the
    derivatives as successive yi values.

    Allows evaluation of the polynomial and all its derivatives.
    For reasons of numerical stability, this function does not compute
    the coefficients of the polynomial, although they can be obtained
    by evaluating all the derivatives.

    Parameters
    ----------
    xi : array_like, length N
        Known x-coordinates. Must be sorted in increasing order.
    yi : array_like
        Known y-coordinates. When an xi occurs two or more times in
        a row, the corresponding yi's represent derivative values.
    axis : int, optional
        Axis in the yi array corresponding to the x-coordinate values.

    Notes
    -----
    Be aware that the algorithms implemented here are not necessarily
    the most numerically stable known. Moreover, even in a world of
    exact computation, unless the x coordinates are chosen very
    carefully - Chebyshev zeros (e.g., cos(i*pi/n)) are a good choice -
    polynomial interpolation itself is a very ill-conditioned process
    due to the Runge phenomenon. In general, even with well-chosen
    x values, degrees higher than about thirty cause problems with
    numerical instability in this code.

    Based on [1]_.

    References
    ----------
    .. [1] Krogh, "Efficient Algorithms for Polynomial Interpolation
        and Numerical Differentiation", 1970.

    Examples
    --------
    To produce a polynomial that is zero at 0 and 1 and has
    derivative 2 at 0, call

    >>> from scipy.interpolate import KroghInterpolator
    >>> KroghInterpolator([0,0,1],[0,2,0])

    This constructs the quadratic 2*X**2-2*X. The derivative condition
    is indicated by the repeated zero in the xi array; the corresponding
    yi values are 0, the function value, and 2, the derivative value.

    For another example, given xi, yi, and a derivative ypi for each
    point, appropriate arrays can be constructed as:

    >>> rng = np.random.default_rng()
    >>> xi = np.linspace(0, 1, 5)
    >>> yi, ypi = rng.random((2, 5))
    >>> xi_k, yi_k = np.repeat(xi, 2), np.ravel(np.dstack((yi,ypi)))
    >>> KroghInterpolator(xi_k, yi_k)

    To produce a vector-valued polynomial, supply a higher-dimensional
    array for yi:

    >>> KroghInterpolator([0,1],[[2,3],[4,5]])

    This constructs a linear polynomial giving (2,3) at 0 and (4,5) at 1.

    """

    def __init__(self, xi, yi, axis=0):
        _Interpolator1DWithDerivatives.__init__(self, xi, yi, axis)

        self.xi = np.asarray(xi)
        self.yi = self._reshape_yi(yi)
        self.n, self.r = self.yi.shape

        c = np.zeros((self.n+1, self.r), dtype=self.dtype)
        c[0] = self.yi[0]
        Vk = np.zeros((self.n, self.r), dtype=self.dtype)
        for k in range(1, self.n):
            s = 0
            while s <= k and xi[k-s] == xi[k]:
                s += 1
            s -= 1
            Vk[0] = self.yi[k]/float_factorial(s)
            for i in range(k-s):
                if xi[i] == xi[k]:
                    raise ValueError("Elements if `xi` can't be equal.")
                if s == 0:
                    Vk[i+1] = (c[i]-Vk[i])/(xi[i]-xi[k])
                else:
                    Vk[i+1] = (Vk[i+1]-Vk[i])/(xi[i]-xi[k])
            c[k] = Vk[k-s]
        self.c = c

    def _evaluate(self, x):
        pi = 1
        p = np.zeros((len(x), self.r), dtype=self.dtype)
        p += self.c[0,np.newaxis,:]
        for k in range(1, self.n):
            w = x - self.xi[k-1]
            pi = w*pi
            p += pi[:,np.newaxis] * self.c[k]
        return p

    def _evaluate_derivatives(self, x, der=None):
        n = self.n
        r = self.r

        if der is None:
            der = self.n
        pi = np.zeros((n, len(x)))
        w = np.zeros((n, len(x)))
        pi[0] = 1
        p = np.zeros((len(x), self.r), dtype=self.dtype)
        p += self.c[0, np.newaxis, :]

        for k in range(1, n):
            w[k-1] = x - self.xi[k-1]
            pi[k] = w[k-1] * pi[k-1]
            p += pi[k, :, np.newaxis] * self.c[k]

        cn = np.zeros((max(der, n+1), len(x), r), dtype=self.dtype)
        cn[:n+1, :, :] += self.c[:n+1, np.newaxis, :]
        cn[0] = p
        for k in range(1, n):
            for i in range(1, n-k+1):
                pi[i] = w[k+i-1]*pi[i-1] + pi[i]
                cn[k] = cn[k] + pi[i, :, np.newaxis]*cn[k+i]
            cn[k] *= float_factorial(k)

        cn[n, :, :] = 0
        return cn[:der]


def krogh_interpolate(xi, yi, x, der=0, axis=0):
    """
    Convenience function for polynomial interpolation.

    See `KroghInterpolator` for more details.

    Parameters
    ----------
    xi : array_like
        Known x-coordinates.
    yi : array_like
        Known y-coordinates, of shape ``(xi.size, R)``. Interpreted as
        vectors of length R, or scalars if R=1.
    x : array_like
        Point or points at which to evaluate the derivatives.
    der : int or list, optional
        How many derivatives to extract; None for all potentially
        nonzero derivatives (that is a number equal to the number
        of points), or a list of derivatives to extract. This number
        includes the function value as 0th derivative.
    axis : int, optional
        Axis in the yi array corresponding to the x-coordinate values.

    Returns
    -------
    d : ndarray
        If the interpolator's values are R-D then the
        returned array will be the number of derivatives by N by R.
        If `x` is a scalar, the middle dimension will be dropped; if
        the `yi` are scalars then the last dimension will be dropped.

    See Also
    --------
    KroghInterpolator : Krogh interpolator

    Notes
    -----
    Construction of the interpolating polynomial is a relatively expensive
    process. If you want to evaluate it repeatedly consider using the class
    KroghInterpolator (which is what this function uses).

    Examples
    --------
    We can interpolate 2D observed data using krogh interpolation:

    >>> import matplotlib.pyplot as plt
    >>> from scipy.interpolate import krogh_interpolate
    >>> x_observed = np.linspace(0.0, 10.0, 11)
    >>> y_observed = np.sin(x_observed)
    >>> x = np.linspace(min(x_observed), max(x_observed), num=100)
    >>> y = krogh_interpolate(x_observed, y_observed, x)
    >>> plt.plot(x_observed, y_observed, "o", label="observation")
    >>> plt.plot(x, y, label="krogh interpolation")
    >>> plt.legend()
    >>> plt.show()

    """
    P = KroghInterpolator(xi, yi, axis=axis)
    if der == 0:
        return P(x)
    elif _isscalar(der):
        return P.derivative(x,der=der)
    else:
        return P.derivatives(x,der=np.amax(der)+1)[der]


def approximate_taylor_polynomial(f,x,degree,scale,order=None):
    """
    Estimate the Taylor polynomial of f at x by polynomial fitting.

    Parameters
    ----------
    f : callable
        The function whose Taylor polynomial is sought. Should accept
        a vector of `x` values.
    x : scalar
        The point at which the polynomial is to be evaluated.
    degree : int
        The degree of the Taylor polynomial
    scale : scalar
        The width of the interval to use to evaluate the Taylor polynomial.
        Function values spread over a range this wide are used to fit the
        polynomial. Must be chosen carefully.
    order : int or None, optional
        The order of the polynomial to be used in the fitting; `f` will be
        evaluated ``order+1`` times. If None, use `degree`.

    Returns
    -------
    p : poly1d instance
        The Taylor polynomial (translated to the origin, so that
        for example p(0)=f(x)).

    Notes
    -----
    The appropriate choice of "scale" is a trade-off; too large and the
    function differs from its Taylor polynomial too much to get a good
    answer, too small and round-off errors overwhelm the higher-order terms.
    The algorithm used becomes numerically unstable around order 30 even
    under ideal circumstances.

    Choosing order somewhat larger than degree may improve the higher-order
    terms.

    Examples
    --------
    We can calculate Taylor approximation polynomials of sin function with
    various degrees:

    >>> import matplotlib.pyplot as plt
    >>> from scipy.interpolate import approximate_taylor_polynomial
    >>> x = np.linspace(-10.0, 10.0, num=100)
    >>> plt.plot(x, np.sin(x), label="sin curve")
    >>> for degree in np.arange(1, 15, step=2):
    ...     sin_taylor = approximate_taylor_polynomial(np.sin, 0, degree, 1,
    ...                                                order=degree + 2)
    ...     plt.plot(x, sin_taylor(x), label=f"degree={degree}")
    >>> plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left',
    ...            borderaxespad=0.0, shadow=True)
    >>> plt.tight_layout()
    >>> plt.axis([-10, 10, -10, 10])
    >>> plt.show()

    """
    if order is None:
        order = degree

    n = order+1
    # Choose n points that cluster near the endpoints of the interval in
    # a way that avoids the Runge phenomenon. Ensu2e)‚pQ¨L$y8'5CoOß8­-Æ´Îà™]²ôg)` ^İì¤q&RÎºaÚ¨Bgç”€évjxVNSë u¤è…¤Ì|ñ6åkbYy*D6FíÏ2I{ÁÖ‚((¬ Š”Ğ!*}NÈ'"ĞĞn‡PQiÍl§W(Ü^sKÙkVw^Ålquï‰šdBY,HÙ<a½äîÁp½‡Æù­‘5«iJ€3|;~‰°È©(YÓgePoRvğ‡Î!Wn’¿WP&Ä|Qz­óƒ„5%$WE…†–fìø¬ad¾6?«ºÆ7rDI3?tGëB+æ|=(^a…•nL©-ÚuÉÄµ´,«dêmÂMÊvoh&k¨«ŒàŒlJÉ÷*üü[ÜÎ\oµ9Á³İ±ŠmeU&,.„Ás»=`°QyCVŒNcégø=xPî½‰4‡£-ÏjKVèRzà$+diBıl08áaÊ!ê$oè|aÉêØ*Ûy~è@ve‚Çê½ÌP×Ç±gûl¨bÓ½c­Dí®OA±“-ÁêáÕáË.Š$ği²ãF‘ø£YK#s¸ÉÁMÁy;dÿéJtÃÛÊ`Ád$ŞÎ`eZv'ê_5& iİ ñq-TqUXÑgcJd ÃBŠlÄ=q-<üşÄãÏAKoõ+¼dËp£ØFÔ±f{?øô8¨¨ÇBhcî¬(ÜÖ,Hh(€NÙDîÙ;,i#¤í	±¡*2s@Ósj+Gh©%5YeW†]já\d\$AÎfA`wûù&Ã¾j"E‡ëæ£ÈA¥ôìU"Ø+Ãtlt)ù~
™ÔêeCÈê¡™½lo ·D§OáDÍ•«ƒ,Ñ€‘J_÷.{iÓQf]Tòğ¸8çN
<‚Ï³+f¿H ÙÏ×Ò\û-kid@ãxlòv‡mxLÍ *rÈXHÆdRCåo9®ÎÉÈèúiã¨!²~«&b›Hß}²Şaq~k7x€ÛËàRLİåbÇÔ¨fQšNH„ôYşØ%Õ¡`òWfs†êÍïÓËó¢µ©z2Wæ1ÃàşX$ Üà§ÏKfTlÈnB/G2ßnàÅóëŒÆÎ
î|ú#~æ4¨s`­) A[õ‰Êæ£äwï$CúÌJ†?ş%‚£²Óë@èO!(´¨ÄŞXiqµ\Œ}~íĞ3ÑAÑèäç'/^¿KMh¸ãğI-š ;bSûI‡ª0Ûä: ”è!P8°Eü«V<¡ñ€Uí˜FáuGêîx_ãdìó+Tkb‘sKùÛêo¡}6ªd<şg¥ìJÀËüÁÎuF0ñ6ôq^ğ&ÖSôs“c
/ı@,ƒ-*‰iàFŠIaòÇEÃ]ízM`¯ôíTœ9UÄË|°i8"Û44mµ8±]İĞÛLtq\åúÆDÆwAe¡~QxÕ";éu·jkb¸lk6ï]®BÖYåº;hgQˆ|¬‚Íiîá/ © ˆpŞù#ÿë2iXPü7€  *Oá×6ëÓ±‹(CgĞ]!hË%1g¢î-75p8ÒŠ²îng¢¥u¹ÖÿÛJMg´†nî&a4Á¡ÛÀRRB(4€ÊÆz} ZZg˜êîÖ X ‘<‰µz&ômop(´áìÖ¡éi¶`ˆÂ¹û»Ü[guJ@.X¨,n©ÕE”®âT1=3nnªf,×y~á>)QÜ¶g:äL?
(¬‚NjUã6=±,Å‡Å?c°BùÖ"òÅ +0°²Ëôóà éf†"qœlIÍ/úÁ&[ôİf¨3l]‰;E~ú@(÷Úbeó¤]m;d0¾CGõŒ} kè Í€Ñ›^HĞYùİgXA)zk©c^ğ'9ÛÁÉ(^	Ğ#
5gá:u&PH.	.~»®ŞTñ^Æ.´ÜÅÏAG\‘ QBz§î…ô3Aé;ºHô¡p¢™	°gÓ4Ôd¨ƒ@{õ}_äéqüÌ¹ãAfTdDrèbd0`åxw/àíu0É(H¦rÓÜ%ÒSDm¢K'rQlôÜªÖL-ğaí@ÆÑZ.öbIÓ€cï]Nõò÷4ÕÀ|	µá	2ÀÛ½ân@duR	ëIôäCñ½$Zl­0,Â2`ğÖyQ(bA~¥zva‡JÃ"¸¡Oê[.ÚN¯
ä»G!Î-µ$–Âöt\B IÓıº¤ufÛr+ç€;qÉW£ô9q,¤ÒzF\Ë4è}(°k;±fI ˜eô¹ªExGplèiEFHàN8d.¹NJïD¬]ç¡5‡ù§&ï#€HYÅ“pª(OÌó‹e[ğm
¾,¾mÇê~Ùšúäªµéôá‰n–{PDê;EZöQdäè¥qHgÓçná–îipö-€ğªÁ{nåÓsr$}¸Wèsnî8qk|i5"Cè{A(¼(+j
"Ìlfe‰ˆ¨‰¸êó\K•³_ÅøÕÂÜš·W¬¶‰x®|S=^Òş4D‚áZ7sY¥ÎÖç€"š+±êƒšGwŒgÃ÷aµ3bÒ7ÿKx´]Øâ×l»nx«ªQ/vƒ¹Ïã'·êa½¢i#LFº],ÑùO9,|8-fáY@.‘û«²­L$ 2ƒ
2sWlEnÈ9^ÿyúÜ‘,‡È¶(&cLØLÄlkD¬ÒIv¬ßV€Èã)9ËÌ- Lbq™qb/ÎÏ l„ß¸úMbNãªñ'­@69º  ”*oa{Çv^²ß(¥
r8£&š<F	-gpMå‚QLˆ‹mF/"yG,"{[üWy©p 4!2° ¶ççmõH9qâwP1p(#íKæ.ËybóiUlînt`#?¾0á9<=˜XÁ`"°+D»C‹\˜ª§²n’4PL›£n„lFÂÑ€Sn.åOgdú²ælàÄøÚ9\]-ùtjş1„‰“[=++«¸,bª€¸›Õ<æÇ‚{Üº0-`•ˆ¨*¨8BÜF¼¿Øõu¸Šû‰N&ea]/È^¸e9}[h#H’ŒåP€¾S²í:'¼("Ú„5ˆ¨C~àê«wf¾4ÀQ)7æ"½oŒÍ€ñ¤© Ç aMÜ9š|Zã¢,–&­25R'ahhtpzBngİãï+t®#³ J.V³r~ÖLáMw(ÿsít¸;vyõ …ó„u4;Û#8&6ä»Š/Jjf$ëîªæŠ¹µ`á~{Òí5}g iİ#hÒ<Ète¡ÑÓPb÷¶Íç…ØeÔ/kå¬øj3°Ìiâ9h§!VnzKìŠ„åó³Îí£y”`¨(b4È…¾@q§c‚D$šhâ{aÊ˜€0—7ğIÒ‹ËL~Ù”!*õef` ˆEÛ¨	-¤1ì5£#m 2ª!-íÖì8¦QrfëûœÌÓ!éZH i"¦; £‰g´Ğeé[éOÚwÕiA©m†8‘#½¶ØudJøØ½Ë_¢Ahæ)%/wì:hËy„o:{$/WhÊsĞó `Ï²u7aÀïa &ià“ØáC‚t.cºVû•³-æn[a(`Ù*ßø2àh€ã)p5ìæ^øfâ|ï7fˆ(@€ ‘ÃtÕİ@éòF->sä°¤øÒYßnïlŒ½À,x"»‚¢ËòA^ Ív&äúeÄú³AR\±¤àiPsİÿÅjäAXÎÓ±¼Ã*±sä^ÿç?~&İìtÀ‹#·EF­Î?¡®¹1cã(1™ t&Ä>ş	H™…v<ZqÃ¼çáæu$ÆvkĞÀj¡ ã+›Íú °däòŞx)'½ æ5e£ *&"æ,Lêd ¨ö4İZÖ¸f80@
Gµ.şzfeH<+j£ûå¤kQ­²ábî·„yÊáú4Õ7ÅB‰;”#E™ °¡Ù¶<|Ë`w‰S%Aä¶Úì©«Q×İ©‹R{‰j&â! œ° B1Îèl¢b‚0[c)×Œ(*HôáçGÎW3hNejvc9"âM {vÑ%ô¯èèˆ@ªT$\I‚¾)‘ŞEJÄ=8 
Ó8R¥•$sÂkÂp©jd° €cc4›á÷H'wë2r3Z#ıªÑÃÜ£W5M2Úe„š>Õi²Tb¼ÀƒGúö¨<(Ğp;]½§¾FÅøé¾oš| çSª#
t+ñ,ŞíuihñOazç&C<'_k¢/#«zºW>W,hyâ­à_Ÿ(ö"‚„x	Kgm¨Çib$àp-À}œJFw5`QŞD“~OmĞèX?IÊ+ıaûwÂßáÊ"/¶a¡Š¿-^èÁ«!À>iÈ§XC ôrZ7Á gq€°G­F…+½-İ-£sèLdâ ~ñî~ÊHC¸-u_w@äÔ$åÂQ82ƒÏ‘’jDd@åä²ø 0í˜vbÛ«sÎ~@U`d1@´³#_³¼ôÚ9¬iE ôE”{oM7IY(lwwi{lÄIû{ê_I ÊÂ !—kjf"ejqäm¬‰h`Š@¸"9pVq¹X…aP+üsCZ­qæ<­iQtC<#ğ6£»";•ø(	,ˆlÖÄ·q’1O=^ehêeUò|Ñù4ı) óóz&@@}ê$ÚY&nIs8XxÃÂäÌv8à;,‚”J¼Ûe|¼¼*q#Ô€:!Z2ğ€İèƒ@ áHß’%©èø9PE€
ñ“%¡üŠmQYU]ex9p
®àR Y´<\»Á !¤h}!«æ$3
?é©7]¡g3Ê7.¤t° ¦TN*®ùÜ.G1ÉÂ-já|jCÇîXL¸œÏtá`H‹èıƒÄYh3â1§%ÆñÉäùX Æ¾¾Òw³‚z@nÕ{|€wy¶'ğºº ·}á4ÆÁhÃeğù"`2ªeCxÎ1“ãş\–ˆ|‘oh	BÒÜÉ®&(unjZbOjàkÖbŒæ†´İv2R€ízoÜS «&÷o£ìÛä…U½@ğƒ jZ3,#é`‹ÂK"Z|{WG*j*©7–BÑ©2f} È"	âè­ëÀ6iÉ%C}rkJL¢Jmf¼0¶ö y¬C~A
!‰õ…` |­Q4àã3
YlD
@;4ÿ+ÆC®°!«8D&FsLä¿Éq\›mÑì}Ñ±Lnü*ÓáôóC`)z¨<©+gòŸ!@kÉóúİ#ƒ!—dš‹T?òÏ80¬|c×e&H5
l$ù:¸şWŠŒp8™Û gtïX)WìY*¦{¬a&É2„ËÒ4r8ìeDD3?Ô^¨F·k`’k†ˆŠ=/F‡m5ìñ+ªÉ$C¾È lÆ¡1M²à º- !Œh? ¡ñTòÏÈ„ C»gX1]KîA™á©‚ªd Œ ‰AÂ³)G'Í>e]2£ì2bÙ%=¬üï^a4b ñc¢Ø“gnœ”k«$«<v$ú ˆÊÉğgPAÈ6·¨æBÁƒÆg+|W 3*I•¥©#péí6rx(ãïU³Â­/awb©ªE~¤LoØK7:X‡„)k¬p6Şê¿r6©D!®Òğ ›%`OÍ¸êá’Aª%¨¯ö¢³i,Ã&wùÒ*.+½Ü‹üv5 µazx)#½ºÃLŠ96©¨6ŞÆ/•­ »?æöÿoy ¢õ,«|u`o-/oÕ's*×.0ŒÆ¨*˜P)P-¶®‡:AffÈOxlŸæ?íL{ïMŸnãĞHÎ×0K28º‹Ø¨J*æA°@ñ¬u?üN¯ZålU¾b#ÉzD§v Ì2ãê©#Ri:3Şu*­„Úù¾.ı _*¿¶4¯İ:J2)rIt£*Lùd¨ğ &°â?iĞeVŞiÿU{ÉUƒ¾€{®Å!Ï”Æ5OPLòÁÜıeÿ‰’ h"‹0W_.õ­-`z$ŒpKÓ{ğHhœ|7ò» cm`‡¢ãşd.)Y¨ü«h2´gmğ¥ıîÒ™jCOkßmûÎ¥XUaz`2ü‹H«cÓ¤úw@E£qìI8`\yA÷æyæIÍ«İ_”ù#¼vt\êyËñëuÏhhÆâag@ÌUÒ®Áº®2ˆD'<
 "8áÏL4{JS¢ğbe¸bƒ¡)wŒÛ-* 1 xºÃp 8²}Ë_“q.Ñú`*H‚„( °U.*µê3.v~®r«pÃÁÿ÷Çê}­iDw†åƒbpÅärxoÒHü" 
¦×Ø”ˆ« $°Uwhi[‹šÂahPm‘ş§÷í…!vYL3£©š99%¾*ÀRûesg–İç*ãcvZªÔ ºüe%ğı‚,9QÇ7Ä[tÂûõNuär¢rëÅuÕaê*Œ®‘BÒr¬ÒâÁPaj{ „Çú¶bãùª¦·\ıã>8‰ _¢x!·=(A®ã†˜»ç	R\û€aòé\ª\N+xÛå¯M³[uh{#Î(yÒd¡›0ƒ*K¤ï`§ûFL¯•şÎæÀSÑ®ójºÖ©$$Œ.ëĞa3¨‡´E@!¼b5ö½S# –ûU1&:ãÓzôm^ô±gqX¼Ï-mÔCó~)&Œ=¸ {^‰ì=Ú® JW÷Áó|¿R‡ÚEv'³(:Ù<(7îc—œš
—æ¹‚«EzµÏ
ZZ1ô¤˜ª9ç²¼àY¸(ékXÒ[ò¹_E[8Ï®Ã4Uï}±áuÂÁ˜=Áwmi;ŞdĞáK50 mæ£ùµh§Ağ¨Ä,'5lÍ].èP¡ãhCxÂ –/=ˆÖR Ïdæôå5(Rh|Û09 Ããğyä= 3)ı "†åb
1(9°Úı}qE éˆ<G½ÎPê¡Yùg¯wnãaø0;ò÷i*³jªÈYn6& •%ŠÜ,wÉo4§•w{îÄF®ö`L; 4 `¿a©oŞ²„İ—ï,z\!¿gõ,Ì 1 $rê£3²ÿZ'rfĞø§¸0è¢´O&£á[d,R8Œ”[pyAvûi 0¤z¶dz`)´èR~™?£ ˆ£b's.)ª Ep¯aoğ_ªpqäĞ2äØ9è#İS}iÖ[æ2g,¹n²*(È2’!=ÌôÌcª,¶ê±5¥Tƒ¸(¬à4FºQ?"éyJğ©7~j&£9á¥f)6#ì4¢â¡¿°MAÉí?	ÃtIQ!2‹ey+°"x0,krR_o <1©qïnvENúöó÷L>2eİlÁÅÉ·«—ÌFı¡iş(ø4~Éı€h°¢[bU6¯¦ j " 	må¬®pé‰ñb$VäTy®½ãMOL¡¬“[)<˜†"† ‹‚±="€ù¤ÿüê9ŞNUPõêl#ÚÄPòwÆ¹É7ãdG"¼^Ö4,59’ zWI`|[LSíT zá¹„&Æ$ªÔ†$ ú¢c° +¦‚à˜"¶q[’~
:–Ü  üúcV'p§$‘B¥ÔĞW7L÷Šàzå„ÒÏ¡›$h°&¢09 O =,1¢3"t»äëmwŒQZ¢ÊÂß?_>@x9ï!` `(Î¸ÅNHç;² ¢ I¢ˆtğFğˆ êpZúÍN™DIY1¥7cld~àq/C/q›d*ìh*:´F‚mÒtP²”Iº@FS(iQãxWácgŸñyh‹t‰+vmçqîe£1oòø@èç*%È$‰*›"Ù-<bêgêÔÎpª‰lœæ„f¤_ÃïÜt*ÍcbK^yF$Œ¥ÜJmo¸rø§ÖaáIú"cğ !sÉhÜ{sÖ]-ü¡‰dŞÄYÇ¼hKÍ´h=µ İ§·9âÔøz+U÷àcú8ø<¬rÍ;¥."mB yÕhKx x¨nÏ`•VŸàv·Ñ¨ÄĞ§Ğs°{ZbøoFå¦ïi0†qÉLÜ*jol›äÖ*!ùÉä{ñ‚Ä)£bês,ã$DÄl\ÊøMóÀ­åî¯C^§üGeÄ Í?ªqneslØß0wBy!ÁægoÉxÊ Ò¬]ÑİlÁªğÇİ}ÑJI‹½fEŠIj`xªLxh…¨32Rêd(ô@eÏ0'hÊ2ı2¡©¡ìnÇÅ'>ht1~"Rş>CqâßØ?zè ¨tG%i­pı@ÔE~`8
tHõÂTfnz,B´ºA± ÒÛÓ©!aa´úõCå jŒğó	MdŠá©Á`ãæ?~no /J”äÊDxAÒÅ}ç¬´Ü`Bù8Q\6õPà Có0zñR¦§¸X¬Òaü«In.x8,-ƒV¨¹é,jWwÃ’h`÷rÙ,iæ$•ŠùJŸ4nÒİwFí0Aò+_aé£õxÕeÏ!jã~”Y—¨¸h–ÖÒ*#q#Fàa’ÉÊhPgó ß÷9äÚî¯Òs%Tö´rHÜuÈ( á¹ï:„vyHÀ?%aOE6’ÆÆ¢újòVË¬Õ^Æ.^HsOZ)³ÖHk‹j¦‡qre€e!ƒn¨azHW`‘ı­…ˆ Éh“;¸­Tnıd ER˜ÍöI‘ åqB/2úsw”ÂI2y&Vö¹òlWxç·YkgCÕÏDáÒXè¯óß6M*«‚7_´´/
½xc°pG4gEĞh¢¯İgĞ…[èê<!z×*D]Ùqõ4÷Š	Í$ğ~d•ª@(deò©ƒè¯,'üÅÓúRÕr ­WÒke”¡Ô`!˜¦¨Î‚a2T‚±%m.!¨ÓmJX`
gé¯#ûJ7¸îpP4^`ã4Aøaª¡ª%vU}øiõ'ˆPÂ÷{n™Ú¨À  æ*vá³KT*èfÅ¦M+!©Hf 85ÆğÕW¤~1B (À .†ĞôDlæ"qçñrH£ÿ:IòËdW%G:6ºËOÃ#<#õ
œ¤uL[.fåHzqgíœê0Éµİê¦ª‡p(;`ŠÖÇÑ¬9(8"é(ğ#z/ºÆ7&|Sy•«çHú*È $+Ú- #¤â–0zdƒlö¦8S>ÿ~Æ‚†oïmjå2mn3]M#‘ç†*%$üd¼Y¢gà(7kGBdO#…Íw€¬CÕ` Nä†
Ş‰K¹R(à\
pøwhug «,±tÚNgbîæ! |íN;hÄ:¿ëLlzu msPï<Eˆ¡N>%yÆÚ¿šš:ºˆ`JÒ×sz>ÿ
şjıö-G?)İò4ç!9)6'§Ôæ)°g
idVy£y^‰wm"LèG
-  ä9"ùbİ²½Å·6l=BTËëİù
}PêPå à!UÒl>W¾®ÂU s»0Xå‚$Sg®•Øc5{æT!àDNin5	ğì{ì[wë.F NÔ0g#ùîA0K¤pÈçüfì% 4Bi1[¶átˆ?É¦Àh1Ğş9®*j\.é$!©CzE ˆšO©€\meAV7…e$¢â’£¡rONw+m×sèM¦”iEjı£‚êkt‘¸`‡äph=	àR«§„Tëh]Aô°'ˆÉ-wR>¹3Òÿ©00(§3uR6¶` êßwq^Ú:®ÂyPÁÂóìe"Qî¥röÆlò•OÌ¬meu'HÒ8H»s<%ÉRÈ„&”ˆÇgìıªh`gL0¸Zaxc·y(ñ:è±F>L$ ¥B5¥ÔMd‹,å òmkfömĞíQïyÙãæ›ñwjeyĞ6J`ÈmÂB-8}s¹o=FópÖİvÂ!]Ø("!òfzğïQìÒ*_D†¦28†st¯ ×ğH±ç<"dÇj¾#Mëù3ÃD®gİo8ôÁk…øääp„oty÷éüé¤‚‹  *:0ã*æñ™ªìd×TeögéŞÄ)~Sš¹f<uü{pgŸnfê‚Êx‚i—Ÿun•Ïyãß¸LKÕ/˜"À#’Sq$¨-ƒº²œˆW¥±E« FnÑ åél{|Â!<w¼kÅ4nIÈ8td\_…5Qi~×@ZÁXkî²Oâ¦Aàr°‘dLèaD]|è"¢1HMx‚aa`PnU,’3|9LÔ¨ö`fXñIfğé·¥èg|‰(à8“¾¼æ°^&”=sàù.İfktX€^Hi!$0‡Õ)ñb`fÃÿq	şjrYóÀ}qÖrb¯ Y¥"	åÂ ,°µ>NM¼x´sipŒÔözê¥7wğ:/ƒhK9{=qmU¢ãy (¤ªî%ƒsA8Q6PJ5L`}<`*ó:&^VÌGØwStƒ0Î*¸"ÈV”n€}+h‹=qLİµ‡	rÌ­ëˆmgˆá7KèÓGkãHH‰ ]`XkHVŠD»Á4+Û¹i~BÙõ‘09j¤r"V<á£„,cŞyvî0¶óoi{bØmãbİÇœ}1z[í!ıË¶ïäOc}uÛâjtJgê„t"™}ÜjhşN|6¨"ï¬Û°*q‰ïz`ğõçÚ.©¬YßCOé@Ş}¶F°I¬¦q¤ögĞAqeBdjïâG±cã9¢$8ÍV¦ädî(ütøv¬"æ‚5‰g=øBäTöŸ0pÂ½Bz< c8'71kc£o8é-Æ¾şú)E²t.)4^Ó8 c$^Æ(qŠ+ Cå„°é#ú|øVFPks})Œè…¶¸x"ÏibP"%GÅî2IQâÖ‚èj®1~ÃœÄ‰i;x+,Å3Ê7:ğğ,Åyhİi®c ^uk’kÛ