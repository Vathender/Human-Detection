"""
Real spectrum transforms (DCT, DST, MDCT)
"""

__all__ = ['dct', 'idct', 'dst', 'idst', 'dctn', 'idctn', 'dstn', 'idstn']

from scipy.fft import _pocketfft
from .helper import _good_shape

_inverse_typemap = {1: 1, 2: 3, 3: 2, 4: 4}


def dctn(x, type=2, shape=None, axes=None, norm=None, overwrite_x=False):
    """
    Return multidimensional Discrete Cosine Transform along the specified axes.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DCT (see Notes). Default type is 2.
    shape : int or array_like of ints or None, optional
        The shape of the result. If both `shape` and `axes` (see below) are
        None, `shape` is ``x.shape``; if `shape` is None but `axes` is
        not None, then `shape` is ``numpy.take(x.shape, axes, axis=0)``.
        If ``shape[i] > x.shape[i]``, the ith dimension is padded with zeros.
        If ``shape[i] < x.shape[i]``, the ith dimension is truncated to
        length ``shape[i]``.
        If any element of `shape` is -1, the size of the corresponding
        dimension of `x` is used.
    axes : int or array_like of ints or None, optional
        Axes along which the DCT is computed.
        The default is over all axes.
    norm : {None, 'ortho'}, optional
        Normalization mode (see Notes). Default is None.
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    idctn : Inverse multidimensional DCT

    Notes
    -----
    For full details of the DCT types and normalization modes, as well as
    references, see `dct`.

    Examples
    --------
    >>> from scipy.fftpack import dctn, idctn
    >>> rng = np.random.default_rng()
    >>> y = rng.standard_normal((16, 16))
    >>> np.allclose(y, idctn(dctn(y, norm='ortho'), norm='ortho'))
    True

    """
    shape = _good_shape(x, shape, axes)
    return _pocketfft.dctn(x, type, shape, axes, norm, overwrite_x)


def idctn(x, type=2, shape=None, axes=None, norm=None, overwrite_x=False):
    """
    Return multidimensional Discrete Cosine Transform along the specified axes.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DCT (see Notes). Default type is 2.
    shape : int or array_like of ints or None, optional
        The shape of the result.  If both `shape` and `axes` (see below) are
        None, `shape` is ``x.shape``; if `shape` is None but `axes` is
        not None, then `shape` is ``numpy.take(x.shape, axes, axis=0)``.
        If ``shape[i] > x.shape[i]``, the ith dimension is padded with zeros.
        If ``shape[i] < x.shape[i]``, the ith dimension is truncated to
        length ``shape[i]``.
        If any element of `shape` is -1, the size of the corresponding
        dimension of `x` is used.
    axes : int or array_like of ints or None, optional
        Axes along which the IDCT is computed.
        The default is over all axes.
    norm : {None, 'ortho'}, optional
        Normalization mode (see Notes). Default is None.
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    dctn : multidimensional DCT

    Notes
    -----
    For full details of the IDCT types and normalization modes, as well as
    references, see `idct`.

    Examples
    --------
    >>> from scipy.fftpack import dctn, idctn
    >>> rng = np.random.default_rng()
    >>> y = rng.standard_normal((16, 16))
    >>> np.allclose(y, idctn(dctn(y, norm='ortho'), norm='ortho'))
    True

    """
    type = _inverse_typemap[type]
    shape = _good_shape(x, shape, axes)
    return _pocketfft.dctn(x, type, shape, axes, norm, overwrite_x)


def dstn(x, type=2, shape=None, axes=None, norm=None, overwrite_x=False):
    """
    Return multidimensional Discrete Sine Transform along the specified axes.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DST (see Notes). Default type is 2.
    shape : int or array_like of ints or None, optional
        The shape of the result.  If both `shape` and `axes` (see below) are
        None, `shape` is ``x.shape``; if `shape` is None but `axes` is
        not None, then `shape` is ``numpy.take(x.shape, axes, axis=0)``.
        If ``shape[i] > x.shape[i]``, the ith dimension is padded with zeros.
        If ``shape[i] < x.shape[i]``, the ith dimension is truncated to
        length ``shape[i]``.
        If any element of `shape` is -1, the size of the corresponding
        dimension of `x` is used.
    axes : int or array_like of ints or None, optional
        Axes along which the DCT is computed.
        The default is over all axes.
    norm : {None, 'ortho'}, optional
        Normalization mode (see Notes). Default is None.
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    idstn : Inverse multidimensional DST

    Notes
    -----
    For full details of the DST types and normalization modes, as well as
    references, see `dst`.

    Examples
    --------
    >>> from scipy.fftpack import dstn, idstn
    >>> rng = np.random.default_rng()
    >>> y = rng.standard_normal((16, 16))
    >>> np.allclose(y, idstn(dstn(y, norm='ortho'), norm='ortho'))
    True

    """
    shape = _good_shape(x, shape, axes)
    return _pocketfft.dstn(x, type, shape, axes, norm, overwrite_x)


def idstn(x, type=2, shape=None, axes=None, norm=None, overwrite_x=False):
    """
    Return multidimensional Discrete Sine Transform along the specified axes.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DST (see Notes). Default type is 2.
    shape : int or array_like of ints or None, optional
        The shape of the result.  If both `shape` and `axes` (see below) are
        None, `shape` is ``x.shape``; if `shape` is None but `axes` is
        not None, then `shape` is ``numpy.take(x.shape, axes, axis=0)``.
        If ``shape[i] > x.shape[i]``, the ith dimension is padded with zeros.
        If ``shape[i] < x.shape[i]``, the ith dimension is truncated to
        length ``shape[i]``.
        If any element of `shape` is -1, the size of the corresponding
        dimension of `x` is used.
    axes : int or array_like of ints or None, optional
        Axes along which the IDST is computed.
        The default is over all axes.
    norm : {None, 'ortho'}, optional
        Normalization mode (see Notes). Default is None.
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    dstn : multidimensional DST

    Notes
    -----
    For full details of the IDST types and normalization modes, as well as
    references, see `idst`.

    Examples
    --------
    >>> from scipy.fftpack import dstn, idstn
    >>> rng = np.random.default_rng()
    >>> y = rng.standard_normal((16, 16))
    >>> np.allclose(y, idstn(dstn(y, norm='ortho'), norm='ortho'))
    True

    """
    type = _inverse_typemap[type]
    shape = _good_shape(x, shape, axes)
    return _pocketfft.dstn(x, type, shape, axes, norm, overwrite_x)


def dct(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False):
    r"""
    Return the Discrete Cosine Transform of arbitrary type sequence x.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DCT (see Notes). Default type is 2.
    n : int, optional
        Length of the transform.  If ``n < x.shape[axis]``, `x` is
        truncated.  If ``n > x.shape[axis]``, `x` is zero-padded. The
        default results in ``n = x.shape[axis]``.
    axis : int, optional
        Axis along which the dct is computed; the default is over the
        last axis (i.e., ``axis=-1``).
    norm : {None, 'ortho'}, optional
        Normalization mode (see Notes). Default is None.
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    idct : Inverse DCT

    Notes
    -----
    For a single dimension array ``x``, ``dct(x, norm='ortho')`` is equal to
    MATLAB ``dct(x)``.

    There are, theoretically, 8 types of the DCT, only the first 4 types are
    implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
    Inverse DCT generally refers to DCT type 3.

    **Type I**

    There are several definitions of the DCT-I; we use the following
    (for ``norm=None``)

    .. math::

       y_k = x_0 + (-1)^k x_{N-1} + 2 \sum_{n=1}^{N-2} x_n \cos\left(
       \frac{\pi k n}{N-1} \right)

    If ``norm='ortho'``, ``x[0]`` and ``x[N-1]`` are multiplied by a scaling
    factor of :math:`\sqrt{2}`, and ``y[k]`` is multiplied by a scaling factor
    ``f``

    .. math::

        f = \begin{cases}
         \frac{1}{2}\sqrt{\frac{1}{N-1}} & \text{if }k=0\text{ or }N-1, \\
         \frac{1}{2}\sqrt{\frac{2}{N-1}} & \text{otherwise} \end{cases}

    .. versionadded:: 1.2.0
       Orthonormalization in DCT-I.

    .. note::
       The DCT-I is only supported for input size > 1.

    **Type II**

    There are several definitions of the DCT-II; we use the following
    (for ``norm=None``)

    .. math::

       y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi k(2n+1)}{2N} \right)

    If ``norm='ortho'``, ``y[k]`` is multiplied by a scaling factor ``f``

    .. math::
       f = \begin{cases}
       \sqrt{\frac{1}{4N}} & \text{if }k=0, \\
       \sqrt{\frac{1}{2N}} & \text{otherwise} \end{cases}

    which makes the corresponding matrix of coefficients orthonormal
    (``O @ O.T = np.eye(N)``).

    **Type III**

    There are several definitions, we use the following (for ``norm=None``)

    .. math::

       y_k = x_0 + 2 \sum_{n=1}^{N-1} x_n \cos\left(\frac{\pi(2k+1)n}{2N}\right)

    or, for ``norm='ortho'``

    .. math::

       y_k = \frac{x_0}{\sqrt{N}} + \sqrt{\frac{2}{N}} \sum_{n=1}^{N-1} x_n
       \cos\left(\frac{\pi(2k+1)n}{2N}\right)

    The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
    to a factor `2N`. The orthonormalized DCT-III is exactly the inverse of
    the orthonormalized DCT-II.

    **Type IV**

    There are several definitions of the DCT-IV; we use the following
    (for ``norm=None``)

    .. math::

       y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi(2k+1)(2n+1)}{4N} \right)

    If ``norm='ortho'``, ``y[k]`` is multiplied by a scaling factor ``f``

    .. math::

        f = \frac{1}{\sqrt{2N}}

    .. versionadded:: 1.2.0
       Support for DCT-IV.

    References
    ----------
    .. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
           Makhoul, `IEEE Transactions on acoustics, speech and signal
           processing` vol. 28(1), pp. 27-34,
           :doi:`10.1109/TASSP.1980.1163351` (1980).
    .. [2] Wikipedia, "Discrete cosine transform",
           https://en.wikipedia.org/wiki/Discrete_cosine_transform

    Examples
    --------
    The Type 1 DCT is equivalent to the FFT (though faster) for real,
    even-symmetrical inputs. The output is also real and even-symmetrical.
    Half of the FFT input is used to generate half of the FFT output:

    >>> from scipy.fftpack import fft, dct
    >>> fft(np.array([4., 3., 5., 10., 5., 3.])).real
    array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
    >>> dct(np.array([4., 3., 5., 10.]), 1)
    array([ 30.,  -8.,   6.,  -2.])

    """
    return _pocketfft.dct(x, type, n, axis, norm, overwrite_x)


def idct(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False):
    """
    Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DCT (see Notes). Default type is 2.
    n : int, optional
        Length of the transform.  If ``n < x.shape[axis]``, `x` is
        truncated.  If ``n > x.shape[axis]``, `x` is zero-padded. The
        default results in ``n = x.shape[axis]``.
    axis : int, optional
        Axis along which the idct is computed; the default is over the
        last axis (i.e., ``axis=-1``).
    norm : {None, 'ortho'}, optional
        Normalization mode (see Notes). Default is None.
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.

    Returns
    -------
    idct : ndarray of real
        The transformed input array.

    See Also
    --------
    dct : Forward DCT

    Notes
    -----
    For a single dimension array `x`, ``idct(x, norm='ortho')`` is equal to
    MATLAB ``idct(x)``.

    'The' IDCT is the IDCT of type 2, which is the same as DCT of type 3.

    IDCT of type 1 is the DCT of type 1, IDCT of type 2 is the DCT of type
    3, and IDCT of type 3 is the DCT of type 2. IDCT of type 4 is the DCT
    of type 4. For the definition of these types, see `dct`.

    Examples
    --------
    The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
    inputs. The output is also real and even-symmetrical. Half of the IFFT
    input is used to generate half of the IFFT output:

    >>> from scipy.fftpack import ifft, idct
    >>> ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
    array([  4.,   3.,   5.,  10.,   5.,   3.])
    >>> idct(np.array([ 30.,  -8.,   6.,  -2.]), 1) / 6
    array([  4.,   3.,   5.,  10.])

    """
    type = _inverse_typemap[type]
    return _pocketfft.dct(x, type, n, axis, norm, overwrite_x)


def dst(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False):
    r"""
    Return the Discrete Sine Transform of arbitrary type sequence x.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DST (see Notes). Default type is 2.
    n : int, optional
        Length of the transform.  If ``n < x.shape[axis]``, `x` is
        truncated.  If ``n > x.shape[axis]``, `x` is zero-padded. The
        default results in ``n = x.shape[axis]``.
    axis : int, optional
        Axis along which the dst is computed; the default is over the
        last axis (i.e., ``axis=-1``).
    norm : {None, 'ortho'}, optional
        Normalization mode (see Notes). Default is None.
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.

    Returns
    -------
    dst : ndarray of reals
        The transformed input array.

    See Also
    --------
    idst : Inverse DST

    Notes
    -----
    For a single dimension array ``x``.

    There are, theoretically, 8 types of the DST for different combinations of
    even/odd boundary conditions and boundary off sets [1]_, only the first
    4 types are implemented in scipy.

    **Type I**

    There are several definitions of the DST-I; we use the following
    for ``norm=None``. DST-I assumes the input is odd around `n=-1` and `n=N`.

    .. math::

        y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(n+1)}{N+1}\right)

    Note that the DST-I is only supported for input size > 1.
    The (unnormalized) DST-I is its own inverse, up to a factor `2(N+1)`.
    The orthonormalized DST-I is exactly its own inverse.

    **Type II**

    There are several definitions of the DST-II; we use the following for
    ``norm=None``. DST-II assumes the input is odd around `n=-1/2` and
    `n=N-1/2`; the output is odd around :math:`k=-1` and even around `k=N-1`

    .. math::

        y_k = 2 \sum_{n=0}^{N-1} x_n \sin\left(\frac{\pi(k+1)(2n+1)}{2N}\right)

    if ``norm='ortho'``, ``y[k]`` is multiplied by a scaling factor ``f``

    .. math::

        f = \begin{cases}
        \sqrt{\frac{1}{4N}} & \text{if }k = 0, \\
        \sqrt{\frac{1}{2N611¨ıBaMQ‰J<ùiàHlÌÊÎ‹Á&Yp[(~BiŠb}¿\Péa8r¸Î$¼ª&JVW{$éÙk©5YÄ¥Rû<+ïEVÍeCÈ	îÄ¬Ì¥î·ØL¨qRµ‹Ò	§°W4JÛYb&u w’Ô¹NŒ÷ùõ¡iüO`úèËBê@n2¦¿>k%.ë@ï,G0OÒE	IùjrWb#ı;Wl°/(e*v60UñÍæp¹áÔzE.K§¥löúdâ!Håmä<’×éXì\	fnxı/“x“¬"i!ÇÕ¡?­”>N ¡¨bştª«xyeû5
j±™m(¥_ò.¯?Ùb¥¶@şqä­|c¬? ?wkìs†^šÍn:ÄIGäDÎ$DQsÈªµ…n£6vMĞAp ãwØ7kƒ¹'˜ÈümX9q¾9h©ãº:Õ"gÉ¼Aâ`PPìHPáVkCAËt5ÏÏù®p$FmÄ3étBïüKe¾WÏe^èCHh&Şhï^„øíjeDCè¨F|”àƒ^|MuT80a†ÆIrñ’psRÎ*r:zU»jUn}aOÛfQnoèoî¯YJ7Uƒf©lYWhiQGSåt÷êU^g©iŞ¦åp³hu~}¥QˆĞA[Øm1\¬êõoXÑzµ¢ÁØÀˆËÌ$…æºg'ç{ádŞ" ÷iĞ.ş¦OŠb‰èNŒ¾$!+vı¡D³Y´ÿPšg!°ˆòöVyL
a‘|™iMVÍSëtj²æ jılBhjjEä§“madV~[€ş—ø/Àˆ^{ÈĞ% ú«$§ù´,fïå¸\+°şÂzıèCöš/İ©e|D)S¡3	‚ô^¥chCİyVõ+ ×J#N¶×éá{qIÅc®@~÷‘küV'Ç.Y–‰ÄÊÌ`ã„×«`ƒ(Å/AØz{V`Ù†?ßåğ9Ékç`¢q€°½l:“šRÀa" «úã{ºb!JèHÃfÏ{ı2…Ô9l‰í¥Ûu'm}NIæF&Î¬^Yâ;âkfY(K
3¹»o} 33µOÎœÍqˆP U‚SÑ0éå\?|ÍËD„D¥Ã/Ë}³ùA eş˜çm
BàTE{ŸBsàË"ttcòQ3Í.Ì„c*óêH€éèBbüˆbÎi ;¸LıÍ^§
Lc}“»` #tï½© °cSº£BïPWıªk_£½}—zãfĞ,zWøx¶‹á0ãõ?.{%XD{ïmöçäw°»¬ z’^àçÜ€IR²¾ğVÎÆ¢í® v&'€œáÒÄAMi<ã`Kô0—ºzEG,-lˆméebã‰fµ+.ê‡í,ùoñG"×_Ì
:}èUÔ$jï’›¬ÂlœZŞn×^ú^[¤'KM$Q¾…&€ç¡VBñ7;fZe¬¡ Ïs8áI…l”%Í/f<Š®<my˜,KI~WBWIuç9«qÜô4cáûİ´PM"H¸ Fr4è©VuÂuÌyf^¾eã7´|8´Y²X>¼)¢o2ŞâíìÄ =|áû5˜N»Ğh=ü×MwÃ]ó<Î²8iGšnñu<ğŸ¸}* ¾LrŸ'ˆãä|¯~ïš¦D¸½4µàª8ó‹g•V%.ä´k^auB÷Ã–Û]µv6Y£Üêd(0
0)`Äb¼Š²&ù¢aÖÏ?ÏÒ%¸»—ïéş‹İ3<áNíæÅÚ#ì²3
Lg%^ÁCÜğÄFÕ0ß!IJJâr¦ñÿÈ3Ó|_ùF3C­\N_ªê>:§¡F3¨YtÍeÉMc}ô-¢ T¥‰í.?ÅŠ¡îúH$ŠAĞøè|¡0s}t?Åš	(ôğ’¤ 4<6!ò‰uxã½şQYÚy<.IÀ¢pŒÍM™ÚûZ<¹Ë´‹³ıS`zftJ¹E¸>ºº,ì` ğÁ$MdXÁ#nïmàåd"ÊÚAŒuiblVpÎ|@P‡ğƒE`>ºVu¨ªSq¥T…£TÕ˜Hf3“lZÌÚ,ªfÏåYÃöaôd$hù®«U‚€OiFN¨p Ê-¼QËüâqå¬g®S{rËHKöQiîa1^rqâa.KÁùzÍÂÀƒmÜOÇ¦¢Â`Ÿ Œ7fyp~dÔV{Ò¼ ÂÏE'l@BÕkk-ƒÎ'Ok(e…”`Ä$Ø„•jhûc »yH‚J–$ô$ Ü7– à(fMNĞuOõg÷ çÙÌ|Ó":ı „åê#(‡p¥óC+EGğZÇü™*¡Å(,26’0I÷à&¸:¬uD¤Ìeu÷¬%ø0Xi@FªiWa&'lç÷Yev}cá h†jg¨”$C5œéi+À)gññïL5(ß¥|†à¼SŒ*Ê ©X"lÿ¥×ÂdiéÒ80n¦0/GqGÙ 9¯Èà'i*IÿpzÀ÷Ù-}=ÒpÇ*¢­¡Á°‹s8eh7ÄŞf•.8ÆM{ğjIß©,´_«¦ã‹Ë¢	×ÎVR@ÿC}Q(¢´Ï*kkïvçb6mJÎzéæÑ¨]§ã7¢.múüÛßˆ‡Fî¬¦š°KJ·-r12aéaF ÇV%*èç¤CÉNmXDÜfàƒí°$
ZÊ=,©FÊÕP²!M+ëmâHwO<µ4£ï@¨å2Pf ErŞçsö:Ï©Ì¡¤|`~ˆFc4CtMšf±X.BäUj¨ˆK´ªJÌw³üÄd9W#*0§,¾é½î*ìgu(T :¬¸W2½çq¦eÒ8ÓÀÜüV&i%ì
Æ|Hå(ğGfs¥oËgdtXq`Eeµ°×x¦r‘¼„PGÇqMCMV¤
 ¤ò°Ÿgo­ifê$€rP„FòÔØd	2ºDc:s2œ Èç;/©’–PX!}¢laŠØ²«]~¦o†—¢\]ˆÒosk*i8	L“áˆÖYNÍzPu)€Ğ¯nd¨µÄmùr÷oq™÷íôiÜl wÕZG>Ê†Ğ´‚ˆA{­¶Ww WÙyg.Í;É¦©´Œ *D÷t6+@¸›\GKãøì{ĞqM¢yXGw¨lµüä* 9FWÀÆÏ ~xfŠ°#!H}ÎBìBUÿ‡å[ô€ !úL•ÁNô©Äi´»r"ãŠ²|ï|í´2HA Ô^ó!¦­½ø`y`!gn®û¨&xêƒÛZ0~  èq§Ï­ìu%åÎhìÃúàvÈ#4(´€,&r]OÉë@#™qıé²{Î#4üASZëª­"ĞÏÊê¨Y)İñ$ı7?„Obÿ_V½Q}ğ{ UEm½"u¸<å"f"êXl1²B¡UqÛá=a6BÕ8®bÒ¹s Q¦ŒÒ2/hå¨År2áO fòó&Nï×Ô³êjæğ{’u