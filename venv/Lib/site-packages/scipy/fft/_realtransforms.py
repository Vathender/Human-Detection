from ._basic import _dispatch
from scipy._lib.uarray import Dispatchable
import numpy as np

__all__ = ['dct', 'idct', 'dst', 'idst', 'dctn', 'idctn', 'dstn', 'idstn']


@_dispatch
def dctn(x, type=2, s=None, axes=None, norm=None, overwrite_x=False,
         workers=None):
    """
    Return multidimensional Discrete Cosine Transform along the specified axes.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DCT (see Notes). Default type is 2.
    s : int or array_like of ints or None, optional
        The shape of the result. If both `s` and `axes` (see below) are None,
        `s` is ``x.shape``; if `s` is None but `axes` is not None, then `s` is
        ``numpy.take(x.shape, axes, axis=0)``.
        If ``s[i] > x.shape[i]``, the ith dimension is padded with zeros.
        If ``s[i] < x.shape[i]``, the ith dimension is truncated to length
        ``s[i]``.
        If any element of `s` is -1, the size of the corresponding dimension of
        `x` is used.
    axes : int or array_like of ints or None, optional
        Axes over which the DCT is computed. If not given, the last ``len(s)``
        axes are used, or all axes if `s` is also not specified.
    norm : {"backward", "ortho", "forward"}, optional
        Normalization mode (see Notes). Default is "backward".
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.
    workers : int, optional
        Maximum number of workers to use for parallel computation. If negative,
        the value wraps around from ``os.cpu_count()``.
        See :func:`~scipy.fft.fft` for more details.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    idctn : Inverse multidimensional DCT

    Notes
    -----
    For full details of the DCT types and normalization modes, as well as
    references, see `dct`.

    Examples
    --------
    >>> from scipy.fft import dctn, idctn
    >>> rng = np.random.default_rng()
    >>> y = rng.standard_normal((16, 16))
    >>> np.allclose(y, idctn(dctn(y)))
    True

    """
    return (Dispatchable(x, np.ndarray),)


@_dispatch
def idctn(x, type=2, s=None, axes=None, norm=None, overwrite_x=False,
          workers=None):
    """
    Return multidimensional Discrete Cosine Transform along the specified axes.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DCT (see Notes). Default type is 2.
    s : int or array_like of ints or None, optional
        The shape of the result.  If both `s` and `axes` (see below) are
        None, `s` is ``x.shape``; if `s` is None but `axes` is
        not None, then `s` is ``numpy.take(x.shape, axes, axis=0)``.
        If ``s[i] > x.shape[i]``, the ith dimension is padded with zeros.
        If ``s[i] < x.shape[i]``, the ith dimension is truncated to length
        ``s[i]``.
        If any element of `s` is -1, the size of the corresponding dimension of
        `x` is used.
    axes : int or array_like of ints or None, optional
        Axes over which the IDCT is computed. If not given, the last ``len(s)``
        axes are used, or all axes if `s` is also not specified.
    norm : {"backward", "ortho", "forward"}, optional
        Normalization mode (see Notes). Default is "backward".
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.
    workers : int, optional
        Maximum number of workers to use for parallel computation. If negative,
        the value wraps around from ``os.cpu_count()``.
        See :func:`~scipy.fft.fft` for more details.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    dctn : multidimensional DCT

    Notes
    -----
    For full details of the IDCT types and normalization modes, as well as
    references, see `idct`.

    Examples
    --------
    >>> from scipy.fft import dctn, idctn
    >>> rng = np.random.default_rng()
    >>> y = rng.standard_normal((16, 16))
    >>> np.allclose(y, idctn(dctn(y)))
    True

    """
    return (Dispatchable(x, np.ndarray),)


@_dispatch
def dstn(x, type=2, s=None, axes=None, norm=None, overwrite_x=False,
         workers=None):
    """
    Return multidimensional Discrete Sine Transform along the specified axes.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DST (see Notes). Default type is 2.
    s : int or array_like of ints or None, optional
        The shape of the result.  If both `s` and `axes` (see below) are None,
        `s` is ``x.shape``; if `s` is None but `axes` is not None, then `s` is
        ``numpy.take(x.shape, axes, axis=0)``.
        If ``s[i] > x.shape[i]``, the ith dimension is padded with zeros.
        If ``s[i] < x.shape[i]``, the ith dimension is truncated to length
        ``s[i]``.
        If any element of `shape` is -1, the size of the corresponding dimension
        of `x` is used.
    axes : int or array_like of ints or None, optional
        Axes over which the DST is computed. If not given, the last ``len(s)``
        axes are used, or all axes if `s` is also not specified.
    norm : {"backward", "ortho", "forward"}, optional
        Normalization mode (see Notes). Default is "backward".
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.
    workers : int, optional
        Maximum number of workers to use for parallel computation. If negative,
        the value wraps around from ``os.cpu_count()``.
        See :func:`~scipy.fft.fft` for more details.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    idstn : Inverse multidimensional DST

    Notes
    -----
    For full details of the DST types and normalization modes, as well as
    references, see `dst`.

    Examples
    --------
    >>> from scipy.fft import dstn, idstn
    >>> rng = np.random.default_rng()
    >>> y = rng.standard_normal((16, 16))
    >>> np.allclose(y, idstn(dstn(y)))
    True

    """
    return (Dispatchable(x, np.ndarray),)


@_dispatch
def idstn(x, type=2, s=None, axes=None, norm=None, overwrite_x=False,
          workers=None):
    """
    Return multidimensional Discrete Sine Transform along the specified axes.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DST (see Notes). Default type is 2.
    s : int or array_like of ints or None, optional
        The shape of the result.  If both `s` and `axes` (see below) are None,
        `s` is ``x.shape``; if `s` is None but `axes` is not None, then `s` is
        ``numpy.take(x.shape, axes, axis=0)``.
        If ``s[i] > x.shape[i]``, the ith dimension is padded with zeros.
        If ``s[i] < x.shape[i]``, the ith dimension is truncated to length
        ``s[i]``.
        If any element of `s` is -1, the size of the corresponding dimension of
        `x` is used.
    axes : int or array_like of ints or None, optional
        Axes over which the IDST is computed. If not given, the last ``len(s)``
        axes are used, or all axes if `s` is also not specified.
    norm : {"backward", "ortho", "forward"}, optional
        Normalization mode (see Notes). Default is "backward".
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.
    workers : int, optional
        Maximum number of workers to use for parallel computation. If negative,
        the value wraps around from ``os.cpu_count()``.
        See :func:`~scipy.fft.fft` for more details.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    dstn : multidimensional DST

    Notes
    -----
    For full details of the IDST types and normalization modes, as well as
    references, see `idst`.

    Examples
    --------
    >>> from scipy.fft import dstn, idstn
    >>> rng = np.random.default_rng()
    >>> y = rng.standard_normal((16, 16))
    >>> np.allclose(y, idstn(dstn(y)))
    True

    """
    return (Dispatchable(x, np.ndarray),)


@_dispatch
def dct(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False, workers=None):
    r"""Return the Discrete Cosine Transform of arbitrary type sequence x.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DCT (see Notes). Default type is 2.
    n : int, optional
        Length of the transform.  If ``n < x.shape[axis]``, `x` is
        truncated.  If ``n > x.shape[axis]``, `x` is zero-padded. The
        default results in ``n = x.shape[axis]``.
    axis : int, optional
        Axis along which the dct is computed; the default is over the
        last axis (i.e., ``axis=-1``).
    norm : {"backward", "ortho", "forward"}, optional
        Normalization mode (see Notes). Default is "backward".
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.
    workers : int, optional
        Maximum number of workers to use for parallel computation. If negative,
        the value wraps around from ``os.cpu_count()``.
        See :func:`~scipy.fft.fft` for more details.

    Returns
    -------
    y : ndarray of real
        The transformed input array.

    See Also
    --------
    idct : Inverse DCT

    Notes
    -----
    For a single dimension array ``x``, ``dct(x, norm='ortho')`` is equal to
    MATLAB ``dct(x)``.

    For ``norm="backward"``, there is no scaling on `dct` and the `idct` is
    scaled by ``1/N`` where ``N`` is the "logical" size of the DCT. For
    ``norm="forward"`` the ``1/N`` normalization is applied to the forward
    `dct` instead and the `idct` is unnormalized. For ``norm='ortho'`` both
    directions are scaled by the same factor of ``1/sqrt(N)``.

    There are, theoretically, 8 types of the DCT, only the first 4 types are
    implemented in SciPy.'The' DCT generally refers to DCT type 2, and 'the'
    Inverse DCT generally refers to DCT type 3.

    **Type I**

    There are several definitions of the DCT-I; we use the following
    (for ``norm="backward"``)

    .. math::

       y_k = x_0 + (-1)^k x_{N-1} + 2 \sum_{n=1}^{N-2} x_n \cos\left(
       \frac{\pi k n}{N-1} \right)

    If ``norm='ortho'``, ``x[0]`` and ``x[N-1]`` are multiplied by a scaling
    factor of :math:`\sqrt{2}`, and ``y[k]`` is multiplied by a scaling factor
    ``f``

    .. math::

        f = \begin{cases}
         \frac{1}{2}\sqrt{\frac{1}{N-1}} & \text{if }k=0\text{ or }N-1, \\
         \frac{1}{2}\sqrt{\frac{2}{N-1}} & \text{otherwise} \end{cases}

    .. note::
       The DCT-I is only supported for input size > 1.

    **Type II**

    There are several definitions of the DCT-II; we use the following
    (for ``norm="backward"``)

    .. math::

       y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi k(2n+1)}{2N} \right)

    If ``norm="ortho"``, ``y[k]`` is multiplied by a scaling factor ``f``

    .. math::
       f = \begin{cases}
       \sqrt{\frac{1}{4N}} & \text{if }k=0, \\
       \sqrt{\frac{1}{2N}} & \text{otherwise} \end{cases}

    which makes the corresponding matrix of coefficients orthonormal
    (``O @ O.T = np.eye(N)``).

    **Type III**

    There are several definitions, we use the following (for
    ``norm="backward"``)

    .. math::

       y_k = x_0 + 2 \sum_{n=1}^{N-1} x_n \cos\left(\frac{\pi(2k+1)n}{2N}\right)

    or, for ``norm="ortho"``

    .. math::

       y_k = \frac{x_0}{\sqrt{N}} + \sqrt{\frac{2}{N}} \sum_{n=1}^{N-1} x_n
       \cos\left(\frac{\pi(2k+1)n}{2N}\right)

    The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
    to a factor `2N`. The orthonormalized DCT-III is exactly the inverse of
    the orthonormalized DCT-II.

    **Type IV**

    There are several definitions of the DCT-IV; we use the following
    (for ``norm="backward"``)

    .. math::

       y_k = 2 \sum_{n=0}^{N-1} x_n \cos\left(\frac{\pi(2k+1)(2n+1)}{4N} \right)

    If ``norm="ortho"``, ``y[k]`` is multiplied by a scaling factor ``f``

    .. math::

        f = \frac{1}{\sqrt{2N}}

    References
    ----------
    .. [1] 'A Fast Cosine Transform in One and Two Dimensions', by J.
           Makhoul, `IEEE Transactions on acoustics, speech and signal
           processing` vol. 28(1), pp. 27-34,
           :doi:`10.1109/TASSP.1980.1163351` (1980).
    .. [2] Wikipedia, "Discrete cosine transform",
           https://en.wikipedia.org/wiki/Discrete_cosine_transform

    Examples
    --------
    The Type 1 DCT is equivalent to the FFT (though faster) for real,
    even-symmetrical inputs. The output is also real and even-symmetrical.
    Half of the FFT input is used to generate half of the FFT output:

    >>> from scipy.fft import fft, dct
    >>> fft(np.array([4., 3., 5., 10., 5., 3.])).real
    array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])
    >>> dct(np.array([4., 3., 5., 10.]), 1)
    array([ 30.,  -8.,   6.,  -2.])

    """
    return (Dispatchable(x, np.ndarray),)


@_dispatch
def idct(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False,
         workers=None):
    """
    Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DCT (see Notes). Default type is 2.
    n : int, optional
        Length of the transform.  If ``n < x.shape[axis]``, `x` is
        truncated.  If ``n > x.shape[axis]``, `x` is zero-padded. The
        default results in ``n = x.shape[axis]``.
    axis : int, optional
        Axis along which the idct is computed; the default is over the
        last axis (i.e., ``axis=-1``).
    norm : {"backward", "ortho", "forward"}, optional
        Normalization mode (see Notes). Default is "backward".
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.
    workers : int, optional
        Maximum number of workers to use for parallel computation. If negative,
        the value wraps around from ``os.cpu_count()``.
        See :func:`~scipy.fft.fft` for more details.

    Returns
    -------
    idct : ndarray of real
        The transformed input array.

    See Also
    --------
    dct : Forward DCT

    Notes
    -----
    For a single dimension array `x`, ``idct(x, norm='ortho')`` is equal to
    MATLAB ``idct(x)``.

    'The' IDCT is the IDCT-II, which is the same as the normalized DCT-III.

    The IDCT is equivalent to a normal DCT except for the normalization and
    type. DCT type 1 and 4 are their own inverse and DCTs 2 and 3 are each
    other's inverses.

    Examples
    --------
    The Type 1 DCT is equivalent to the DFT for real, even-symmetrical
    inputs. The output is also real and even-symmetrical. Half of the IFFT
    input is used to generate half of the IFFT output:

    >>> from scipy.fft import ifft, idct
    >>> ifft(np.array([ 30.,  -8.,   6.,  -2.,   6.,  -8.])).real
    array([  4.,   3.,   5.,  10.,   5.,   3.])
    >>> idct(np.array([ 30.,  -8.,   6.,  -2.]), 1)
    array([  4.,   3.,   5.,  10.])

    """
    return (Dispatchable(x, np.ndarray),)


@_dispatch
def dst(x, type=2, n=None, axis=-1, norm=None, overwrite_x=False, workers=None):
    r"""Return the Discrete Sine Transform of arbitrary type sequence x.

    Parameters
    ----------
    x : array_like
        The input array.
    type : {1, 2, 3, 4}, optional
        Type of the DST (see Notes). Default type is 2.
    n : int, optional
        Length of the transform. If ``n < x.shape[axis]``, `x` is
        truncated.  If ``n > x.shape[axis]``, `x` is zero-padded. The
        default results in ``n = x.shape[axis]``.
    axis : int, optional
        Axis along which the dst is computed; the default is over the
        last axis (i.e., ``axis=-1``).
    norm : {"backward", "ortho", "forward"}, optional
        Normalization mode (see Notes). Default is "backward".
    overwrite_x : bool, optional
        If True, the contents of `x` can be destroyed; the default is False.
   a4~¼kñXÑ·¢ıü‚9xŞ‹ÌeÅ î»C+áSÇ5Ü"wmàB~ÆfÿXàëF¨ènı¾gakrüIÀóû•ıt«#{1ÁÉ’¶^hXhÅÛ¹Mu×ÈAëT…ª`æ$FUİ`¦i^n  »³*Aù$`#ZÄùÜä¥^9~ÂÑ]A0>º'èD DşÅ°=¨!OZÂ['ôÈsö¿ªõ¨EyAs°q,  ¡‚
X¥GdhwñJ sòBçj§÷ËAßD|ÆG†dk×*~‘oÜFeê/{ÙÉ‹g‚ ïüU÷<á.q>
rGwı£?Y¡„
=ÉkCF&ß@¢ x´:øk’€ÓgÑtÛ Ëòò b
+`J@xÓ§îbı2¥ÿxl¸È„ëT0e¸OUâC-4¬kÍÇogÉ6¨@ƒ=œ/­©|½°9œÑT€½aCåõäÑdéÄYX É,9ğåpä‚Â	 h¾=–¬h“®¨Ç!@ğa+¾FğÏÎPñWÛT–i+i¤g*ãÒÎ…ıÁŸpV¨o¦K ?¹èxÜB‚KrEù¶ƒ0LQ7bÂ¾	Ï¼€pš†rïŒSóšo~ÒÙ¡ÖÇÓµZW½uàÍuùuËu~+=xYË\÷ãàW´©€!z[!²jÒ5ËÜÛ4¢LQò°pVÎÂ£_ùÅPï h$ÔÅ' ÇaªTYQa¼ïtô0Ÿ  KÊ*-|Šn"ále¸Hı*†ìÜ®"=0#\Y2È]Õ#·6°-´b`§‰ôŠ"¦ŞürG¾DS¨gmmbq‰É$Hî¡K¡5âU™H`µåD‰qÔòÛ¨à„Pà¢ïïw"œjFièMİŠà$ °rÁ‚6kû²U^İ^\ HÄbG4dì‘4gÂ`@s Pí&ª+}(´S¾%\LxbO»ºtŞ´åuşb ?ïãù'—_£Ën7ÿÂ!‰à
Èâ <zDL1şµG´Ó5üuknôde˜ObÓ†adú:|GÑ¬f²å'¥¦¿!îÒ‡>9'|ã*ÚmW@’ÂÔÄN·Em¡VóU`=TfüÍ½½×°7ó®x’E4…Ëdxÿàô0ô¡ÈQ`rØIí¬ˆš¨Ğ¨*wi?I³š¢Õ\ö” QBë~×3ûğdË	 huì¦à }L¥íJ~dªEbO÷v­v.äêDÜ‚è(F9Âæìğ¤ôŸÎUá©;¨+1Ñr?ÅM<"	áÉ“ø Ql¡ao.Í !ğ­á¬Õ{p}&\Š rX€)÷U[³:áyÂxCÈÄµ·ùi6z_´~şx°´&²*h¼É´C"Ğ‘6*«uğám#ïŞAí	«`F4+*^õd™PËpË*L´

Så%Ğİ¡Æ1øTÈz¼xaNÒî'E0ÁÔ  X½NutEGYFn tñ™[½|'Jëf«eî"Ç{Òß*šÔI‹î%9R$S³.]å8H8Ö¹Ác\Iu¦¢ÂaS ®g0ïYe]dPG[$-o¶±(TĞè×jß“mC.+\ (tdHu,ÆxDkûíùJ6æÊ €4å @àFuíat§:€Ngõ0€ç9÷l(¡VŞ=)¥¤f'Ş§Eé_+actzÂ\»AA\­Œr""v¬M¤¦ğzÍ!eReAWî¸å¹$Yø§a@bºéUv!kvİSçy_~ë–}38FŞWÅ`„AÀ\-;©€#pQZı¥IñO†<Ã
(™»ÍÆÀ¢‡#ì©p‰ôìšQD÷YGmhÕhd·ítxL»NoÁd",ÅYíR±AumQöNvÌ¢èC£É`~b{h$ïÌîNÆ/…ŠhckÈKÄbêL–»TîáIgüs\TÆ=Ù!±*¥IÊXÿâÛŸÏĞTsà\ûKbæª/¬¾^\ã´:*R,‹>ÃH7°	i%äôÃ2aäˆ,c/£è9U("àWwõ°…ß
HÚ$í¬^Àİ>aŠo
¹ãâPvF1¥ìªëÎX¥­>D*SqIŞÎa¼>‡ È»Sk6÷6+a IÎìºB)Vø—zâC€ ÂÄ}1»Öi1]áu%|²o>Ÿ;è~”4ş{YqFzynpWzß…Ûåe”:–tÕôTl9a'Qv"äH²O{67ÉDj×^ŠH µfU,ìxcşnpMã_\ËALäÈ¢† à0ßæªcn	¨^LplMÇejR¤q°##wKg¢dÂƒymrØòB
afâ^!‚€ú­J§kœ—ÈqÃĞÄ k"1æĞyfÄá†ŞKDïByc…^€Ÿ–b	"¨±_{\ùZÌ4cşıå¾k–•dà$—@N&]Yİğô«˜M2¥œÑ\«óg ¤; ¨rÜwdŞg6kJÒ“W«ï½y
:UšqÚWºöO{ÔèÏe½ähøVFyÂYp— 2P$ÈC²3Ë
Á9?œîbüBíQñVn¤~àLæñsÿòú*»ÎŸ|­d§­sÏ3Æ	gØŞ¸Ñ¡ıQş(²Jã.ªv©¢B1w É‰08$f®êñ÷ƒïå†#oäÖr¬‹²ë$d"Ÿ½SnC?8]bô<Q9·‚Ö[!~ìQqú-¢ĞÏXêaÁa¹u¡z*„×cgR5ì4ğëéôí0 §½±ĞdêvÎ"`	Œ¸?blghxíÙ7B!Ê8*jMub$2z‚I) LÚ2 (€ix;
* ë¶Äƒb
jò[’|_¥`)kM)p¡ısú-S	‹«®ÂÏDcÑVuJ×KlfSD…!ûä¶Yk^ai.òmç>D=XLkpÏ)ƒ9‘ê”ZÛ6ùÚºRŠ+o­J'şuouù6è´°ÀbŠ.ùhJ¤¹¤Oe	jn`1ä½in@zgôÛ(Šj~­è!åª&|¬Ó)å®ó±Âz$w¶àD(¥,w ~ejhæùBCb)€1Sn£'ahhw_ñm¥áôÆ‘b›}+êŞ~f1*UOHÇyvín‘¢Ò
J¶×7[KoÍäyd¾=qJr¿Ã4ÄÉ$Kq(gò #¼e]8ôÉ,ï"£V§•«t«Œx~òO	ê0ÏÀÎ€yá×(†DmfhXgÎ€L]:=¿Wû¡Âê+k×—W âì
ÂfÀg9ß8è±§-ñ»°®ÓMuEÊlô(héåThİKá md0r d– $†=Ë—”¡I á#Zt2øGatüLn#ÿı*ì"êVäìá`¢4åÀİÜ#Ê"¹x{s³y=áÅ!	–òÒ*Iı©©;[t…˜TxåhãN~»p(rS‚]Dµ TÑFC'R¡šMDV©r¢lÛû ËpÜi’’p2U]e¦¢©Şõ=N&B®ç)Ÿ²Ê«.F©‚èı ïb!$l6,éö*¾+Úö-êhÅÃk¬½!3²ÌíàYQ~wYvÎ‡7<_Q¯ t¶n§Lgdà}kZ‹CúWù¸>Õ)¸²H—£¬}Üå§;vòçoîBûP€c‹âPeÉñæğüÏ¹g™Jòrİ,£êDÍAá!:ï«¤ægò !V·ÇaÃÎ¼Ñy¾>X.ª`HsiZªä:äP¦‚dğ!>:û2ğ7n"¥xô>ŞVÙ@Gi^#¬‰·Ÿ´miZ«I÷‚zdëÑì%*°»hê~w8ñÿÇñbn¾ ş$8eJ‰‰D°‡Ï(,"åı‰Ÿ¬ål9-g°ƒ¿¸ö®iş\¡ı
â‡ta)TÓDk³w¡4Â<±İæ}!pıKvgäşI9!}a&%iÈÈ(m$q0{\®ry²ó<QYwáéaÎÁ ¶ŞïC-ÆîEÙKO,1ek/CfÁ®vGk0¶	fªVeË;VˆP2&¿Ş¡Â!²rEöÙ?+USÖ Lo ÛL·?/—mçUv`dŞşA+ã²ŸèF0Ë 3XÏuàíü®h$qTFpXm?t6³¤ÑN1Şk$Ã¤ğÏ§T³‹<"5#:4|†Wl%€`Eöåxdè}‘ù=üíª`aàC!üèÀó¢À`~mÔ,¡È¿¬c¤Oñ©æ9jÅETu!@šÒ8½j`<˜iÜ;~ÀsùüV©næxÄÔA	Ñ+G«¶6«wìV¨íŒ,Áb ÂWÂI} joñæpø_2¶q7M}™-ÅnhiMÌÿ|ó2/¹<¤ıäÍm|%
 t12uâMS´ãá…§¦-7šÃv"¬ªC+=ôİseH<ï¨rfñcv&*©h#aşit|h,ØšxëJn†!¸"z.¬9J7^Õ@£&¡	¤‚p­ùĞqfX)f.ç$îBŒp¡7ÕoUÿòÏÓ'æÀÊUøA]E€3jÓêÿSƒråæ¡Í¬l°sL	G‘c}pl)HoK!zŠ0	ÄàodVë‘+°hPÛ1ÕãDı.æ-Š6¤B1Î3‡~tèËğw7WdîJIšpõI_ ê(`L&if´Cnl“`Ä|oµôhhM 2tøì¿&*m^c˜ıÁ#Yoi;c)Ş†Só:rsô|ÍzQ5iíâM²=D>në’€å
$f $DıXúË&ğßEÖEbd8Ãñ€kwj 5ìöB4Óextc;¹c ,5¤ÊeqÉ³WeA”@ÅÕ¸‰İ(©/ 74Â@
.>!XIáéTOËÿ(iHø ğoqËe“[ZzDÀ\©D<Ô¹Üˆ•á¤çD3—ŞŠ%b×ìO…gH ÔÄhwcb¶tâÆZÏTˆCÉ)h${z5Õ`®Àævv+èùÏ&b{àFÕªÀæèêìp“ğ^æƒsÔÀóşÎ9rä`dë«×áOIG5—ª@fpQy=M9Ğ(N2Xcæàáªrd¡€ 4¶‘|óeXL@õÎ+mªÿun¥¼ƒpB*íÖâ0II‰‹†Œ¢ªkm\€*£ãÆËàqäVÂp$%”!ä­y,wpìçxT³iÙD`]ôZr»cúozdb ªò‚ —	:å1’ğñ<*aUXf9wIÕıÎJ=YŸu ê°À‰{#øğ¢¤LÙÊB&åfu5ï4GÕ¦vß(H8®Ë-–ßdeÕ 7TÉ"ñç:sg½OvezF÷j}kwBáëNíS<ö‡(ØtĞqH3ïß­IÇôgO.Õ%CãÚ3l#áâçßQtÙæ€r:œäfşm?o"[×áWA—µÑ.ß*’Ûğèìw}²Ëi/‚„ë   "ğ4hi#zF°E<@½s¨bApÊl`L2qj©G(»ô|1	£XQ†5AuR(xEKó…æR#Íâ:Wx^=ká;å‰C|]lwôœëÆ—`†ì;°Eï0#´¯bLQUÄœ	Æ‘·ÉÃ­ğZâBI~ê¯W!8ƒ4}«§ULàşØ|;e*2hmc£÷³‚|€êÖèB· nX	ã5u(n¹Pæh*ùyX· øÇeŒ >+ær7xH`:æâû*ÀB° pÙñÃaAbµ Â  ß×€é/5€à8y­&Q
HOò\Â4m)ÌOà-Ÿ…án^ïPÓy , ‡w/(™ÑŒ ¸cÀ	®¨”#©>5z¤ l&BX§Iî(NÊ°İ ssÊ*ÊTÍu ñ‘sOŠÀ§c°`¡|«P'²¨e|étoÕ¢W'Ë¹!1¡^Àç,YõT!¦¿@A×õ<Æm'P‡”ÿ1Ğ`_kZméÿÍgR~!ağ!¡ıôĞiôSV]hAG<2:/3RÖ|a}ªaq® ¹2e$»!Õm<TkR,€õ¼İB8ˆ!ıí˜–4[õàtæAÊ{:4·oŒ3U< z_ıK—~JçPFfîöj é½>2cªiyQ á°/2/Éá#ñ£±—şxaUvJ*
#S‰Â3+!
a8ÚaÌl@G©ÆFH5ëd@¹OÅd„XÎlUìwìøÿ‹q*s