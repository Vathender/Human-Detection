import numpy
from numpy.testing import (assert_, assert_equal, assert_array_equal,
                           assert_array_almost_equal)
import pytest
from pytest import raises as assert_raises

from scipy import ndimage

from . import types


class TestNdimageMorphology:

    @pytest.mark.parametrize('dtype', types)
    def test_distance_transform_bf01(self, dtype):
        # brute force (bf) distance transform
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out, ft = ndimage.distance_transform_bf(data, 'euclidean',
                                                return_indices=True)
        expected = [[0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 2, 4, 2, 1, 0, 0],
                    [0, 0, 1, 4, 8, 4, 1, 0, 0],
                    [0, 0, 1, 2, 4, 2, 1, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]]
        assert_array_almost_equal(out * out, expected)

        expected = [[[0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [1, 1, 1, 1, 1, 1, 1, 1, 1],
                     [2, 2, 2, 2, 1, 2, 2, 2, 2],
                     [3, 3, 3, 2, 1, 2, 3, 3, 3],
                     [4, 4, 4, 4, 6, 4, 4, 4, 4],
                     [5, 5, 6, 6, 7, 6, 6, 5, 5],
                     [6, 6, 6, 7, 7, 7, 6, 6, 6],
                     [7, 7, 7, 7, 7, 7, 7, 7, 7],
                     [8, 8, 8, 8, 8, 8, 8, 8, 8]],
                    [[0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 2, 4, 6, 6, 7, 8],
                     [0, 1, 1, 2, 4, 6, 7, 7, 8],
                     [0, 1, 1, 1, 6, 7, 7, 7, 8],
                     [0, 1, 2, 2, 4, 6, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8]]]
        assert_array_almost_equal(ft, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_distance_transform_bf02(self, dtype):
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out, ft = ndimage.distance_transform_bf(data, 'cityblock',
                                                return_indices=True)

        expected = [[0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 2, 2, 2, 1, 0, 0],
                    [0, 0, 1, 2, 3, 2, 1, 0, 0],
                    [0, 0, 1, 2, 2, 2, 1, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]]
        assert_array_almost_equal(out, expected)

        expected = [[[0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [1, 1, 1, 1, 1, 1, 1, 1, 1],
                     [2, 2, 2, 2, 1, 2, 2, 2, 2],
                     [3, 3, 3, 3, 1, 3, 3, 3, 3],
                     [4, 4, 4, 4, 7, 4, 4, 4, 4],
                     [5, 5, 6, 7, 7, 7, 6, 5, 5],
                     [6, 6, 6, 7, 7, 7, 6, 6, 6],
                     [7, 7, 7, 7, 7, 7, 7, 7, 7],
                     [8, 8, 8, 8, 8, 8, 8, 8, 8]],
                    [[0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 2, 4, 6, 6, 7, 8],
                     [0, 1, 1, 1, 4, 7, 7, 7, 8],
                     [0, 1, 1, 1, 4, 7, 7, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8]]]
        assert_array_almost_equal(expected, ft)

    @pytest.mark.parametrize('dtype', types)
    def test_distance_transform_bf03(self, dtype):
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out, ft = ndimage.distance_transform_bf(data, 'chessboard',
                                                return_indices=True)

        expected = [[0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 1, 2, 1, 1, 0, 0],
                    [0, 0, 1, 2, 2, 2, 1, 0, 0],
                    [0, 0, 1, 1, 2, 1, 1, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]]
        assert_array_almost_equal(out, expected)

        expected = [[[0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [1, 1, 1, 1, 1, 1, 1, 1, 1],
                     [2, 2, 2, 2, 1, 2, 2, 2, 2],
                     [3, 3, 4, 2, 2, 2, 4, 3, 3],
                     [4, 4, 5, 6, 6, 6, 5, 4, 4],
                     [5, 5, 6, 6, 7, 6, 6, 5, 5],
                     [6, 6, 6, 7, 7, 7, 6, 6, 6],
                     [7, 7, 7, 7, 7, 7, 7, 7, 7],
                     [8, 8, 8, 8, 8, 8, 8, 8, 8]],
                    [[0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 2, 5, 6, 6, 7, 8],
                     [0, 1, 1, 2, 6, 6, 7, 7, 8],
                     [0, 1, 1, 2, 6, 7, 7, 7, 8],
                     [0, 1, 2, 2, 6, 6, 7, 7, 8],
                     [0, 1, 2, 4, 5, 6, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8]]]
        assert_array_almost_equal(ft, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_distance_transform_bf04(self, dtype):
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        tdt, tft = ndimage.distance_transform_bf(data, return_indices=1)
        dts = []
        fts = []
        dt = numpy.zeros(data.shape, dtype=numpy.float64)
        ndimage.distance_transform_bf(data, distances=dt)
        dts.append(dt)
        ft = ndimage.distance_transform_bf(
            data, return_distances=False, return_indices=1)
        fts.append(ft)
        ft = numpy.indices(data.shape, dtype=numpy.int32)
        ndimage.distance_transform_bf(
            data, return_distances=False, return_indices=True, indices=ft)
        fts.append(ft)
        dt, ft = ndimage.distance_transform_bf(
            data, return_indices=1)
        dts.append(dt)
        fts.append(ft)
        dt = numpy.zeros(data.shape, dtype=numpy.float64)
        ft = ndimage.distance_transform_bf(
            data, distances=dt, return_indices=True)
        dts.append(dt)
        fts.append(ft)
        ft = numpy.indices(data.shape, dtype=numpy.int32)
        dt = ndimage.distance_transform_bf(
            data, return_indices=True, indices=ft)
        dts.append(dt)
        fts.append(ft)
        dt = numpy.zeros(data.shape, dtype=numpy.float64)
        ft = numpy.indices(data.shape, dtype=numpy.int32)
        ndimage.distance_transform_bf(
            data, distances=dt, return_indices=True, indices=ft)
        dts.append(dt)
        fts.append(ft)
        for dt in dts:
            assert_array_almost_equal(tdt, dt)
        for ft in fts:
            assert_array_almost_equal(tft, ft)

    @pytest.mark.parametrize('dtype', types)
    def test_distance_transform_bf05(self, dtype):
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out, ft = ndimage.distance_transform_bf(
            data, 'euclidean', return_indices=True, sampling=[2, 2])
        expected = [[0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 4, 4, 4, 0, 0, 0],
                    [0, 0, 4, 8, 16, 8, 4, 0, 0],
                    [0, 0, 4, 16, 32, 16, 4, 0, 0],
                    [0, 0, 4, 8, 16, 8, 4, 0, 0],
                    [0, 0, 0, 4, 4, 4, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]]
        assert_array_almost_equal(out * out, expected)

        expected = [[[0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [1, 1, 1, 1, 1, 1, 1, 1, 1],
                     [2, 2, 2, 2, 1, 2, 2, 2, 2],
                     [3, 3, 3, 2, 1, 2, 3, 3, 3],
                     [4, 4, 4, 4, 6, 4, 4, 4, 4],
                     [5, 5, 6, 6, 7, 6, 6, 5, 5],
                     [6, 6, 6, 7, 7, 7, 6, 6, 6],
                     [7, 7, 7, 7, 7, 7, 7, 7, 7],
                     [8, 8, 8, 8, 8, 8, 8, 8, 8]],
                    [[0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 2, 4, 6, 6, 7, 8],
                     [0, 1, 1, 2, 4, 6, 7, 7, 8],
                     [0, 1, 1, 1, 6, 7, 7, 7, 8],
                     [0, 1, 2, 2, 4, 6, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8]]]
        assert_array_almost_equal(ft, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_distance_transform_bf06(self, dtype):
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out, ft = ndimage.distance_transform_bf(
            data, 'euclidean', return_indices=True, sampling=[2, 1])
        expected = [[0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 4, 1, 0, 0, 0],
                    [0, 0, 1, 4, 8, 4, 1, 0, 0],
                    [0, 0, 1, 4, 9, 4, 1, 0, 0],
                    [0, 0, 1, 4, 8, 4, 1, 0, 0],
                    [0, 0, 0, 1, 4, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]]
        assert_array_almost_equal(out * out, expected)

        expected = [[[0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [1, 1, 1, 1, 1, 1, 1, 1, 1],
                     [2, 2, 2, 2, 2, 2, 2, 2, 2],
                     [3, 3, 3, 3, 2, 3, 3, 3, 3],
                     [4, 4, 4, 4, 4, 4, 4, 4, 4],
                     [5, 5, 5, 5, 6, 5, 5, 5, 5],
                     [6, 6, 6, 6, 7, 6, 6, 6, 6],
                     [7, 7, 7, 7, 7, 7, 7, 7, 7],
                     [8, 8, 8, 8, 8, 8, 8, 8, 8]],
                    [[0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 2, 6, 6, 6, 7, 8],
                     [0, 1, 1, 1, 6, 7, 7, 7, 8],
                     [0, 1, 1, 1, 7, 7, 7, 7, 8],
                     [0, 1, 1, 1, 6, 7, 7, 7, 8],
                     [0, 1, 2, 2, 4, 6, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8]]]
        assert_array_almost_equal(ft, expected)

    def test_distance_transform_bf07(self):
        # test input validation per discussion on PR #13302
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0]])
        with assert_raises(RuntimeError):
            ndimage.distance_transform_bf(
                data, return_distances=False, return_indices=False
            )

    @pytest.mark.parametrize('dtype', types)
    def test_distance_transform_cdt01(self, dtype):
        # chamfer type distance (cdt) transform
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out, ft = ndimage.distance_transform_cdt(
            data, 'cityblock', return_indices=True)
        bf = ndimage.distance_transform_bf(data, 'cityblock')
        assert_array_almost_equal(bf, out)

        expected = [[[0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [1, 1, 1, 1, 1, 1, 1, 1, 1],
                     [2, 2, 2, 1, 1, 1, 2, 2, 2],
                     [3, 3, 2, 1, 1, 1, 2, 3, 3],
                     [4, 4, 4, 4, 1, 4, 4, 4, 4],
                     [5, 5, 5, 5, 7, 7, 6, 5, 5],
                     [6, 6, 6, 6, 7, 7, 6, 6, 6],
                     [7, 7, 7, 7, 7, 7, 7, 7, 7],
                     [8, 8, 8, 8, 8, 8, 8, 8, 8]],
                    [[0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 1, 1, 4, 7, 7, 7, 8],
                     [0, 1, 1, 1, 4, 5, 6, 7, 8],
                     [0, 1, 2, 2, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8],
                     [0, 1, 2, 3, 4, 5, 6, 7, 8]]]
        assert_array_almost_equal(ft, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_distance_transform_cdt02(self, dtype):
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1*(o m©¤Ò*ü©%Ç Á*£b¡f`³FvÕ9\ªp/öà‹‰$ªê!Z‡¿$ ò¸‰9‹b( 3,Y¿vg<)Çäeìo)ª˜#Ã¬+ ¿oÂ ±„ˆ%óB	)ˆd"6*BC[º,(X'¦˜h05²ZFº:ŠQ»U€é ˆ	`  …
T#?!"	
`¡w¡»ª?aÈé?	¼ˆœ D>R!
t"•Åy, s°ºa•#²Aø ^â$@ÖšdaÁã¨°~k•$¡há2 ´!8/)1l °æ®2C¬t0H¼ôüD`q`Ø’`3Ù6`a@ Ó_ö„¥…m¬»
íêmM
Éy­ek±vè­êe{ö6ÁyQ/òQÈlfÂ%Ó¼¹+­MrİrGNíd3Õ(_!¨‚! :æb>c  1 <Ò€Š¡¦!Ãòhq"«c ±
è ° : Ê(È˜2DfäöôcjŞÈ>¥åÕv±ğ_y(.Ø´¸G"`d|“¦ôüI¨óãcŸ´Q±<~Ê …¸Ğws¨ËRÄ÷pp­òK48 †Š2XeQcÒŸËóÉé+¢5û ­®€bqQğUÄŞ«KqÌ!¥`b|—]XApU‘Ò)i|ìgn¤«#
°"T:”9 ER‘Eõî¸ ¯²ßº+¢0Å•¶¬w° +00=(!TÔã Ÿ­"øXğ,¥p´
 ƒâQª/Ü¦	S9#~zºb(ZÀúª ¢Œ47Í‘î ùt&…@ŠQ*,˜2ôfz¥ ¤7¨ªŠ |•….(°Nã`lÿ" 	§>òH°°Ò]gŒIpé¨C0ø"’¢¢1Tª¸à7‹ –²~Èƒ&Î'@û$‘¦0y¹-è‡E=¨R=`0! 62Ã#¦L8;Ê4èôüL!Œ:DäÄÉ»Ø	- §=4	qeŠa‰8' *;lA7<&¯ñ\#W—ŸÒ6¥Ô(–Ú¥€•Xw$‡İåá¨b»%(ğƒÏ -~mÈ€¼ŞSÓ,Å2uâÓM(78¿€#SF ``§6ú#”£šdî$ £!/½}´+$—\¬¨³¬Ü-> *dI ÷O‰µRQŸà²@¦‚ú!fŞlŒ2j@Æ‚›:¦&¾LQº¥¾p±…8é¤—¤ë$[+¼*F2 ‚,Œ 	$"şû#– ˜  Ù¶Çe4á1\!5>¹È. e§pÙ†V1"‘%³Ğà¦@°:)
!K¡PG—X0Pq:åª„ø=‚ù¤I2=E7|*7&/;Y ¼
}ĞRe r ¿Ğ/ŠÓ¢ Ø@Ó U«Ps ¬rÅ0˜#•8æ¬"'*€§,)»s)ÖÆ{=Ú ëÔdhu`§¼ŞÀ2Ia¶^&>n† ¥6ÃYrítt,In-1õ«#:x* (êV
.4<À©‰š0^@"*"&Íó(¬¡Frµ*`0€á2Ä3+¨D[–£;ïZb9…ƒ¸²d‚†™˜"ø‚à65L:hƒÀ±¹Á´7YM‹… â,­œB4İ¾°â‰j‘t	ğ"•Q#äª
—³¸¬9ùà¿À1l2<Ä5å50wæ-gIŒl¯Y)d¶Jd*hoS3‰6®'°+ãÎş8¸%—®‚¨Uë&4©)W$:ú–!-Í m¿7â$Utn`(¨ µ6D9!Ä` 7èyò™p„Àç·<
ázÃ†,àÈó©<V“Ó$}1šB!¨S2ez4©õTúhjöDÖÚ*æUòtö`jôÇõ _cÁ ci˜îz8ñŠX}%$ùÔ®eaS=ÿÃ…ÓAai²5c¼Œ( l{RLM(MòÌ;Y¦“ ‚Ägà}
™%ü~`;1\7CÜh	$¨²©°Cõ{’¨CƒmæS¨LÙÕ4"+’Kq ¤è,³šºœ€/¬ùmx{&#ûùéq[ Š4
[„ü40ˆ"QQÌ<Uì2Ï%d©&(ˆ¶/‰bj¾P¨h¨ÍDXÈ+Lx%À`*’1x¡pêap,lU$š.ŒaL™LÖ18¹>àã$¬†…¥g¡åhÄ Ÿ> q®äL&,%2Ø:Ôg`P¨
<>¶ˆ,¡k4½ï 8…o¸Zvœ4‚,qÆ`*‡¸=(Di(]Á¤‚! /„N9ÚÑúA(•¦é‚.)†*"Œæ/“$/ ]`	1ª§1$¨ÂŒºÆ æ 	PtàbàJYs0zZv6FÎÌñÜK|«(îŠğ:è7œ0ü|0³Ii% ¡Us,7„ã`¨j¹»'F …oŠšA Üy(p0T
âlŠ3Y;«ÍaBˆ*ù¨4O˜
&~Pb‡ã8ªş4kÆ¡*8æ›Œ 58¸3ç" t)jY¬I‘T¢Ë kb)P®bjL";Úí,ˆ~}èö,"ø²‹²š>¸¨ nø$™ÆãP¼ø0c:,;±,1%Á–f€|-Ğ:UÂ,„¡Œi8*@2â6™£ƒ\Çøt¢ˆp®5ˆ€œ „ ‹l¿N<°>,(D¢›H:2‚,Sêœ0õù/¿[7IÏ££!Î&^bÂĞv†|&¥àî†—•Y²¤ùíYfö¾MoÑ]mFˆbMtZxÂÓZ-dl^—jŠx‘uã'ãã|…ª¤SIi‰èÌïY_@p%ç#ŒÈ¡ 0
lˆE§dß«Ç‘In!&(›&ÜúÏj\Ş7ÙK¤Fõ A4êÆÈlëY{pîvA£-d#i@×2Çxäk—ÎùDğ5:‚úL®kÔõ1éÔo"¢tÊÈä•d‹úG^cJıK"èo	‚WutÅ©FtÕmùûf¼nn@tƒ<:áhtIGÇ¥w[‹-Ä*iü30†<Mp#i¡xGÒ?Bœ¤Š*cb¨Šd®ı¤Â®¯@ªÍjOÖ÷å"6±—R]QöPtá|[a
ÄÙk†™²èbñ*»¡y(ÆÌ&4GhkÇ£¼õ¶â¿ÎuW4%+¬EV•Vø‚!¤.â„>qt±ïGK³kŠ+g„íòç?}ÇÄ…6" À¡ VÔ÷»İÜ&øa¹d¶ ƒ º'¬Gë° Ô©—kÔÄ/tqìî†múdş¢Ì…™^´ÉAY•k>²EÉp8¼æàzÀ,	NbLíJ¶Õæ¢Pğ,NK7ÂÑÖÍì@mq(hÛñfİvÒR£+Åpç[ÅÈ`F­¦êøú°ìiÈB!µ˜²¼!ÿ0cÈ ™şq³ü~é1{ràcæ½!`%älS<æP™d•4Ïmd­Œ©>Ãh¥'Ú,æ}%¥­ğUD !§åŞC%}dp¹|JªM(Š›‰ ¡
ék6bÇŒáeéÑŠX;"}pÙüôşŞıTrãäkèÎ¾ïaLf|*±"k`$Â«aÀ1™ã¤ àe]vĞc`;„idsÈE²rfO¿N>.€¤Àí¶WvìF®û.ïaì¨‡`ã¦'b(¬d½¨€pÓ$|œNf^‰ UP›¬h²øãa$¢ÖO½ßı3o1vZá´\GëÙä7p¡Ø8€_5dı|*Il¸·+èç áë0J&£b	!÷¢º"Ée[f/pkØoLÅôıJ¦g5Ñ#Ç¢øŒºaƒ éAzñpvæ^`&)ıZj`KµÄhvl¢4D§8bçCU±Sís³íîûHJ"#æøjBe"LLµ	0\arÎÆDd‘Ğ j©¥tUu´J3T:(A®÷K 0"(¸àBì{†A“åK°¤U¢á«QáƒiõÅm ³E¸aí-ÅÄdôXtm;#ĞòµlcgØÚÙ	‚ ´ cK0íü*0>OqıOw„*fÙ{ôÀd#õ‚Ü‘âi1^ï-ÆWa5¦#¾§$D ¬…¦´"E9dâ
@mGİ†TxÌasnû]Eğ]MÆšdàr†Q>¯ãpyJQÖ8Wé@òeVe"=ÖZDöÀé©¶ÁË¦|•3î8½¸êÉú¢l)vaEtÊÖ¬¸&› “’IdàÜ 1K÷×dáå3Ï©D)Q ¹;úQZ4='UL!1F}4ß.(°S1‚L:Ë@$obâóà½¼xíPGÑ?}í{àgèù¶õÈ@nû À2av4ÇdÂ\É2D|oZŠŒâ}¥W!Z ¸€"‘ Æ6BQ9ñöcø\û[|qo¡Ş^nv¿×LuÖT‚Ç2ÿOıÖ`¬gšMÃm÷TÏ0¢iê &¬›2< :"†!µ$ (?‹`õEÉHB #Ä®`,$]várÅpÏæõy …9é4$hoªee‘Ó«æ	õQJıÏ4Ä"@Z.”+êxV7Ôh:ódå‚,h;’¤dîdg!Ew¾H*ìl _Ù
˜®–UfZ2JgÏ7Dw®æâz<H8A4‡¢	g†°*83^¾jPE$G¿Z4]<ÓÌ}¸PÉÓÏFLJ|Å\Õ¹<ä+p\2r~d»:Ôõ;
L¥>¤N»Õµê²=´zH&h€§h+S)ŠTDØdì1Õv!Jıiw:aåyğAJHFQp)Zš,-ª˜ ~XmVöÄßö~íùÑı]ŞÑ|n¡Xi"koõ9{ï{ x½NDbkJ%€{äNp¨™á"yÆpuæŒÓM¨ø¥.ÎÆasÇÄ bWÔ³Æh»5ãÚqGîÁn;­rxN_v0ñ›B“±¬ äBÜuT»#Ùùkİßdğ«&'È
:,È ¬
·°8=ÙÊ¨Ò`:¸Ø &r ˜dV1€)h$"d b&0*!ì’$hı ªÀ$Ù$[]­p…5):.$9 ˜0) 	©›¦eßŒêà!ât Pèd*…2 ¾© Ù`	Át¤Ú;Ak`ş+Ät)ä^pÈ³(…à%igZxls¶²Pv•… :M¤+Ê™š=?³j $*røìP!’Q˜†‡€û¬r61vˆA<£ñ¦kA,´h‚»¯–o 11¯9D .¥ƒ=R¨@&êl«*s)äì{·À“G´®p¹¦è`I."d 1y=hğ"İ<)ÂÆz1Öùb,¸…>`û¬,,FW<8"A²ÓÆ8M’Œ—ã&1&A±ËWôğJòWÊ*Z§H°¤\½¯ˆùñA6±^( *`OèQ"ˆn™0!â8° „¬L	€PÅ}@¤“6¸¶$ ³Ìï J¬°Äã)Xî«Ïh" j„‘’PŠëHË¾	¶(°XjRœ&¡7­¸ÇDü,2 ¿ ZµN¨¢ª8&’eShS ´È,]©ld )*wKˆ2;(q$¯×_3à$-9 ¬¼*Ú •î«¡h9Xq ûEbnŠÀF£ËgNº{óÃeÿÒòfT&lxØ*»'×éBïù˜2­Õrâêì'ïºªª™n-JgWMü€tà|E°%n;Wì,NØàÙ2e@ğB¨ ¥“sXĞÎ¡qQˆkœß“a“çˆû,‡Y<ÌA¨UT*N/å ´,CàĞA8^‘}V(¿âcì¦GyÕ5AïK…=µ^{rœl§¾Ïàu('Q*K@  ˜N0  úòpâ1É¬" ‰˜c¨¡ &3$4Ã"CõqIbZÔ0'*¬Âeù~\ŞZ%¼é|à`¢¢ ïI3,"kì6Öêÿ|ÜKÕ¬r#|K­!ƒ¯¦B–¸¨6Â‰’+ä4,²kC/à†Wâ=ú‚Àge“¥V¬#u/R 
€pikXg¡U1>i+rÛ¾ro{ì¯£p4DHEçWó¤Û? .âfÒn¥ñØ(„`ßc	ShiX²È7Zê@ğ7C’Æ$hC‡siJA¼Æ0µ6ºMÊævĞ
àíñ&Ê a¡p- 9çuŠ³ãtËcÇ€i+YdnaÙÖvÄÇ3pvûç¡¨LiÌaª®ÿà:g) ·Š5C	—ÅÖ÷×MS>«|úñ3¨wÉSd¡0°+Û´şÊ-¢4E {—’8^I²C#ª h-²1é(¨ 7±-:bfˆ¬Œ!à 1kp $¹Bª/a°'s;­c¢¤œ"åÒJÙ:}:ˆ 
'
À
 À8zÍÎmŒ‚ QIL )8 Ò-Ó&¸#¯µÖv½31©‚(’ÜÌ0”_€¨sü%Ï 
"€"¬Í¨Ãc òê$(ŠavQTP¦AÜtû2¹$†IWìñ -3î(´¼Ü­èã
0)ˆnIi Œ”û€~¤`0ncsè;Z;:Z¡)6¯q°­®&U–©Ë»§UÇ‘É,(¤,8Ğ é™ràk
I%Ïcc"¢*ÆÆ¥VÄ"0#9°¢.”: .Tôb²c@4{ƒD *œ)2IÚa#å°"é$m< ç b>Áx0 ]"(:U0’<_ “t¼ª;/`‘§”¿-?Qj¥²-0.æOŸ_y'#¬ô
`(),²3”ˆŠ	ù(˜uŠ…ŒŞ2Š ©§t2(HDª2s)“²Ÿ)ˆ[w©å©°& `ä€`åÁ*S)äğlO…08#¢[8~	”¬­Kç˜Øø*Ll°A»<¨ÅÂ?î«ê¦ºyÜ3:ªq22{T+`÷<¾¾Á¤?Ÿmpoc®7Ù¶DXnäõ5xS)­Crsäıín4- Nûş.ÄÕ3fwQÛ¤)YbÖÌS‡= G2n"çG77şÖ?)Iİ(‹Q)7ßáÖ#ƒN p O¥Oq_âeêÆÔ5)(ÇšÜ$İ7`‡:€å©°zlÀoXr-Ú6/‰}Hî	_jÍH7Å_ùd¿,*Áê£@‹¤X»: ¡AË©4gA|VúbZÔG¹=Í-k8wi]-Æ¨Çqï±fìª aØ6Û°Y—ç~Ø0›ÏYòGìGÈM¡+0(¹­¨ ª¶Êp›'÷"ˆ.İğ`Qd¥¢«YpYşƒéÉ† €/ ¿ Pbğ>;yã¤heCtGi¹ˆF|ìAòç(
bW!+ 1*H! 1L¯ ¹+Å1ª4jm$œKØÕÉwAuò\É¤èb™‹1VN6ğğ$x Àş¸åYùzü1°v$9Fà‡}ò¸´q !ÃlÇ·‹–Ü,Gz8mËÛŸ†ÁµdÑEâl¨7<;Å@(‚Œ Úa0<8tõsĞŸ¾y‘s¦biC^‹diá$R¥vyô¸@]ÏyW“9,,€¤Ğ`ÕÂùvµ=šşäiÉUÀ,¼Eİilóå±ãn­/Ï:­³ª%.ºF¾nåpÔåî’Fjî¸…¤0@üvx¸7#‡ãKRPø™“ë$1YÓÛêäH”¡-n°ã-J$pmy·F²–#o3‚<,Ø&ù¨~)ã.`³*9:ğed1”¨˜8y¢m¬2gñSşû’A4ëz@›Œ…~£àÄ–é;¨#0™,1È ²«	V¹#®˜Ï å÷»®„‡¯0_©Ğô€•-¤7²€³¨xW¾Šh~GÎ!â`+©_c–âÑ »ƒxÀÃ+ k‚á0o + H—!·2C+Æ<ê‹$­1¯œ(¦ÂvÜ†©ÂŸ°ìàà¨*¹`s2†4ĞŒ'
"±ç£Rª­é2˜æÂ qò%øN(á¹¸=‚\&jd°£œÊ(­",¨(.t²¡  Êˆö!š:J”´TN—Ñ “ªƒ±¸ cÃ”FHè*õd­e -2JÄ8€ ¤¡ „¤Â`ºc7`S8®Eã€_|‚s8å©èÉÍ>ª‘Ö­ôq²hŞ{J8#†ƒháã 
 À$B®¦ RÎŠ#}´õ„ $=,‰1\è»ÁüFLp„aŞH„ÒÜÿw˜1„Šâ`D%)JÃª¤ÛØP	áÂK÷ˆ—Æ'..eœ*ö š4²$ä¬$¼ï^1\(æ]a§â¸Wan$«Äf€´##"$¾æM44E5™nõ©MãCQæç[8w©c;İıhgem0§æ•p8hDñÄ`—©êwñG|ª˜«lH@sIÕrñíŠ„)˜+(&s~6g¼!ÚG’°à®-´,ÍHê`Q ?em²â8--b2Å† -¶øØ{ù»ñDqc¾,]qöiú·ÜAKíOö2Y}0v?F?Œ*}n>n§Âî~ì9" ø€ì$`+ş;Äğ¿D»3è®Gš|x«XÿL¥æö
Üiıo#.oÊn*”N)ó*Ø`š†¤
#¡zFI~ä1Uqx±k­ ºŞ$)%"3	Vo|šòçCÉÇN&jiàIie:Ú.;ÁIËıïH.ì±™
;"%+œ>¢4£¦Mbæq-1¨4!‹.ñãocTa‚G­KD9\ÄVoİ~ëêU©F¥[ÑXE]í ï€‚!}34ƒª]ûâaüÄ.tˆqË\šÓ¯%0Ù`"6+£i´jæC>`;©äYæ`0HhğîKlğmå:îÊ€hBIëİLû[ÆÒµHà>›E0ìŠL‰#Áàøsd\÷yüH91Ex·æt¦A·Í/”é3<f`îiÊåê]©hF¦ &@œAÂæÅòîVÌDc@1"“|]ås]µZïG² &Eùg“äovZWÔi1ˆÚ9*9 a|®ƒ`p£vş™^¥a>”24.Xƒ•zdùD~~µïXv~'š®&» ƒ º
—ö-¨Ûh—–0Ãb4Ad4,tÎë6 âVBÌĞÎ¯SôgÔú,8‚
.,à(‰ºôc,Å²r"]sãmšlñªoÀ}şYtd#†‰5"-cæJ©Ôæëí1fàı‚89t“/ÈSö‚€« 
%±mörê#Ådrë|Œ
Áƒ†"¸„ó Dej¯ ×îó7ïõ¯ç§_íµ?(,§i@ç®<0®çÖµof]_‡XµÑ4òò]J+<Šf»©£Z0x?*lxãa¡›$Ãf%àI«§ºoûÕÿZç]Åê .[úñ©$4˜z£Ô t}Ó]UAP¨fqö˜RW'bÖ¼E0ÅTosÒÎ¤'JñåeaIıYeNˆ€óœ( ˆx¼D>ŠÙ¹?ÊBêT‹“@¢8»YÂ€š€"q¶
:ÙBll2î£ÊÒH‚ Eö±
JZµàğŞ*mt°áä÷¸:énX#ãù_EX!Ï|Ã-5­>²ácĞ²™Ç’JfmHh¡ºeÒµI'2âiÔDgå:¡y¦ÉğÙÂNa$)Én,æEáåh×.¢®€/9H²R`ÎP é°7hnXt9R×}µl¡h!7ò™¢;)ÆovF((åØî8Qãa5Eúˆ>V-N.PíçIé bdf¯áp¼„2n¤$y(ÕÚ¿éXnJ6$NC#ÌL( ´"¥—2l¨Àáö0\zD?GsÊ”ùuº6ØğÀ©4©jyÛ\!¹#µoÈ·1Væ…ÃTèö¢òšN!b$”è¤ô2y¢ö_i²òiômCœ'`A²éj`(·¥WÕta²áWNİ}°@è ^p!"*8"
8â p' x÷W¼#dàÒtóˆÜSütß9êÆàlg­ı}Ñ+:v
‚ESÇ#=Üü˜g¼è¶$·Øu´¯ÿ­ùÄ6»e~líúÈ´Oa£-UóZò­fœ$që4÷ã¡ûœ^B©?J]DRv,PfSc9)*%(g.kÎR"Y:÷0"çIvë^OtHÄÆ¬½äd
p0a„2€‚ÉHá~…üvèá-©dşq=*ˆ»(á.$p'áÖiHØràe~õù-tÏëøb°VpWñë¡¬HOJã.i’†¦‚$ —=#Õûw–¿ÿê9v^Z6õè{">(L0Ø¦` ·wÓ½›§AbR}f/†Ou—M°zG›+d(O¾Ü‰‹L 9Y"f{âdäeúâ‡`"+üö2Ao…tàé”e#4•\?£X,z°01úØa`!#b†-PöŞgy|SgŒe{ĞäğDûi5ƒyÕcdÀocl\E&T£öí‹´è *Uî10ÀÆÅÙo&|^u+hf(Û(Oó~( +–râp† š<”±”ªÏ-ˆ8úŸd¬b9"ƒic/ ¨ô1-dU‚h*	f «++ö4€	Ó â¬y´+š¬
wpH&!1e<#òİL
‹"ë$¶€!ªƒ `H€"*ƒ+B' H>Ê1Íxıj¹1m»ÈwöÔ d¡p¾°áX:â=½“ˆŒ2œ'ôv&"ì‘œib,¸ºAşåÓ ‡ikù±`3#'j O°iØËu*Â’x¡ğa(-Mğ
4•dŸƒ—(O¤#¢¾h(a‘¢0Ó,yœ|¼¨şF#.ÎÑ=Ki¦Á4	 ”Šj£  A´yåÑhà‚ 6‡¬¦J:BâKb‘ƒŸ1pà™Ù@ï¾	"
/=¤r,|)1åY¸
Å)£bë7` FfÕ-T2ø*ô`†™ågî!x‚÷ ¢8 ‰r<*0s,Ù»X5g(%4èaì-)è\,á/$,´ OÂ€°ä=°BI»µvgö JBX¨[h-¦¨h =$ğ!„D¯"ŠS½ aiå(%¥$
 #5!2•"`c2õ*;!3à¨? 0¼8Pœ ”d B ™Ü"µ}nd#°A#rQõ;zã¬A¶t Åã$s~=l aèá3ä®>m,/!+k 4Ä.L:F¢õTËãætäAañhø’:5Ù6qá@³X^şUŒ!ıiŒ³ˆıúlE"Ø9­$O Fh-&+ö5Àa	JqXm"b'Ö¬¡+cuOÒtoft3W+m%(¢!ô`öböaˆ`gq?×™[©¦/Vòh‹!bf«dD‰a r!İÑr¬KîÍ’cDnöô!*dì¸'­pÎ¡tVy(?Ø´±`M.p4p¦ô|hºòér7´U¤/{*§7ˆÑ×@+'Ê.Äÿqt…aO2<ãˆ2b)TbóŸÏCi¨mkú=}Nt¿'“bu¸uÌ†©gõh¡ep"<u—}˜P0Q‘’) quÆ0j £a"±%5:ö5i	ES1@óùº¨¯óp¾+¡Q½>{4$Uµ02°p=ieT¬ç ıb x„Kàé$­põ drQ²'€§	1‰–ù!nzºĞrXÈ0š¢â47ÿEÑ~D}ö$…]EÛQ8-„± f8å ¤5& Šˆ‰ l¡§$Õ>( DòC mî"9É¶?öX6œb[8QX©¨#08"Ò¢¢1|t¸¼´7
 òNÌ$ T	ª µm5CXdéA9( p?11è¾2Ã$c§LP"¤ àdüL%"®:Mäv»˜ %`ïr©0	Te1ÊAÍ+"‡,®;,4L47<‡té C×“À ¥p¨Öz¥‚¶Ùd÷dƒıaá$eZ ™­ ÜƒÃ*-vlÈ½4pø*5buà])3 ¼é€+sn `eg6 y$ùr”£ºlöd %m½-O¼®*0>Ç\,È2ä¼-=AhJdI"çK$pÑ&à²`æ¡"At›l%AÉ2jÎ‰6”4ıtU#øä¦ p 54xÈ¼µ¡ÍHZ[+}"f2å-„$ ~ª3‹€° Q2ç%öq RXËa´¬¨b,Å1py‚Pv‘%Ôám¦)º2+yj¡_—±y0|yj>éª`üe’ıâU0mEgün¿bíj{Z¸ıöBG@r$¿'/‚U0 XAóÕ©pks`,úGxU7c•=å,"*‚¦)/k)vÎ{}N5éMõemVuQwğŞc2Ik²pnGfff(…6DÃYváT`$)d=1×ë#Ÿzøn€yÈ? 4<à‰0‡1*zLr({'Ò3ãaıÉLv·
d"á$À3hhÔF6°+mRkÚR;¥É³l[€…%dXK‚a`c5^6hCn‹±Ç¦1YLO±T1à=¯øJf€ú°â©o‘Öğ ´+ÕVQ³¤.³ò,zñ\ã8ÀetLvtuõµg51w -gQŒh¯l-|—Bv.HkÓVJwd'4·;^çNş:ì%×æÕˆ^Õì&4)U)%8øµ1$ÍòE$¿uâSthF(¾E·wL_¡ÖäA-5}5>óÒ]pdÀ«²½ármá†,NÁÚsl,S“${±Şb!ø"rmz©ÕøujvdyÚ,$Tâ,6``õGğ¡MbA[hƒ=o~;ñŠ} ¸iü.`ay1İó¥ËBgè³?!¼Œ)–owpLW(Hğ`?æ ÂÄ7àU}%ıw`=!X	èh$ ² ¾°4ñ1“ª 1eq¨KÄ/‘"`#"S1b¤ø$ó2¸8„g¬Ñå /"*ù[üì%s(,,4*]ì40`Èt"q] <]Úï%p)&(÷9`î¶u(z0İ`PàkTU0% æ*’1l%0xêai$l 4o”El,Ätfz02!ñï-¡­`meKÄ – y1®lÌ ¤ qÜ‘:Ô `pªD,H8¦L¬k0¿â¡yO00v9=Á)q$à*§¸=,Ì`h_Åå1 ?°Rl9€ø¬úA (õ1‚*i®ã$0õg.H$U`1d('q5(ÂÄ-%C)QpAbà`UUYsU4xb˜rNÊEñ@şj|©l*+ì8¨tyí}
r³cyå %‡Uqìa!@(hb™x»>W %xëÚ ı#ôm(0!DF¬lë=Y/Á8`b4ğ:]œè%/Ğh&Pc×ç®r kFé (n¡Ì 54NÙì"±0u!r[­i•P#„Ã¢hC!X¬â]L*!JÁl+ v}ì 50, >øº"··ş0¨	¥ép §1Ä"xXø q9.:,ù,E–fìu4@zO¯²$ ñi9%)@6êWu«_]Wù)İ¢Dph5¨Nl*ªî+ÿY=2>h¨D0xw‹µúœ ñ¸/·/IÏ³¥ 4bz€‘4væş$¥ —CÿµY0€úâmFeû	o@k}-`M$zxòJ:­$|F
j£xq3fkéXaª„ó@‰Ñ°Íßã_Y` ¦#2¤Ø^…ó1.M
åc¦ùˆâî5I/%¬™$™ûÎËfTÖ"Sp´$eä ´jÆ@ló]>n­|D…a£à@u6nŒäkƒÆ0¹ ğ1‚¸¤ cñ×0ÁÖo¬vîØÎdU$úe^r0.ü@"è• 2¡4E‰p%ašg½en@tÒp6á{t[oSÍkw^‹-Dì(^s0¡”-+ˆ U+UeŒ¤¢+kr¨Gêì¦Í4Â¯P"nM’~×õ :³•^gq¿R4ÁtS „¡zq3ër(Xà:½¡L]dìÜ†,6gèoEã>öf²Ş]$d#<Õ”…Rx‚ $bà„:14¥¡ej±+˜*¯¥í¶g_Fä]6p äñ _6»}xaı&¶07+'­Gk´ õ¹‘éUè$TeÀËæâ­ştãŒ^ô©3Z•k:²E9'„8¸f°Ñ€¼ZZ`XíCß•%fbpp-eCwÆ‘Gıå e(x[ñvÜsßR§#u	æ[§è`N­1ïxzò] éÈb#ó ½%ß1£r1‰úñ¯ü28ş8{Ràcì®44T`$ì`U ÷<ö›e`=µù%¾Óh…3p^'d%úÙUÍß¡§ug±:ät»8V«n<Ÿ™ƒ's‘û/Œër¢Ç„ U%eÑhXk1<Ğéí5şZurjnoR
¿ïta]kt0ñB(SLeKK«e¡0¹â PsS=RĞca;eydcìE²sfN¿x;?,•$À}¿U|œJ¬ÿ+ÿil ÜlBlã¤wc $Ä<)€V%$x¸n÷ 
QP»,`ğ(é,B$%!&µ¶½}1t:íµİWéä5!Åq¡8ƒ°t	-~ FI,¸µ(… ç ÁãÔ
$#z	#òè°" u1b1a¹oMè¼h$f2q!‡6€ÿ5ÎŞÇé÷`ıCpõp6æZd )¬Zo@Oµ_`ql¦ %¢+@òCU¡Sm2ğ­nsfò&sôy|fkg'@¤	rMk2şÆP`ÕĞL`>#v–q´X#d*²C‡uK4c:ñpFá;®Q“e[q$Qº «u¶Wiõƒ¨l±)å´ ­,Md÷(Ta) 
 }'u"g\P]ƒ $bË0í%	 >°q»>w€ føxõ¤(õ‘âi0ƒ!öô7§cœ 4Ä ¬$"9`Æ @%EÍ„UaxÁa·zmUKÛÕLUT8$ãQ>ãpÿbQ×Ùe4ö{OåvÕNE¿àéé¾ÑÃ$ü‡5ø8÷´ëÃêºj%rI |tê–1¼‹°6Ñ ‘ÂIí0Ô,!Xßä¡u¹@!Q ¹1ğP(4<7WH0½!f-]6*"0,°0’L8ÍP%si#3àÿ8øíp,PÛ}í¸`&à ötÌ²gè1À.cw4‡æÆNé²DfsHNŒâ}!W¥q'8á0&·Ç0kÑ;ñRb0\²Ñ(ñ6m±z~ïtŸaBwŞTÂÅ2ÿK½Ğà-g
ÍU´_p4°e¬e7,™1, :	U¥$$0½"ğõgI@BaÄ®p,m$ra2‡pîåx…¹ 0\ hg¨e •~«çôSOÿ4Äb`@&”(+ø(V 3Ğ+2Ñà° ,`1e“$dlu#á“E7 Ü/`l!MùÍX,4uFXj¡
5 ç/¦óp< @4ƒ,oT°+2^<*"@T%C·Z »M<SÄ	1±pèKwL|•MÑ¹ $qa|6r~ä#rğõ1
D­:°Ûôµ êp0½µz@&h€µJJ!q( < -ä5¼d1Jıx> åyĞ@JJnp`E-Z›eòÜm^X|Vt€üöp!ÿÑµÜÔ\*9"k%ìõ9?ğ¿k t<"Bko%Ù,æfz.a02iÆpuäBÇ¸8İ*†Ô0’.Ç€¨`à·‡h:4¡ Sê!~[;,ryN_v3!Dg5m´JŞt\‹#™`kİßfa+$Ñ
rkÀuğó9q56Uª2(ºùÑ0&` XgG1 -q§>|9fDykcl›$àå ®À$ÕzS[¡p¥azj9))'‰Î©¹Â8 Ó¤êõar` AïHd)å  â­¤ß`	u%Ù{‘kaö+äUmÙˆ\`È³0À`% UKL…dp0r%… B:Mä+âyp5nµ. ,2
1í@á–Q˜Ã { r_7´4È 1¡òrKH *¦ ìe‚±§£m!7N=¯10 Å›=8`o*S|™:[píäÍª÷€@"G°*p¥¤ àXlªd 1p}	zğaU8 Ë¦YDq97ıb8¥<c[¬,Fwizå®@²÷d;EÓ¶c&µ_Ë´ËWÖöaKsGÆg(çH¸„\ - ùğA6³Rth¤*`aİY¢¬n`­ÌŠ ©L	 X [QD8¤Òv¼W´ «Œã.T¨°$}¤ñ¡Ø*B$
 &¥Qr:ÑŠiHË¯[L ±Xâ ´ wm¨£Lì"{'¿ªNZ4fà¦î¨Ÿ>P&òoYzS,öIŒU)md )l_A){!|p¤¯UA3à0=©ït²Ú&™Î£ñ`9X7q$áe:^™Ğ‹ÊA º*±!eªò£ft¶dx¸.&#C‰$‡ñ ›uZ£«üã
´.ª n,€pf(Ü t`lEe*,37Ì F°€XµdØB©"½P`xP¿"¡Y¨#µ™{æ8<@=¬G¡Up(Nt	`4V$AàŞAü&‘@ur¸¯ h¶GYÔ•í „,‡wYR8|%¼Ô *%S^*zX  PN¾!8ìİòzöÉ,u ©Ù8fªƒ'&w.C¤c!GõaIb8Ô '*¼à3j>ÇZ%9yuñzğÚr•M*n]7ş&zî>Ä»¢·ÜhÕäswg}k©ğq¡&…í²JrU°×(x6Ö‹³ô°frjS"à†sâ?(ÇÃÌuwÒ%ví!uoGS"
Er(5lZa±D¹`á%bÓ¼7.zì£"0ŒIåUó!š1d>jÂÀO/õñ8(`bw(À	`’@ ® °?c‚Ä-jCsin%¸Æ847òmÚ+BÖw5`ıñ$ë,
Í P-$¦53ç2ÚG !*Ée^xYŸıäA!1|x'!ªlá¨aŠ¼è9eMÑ0µä7QKårÃo¿#ü­ñ#¹vÁAfppğ;!O„`şè'³m_âhæ{Da6s#Êâ/h=21m¨¥13sµ­:b@oÈŒæå¡8q‘rt=« ;V¬%a°ár<¥k`¤=åâKÙ*mzTD*gKÄpW®à>{Ï¨m‚ 1IL(1rnÑ'‰ô,/Jo7Öœö52kŸ‹Ëy²ÔOpA]„ésäE^ bhÄ1ll9Í¨$›" 0z$=cgp]IVfAİöù³­ FÉWìñD¨=7d!>ŒĞŒèá4ˆJõ)ˆo}Ëi —ï„h†l4~csêzJ;:|µe­Cz¤í"š«â¹¡Ug±ˆ)ˆ(nxğ óÙRèbšY¥ïk!¶*zÅäå] &q+8ğ³._.0lTô ¢aua{ƒd`*”i2Ikc+g³il=hõ ålx5UbÑ(;Utó</¡_Wtä«:?h¥µÿ-wákç9Ã°,$g|û	ws3¬ı*ã(+!ğPFVˆA_(Hw‹‡uÆ ×q­g'%t:(H`ª6c1 ¾i‰{w;Õ.´e``Hd6X`dáhSt/ÔTp|]§8q#¤s%ú)­•ãI‹Äû~D|°c)tWmÉ’Æ7¯ëúªz|1#zêq0²jT{u=ÿ>ş&é$4m:tc'¶5›6d8n¦p4pS(ùNzsd½í64-ªfûªQ&Äı=v7<Ûä+YrfiSQ‡;Bß8S³jâ/)37÷×·)Cí(­q)·?¢æ+ƒN y¢O O~aí7ñfÖÕ5)	°b1[Ş!ì]?q·:‚Áõ©]hlÃoXr]¾*›l@î	FzÍHÍ7E[é¯®rÁjÁĞ+¤X»z(!AÛ)6gUZşLr:õE5¡k˜uëlÖ€öxj·fÌbªRÔ[6{‰­y‘,ã~à°såYòMôE,Lá3 ,!­8&öÂPog·3¯Íhhqe±¥;xZ1¸¶t&YÉm —.€%!Ôrp<;)#¤hgSvfc»­.vöqre*cEEj¨ XL½9`¡A˜+9 7ty/$œëøSáruş\ItÜ"™)1~N?Ãòñ4|àà»¸ñ3)X¹Yø0v 9Táæ}ò¼%|{=4ÇvÕm4œÈ.eh)mìa‘&µPÔÃ¨.(š<)ub$d¤K$Úe0<x"ñ‘or9sšCxUVÈLmeDY­<mÔ¸@U-HùW–9|6€¤AHÔÒñr,=*²0MÏ%E<´DuÙq!(Òà0 ~¨&
2­£¸%,®@í|erÕeî0Fjîù]®F2Pínx1bCÃäKcªø™ÓK$1M×ßêäJÜ$à¿æ4¢mB$sğmyA·f¶Ö#nÑ3£r?\&ù 9«.t÷:9zplt“‘´ŒWxø )¾ãe'ñTöûÒ]4ïnE]€œ­n6©æ&ÆW}¨#ur™vCùÊ0ò(İ¹gª½Ï¤æ¶j§…jr_¹½ÊğÌ­3¤=§AÄ±¨xS¾›lZWÄ¡ J(©_sôrá =ƒ|È[i…{ápoÀ=¤	@U`ñEÂ8î¢$0&ÿœ(rB~ æR¹Â¯Ü-nàé 
ùzq:G÷ñ¬C7@7µu¯.¨éí2“fB# uşñ0C(á½=f–~bjd°¥<ëiíÅ2#| ?~T0©Œ÷ŠYGª»Zœ$WDµSBÇºÁ°¸(;Tc@¥V`Èkœ4?%mup ¾Hd	¸zµ¥‚”¤Fh,c5fÓ8KaG=Ò|Ësig¯ÉˆÍ{*‘SívSã`şn<#Æp I0zÁ$i«nõvL#m¶öP>,51\é«D¡ö7MpĞc~@Ä(ÛüÿŸuøa•åç&isB%–!nÓª$NÛØQ)éÂh³¹V•N'vveÌêö,ø6*1å¨,üçX!X]äa£a™Waj%¹íoÀ”K;2$áæ	‘$µ[Ytñ(E#.Q2ş%i=÷#G:İµx}ea=¡æÕ9:òû`b—«e7ëWu*f,yH9IetúÍÆ)›á,4s~&g5€1ÚCààö}7-í\ë`;	?ehÿóó"<a%b25
+¿˜ú˜q`Sá@qc?~yş-ı–ü%OígV2I=9|F? Šmlî³Âî`3 ¥ù³ı`/ )ü;À+²µU¼0&ø¦G
dl«{Y?l¥nôJÚhíO#ooêjj”^+óÊ(Â!’ $‚q#z\é_~ğ!Qux}ko’vŞ%1Ñe`2	6o|*óC	”M j)¡IyÁŠ•ª*ĞXğ}ëH.íá›Jbeïnrñ½%NMzgy<-4¨4¡xã?)Ek ¤(IDó\Ôt/ÓîËªE¿z†[¤S×x&ENl±ş	Ó¥}w4‡¸}úá)¸Ä(4ˆqñ´"W¯¥8Ñh ?; ³i4^nÃ>`;!9¤p0X9¼Ï*mğeå9®ØÕjAEkß]ÜšõH0a>_ ôO0|¡&Á`zs c\vqì3±Oy·vtgK¨4Í¹"6s•d^æyÂål}Å©$Æªa"bœTÎáúv6EÄgX3r‘}åç\¿süc°4ge¨c“åKvT0i3ˆ1" `X¾ƒx1t ~^İZ§u´ëloZ£*d¹E.|5÷Ğv>|Ú¬ûH!‡¼µò ¬Ûh—´0@b$ëä4l~f
K«2 b)WÔZÜñî¯*1äSÔö/=*ÃRÓ-)Ø(¡¢ö#©¥° 2;·éÎlu¬oéZõÛ|f%Ø1l/sÿC©”d#m1$`ı 8qpDY
ö‹0i%°,öRêudMse|œ)Eƒ¤´°ŸâÀTaj¯ „÷ú±5ïõó§7oí·=(M'w'i@æ$2e‚›ïïmW#Q)4Ô,æãU·~#6›îşé¢[0x?*ì8q(¡›4“fœ? ]ë<¥ºVÍñÑrŠlY1k{/]Zİñ%aÙzëõ%tµ×ÙU@<` 1ò¸27b–E°Ácjóqîô#Xõmg`K=Y‰i\ìaó8SXx<D?‚Q©àJêW‹5»`¢x{YÑ‰€'sµ
*B$n5ï³_˜WL6‚+E~4ÿPrµä¤Ş*T°± İ¸8áhpˆzı~GI+Û¾ãŸ%#¯6²a`ÔƒÕ>OjwmI`1ºeQµi—2H!Ô çb³ Y¦ù ‰âgp24)ÈL=ìR¡¥hÖI*†–/=ÈÒ2b_ ñ°7,n\¹2)FWifh h$°¡*™¢-¦g7F juÚn}Sã ·Eú ~V-nŸPmg[ñ(bíb®çp¬„*¡Äy(åÊ=© `
v%~‘SaäÏh¡İ´"í—sj¡àâô"\:d?@cÚ0è5.7Øô ­%¡k9š ñ#±%61šã…Ã|hv&ªvš_crfTğm~4ø¦¶marĞ/gôy…
%y °hjd 7%4QVÙD!d{GY=pàÌ²n3cb{:&J4¼òDp§4xº^¼s ğÒt1(ÜS¼w.)êÕd|n=ì}ñ{V[	ESÏ3?Mü0ç¹è2ï¶0%µş©éä6;D'h pÔ²ow++Ôóâ)$ U«4wø"}4VB¼)?DÖ6¼0o9ígi+¢-xa.käTG_2<"el3xt
’R”­lÄJs2á$3[éHà,—¼>èá%éw¾b=(ˆ³,¡.%uoµÖzÈÉrâg&uÛ¬4Ìë¸ 0fàWù¨-j|oJ¡®‘I+<"ò‚®—¦/„5=#Õku†¾¸È8^\|6õ.b1:	D1úçt 7wJ½§V'X|'.–`ou)ò)šz‘¹md(]œ•A_D%Y§w¿àdgexQ§$6*zôC“!}„àáà >I ‘<¥+€X(dä 2~øape"j®-sæü==ys­Œá*S`ğ$Ûaµ5 at#äRÀM"q|G$q$t¹‹ôé¢kuk›$>€Ú=AO.^^p2‰)f(î®os~:asårÂb¨šXŸ³°ª{-½>ÿd­f]}c#mf/`®l1-eSs`*‰fhû8/°t Mãğ`$s”\+š¨/s\i>a‘Mc½{pQĞ%)*ï5,-·,a®G€ @úˆ~í?"&H>‡i1Åyõj¿"¿ègVÑYtzh¾°©Q ò9}QJ¬~¼‰#ôw	_"lŒk8j-¼úArÍ‚Öm[ùt91R?³!™j G_¶K0¦vÙbå*Âø¡øa`eÍòC<at‡v(mqë¾H(s¡ªuÆ-yœtıh|F#%ÎÁ3@I"Å<: ÊzÆ`ƒÙ 9à#Õéi‚°7÷œf|:BØJ` ƒ½)#pàuÀ`o´ndimage.binary_erosion(data, struct, border_value=1, origin=-1)
        assert_array_almost_equal(out, [1, 0, 0, 1, 1])

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion16(self, dtype):
        data = numpy.ones([1, 1], dtype)
        out = ndimage.binary_erosion(data, border_value=1)
        assert_array_almost_equal(out, [[1]])

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion17(self, dtype):
        data = numpy.ones([1, 1], dtype)
        out = ndimage.binary_erosion(data)
        assert_array_almost_equal(out, [[0]])

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion18(self, dtype):
        data = numpy.ones([1, 3], dtype)
        out = ndimage.binary_erosion(data)
        assert_array_almost_equal(out, [[0, 0, 0]])

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion19(self, dtype):
        data = numpy.ones([1, 3], dtype)
        out = ndimage.binary_erosion(data, border_value=1)
        assert_array_almost_equal(out, [[1, 1, 1]])

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion20(self, dtype):
        data = numpy.ones([3, 3], dtype)
        out = ndimage.binary_erosion(data)
        assert_array_almost_equal(out, [[0, 0, 0],
                                        [0, 1, 0],
                                        [0, 0, 0]])

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion21(self, dtype):
        data = numpy.ones([3, 3], dtype)
        out = ndimage.binary_erosion(data, border_value=1)
        assert_array_almost_equal(out, [[1, 1, 1],
                                        [1, 1, 1],
                                        [1, 1, 1]])

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion22(self, dtype):
        expected = [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 1, 1, 0, 0, 0],
                    [0, 0, 1, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 1, 1],
                            [0, 0, 1, 1, 1, 1, 1, 1],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 1, 1, 0, 0, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_erosion(data, border_value=1)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion23(self, dtype):
        struct = ndimage.generate_binary_structure(2, 2)
        expected = [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 1, 1],
                            [0, 0, 1, 1, 1, 1, 1, 1],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 1, 1, 0, 0, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_erosion(data, struct, border_value=1)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion24(self, dtype):
        struct = [[0, 1],
                  [1, 1]]
        expected = [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 1, 1, 1],
                    [0, 0, 0, 1, 1, 1, 0, 0],
                    [0, 0, 1, 1, 1, 1, 0, 0],
                    [0, 0, 1, 0, 0, 0, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 1, 1],
                            [0, 0, 1, 1, 1, 1, 1, 1],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 1, 1, 0, 0, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_erosion(data, struct, border_value=1)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion25(self, dtype):
        struct = [[0, 1, 0],
                  [1, 0, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 1, 1],
                            [0, 0, 1, 1, 1, 0, 1, 1],
                            [0, 0, 1, 0, 1, 1, 0, 0],
                            [0, 1, 0, 1, 1, 1, 1, 0],
                            [0, 1, 1, 0, 0, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_erosion(data, struct, border_value=1)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_erosion26(self, dtype):
        struct = [[0, 1, 0],
                  [1, 0, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 1, 0, 0, 1],
                    [0, 0, 1, 0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 1]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 1, 1],
                            [0, 0, 1, 1, 1, 0, 1, 1],
                            [0, 0, 1, 0, 1, 1, 0, 0],
                            [0, 1, 0, 1, 1, 1, 1, 0],
                            [0, 1, 1, 0, 0, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_erosion(data, struct, border_value=1,
                                     origin=(-1, -1))
        assert_array_almost_equal(out, expected)

    def test_binary_erosion27(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_erosion(data, struct, border_value=1,
                                     iterations=2)
        assert_array_almost_equal(out, expected)

    def test_binary_erosion28(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0]], bool)
        out = numpy.zeros(data.shape, bool)
        ndimage.binary_erosion(data, struct, border_value=1,
                               iterations=2, output=out)
        assert_array_almost_equal(out, expected)

    def test_binary_erosion29(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 0],
                            [1, 1, 1, 1, 1, 1, 1],
                            [0, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0]], bool)
        out = ndimage.binary_erosion(data, struct,
                                     border_value=1, iterations=3)
        assert_array_almost_equal(out, expected)

    def test_binary_erosion30(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 0],
                            [1, 1, 1, 1, 1, 1, 1],
                            [0, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0]], bool)
        out = numpy.zeros(data.shape, bool)
        ndimage.binary_erosion(data, struct, border_value=1,
                               iterations=3, output=out)
        assert_array_almost_equal(out, expected)

        # test with output memory overlap
        ndimage.binary_erosion(data, struct, border_value=1,
                               iterations=3, output=data)
        assert_array_almost_equal(data, expected)

    def test_binary_erosion31(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 1, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0, 0, 0],
                    [1, 1, 1, 1, 1, 0, 1],
                    [0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0, 1]]
        data = numpy.array([[0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 0],
                            [1, 1, 1, 1, 1, 1, 1],
                            [0, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0]], bool)
        out = numpy.zeros(data.shape, bool)
        ndimage.binary_erosion(data, struct, border_value=1,
                               iterations=1, output=out, origin=(-1, -1))
        assert_array_almost_equal(out, expected)

    def test_binary_erosion32(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_erosion(data, struct,
                                     border_value=1, iterations=2)
        assert_array_almost_equal(out, expected)

    def test_binary_erosion33(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 1, 1],
                    [0, 0, 0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0]]
        mask = [[1, 1, 1, 1, 1, 0, 0],
                [1, 1, 1, 1, 1, 1, 0],
                [1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1]]
        data = numpy.array([[0, 0, 0, 0, 0, 1, 1],
                            [0, 0, 0, 1, 0, 0, 1],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_erosion(data, struct,
                                     border_value=1, mask=mask, iterations=-1)
        assert_array_almost_equal(out, expected)

    def test_binary_erosion34(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0]]
        mask = [[0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 1, 1, 0, 0],
                [0, 0, 1, 0, 1, 0, 0],
                [0, 0, 1, 1, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_erosion(data, struct,
                                     border_value=1, mask=mask)
        assert_array_almost_equal(out, expected)

    def test_binary_erosion35(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        mask = [[0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 1, 1, 0, 0],
                [0, 0, 1, 0, 1, 0, 0],
                [0, 0, 1, 1, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 1, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 0],
                            [1, 1, 1, 1, 1, 1, 1],
                            [0, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, ˜,-ó]Ü+£Óy¢ S¤0+°`9ieTĞå ©bø
°í-p½
`¤´ğº/Ì¥]Qˆùkz¹Ğr(JÈúˆ¢‚<3uÍÂÚP½ö&µ›a;-œ!°d*%´¤3¨ŠŠ0,‡%("¤ò`}º*qÉ§1²€Ò^",Xè©C0ü "¢¢10º¬ô%Š Ó¢–ì“$Š)DIë$¦m1SØm)‚((¨9R/  ˜ à¿2Kc¦L\+èğ´,%N: m¤‰û»È	!`ï©0T4ÚEÉ:!4:±l  <#ûáTCÇ›â& €ºÒ^¥’—éö0‡é±¬¬gX›
(Üƒ",t(È‘½ÎÓ€&u²ƒO9*¸û +S `ag69 xr„£lxp$ƒUao½yo<=š*I#×D¬Ì·`Ì¬>AjP$A]ã÷K‰ R “`²@¢—úEvVßh Ì2jY@ÎÄ™?Î&½LQ^éå¦pñµxÉl—áãHp{+¸,Âsı)Œ$&şë#†˜òdq¶ådä±!vTÇ\‹m¯ıZÈ8B`ÁöpÙBGVb‘%Ñğ	¢A¢:!
hK!U_×°]*TıC0åªŒıx†ùâMò|a'öjõbí	{H¸F
ığG@rîÀlÊ„×³ 8@Û õèPNg4¼ğÅp•uÈcU=ç$æB?¢¦ˆ©§#aÆÆ{}ÚaîuÄe,6qP¦¬ÎÁ2Ik" J~$† ¤6!ÃI4é ¤d-1ÖësA_~ùnšhâ^,/µ<à¡œÇ1ŞL2*"&ÜóA­©Bvµ
$  á"À1*èô’¢)îZcXR9ÅçÙ±l’˜Ÿ"¸O#Gh6=L~hÃÀ«¹a 38…mÍÁP°ò|¯ĞBdØş à‰o‘ÖIğc•rS·ä®:Ç»º¬8q]d¾ÀE"|Ät¥•Gq5wö-gA l¯]/vKv/ {Ó^Í{¾&·;Câz:ø$×n×˜
Õê'4¡U)S%:x—%,H ·7b&@4.F(>A´"L= Æô	7}8³ğİ°€Àç¶¹
à:ÏÂ¦,ÁX².©,F’Ój±!èbek©X{|jöDÒš.¦Tâ,Œòph¦Ò ¡_jÁ[h¹Ç{ñ€
9!¢¹ßº`!4ÜÃ­Ó gè²-c4Œ –,uR(òÌ=d‘ ‚#àU<
™0¼w`=!\3+Ğ $¨°(–-á{’ @=áS HËÕ/˜bÛ+ÒSq`¥h(;ºœ67¬Yç(C*¹}é${ Œ0+]¬`È"TQÉ9UºwÎ%p©$h$³‰fæ¾µ¨h¨DXÈ(\`l€æ*‚±há8ªs!XlP4šk¸a@™äFx©2!ã­¤­gée[D« y¬l@&(%rÌ>$Ô¸c`PªJ$,H>¤‰L k$«â!xI+¸Zr¼8Óœ pÖà+§¨=,F)
huÕå†1¡”BJ9XÁú(‘µù‚*)‚«&”æe‡./@U 11Lª¦q5¨‚šÆç) ábÉX=EY3UxjXrVÊÌ±Ü:Z<«tşªä2¨r€0í}O0£9åå¥Ï3¬2¥ãP¨j&™›?B „~ŠÈQÕCü}( aTNæ`Šé
Y/âÙ`LĞzÈ™è4,Œ 
~"6â®>4oÆ!2¨8®‹N 5,Nø£"°1-jy,i‘p‡–Ï¢;)P¯à*U.+‚Il*‰hyl¶,4øŠ'šş¼8¤©xP!™Îã
‘pø0Ñ},:,ã1ÄÁ€hÄ9,€Š`U¯Ò$ÄôŒ(=.@2â¯—]Ç8	Õ
¢Ìpî5ˆ!ˆN„"‹ìø°.,¨D¢›h;‹†­Sh„ °¨/¯-I“Ï³¦¥Î6Z2‚±ÑtÁê&¥à½ƒÛ•ğ€øâ]FóûoÀI-ˆ. p’ˆZ±%ü^—*ßx€0ãckãX€¨„ÃI	ˆ¨Œ“Éo ` *"ˆX %
qˆÅ
§8Ì<kOAo1'¬›2Üûf&TÔg³[$F õfªÆ@,Y6Ê®1A9¡¬@W6Çœ¤c”¬»Dğ1‚úŒ®jÔ´ IÔoºvØÈd•$ŠøS<" 
l"è•¬¨$ÅB1…!éªf4o"Qd‚0>iè	4 £w‹%ÄêiÒr(“M8"  ;B¤¤"+kb Î
‹¬®I¤€ª¯`"Ÿ.²ÌÖ¡ 6±‡4qæP4 <1#„!*²™³årPñ8º¡(<îØ$G,kW£&ñ¢²ßE$$¬ñ’…F²‚ $jâ„>!`!êåN³k’*.€í²¥W†ä>r Äğ(Bœ¦¹İŒùe½$¶0—ú#­Gã! £„±‚jÔÈ.`À€¢‚¥¾qú#ˆ…™Rô¨r•j:¼0ˆ„,¬ä´ßÀ<(
bäÔÕfâ@t-G5Â±×ÍùmH(yÛñbLs›Şt¢bÄ)§[…WØkC¯·møºâ¾hÉ.B#µ€ö5e^0£ÈFÉêñsü.ü(oRàcæ$ U_`0nhuã5öT›/Ä(Íedù‰©¨Ò(…#š"tô­yTmä 'ôGÑ9$tû}ªZ«m=›‰ÅßòûOÄ®"¦ÇœáS8éğŠX;3}QØa´öŞı sn´oÈ‰¾çQáLct¶5JkW_eEbÃ«dá0™ãä6¡yrÀ%d3y@s(²7¦N¨N%6.¤ í2V<¸F¦ë.âaì¨†nP$â¦gã)¬åü©€d—$x<öZ½0JUHÊ­hÓù«O!£”¡Şµ#]1vmñŞGkæs-qeÙí8cWeI½|jÆItü½+…èöàCùæN$ãÚ	# ê·fØ5ZcqãØLÄğF½Jo¦w•0Ñ!ÇF°ø7ŒxˆáÇ`èkzñr6åZv&!üz~XN—Ô(h¤$T¦)@â1CA±p(2³¡®3HÒ&sæ¹zf^'&Y¤( Œ ²Ş„P`”Ğ`	*¡¡vÔq´p3Dˆ:*Aƒ÷i!c) tí[†PƒåKÒP¤U2ä®’!ğÍ` 2Ke½ ­$ÅÄ)¾XUl+
À{÷u#SgÎÊÔ¢‚ ´0g÷4áı	0¼Kéq«_„	fèzñ€¤bç£(bi ^ƒ)öSôw‡c¿ã0ÄìĞ%ô"D<`ÇAiEFÍÆWxÉ!µ~¥MKñ]MÀÆª`c"p:¯¡0-
Ç°VR 4öaB¥2)–N@·Ài­¾Õ×¦ü—u¿x<¼ûÏú2luvÉn\ÚÒU¬‹¸wÛ ‚ê	åàœ ¡Zó§æáıkß|D)q ©)ª [0=·A Ş!FrVË: °G0ÓDzË%j+¢²áü¼øí Ñû}åûãfè¹våÈ‚gò Á2cf,ƒÌÂoÈ’kzŠâm¤Â¥Z'¸Á f”·Æ0C™(ğâ"¨ú˜< m¡À^mv¿“@uÎ0’‡0¾

°– ¬g›åƒMö_`¶-şdw$›)8 6"†´$  /‹âåCÉ@ cÄ®`h|M!varAÃpßîõ>yA•»¨@io®aa“ª£,ğq
ûÍqÄb@X@.•hjú9R2Åk*Óä³‚ x#e›µd®ucˆ’d2L,èl [p

X®¾UdZ#Ï3Pä®4ôz4a ¦¢kÆ°+ 2|¿( %µ*$›]<ÉÌ	0¸PÍO’êVDKxÅ-Á­8¤ÈeD6r:À¾zĞu;jD•+,ÛÀµjâ±äzH¦(€¦[J\*q(Êd˜ìqÕd1OıxV{ åiPPK@îQH,š!®>˜ 6ÈlP¿€Îö|éïÑ¿LÔLz¡\qbkîõyt«{ |¬NAc"{zeğ{÷J~’™÷>mFp1æÒK¬ø¥*ÆÖ`2VMÄ¨bSÄùÇhº-5áBèÁ¬z9JKv2õƒ‚÷·­õJÜtT2¿èkİßlô®"È
:(È¤hPç°=5ÙÊ5Ò`:ÙÑ0$b€Ü$V1€!p `9fF i!¬’$	zy¤®À$Ùy­p…a`j(™8)&‰Î©†8aÁ êudò4€QçHD+År`ş­´ıeÕw¡[;é"a¾ÄE-Yä8pÈ³0Å'áUhZKH©gr¢Pp•… B:Mä
Š0Úo·n ,p ø­Qá–:Q‚"Ç&„{¬0[3´vÀ@=£ââCH ¦ÌE‚»º–'!5N¼¯1@$.Ôƒ02ù@Gî`|3>K#íàIêr€’C´ª ½†èàYnª` 0ù}	r°#Ù,¨IÎ.Äk0Óõ" ø!>cú,,Fv}r…>P:ÇÂ<’<Œ–â6µ&H´JSß’‰
ò Nj*æhğ  X½¯Êñ°A³^T¤*pOM¢n˜p­¢(°„¨)€:ÄzSD¬Ò€v¬4’$ ëŒ+-°äæğ¬îÎ@lMáo‘²ŠéLëîÈ(óXoRœæ÷k¨-Ãİì0*'¿ªZµdù¬ê¸,.âmZĞ$pÉ¬]©%$ )*…";x †®çO 08ë/¸²Ú&‘n¯ñi0X<` ïEr^Úˆ£ËBNª*“‚a»Úód¶lx˜.®#ÆˆBƒ¸r’„â«ù'c¶®¨˜.,Zfx€Pà(D€a*2ì,FØ Ø
áDĞ" ";ó-p‘"¡yŠ)™¸Ÿ9&˜¸,Y0Œg¨`(Nà`´,A êAøZP|V¸û¶¨¶Cy•Pí
…=¯?R˜l¥¬ïTq*"S"[  Ø. ˜¤¿²xâ À,"(‰Øg¨ƒ'07.¤Ã!CõqMbƒÔ0 *¸‚ ¹ K%¼é|q"p¢ò±Lï7Ü&‰:è4æ«û·8jô82w
©Äeƒ…¯"JÙ06ò‰5äpMf²^z×.àÆSâ=¾ÇÃmgu’$Rm"qoA 
Åph7o|c9A±zëkaÓ­2.{ìëjp,EHEg×óá`~âãÖO¥ñøe€áŸbIW,=	H’È•
¤@°3C‚Ä$’(Á‡2ih  †0± ª	šB rtDàıñgÎ¤ÍôQi$çµˆ±§r^gÒ7„)*Édj ùŞ2DÆ 0aû³¡:\ËÍcêÿï;omÉ°·7SCƒeÒ—ÓO/kü:Õ#yfdCñpğ9LëüÊw¦gTâÿD’·ûZM²S#ê´h=²%í¨¬6S°¥:bEnÈŒÌ`á|aãfp$¯Vn{á°ãs6½gâ¤J ‚Ø"|2ØäeÔZ,CÀ6;íÎmŒ"—(QIH )Œ Â=&‰¨ 
•­ó×¼òµ2`ÉÂY–üÎp„UèsüDß J €#à	èÛcòø$%Šcf±QeÔçA\äú³½ ÃYUìõp(=5î*¦„Ğ‰éaNĞ)€j'é( ˜”ÿ„j„l$("3 {J+:•-6¯Cò­Î&$–;Íê§TÇÉ ( ((( ùÉr(k\5cc0ª2†Ä Ä&q)(ğ¶,] .P´b¢cEd °‚D`*”)"IÚ!#g²"è,m9,F 6>À|H5uc˜(;U$Ã(¡‡xø¡; §º17…*¶²Á°.všev3 İC((,ò@F’ˆ. ¹(˜c«$œˆŞ"Šq¸§)t08Hd"6s%“¢ß¦iZv©P©0#` H`È`áÀ*[.”E°,…8<!¶n(ú¬]O
™Øò*Dx HA»d­Æ=ªëúƒºrÜS
zëq& :T+6>µ=>¾I¤6>,2te  &7²dî¤p0@K)9Lrrä8ì. 9 JûŠ‹.ÄÑ65Ty¤/r„æÉWŠ1Bß(±jâ÷37«‚')I˜ ‰a(¶Ÿª×#ƒ* 1°C¥E;d	ù¶ÁîÖÔ1)¸Æš8  Í9!:‚€ó¨ßôuh@oP0	Û¤*[)ÈèOpLŠ3Ä+ø«¡	*ÁÙƒĞŠ £:  A(©4gXş@bÅG¹8Ù+wÈL’,‡xî5dì° ô™&Û äƒŒãf˜ ‹"XòKìgÀ@ä;0¬¹­¸˜ªüÊ ÚC÷!ˆ ¨`Pd±¶»Zpš”^ƒËÉª €•+€¿ ÀRğ.;`£ hfSvF*1ˆlA"÷¬
#GD+¨1R½ 5HïIœ+•)«4{- ŒãØXƒbuöXÍ DÜbQ‹´VDvãò;áu|@„û¸å;…{Xùü±> 1ãÆ|ó¸´Tq-5çlŞ¶=˜ÌmGjyo‹áß„}õPÔÃò4¨gş<;AA$†„JÚa4<2ñ'š¾x‘c’h‹Lm…åG­6mğ¸`M	ÍiGÕ9m2À$ÑLÄòıb´½Š¹äMÍ%€,¼lüe,÷åğ³k© Ï:­¡ª!gºB¿zävÑåîCzãùÕ/Bt@aõvxüfGÃvU¨°‰ƒæ%1M–ßj Já¿şµómJ$òm9@÷F´–cz™3“/ÜhøŒ~8ãntñ/9:°dt“€”Œ‡¸yøài¶2ãıSöû(–memûzMW› œ…j¡áFÖ~o¨#`™&üÈ4ó‹	ë¼g¯ßç¶ë3ÕGï`[=Œèôn‰¤'§A„³¨}V®Ÿd~Gê'æ
&éNs–RÑ ¿"m0Ñÿj¥kàpoÀ+¤h‚`·C;F8î$¼vÿ)âÆvÎCV9sŸÜŒhäá¸*¹8s
‡¤Ñ¤J6¥÷dNªèí2³˜æÃgqò1ù O(á¸	=d‚t2`e²§Œ‹(­Á#|¥¬~t¶æi„sRÊÉ÷Uæ;J¤SN—ÑNÃ:ƒôøi[^cÂ”4¨*”´<eíe4%¼BÄiøJµ1G•´Û[ gtaÓ8ËE†ÂKxÂkxæ¬ÉˆMk«‘Óí5¶SãhZö[Nx#âÂxåê±HÅ ¿` VnÊ!aMòä†)4q]m¯ìÕÿSmuÔgËH„ÒÔ¿7Øp%A;A4”;NSªàX{Üq	ÛÂI÷İqÎe\~u˜jæ,Ú4âe¬(ü.!\tæa#âÙWën»Å€Ôko"d»nˆ™4·Euì2ç¨M#BA"çK(—¡: ÍUxgmi=§ç‘x,óFéÁb—©ï­7cVyú”«xH+9I©r¢gT)è,&s\k6o¸€!BB’ôdŞlµMÍ^ê(?e-ë£³(9) rS‚Dj¿šs˜séÓñ`qaşwXyömúÄÌOõFV2K};s
B?„ˆ=^>íöÇïè1##i“ü%`/Iş;Àª¿e¾qFø&¾dX
|ixŠ{	¯l„æöhÚmıÎb.nËjk–N+óàØÂª†´’7íz>É~äE1Yahñ+¬’êÚ%hd#1o|‹ó¦R"™¯×*1£I}Áºåš*2X‹¨¯hnıñ‘^'be¯Ífç,§ÏLqç{eeèp ‹´)?)Eaƒ©
û\”V)İcëªE¿'òKÑ\%Eo¬pÃå}w4Çõ]şá{üÄ+5ˆqÛ¬š×ú¡=ùdb5k€£k´BâÃ.`;¹¹$g H;ôçmğôñ;ïzÙjCL
¡ÏEşÎ—ñTãoÎvU:ì‹L‰'Áñês„]÷dü,9±Lyµç<¦
‰¶É”±#®rœ`LïyÊåê]Ï(lÎæc"C˜U‚¤ÅòïÍ c 9"²xäo\õZ
bæ¬'E½c—b]KvZVĞi5©Úy+S!`x>ƒq`¢|ß½J‡uó5oXË…2b±E.~åÿĞs<vÚ®»lƒOó—àm¬º`Eµ–0Ç+0Hä&h|Æ]é6"JãÆZÿĞØïbUäSÔo<-gËñ	.,€,¡üÿ¢©Å¢2;ãëšTlÑ®OÀ[ÿÙpf'ÆÙ¼j¦cÿn+”äëe$&ä|†09p“%ÔJò‚ª0K!±möCêÕdİ}û}Œ»Åƒ†¶¸“³Èt!kï¡ÄÇ{ó7ëõ«¢¢Ní§?`-§i@ã.,®ç†ïãM_YÁX´Õnâã]İ+:›¦ûi£0x*ÎîxS!áÛu“v< M»<§?UÿĞÿŠæÜ‘ú³/u:Ü©$uYz‹Ô%p5ÃYU†E1¼nCaòzN4$b‚¼EpÅCow’n´áZñå'dhıY‹i^i€!ã„(UØ|´D>šÙ›lÊAúS‹7£@â|ëIÂ¡ rq§*Btl7î ³›Ï€’+‚)EÿõÛ
zZµä¬Ò(8Ğ°±öY¸z¡n0âùO!Y)Ï¨Ã%¬>g²Ás„œ>²[vi+h ˜eÒ5IŸ"b-U åá©¤k§Ûà™Ân`Y$)ÉI-ìPáåx×K>®¦.<È’B`ÏW¤ù°7(rn\™9FÃmñl¥aA”5¡ª›¢3,‚÷&!F(cÕ™î_C£A2Ez‰>FqN¿Qmç{é bìcîápüè2}¥ey,ÕÈ¿?n
6%N	CaÌå`¡Íä ¥×2h Á ãö"\zDoCfËÕé6:&ÙõÀ(‰•©`y\"ù±'ˆ¤1æ…ÃqøæµæOerv…zåv2ñ¦ÖOa²ÒgÔ-­š(3 A2èb @÷UáSÙd)¢{Foİ<°àÈ"J1af{8U
¸ò@p« xæ~¸seğÂtóˆÜ[­wŸF,êÇä|wŸ}iÅw?ÊDSÔ#/İì˜c©h¢f·à5uş©éD#S»loníğ]E´ïq­)g÷²¨g4«$öø ñœ^™­?JZDrQfRÍg8-‚%xffkæRY4ò|"åI7ª~_tI’’œ¼9ôä0 Œ €£ÉHà¼—¸VÉ -©u¾p}oÈû,‰ä%u/¤Æ) Évàf/5¸*4Êë¨"°RàViª-¢|KNã.ÑiXò‡®’¢Õ-bõû}—=ş9NNP6ñè}"u*	XØu` §fÒ8Š§R"Cœ|&.–BNa1M°z€Û+b)OŒaßìE[Y¤fwã(¤aú$" èq³A{ÅfàÈ`}0L\DX-{Yà 2ş|!0eªb‡-@‘æš5=+yQ§Œ!jSä  ûyµ­’=^'å	ÀD"ø]E–Q¤ò½ŠôéàoTï$:ÀÛÄ]Yo"P^p:­Dxf:ÎîJã~*±–pâr†FŒº1”¢ÔëÍ&œ<÷ÏdV)rL9B‚ib-`®äq=eT¿Pn.	bhëZ/?ör€O“\à$kÔ*š¡'sXI2a‘M]a´cóÙÒ
«0«-"„ ®G0zLˆcgÇoF/"H:—Ë;Íiíj›¢}BÈqÖÔ˜ä¸i¯íX;ò-_ÒjŒnˆ©#4vC_m"4í‘œK{-=ºeïÅ×ƒÇQO{D¹”R7¢'™*¬O´KŒÙËä*Ã“X xAhmMû
}Ñt—0[„sãº`(g‘âuÊ-yœlühşG%*üÑ;Oi¦3Ä<	k”†Èrç@ƒWË•záÅéíƒ°eG\æZ:GzNb‘œi`¤U™@ ®®©*
kAm‘åÂ-ı)1e[ª°Å+ïb«sqó.võ<^ºäoöà­™$¯aZ‡ë`æ9ß<‹"
pq(Ù¯Bs {-Æà%ìodêM™'Ã/¬	´¿[ÃÈñäÙUóJL9Ÿsvz+JGXë+xl#¥ˆH00âJ ¤FsÿPÚS:$é°‰ekå…T#>!c]
`Ã3µû¹>1È¬4E	œˆR\ …D>B1YôcÁ}Gr	dsÀòa•!öQé2^èäPÔšôa$ã­‘ñ_kd"àhà5à¤½ho-#m`°b®ND(C¡õZÅÏ¬ğü@eØd’z7Y2qò@ÓB_ò€¥iÄãˆızlM
X9.4G³nø)®+ö5dyQp‚ŸQX<"Ò Ö¬¹+½AI1vG<ù,3€+_!ˆ€etzöböaàw±=×Ú©´}Â²( qbF bE‘è-h²!İÕ~íËbÍ
sdfœöm$@ŞTÈ>¡äÙÌáä~}jè´¹0$`$l¦ÁôøLºóés–´E¤/{*?LÑW)©È^N÷upòo"0â.ˆ0)$’—ÏáÈŠéj"=úî½¯³bVQ¹UÌ–qGóÌí¤tRi<QtQ0ƒ-8}~pcµ+#"°#P6Å‡!!ES•Ÿóîp/óÍ>e+iR6[¶®lWµ0+°xei}Te  `ğ[pí$­pı`'.Ñ¸/í§)1%–ü!|rùpa(Zè¨š Â(45wAÓiNqv&6eQ0-œ³´fbåô¤7†ø=©d¥…õ((}FqA`m¾"`Áï?ôPN”Ê[sŒyzc¨g0÷0oÒk 1tn<äw£ æòyLrÄ#$Dkr ?—¶E1{\Xmë‹A) p?`1a´2ÃcâNqXŒJ?htşD%¦:Eä.Íÿ3( aï©,	UeŠA 
#¯a®;‘lAC7t¥şé\Cu÷=Â6¥Ğ¬tØ €·ÙT÷d]má¬gBD“¥tÜ?_"-~mè™Drñ*Å`bO93¼o +uNğ`aï„kós”"šlşe ¯K!o½}O\¼B#	xß\ ÈräÜ¥/C B`I	¢!Kl$PÑàY°f7‰º—`ŸdAa2k N¢‹7” wLQAÚà&pñ…x€½¡ïHp$[iı"f&õ-eº	,&şü3t«²(Ù0eeôaar|Ãa¾ñen%Åıx©€ R"±a“PàO¦W²r+yK¡t}o™Y:tùG>äªŒü=’pâ2=E5üb¿ miy	©
ı°>rGprĞ/Å²ÜpÓ ÕmP\s$¤ø…p•Üc…=æ¬£+‚%Š ®")VÆ{uPukMTemVeUµ¼şÉ0TkçRSe<f% §´$Áu~`Tá¦Id41 ×ë#gøcˆhÊV.´}@™	ú‡q
[d*"'\9pa©Év4*$  ábÄ5`{ÔK³wZbø#…Ø±wÒ§Ã ø&à&5=hÃÀ å 3Y­]ÍÀT â9/OØBf~ğâÉù^ğ&´•W{9äª³²¦tñ5à> e l4|àut•5!wò-!Q Œl/M)t—`v&HkñJ u,'·;\çÎî:ü%×æòŠÕ`&©e)S%<ğ(Í¤M¿3b!UtnF/<s·7L=¡Dìkwÿ=ñÀMğÆÀç¶¿0éjOK†<N¡Zõ(,D$v±@!p"&eh4iÕXxnjöÄrÚ.¤Tâ|œö`jõfø¡b‰i(œÏ{ñŠ3}%º¹\f`i[5ÿËQBgh³=c¼Å)fhwRLW%(OòÈ7xä¢ ¢Ä#è U=*9%üwp=eT78h0$©² 0Qñ{“² d94eS¨nËÕ/"ß!A[aâ¤ølùª:…g¨Ù!g(*<ù|ıé%9( 4
_”&i4B`HVA}_<UŞvO4pí&i9w9vî¶Õhxù]-HJkPY àî0*Ó±n-apêcaxlY4o™A$l«ÄÖVz¡2ñyŒ­†%&íaKä šäy.^Ìd®esÙ›*5Ä˜u`V*3,L>¤)L4kp¿a©xk¸ v=ÁÜeqaà-ø=,Ìi"hU×í†1½¼PM9 ĞÔzsA%(š÷1¢$i†ë&ô÷e“-`-Ua=n*¯a5èBìœFeK	y$AbÀa]EysUx òrGÊLóx^`t£lj
a:ìvqO}p³Iyeå¥­UsìuÉP¨jF9y;vuà…uSbÚEUsü?(pc@NälšëY.Ëä5q@SğxU4è5/YJ$"Xc÷å2¢|ecVéRªhæZÎu5,Nù3á"<‘°w)lS­I‘PÉ¦c"+C P­` D.+êIm+ |}ìt,>øºË¿~,¸¥ìXT¥Yæc1pø ó#,+-ù1ÅÁ–ne}'À®zUÓ&hóÄi=-v@g©àWı§]†ñ(Õ¢Èp&5¸£LN¤*Aîÿ}°>l¨`2ßX9«A=Bú” l°_¿/iƒO³#¥O6^zÀ‘•tBş"¥eŸôŞ•Y°€ú`qF7ùIoÀKzˆbm$:pEJ­dü~*3jxy±eëãxE*DÓb‰¨¸ÄßÍIh`®k:ğ9… 1mŒEdc'ıÄkÏ Imc¬&dûNnpŞu[Y4Nïæs´êfÀ*ÉL<ÊQîqA&£è@Ö4¢dkÎ »Dğ!zljq×1KTm>vÚÈä%$úW\""|k(h•[¢e©tÁ©Bpy%éºn½{lOtÂp1á(	u[<Í!w\	-Dîh^!8§”`#€![W9Ub$ *kb¨>ì¦Í°Â..` ŠlI’ó{ 6±\qÿP>Á`S1 !j–8³<r 0p8¯¡8u0Ää†4Gà!G"¾õ–2°*U!+¨U…VúŠ †j">qt¥ëeD³{š)¥–m®åoWÇd¥6r(Ä:¡ R´»»İ¼uaµ$7 — ¨' Gm7 “U¹4Kôè.tbàæ¢­÷tşã•™^ò!iZ=i~º-‰‡?¼æ°Y€¼ X@bDä`ß$GæªPğ-oo7C³²İã l	x0õvÜs>X£+ 	á{¥Hàf-—ï|ú°ß é‰N!5(¢µ!× £È‰ªñ$üD8ú8{ribâ¬ht`dälUfÿ8öp›'‡$æe ½ù¾sh%#úNç¯r%yÙUMm¡s§İC}dt;5<©]Ÿ£Îó°{Œã$¢çŒ WéÑ(p83uĞ‰í ş6½0Š´eÈºï!aDc 2Ÿb)S]m0cÓ+eÁ â àRR€c`;„ydbÄE²cæj½ ?*¤à ·svœ¬1/ía¨¨•NLc¦eã $iÄµñ”V$x˜N÷ZŸ`URS¬hÖxëC|§–M5ü½s_1råµÜEêŒd7‡uÍy8ƒxvi|aÆi,¨·;…sçàÁéÖN&yø	#óê±"huk"bscr=w$lÄ8D¼H7&f=0Å!å üHŞOéÆ`OKv¡qrvfZf"!¼P~Hµ@hSh$ %d¢!@gBuéQé23­®ûkÒ*sîù{Lg$y¤S)Ma²~F@`$ÀLar‰$6Õq4Z(3`8¸@¯ôkL Tc)Øàfm;QåK°.¤U2ä£Aµ¡iá‡ílD³å¼ k$ÑÅ#÷\m+!
@å75#wüÒİ‡“€0gÉ%íí4eq3}¯(vØqõ $&u€˜â]8%ÖSô5$c §0Ä$¬¦´"9`Ä
a-$GÍ¢U)xMa·fï]k±ÕmUôšlã2†P&%cqïQ ˜GÙd6qvå2=pND·Ài!¶pÃ&ü“768±¼ÛËø²(-fÁQ|<ÊN1$‹84rñúCå$P")pgS`éõvO¹E) ø;xP_<4·U@q	¾B-	6¼*0<°s0ÛL;ïP%ykçóeõ¼øoPFAû}í3Â`è½rôhª
è à2av4 FjFiTnmJ«¬Ó]1W ¥^%¸A $µ¦0#ñ9ñrb \[Ùpm!Ú~ìfµQHuŞ$D2<2¾
I½Fá,gšMƒ]´V²pªm*d#,›3< 4" U5$$05ªğåGÈHb$`Æ,plm]!1rárÀpîıœ9!€±h hgªea•‚©&ôQÿ4Äb Z1./z9T3t+9Û$3¬$x3e$d
ufI’E7Ü/¨l	$YÅØªQf8J¡Ï7`ç»®ó|¼a<ªo²°#1^,( `Q%· x <°Ì 1(pÁÂK~l)|¥Eı½9¤)qU\*2~D0zPô1
$†2´Ùµ j0½µzL¤y 4Xh1Q  ˜¨5]d#Jõxw; ä Ğ`J@ÎQ`-Z›$e$°M|ØlT0€Ì¶xi}Ù=0ŞÔ\h9 iæu9ø7{ =¼nbo{ZaĞræYzN˜™ã2mÆpuà­¸G´¸¡*ÄÔ`&ÄM¨bwå·¥` 5¡’S#êÀ~-rpNv35“@š—µ¬4JütD‹0˜¨k}•f´«W'Ê
: $È ø	Yó¹-54ÙJĞ. º™Ñ°$"Š0eV1„-8¥.l9&Dpc%ì²$	àı *À$}rs$05)a:*1™9)'!Î¡“¢eÓ,$ªõaò`€A¯XD+Å$$ş­´ße	Fw%Ó;Ñi!&¤U%Ñ¤\`H±8¥`$`WBk3°2pr B(Mô
Ù¨4·jl: 8íAá’¸"¤ó¬R0]2´vÈa=¢ò2KH +"äE¢+­†g07J½¯1`0(Å=J°`ElS8±>[seàÍh÷À±Gd±ªp½` aN(d 1<}zpc]8!K[Æ89¶}iø…>ãx¬$VGiz.@²ÇF8Å0 ²ã"5fK0ëVŞÒK¢Gîb*çh,¤$|µ¯ØÙta6³}\¤
àjİ1¢€f(p½`00d©l	„rîsyD(¬Óv¼XW¶ «ck[Ô­°ÀU ùxbÿBdàoQğÙKéMëã3Ï¶)±hèP<å…÷í­-Àla s$»ªZ nà†ê<3&æm)[kS1ôÉm)}fh)c]0yptu¦+×{e0=© o,²x&î-ña9^?u&{Ur^yPf£ÉcNº2“e;Ú÷lD6lx®®+‰†ù˜r;0RjëTtáB¶.ª›!n$$Pw)ÜTñlEmh¹L-lÚ€À
åDĞ@©"½Ñ`XÑ“¢¡Y+-™/{‘æ¸¸,'0=Ìg,UP(`%ôˆ` v(CàŞAüP}V¸©²1à–uY‘•,í„=^{P|¬>_Ü`(MK*kX  ØL¾¡8 ç¢x¦É¤"*Ù
g¨¡b$g.c4â!õ1I ]Ü
/"¼‚8j ïz$´ñhñ xbZâŸ  ]/Ş&	%r,6Â¹è·<ÜJÕ¬r_
))Àa ”í¦J0õ¨2R‰€³ì°l°+ó.@$s =2ÇÃÌwuC% í#qm,S 
Epa7oRb±e»{é+`?¼2,kä® p iÇğq º`>¢à"K¥ñÑ ( àbõ @ h’H¬ °1C$Ä$˜hÃ‡s!H	¸Ç8º7ªMÚ#"ö44aı1&î­BÍypQ-dæ=³â:"gœ © á,^0YŒß6D´+0tß§+ªxá€cª¬òè8e-ñ°µ7AÅ óOŸ©ü°u#¹,Áplápì;	[”ş"/£e]ê»4²“†szi q#ê¤(5²1 ¨¨15s¤¥"bdoĞŒ¬eh8q‘!tœ0»r®.a°ãc?ı)b¤”@åÀIĞ tr8Ä(e*ÄJ T¦à>{íÂm¤   Al9!Ú<S4©ø/­·ŞœÖµ2a+‚q‚Ü®p W „èsôeK `j€1$ì Í°Ño€²z cv•PUÔ$IÌô[¹
 &iEì¤@ ¨e7®«$`©ã("õ)ˆnI  ¼•w¤~„,4>csâ;J1:_•,Cò­î$U «éó§ub 9)€(¬(P xÙrè+|¥Íka¶ªzbÄ¡WŒ$1+(ğ.œ]&
0nDôb¢" y `*”!2h#Øa!ç 2q,m=,Õ0w?ÅlX4]"ø(9Uô<©Ö|}«a ˜%•±%#Ájï1Á°.ÇL›Kuw3¬4ÿãx),ú\D7¶ëiù( w+…]¦"y7ç@-t6)IH*­6s1‚  ‚i[wğW¡´'`iiì%ø`ÅArÓAÔEğ,_8y!¦s0ú-.çØùjd{°k!t?­q²â=¬kø‡xzLpàq0°ct"w>÷5ş.É 62Ÿmfat_¶73"Dqî¥ø%XY)<Njs¤=í6&4= HûVû8\‚Ùb7TÛ¤#XğÄåsY‡=b_3fà}% 12|Ì·)i8(‰Q9·‡¢U+N q°O$G#a!í6ñ¨ÖÔ5  9:Ş $¼=`—.‚ğõ)U4dÁkX1Ê¶"™iÀnpÄH†5ä`§¬	:¡J Ğ‹¤9»2(!Aû(6fE4¸DAÆE¹=Í+˜0é@	Ôˆ7x¤5bÌ*0Ô¸4º$YŒ"n8²OYğO¨FÌLá;0¤ ­8®ş*pgñ3¨'Ôè`Q`±²¹mZ01š°ƒi©®, —/ ¿©rà61i#¤het"k¹>ìò¦¨"áOE)¨0z½9,/A¸+•1,y$$,K¨[#pu¢tI¥TÔ"‘³n6Ã"ñ<<@¬»0u#yx±[´1ğ>
9áæ} ¼$\q=1Æd×¢>ˆœà.j(-®á †µP4Cª$°²|İ$ ¤j¬Ze 9`ñ'0›®p%QyCyC%T‹L]á8­4!t(@\ùt-9l> ¤İ`„Ğ¹r´­‚º¤MM 4 D?)(rà°£v¡®m¤£ª!.:@¯tdrTåf°ljäyÕ®N0Htfx±fc bIP  8‘ë$1M×ûjdB„à¿ê<bmJ$3ğ)q)·6#n93“=Ê&é(j9£.tw09zğ$tƒ‘ ¬³?¸xh¢(¾2ãq|öúİ<8'nLW™€­`4m`„R÷(#p™|aùè0â‰	ß°g®Şæ4r§Ô‡©r±”ÈôÍ”­$0%A„» x[7¾;l6WJ£âB+©nq R¡ ?ƒ|°àÛ+…zƒaphÀ)¤!H`!N59d8ì­$5&õœxpŠt,ÆR1 BÌì`á¨)p3:õÁ,!7J 5ğ¥ ¨á*í “,fâ q¶1G(\a99D‚v2bd  ˜êaåÁ #l¨?,T2¬,)€×àY½Š»œ¬u—Q@Ãº£8  \kÂTVhÈ"”dm`2-¶6Jd)!¸~¥m‚Ô´ÎKh$’}7`Ó8ëtï>Ò^|ãqaí-ÉIM¨!Ñ­ìQahvzL4!æ!xáK³R7ÁGc?F ^îN!w6e1>-51Té¤ÄÑşWOtôiŞH„ÒüxŸwXq•}ïMAL%;C[*¤PÛŞq(ÃÀYı™d—n%\pej"¤Ú6 =ç¨,ìï|!P\æ%a#Â™kál»Åg<c;v&»fh¤Á™t7aÑvó¨e#Bp5öçKqÕ%G2'Yx'aq=£æœ88° ûDb—©î½/ãA}ª£,PH;iÏ"ğ† )¹ë$61^$g¼€ R’°`”u=Í|è`;e,£q4!-€b2œ (+?¸ø˜sèóñ`pa:~qq6-ø”ì…OåQÖ"I}1s?€ˆ%|&î²âêà1!¥x“ü5 '	,;„2=U¾8&ø8G€<(8‰}Y§`æ²@r`ıÏ­!"g j*´N+ÓÂx@š‚¤€1¡:|<é~$-Qqxpk¬’ºŞ 9€e"1e\‚%"‡B™Şm3j)#)9i¨µŞ*;ÁX}ïH,m0¹Bb%£hrâ½'îLr q	-1¨,ƒ.°¡?)ua¢(CDûtF-Qî¯ªe½†¤[õh&DN 0w	b%xu4ƒ8qzà!¼ä%5¨qéœ›×>%8ñhb?;€£a4RfÃ>`99¤qX8¤ezmğe©;nØÌjQMëyq–äH1é>İô@2, ©"áğú1 \àqô09±Yµæ4¢K¶Á–¹+¼2½ ^ny í ]©hf a,´\äÎåòhIÄaX89 “|áå|µB	C04"E¡cåxt i1Â9. h0¼ptª~İõT'$”û4oX"…*$¹a&tµ Ğv6&ò&{è¢…¸‡p,¤™h—”°ã`4I¤6t|l
¡" 
	¡öXüğÆ® 5äSpô=9<ÃCÓ/p,	ºö¡©„°72	 83bé,õ¨ohZ.Ñpf'–‰½`¯bÿH« d*ì1&àı"00P³7Åyö°°è°o%±,´R¨Uds«|Œ+Mƒ ¶8—sÀtai¯ „¤xs7®uª§¦Gè·; (%§m@ó®0®å‚»®çS1´,nãiT)>æ{i#s p+*ì(Q ¡›4f’Ñ]ª<£º …¬q»
àÙ•ºó&?ºİù4ÙhaÔ-p½õÙT†A°f1÷˜R$à&<E¸ÅCmóÂî´¡ZõEeiIõQ+k^ìdò(QÚp¸F:Šy©>¢Bi‹»à"xûYÖ‰œ ay·
*b  7l²7ç:SLNƒ*Güõ_
ZZ·õ¤Şª9Ô01ø_58é`Xˆ43c}]EI+´€•03/v'rÁz0äƒ/>@0[wmkx3»gÂµO—rjhÔ$çá¬Y%y¸›‚f`0d)ÈLlìp¥_`YKz¦®f=hÒRrÏ ú°7(ln< 29VĞé¹hªh%3*±">&ç68d*juØb}Qãe§EúÚ>V­NŸPmåSùbíb®ãpı1¢äq(ÙÊ®‹,(6%N¹BaÊÍh!	´"Ë5%h¨À âô 0:D?cx<h7>7Xô	µ c9š| à#±/€¶!º¦…Ãtêö. ô˜Actf”<!v"ø¦´a.Re,Ô,-4*7yA0©j  ·%4Qxd!§s&G=0ÀÌ0~1ab‰s9J¸òLp¯48æV¤sdpÒtñ€q°wŸ8`[d|`½ıuá;Ö¬EQÏ"?Mô˜Ï©è°ï³°4µ"ò©aÄ!4»D;lïø,Ô´ot«,µ±b©l5]*4÷ø¡ıŒ^"œ)5b_DôvœQoia((¢Ix..!lr]:s< ç©^2t(Rœ­“ä„*Q a¬3 £éHà$œBh %©w¾p5,&ˆ;“-™a,t­¤V(ÀÉpäg>ui¤0Îc8"0`Rù"%¢Xgbã®¬I
"Ø¦¬‘¤§„Õ=3Õºw¿úÈŞh\&õ`"1$	\1çp"7wR½‹æV!r¼^&$Œ@u°z± ›/d(NœœÁÄ$‡vµâ$deêĞƒ$""8ö“ ¡` È´ ŒapL€xz8  ²~øp0dªb´xƒfŞ7=2{R§¡bSdğ{x¥  !Ô#ä	@M2y|g†a¦t¹2ôa¢/E|‹%4èØ”©O&\p:®% !f(®$óh: ) pbr‚B)Úpœ³4ª/%œ<ı	d­#]9cms(®ä1-e‡`(‰ hù8&-æt m Òb¤(”) q|H4!‘m9%=bbÒ* ;4-·„a®gƒ Bğh  ï‡?B'&`4'Ë3Íy}b¯ ==fènVØ6ô©h> !;ò9ıKÊ$~¼‰'ô6)BW"ä‘˜hb%¸:AæA²ÅMK{10Z3³/((`_¬Cwy*å*Â7ø¡ğah-å0r4 |¯‡…(W„ c¾H(3‘"uÆ-y¼|¼ì¬f#=ÎÀ;MI¶5!m<08”JzÍ`ƒÙ•yå!´iá‚ø7æ?æZ2CpKbEƒœ)BpôU›È@í®‰(
ol›¤R*¡ù¡såS G*¢bãw`#FtÕ=^:ğ_÷â¯™mïîiXOÿ`æG5ír-ps y8Rwc?%EèNìn)*\ˆAñ,¶}OBŠ£ÄÕcBiºŸvfü)jdX(}@.¦hp=spJ.¤Dg2êsÿé.	ieO(e¥T
\#>!s];`ãmÕÿ9?qÈ½A$i¼ Rt wd6Bc‘(T#Á}l8daºAµ#òqh³Nã¬At ôaÅã¬‘q^}Ÿ áè`3à¤^= 'k!m 0æªK2o q^àI¬ğü@añdø²:2Ù6ñÁHCzş5%i¬³ íê!M
Ø!¥'m,F¨½®*t5@0aĞ0Ø, R5î®1#¹ueR˜veít"Ğ!!‚9ô8ô2übˆàw0=†™Ş©³/Uò,¡1bD
dd ‹à(2  !ÀU8,ÈîíšsDG¼t1
lÈ:¡­øî¡`\q np´¹'(&p4p‘¦püH¸0á2•0U¤/~ª0¥3ˆÑ×+±Ê Ägq1… ] 4ã¨2!pbbŸÍÃˆikò=ñî7 ‘bU¨Ì+Oñ ¡ q
<y—`˜T0‘2+"ylÎ`j «# °%`:µ•)	As‡$sä, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 0, 0],
                            [0, 0, 0, 1, 1, 0, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_dilation(data, struct)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_dilation28(self, dtype):
        expected = [[1, 1, 1, 1],
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                    [1, 1, 1, 1]]
        data = numpy.array([[0, 0, 0, 0],
                            [0, 0, 0, 0],
                            [0, 0, 0, 0],
                            [0, 0, 0, 0]], dtype)
        out = ndimage.binary_dilation(data, border_value=1)
        assert_array_almost_equal(out, expected)

    def test_binary_dilation29(self):
        struct = [[0, 1],
                  [1, 1]]
        expected = [[0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0],
                    [0, 0, 1, 1, 0],
                    [0, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0]]

        data = numpy.array([[0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 0],
                            [0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_dilation(data, struct, iterations=2)
        assert_array_almost_equal(out, expected)

    def test_binary_dilation30(self):
        struct = [[0, 1],
                  [1, 1]]
        expected = [[0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0],
                    [0, 0, 1, 1, 0],
                    [0, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0]]

        data = numpy.array([[0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 0],
                            [0, 0, 0, 0, 0]], bool)
        out = numpy.zeros(data.shape, bool)
        ndimage.binary_dilation(data, struct, iterations=2, output=out)
        assert_array_almost_equal(out, expected)

    def test_binary_dilation31(self):
        struct = [[0, 1],
                  [1, 1]]
        expected = [[0, 0, 0, 1, 0],
                    [0, 0, 1, 1, 0],
                    [0, 1, 1, 1, 0],
                    [1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0]]

        data = numpy.array([[0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 0],
                            [0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_dilation(data, struct, iterations=3)
        assert_array_almost_equal(out, expected)

    def test_binary_dilation32(self):
        struct = [[0, 1],
                  [1, 1]]
        expected = [[0, 0, 0, 1, 0],
                    [0, 0, 1, 1, 0],
                    [0, 1, 1, 1, 0],
                    [1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0]]

        data = numpy.array([[0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 0],
                            [0, 0, 0, 0, 0]], bool)
        out = numpy.zeros(data.shape, bool)
        ndimage.binary_dilation(data, struct, iterations=3, output=out)
        assert_array_almost_equal(out, expected)

    def test_binary_dilation33(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 0, 1, 1, 0, 0],
                                [0, 0, 1, 1, 1, 0, 0, 0],
                                [0, 1, 1, 0, 1, 1, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        mask = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 1, 0],
                            [0, 0, 0, 0, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 1, 1, 0, 1, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        data = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)

        out = ndimage.binary_dilation(data, struct, iterations=-1,
                                      mask=mask, border_value=0)
        assert_array_almost_equal(out, expected)

    def test_binary_dilation34(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 1, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        mask = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 1, 1, 0, 0, 0, 0, 0],
                            [0, 0, 1, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 0, 0],
                            [0, 0, 0, 1, 1, 0, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        data = numpy.zeros(mask.shape, bool)
        out = ndimage.binary_dilation(data, struct, iterations=-1,
                                      mask=mask, border_value=1)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_dilation35(self, dtype):
        tmp = [[1, 1, 0, 0, 0, 0, 1, 1],
               [1, 0, 0, 0, 1, 0, 1, 1],
               [0, 0, 1, 1, 1, 1, 1, 1],
               [0, 1, 1, 1, 1, 0, 1, 1],
               [1, 1, 1, 1, 1, 1, 1, 1],
               [0, 1, 0, 0, 1, 0, 1, 1],
               [1, 1, 1, 1, 1, 1, 1, 1],
               [1, 1, 1, 1, 1, 1, 1, 1]]
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 0, 0],
                            [0, 0, 0, 1, 1, 0, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]])
        mask = [[0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 1, 1, 1, 0, 0],
                [0, 0, 1, 1, 1, 1, 0, 0],
                [0, 0, 1, 1, 1, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0]]
        expected = numpy.logical_and(tmp, mask)
        tmp = numpy.logical_and(data, numpy.logical_not(mask))
        expected = numpy.logical_or(expected, tmp)
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 0, 0],
                            [0, 0, 0, 1, 1, 0, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_dilation(data, mask=mask,
                                      origin=(1, 1), border_value=1)
        assert_array_almost_equal(out, expected)

    def test_binary_propagation01(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 0, 1, 1, 0, 0],
                                [0, 0, 1, 1, 1, 0, 0, 0],
                                [0, 1, 1, 0, 1, 1, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        mask = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 1, 0],
                            [0, 0, 0, 0, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0, 0],
                            [0, 1, 1, 0, 1, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        data = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)

        out = ndimage.binary_propagation(data, struct,
                                         mask=mask, border_value=0)
        assert_array_almost_equal(out, expected)

    def test_binary_propagation02(self):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 1, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        mask = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                            [0, 1, 1, 0, 0, 0, 0, 0],
                            [0, 0, 1, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 1, 0, 0],
                            [0, 0, 0, 1, 1, 0, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        data = numpy.zeros(mask.shape, bool)
        out = ndimage.binary_propagation(data, struct,
                                         mask=mask, border_value=1)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_opening01(self, dtype):
        expected = [[0, 1, 0, 0, 0, 0, 0, 0],
                    [1, 1, 1, 0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 1, 1, 1, 0],
                    [0, 0, 1, 0, 0, 1, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 1, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 0, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_opening(data)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_opening02(self, dtype):
        struct = ndimage.generate_binary_structure(2, 2)
        expected = [[1, 1, 1, 0, 0, 0, 0, 0],
                    [1, 1, 1, 0, 0, 0, 0, 0],
                    [1, 1, 1, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[1, 1, 1, 0, 0, 0, 0, 0],
                            [1, 1, 1, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0],
                            [0, 1, 1, 1, 0, 1, 1, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_opening(data, struct)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_closing01(self, dtype):
        expected = [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0, 1, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0],
                    [0, 0, 1, 1, 1, 1, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 1, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 1, 0, 0, 0, 0, 0, 0],
                            [1, 1, 1, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 1, 0, 0],
                            [0, 0, 0, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 0, 1, 0, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_closing(data)
        assert_array_almost_equal(out, expected)

    @pytest.mark.parametrize('dtype', types)
    def test_binary_closing02(self, dtype):
        struct = ndimage.generate_binary_structure(2, 2)
        expected = [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[1, 1, 1, 0, 0, 0, 0, 0],
                            [1, 1, 1, 0, 0, 0, 0, 0],
                            [1, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0],
                            [0, 1, 1, 1, 0, 1, 1, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_closing(data, struct)
        assert_array_almost_equal(out, expected)

    def test_binary_fill_holes01(self):
        expected = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 1, 1, 1, 1, 0, 0],
                                [0, 0, 1, 1, 1, 1, 0, 0],
                                [0, 0, 1, 1, 1, 1, 0, 0],
                                [0, 0, 1, 1, 1, 1, 0, 0],
                                [0, 0, 1, 1, 1, 1, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 1, 1, 1, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_fill_holes(data)
        assert_array_almost_equal(out, expected)

    def test_binary_fill_holes02(self):
        expected = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 0, 1, 1, 0, 0, 0],
                                [0, 0, 1, 1, 1, 1, 0, 0],
                                [0, 0, 1, 1, 1, 1, 0, 0],
                                [0, 0, 1, 1, 1, 1, 0, 0],
                                [0, 0, 0, 1, 1, 0, 0, 0],
                                [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 1, 1, 0, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 1, 0, 0, 1, 0, 0],
                            [0, 0, 0, 1, 1, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_fill_holes(data)
        assert_array_almost_equal(out, expected)

    def test_binary_fill_holes03(self):
        expected = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                                [0, 0, 1, 0, 0, 0, 0, 0],
                                [0, 1, 1, 1, 0, 1, 1, 1],
                                [0, 1, 1, 1, 0, 1, 1, 1],
                                [0, 1, 1, 1, 0, 1, 1, 1],
                                [0, 0, 1, 0, 0, 1, 1, 1],
                                [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        data = numpy.array([[0, 0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 1, 0, 0, 0, 0, 0],
                            [0, 1, 0, 1, 0, 1, 1, 1],
                            [0, 1, 0, 1, 0, 1, 0, 1],
                            [0, 1, 0, 1, 0, 1, 0, 1],
                            [0, 0, 1, 0, 0, 1, 1, 1],
                            [0, 0, 0, 0, 0, 0, 0, 0]], bool)
        out = ndimage.binary_fill_holes(data)
        assert_array_almost_equal(out, expected)

    def test_grey_erosion01(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        output = ndimage.grey_erosion(array, footprint=footprint)
        assert_array_almost_equal([[2, 2, 1, 1, 1],
                                   [2, 3, 1, 3, 1],
                                   [5, 5, 3, 3, 1]], output)

    def test_grey_erosion01_overlap(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        ndimage.grey_erosion(array, footprint=footprint, output=array)
        assert_array_almost_equal([[2, 2, 1, 1, 1],
                                   [2, 3, 1, 3, 1],
                                   [5, 5, 3, 3, 1]], array)

    def test_grey_erosion02(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        output = ndimage.grey_erosion(array, footprint=footprint,
                                      structure=structure)
        assert_array_almost_equal([[2, 2, 1, 1, 1],
                                   [2, 3, 1, 3, 1],
                                   [5, 5, 3, 3, 1]], output)

    def test_grey_erosion03(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[1, 1, 1], [1, 1, 1]]
        output = ndimage.grey_erosion(array, footprint=footprint,
                                      structure=structure)
        assert_array_almost_equal([[1, 1, 0, 0, 0],
                                   [1, 2, 0, 2, 0],
                                   [4, 4, 2, 2, 0]], output)

    def test_grey_dilation01(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[0, 1, 1], [1, 0, 1]]
        output = ndimage.grey_dilation(array, footprint=footprint)
        assert_array_almost_equal([[7, 7, 9, 9, 5],
                                   [7, 9, 8, 9, 7],
                                   [8, 8, 8, 7, 7]], output)

    def test_grey_dilation02(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[0, 1, 1], [1, 0, 1]]
        structure = [[0, 0, 0], [0, 0, 0]]
        output = ndimage.grey_dilation(array, footprint=footprint,
                                       structure=structure)
        assert_array_almost_equal([[7, 7, 9, 9, 5],
                                   [7, 9, 8, 9, 7],
                                   [8, 8, 8, 7, 7]], output)

    def test_grey_dilation03(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[0, 1, 1], [1, 0, 1]]
        structure = [[1, 1, 1], [1, 1, 1]]
        output = ndimage.grey_dilation(array, footprint=footprint,
                                       structure=structure)
        assert_array_almost_equal([[8, 8, 10, 10, 6],
                                   [8, 10, 9, 10, 8],
                                   [9, 9, 9, 8, 8]], output)

    def test_grey_opening01(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        tmp = ndimage.grey_erosion(array, footprint=footprint)
        expected = ndimage.grey_dilation(tmp, footprint=footprint)
        output = ndimage.grey_opening(array, footprint=footprint)
        assert_array_almost_equal(expected, output)

    def test_grey_opening02(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp = ndimage.grey_erosion(array, footprint=footprint,
                                   structure=structure)
        expected = ndimage.grey_dilation(tmp, footprint=footprint,
                                         structure=structure)
        output = ndimage.grey_opening(array, footprint=footprint,
                                      structure=structure)
        assert_array_almost_equal(expected, output)

    def test_grey_closing01(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        tmp = ndimage.grey_dilation(array, footprint=footprint)
        expected = ndimage.grey_erosion(tmp, footprint=footprint)
        output = ndimage.grey_closing(array, footprint=footprint)
        assert_array_almost_equal(expected, output)

    def test_grey_closing02(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp = ndimage.grey_dilation(array, footprint=footprint,
                                    structure=structure)
        expected = ndimage.grey_erosion(tmp, footprint=footprint,
                                        structure=structure)
        output = ndimage.grey_closing(array, footprint=footprint,
                                      structure=structure)
        assert_array_almost_equal(expected, output)

    def test_morphological_gradient01(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp1 = ndimage.grey_dilation(array, footprint=footprint,
                                     structure=structure)
        tmp2 = ndimage.grey_erosion(array, footprint=footprint,
                                    structure=structure)
        expected = tmp1 - tmp2
        output = numpy.zeros(array.shape, array.dtype)
        ndimage.morphological_gradient(array, footprint=footprint,
                                       structure=structure, output=output)
        assert_array_almost_equal(expected, output)

    def test_morphological_gradient02(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp1 = ndimage.grey_dilation(array, footprint=footprint,
                                     structure=structure)
        tmp2 = ndimage.grey_erosion(array, footprint=footprint,
                                    structure=structure)
        expected = tmp1 - tmp2
        output = ndimage.morphological_gradient(array, footprint=footprint,
                                                structure=structure)
        assert_array_almost_equal(expected, output)

    def test_morphological_laplace01(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp1 = ndimage.grey_dilation(array, footprint=footprint,
                                     structure=structure)
        tmp2 = ndimage.grey_erosion(array, footprint=footprint,
                                    structure=structure)
        expected = tmp1 + tmp2 - 2 * array
        output = numpy.zeros(array.shape, array.dtype)
        ndimage.morphological_laplace(array, footprint=footprint,
                                      structure=structure, output=output)
        assert_array_almost_equal(expected, output)

    def test_morphological_laplace02(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp1 = ndimage.grey_dilation(array, footprint=footprint,
                                     structure=structure)
        tmp2 = ndimage.grey_erosion(array, footprint=footprint,
                                    structure=structure)
        expected = tmp1 + tmp2 - 2 * array
        output = ndimage.morphological_laplace(array, footprint=footprint,
                                               structure=structure)
        assert_array_almost_equal(expected, output)

    def test_white_tophat01(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp = ndimage.grey_opening(array, footprint=footprint,
                                   structure=structure)
        expected = array - tmp
        output = numpy.zeros(array.shape, array.dtype)
        ndimage.white_tophat(array, footprint=footprint,
                             structure=structure, output=output)
        assert_array_almost_equal(expected, output)

    def test_white_tophat02(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp = ndimage.grey_opening(array, footprint=footprint,
                                   structure=structure)
        expected = array - tmp
        output = ndimage.white_tophat(array, footprint=footprint,
                                      structure=structure)
        assert_array_almost_equal(expected, output)

    def test_white_tophat03(self):
        array = numpy.array([[1, 0, 0, 0, 0, 0, 0],
                             [0, 1, 1, 1, 1, 1, 0],
                             [0, 1, 1, 1, 1, 1, 0],
                             [0, 1, 1, 1, 1, 1, 0],
                             [0, 1, 1, 1, 0, 1, 0],
                             [0, 1, 1, 1, 1, 1, 0],
                             [0, 0, 0, 0, 0, 0, 1]], dtype=numpy.bool_)
        structure = numpy.ones((3, 3), dtype=numpy.bool_)
        expected = numpy.array([[0, 1, 1, 0, 0, 0, 0],
                                [1, 0, 0, 1, 1, 1, 0],
                                [1, 0, 0, 1, 1, 1, 0],
                                [0, 1, 1, 0, 0, 0, 1],
                                [0, 1, 1, 0, 1, 0, 1],
                                [0, 1, 1, 0, 0, 0, 1],
                                [0, 0, 0, 1, 1, 1, 1]], dtype=numpy.bool_)

        output = ndimage.white_tophat(array, structure=structure)
        assert_array_equal(expected, output)

    def test_white_tophat04(self):
        array = numpy.eye(5, dtype=numpy.bool_)
        structure = numpy.ones((3, 3), dtype=numpy.bool_)

        # Check that type mismatch is properly handled
        output = numpy.empty_like(array, dtype=numpy.float64)
        ndimage.white_tophat(array, structure=structure, output=output)

    def test_black_tophat01(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp = ndimage.grey_closing(array, footprint=footprint,
                                   structure=structure)
        expected = tmp - array
        output = numpy.zeros(array.shape, array.dtype)
        ndimage.black_tophat(array, footprint=footprint,
                             structure=structure, output=output)
        assert_array_almost_equal(expected, output)

    def test_black_tophat02(self):
        array = numpy.array([[3, 2, 5, 1, 4],
                             [7, 6, 9, 3, 5],
                             [5, 8, 3, 7, 1]])
        footprint = [[1, 0, 1], [1, 1, 0]]
        structure = [[0, 0, 0], [0, 0, 0]]
        tmp = ndimage.grey_closing(array, footprint=footprint,
                                   structure=structure)
        expected = tmp - array
        output = ndimage.black_tophat(array, footprint=footprint,
                                      structure=structure)
        assert_array_almost_equal(expected, output)

    def test_black_tophat03(self):
        array = numpy.array([[1, 0, 0, 0, 0, 0, 0],
                             [0, 1, 1, 1, 1, 1, 0],
                             [0, 1, 1, 1, 1, 1, 0],
                             [0, 1, 1, 1, 1, 1, 0],
                             [0, 1, 1, 1, 0, 1, 0],
                             [0, 1, 1, 1, 1, 1, 0],
                             [0, 0, 0, 0, 0, 0, 1]], dtype=numpy.bool_)
        structure = numpy.ones((3, 3), dtype=numpy.bool_)
        expected = numpy.array([[0, 1, 1, 1, 1, 1, 1],
                                [1, 0, 0, 0, 0, 0, 1],
                                [1, 0, 0, 0, 0, 0, 1],
                                [1, 0, 0, 0, 0, 0, 1],
                                [1, 0, 0, 0, 1, 0, 1],
                                [1, 0, 0, 0, 0, 0, 1],
                                [1, 1, 1, 1, 1, 1, 0]], dtype=numpy.bool_)

        output = ndimage.black_tophat(array, structure=structure)
        assert_array_equal(expected, output)

    def test_black_tophat04(self):
        array = numpy.eye(5, dtype=numpy.bool_)
        structure = numpy.ones((3, 3), dtype=numpy.bool_)

        # Check that type mismatch is properly handled
        output = numpy.empty_like(array, dtype=numpy.float64)
        ndimage.black_tophat(array, structure=structure, output=output)

    @pytest.mark.parametrize('dtype', types)
    def test_hit_or_miss01(self, dtype):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]]
        data = numpy.array([[0, 1, 0, 0, 0],
                            [1, 1, 1, 0, 0],
                            [0, 1, 0, 1, 1],
                            [0, 0, 1, 1, 1],
                            [0, 1, 1, 1, 0],
                            [0, 1, 1, 1, 1],
                            [0, 1, 1, 1, 1],
                            [0, 0, 0, 0, 0]], dtype)
        out = numpy.zeros(data.shape, bool)
        ndimage.binary_hit_or_miss(data, struct, output=out)
        assert_array_almost_equal(expected, out)

    @pytest.mark.parametrize('dtype', types)
    def test_hit_or_miss02(self, dtype):
        struct = [[0, 1, 0],
                  [1, 1, 1],
                  [0, 1, 0]]
        expected = [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 1, 0, 0, 1, 1, 1, 0],
                            [1, 1, 1, 0, 0, 1, 0, 0],
                            [0, 1, 0, 1, 1, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_hit_or_miss(data, struct)
        assert_array_almost_equal(expected, out)

    @pytest.mark.parametrize('dtype', types)
    def test_hit_or_miss03(self, dtype):
        struct1 = [[0, 0, 0],
                   [1, 1, 1],
                   [0, 0, 0]]
        struct2 = [[1, 1, 1],
                   [0, 0, 0],
                   [1, 1, 1]]
        expected = [[0, 0, 0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
        data = numpy.array([[0, 1, 0, 0, 1, 1, 1, 0],
                            [1, 1, 1, 0, 0, 0, 0, 0],
                            [0, 1, 0, 1, 1, 1, 1, 0],
                            [0, 0, 1, 1, 1, 1, 1, 0],
                            [0, 1, 1, 1, 0, 1, 1, 0],
                            [0, 0, 0, 0, 1, 1, 1, 0],
                            [0, 1, 1, 1, 1, 1, 1, 0],
                            [0, 0, 0, 0, 0, 0, 0, 0]], dtype)
        out = ndimage.binary_hit_or_miss(data, struct1, struct2)
        assert_array_almost_equal(expected, out)


class TestDilateFix:

    def setup_method(self):
        # dilation related setup
        self.array = numpy.array([[0, 0, 0, 0, 0],
                                  [0, 0, 0, 0, 0],
                                  [0, 0, 0, 1, 0],
                                  [0, 0, 1, 1, 0],
                                  [0, 0, 0, 0, 0]], dtype=numpy.uint8)

        self.sq3x3 = numpy.ones((3, 3))
        dilated3x3 = ndimage.binary_dilation(self.array, structure=self.sq3x3)
        self.dilated3x3 = dilated3x3.view(numpy.uint8)

    def test_dilation_square_structure(self):
        result = ndimage.grey_dilation(self.array, structure=self.sq3x3)
        # +1 accounts for difference between grey and binary dilation
        assert_array_almost_equal(result, self.dilated3x3 + 1)

    def test_dilation_scalar_size(self):
        result = ndimage.grey_dilation(self.array, size=3)
        assert_array_almost_equal(result, self.dilated3x3)


class TestBinaryOpeningClosing:

    def setup_method(self):
        a = numpy.zeros((5, 5), dtype=bool)
        a[1:4, 1:4] = True
        a[4, 4] = True
        self.array = a
        self.sq3x3 = numpy.ones((3, 3))
        self.opened_old = ndimage.binary_opening(self.array, self.sq3x3,
                                                 1, None, 0)
        self.closed_old = ndimage.binary_closing(self.array, self.sq3x3,
                                                 1, None, 0)

    def test_opening_new_arguments(self):
        opened_new = ndimage.binary_opening(self.array, self.sq3x3, 1, None,
                                            0, None, 0, False)
        assert_array_equal(opened_new, self.opened_old)

    def test_closing_new_arguments(self):
        closed_new = ndimage.binary_closing(self.array, self.sq3x3, 1, None,
                                            0, None, 0, False)
        assert_array_equal(closed_new, self.closed_old)


def test_binary_erosion_noninteger_iterations():
    # regression test for gh-9905, gh-9909: ValueError for
    # non integer iterations
    data = numpy.ones([1])
    assert_raises(TypeError, ndimage.binary_erosion, data, iterations=0.5)
    assert_raises(TypeError, ndimage.binary_erosion, data, iterations=1.5)


def test_binary_dilation_noninteger_iterations():
    # regression test for gh-9905, gh-9909: ValueError for
    # non integer iterations
    data = numpy.ones([1])
    assert_raises(TypeError, ndimage.binary_dilation, data, iterations=0.5)
    assert_raises(TypeError, ndimage.binary_dilation, data, iterations=1.5)


def test_binary_opening_noninteger_iterations():
    # regression test for gh-9905, gh-9909: ValueError for
    # non integer iterations
    data = numpy.ones([1])
    assert_raises(TypeError, ndimage.binary_opening, data, iterations=0.5)
    assert_raises(TypeError, ndimage.binary_opening, data, iterations=1.5)


def test_binary_closing_noninteger_iterations():
    # regression test for gh-9905, gh-9909: ValueError for
    # non integer iterations
    data = numpy.ones([1])
    assert_raises(TypeError, ndimage.binary_closing, data, iterations=0.5)
    assert_raises(TypeError, ndimage.binary_closing, data, iterations=1.5)


def test_binary_closing_noninteger_brute_force_passes_when_true():
    # regression test for gh-9905, gh-9909: ValueError for
    # non integer iterations
    data = numpy.ones([1])

    assert ndimage.binary_erosion(
        data, iterations=2, brute_force=1.5
    ) == ndimage.binary_erosion(data, iterations=2, brute_force=bool(1.5))
    assert ndimage.binary_erosion(
        data, iterations=2, brute_force=0.0
    ) == ndimage.binary_erosion(data, iterations=2, brute_force=bool(0.0))
