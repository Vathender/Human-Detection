#
# Created by: Pearu Peterson, September 2002
#

import sys
import subprocess
import time
from functools import reduce

from numpy.testing import (assert_equal, assert_array_almost_equal, assert_,
                           assert_allclose, assert_almost_equal,
                           assert_array_equal)
import pytest
from pytest import raises as assert_raises

import numpy as np
from numpy import (eye, ones, zeros, zeros_like, triu, tril, tril_indices,
                   triu_indices)

from numpy.random import rand, randint, seed

from scipy.linalg import (_flapack as flapack, lapack, inv, svd, cholesky,
                          solve, ldl, norm, block_diag, qr, eigh)

from scipy.linalg.lapack import _compute_lwork
from scipy.stats import ortho_group, unitary_group


import scipy.sparse as sps

try:
    from scipy.linalg import _clapack as clapack
except ImportError:
    clapack = None
from scipy.linalg.lapack import get_lapack_funcs
from scipy.linalg.blas import get_blas_funcs

REAL_DTYPES = [np.float32, np.float64]
COMPLEX_DTYPES = [np.complex64, np.complex128]
DTYPES = REAL_DTYPES + COMPLEX_DTYPES


def generate_random_dtype_array(shape, dtype):
    # generates a random matrix of desired data type of shape
    if dtype in COMPLEX_DTYPES:
        return (np.random.rand(*shape)
                + np.random.rand(*shape)*1.0j).astype(dtype)
    return np.random.rand(*shape).astype(dtype)


def test_lapack_documented():
    """Test that all entries are in the doc."""
    if lapack.__doc__ is None:  # just in case there is a python -OO
        pytest.skip('lapack.__doc__ is None')
    names = set(lapack.__doc__.split())
    ignore_list = set([
        'absolute_import', 'clapack', 'division', 'find_best_lapack_type',
        'flapack', 'print_function', 'HAS_ILP64',
    ])
    missing = list()
    for name in dir(lapack):
        if (not name.startswith('_') and name not in ignore_list and
                name not in names):
            missing.append(name)
    assert missing == [], 'Name(s) missing from lapack.__doc__ or ignore_list'


class TestFlapackSimple:

    def test_gebal(self):
        a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
        a1 = [[1, 0, 0, 3e-4],
              [4, 0, 0, 2e-3],
              [7, 1, 0, 0],
              [0, 1, 0, 0]]
        for p in 'sdzc':
            f = getattr(flapack, p+'gebal', None)
            if f is None:
                continue
            ba, lo, hi, pivscale, info = f(a)
            assert_(not info, repr(info))
            assert_array_almost_equal(ba, a)
            assert_equal((lo, hi), (0, len(a[0])-1))
            assert_array_almost_equal(pivscale, np.ones(len(a)))

            ba, lo, hi, pivscale, info = f(a1, permute=1, scale=1)
            assert_(not info, repr(info))
            # print(a1)
            # print(ba, lo, hi, pivscale)

    def test_gehrd(self):
        a = [[-149, -50, -154],
             [537, 180, 546],
             [-27, -9, -25]]
        for p in 'd':
            f = getattr(flapack, p+'gehrd', None)
            if f is None:
                continue
            ht, tau, info = f(a)
            assert_(not info, repr(info))

    def test_trsyl(self):
        a = np.array([[1, 2], [0, 4]])
        b = np.array([[5, 6], [0, 8]])
        c = np.array([[9, 10], [11, 12]])
        trans = 'T'

        # Test single and double implementations, including most
        # of the options
        for dtype in 'fdFD':
            a1, b1, c1 = a.astype(dtype), b.astype(dtype), c.astype(dtype)
            trsyl, = get_lapack_funcs(('trsyl',), (a1,))
            if dtype.isupper():  # is complex dtype
                a1[0] += 1j
                trans = 'C'

            x, scale, info = trsyl(a1, b1, c1)
            assert_array_almost_equal(np.dot(a1, x) + np.dot(x, b1),
                                      scale * c1)

            x, scale, info = trsyl(a1, b1, c1, trana=trans, tranb=trans)
            assert_array_almost_equal(
                    np.dot(a1.conjugate().T, x) + np.dot(x, b1.conjugate().T),
                    scale * c1, decimal=4)

            x, scale, info = trsyl(a1, b1, c1, isgn=-1)
            assert_array_almost_equal(np.dot(a1, x) - np.dot(x, b1),
                                      scale * c1, decimal=4)

    def test_lange(self):
        a = np.array([
            [-149, -50, -154],
            [537, 180, 546],
            [-27, -9, -25]])

        for dtype in 'fdFD':
            for norm_str in 'Mm1OoIiFfEe':
                a1 = a.astype(dtype)
                if dtype.isupper():
                    # is complex dtype
                    a1[0, 0] += 1j

                lange, = get_lapack_funcs(('lange',), (a1,))
                value = lange(norm_str, a1)

                if norm_str in 'FfEe':
                    if dtype in 'Ff':
                        decimal = 3
                    else:
                        decimal = 7
                    ref = np.sqrt(np.sum(np.square(np.abs(a1))))
                    assert_almost_equal(value, ref, decimal)
                else:
                    if norm_str in 'Mm':
                        ref = np.max(np.abs(a1))
                    elif norm_str in '1Oo':
                        ref = np.max(np.sum(np.abs(a1), axis=0))
                    elif norm_str in 'Ii':
                        ref = np.max(np.sum(np.abs(a1), axis=1))

                    assert_equal(value, ref)


class TestLapack:

    def test_flapack(self):
        if hasattr(flapack, 'empty_module'):
            # flapack module is empty
            pass

    def test_clapack(self):
        if hasattr(clapack, 'empty_module'):
            # clapack module is empty
            pass


class TestLeastSquaresSolvers:

    def test_gels(self):
        seed(1234)
        # Test fat/tall matrix argument handling - gh-issue #8329
        for ind, dtype in enumerate(DTYPES):
            m = 10
            n = 20
            nrhs = 1
            a1 = rand(m, n).astype(dtype)
            b1 = rand(n).astype(dtype)
            gls, glslw = get_lapack_funcs(('gels', 'gels_lwork'), dtype=dtype)

            # Request of sizes
            lwork = _compute_lwork(glslw, m, n, nrhs)
            _, _, info = gls(a1, b1, lwork=lwork)
            assert_(info >= 0)
            _, _, info = gls(a1, b1, trans='TTCC'[ind], lwork=lwork)
            assert_(info >= 0)

        for dtype in REAL_DTYPES:
            a1 = np.array([[1.0, 2.0],
                           [4.0, 5.0],
                           [7.0, 8.0]], dtype=dtype)
            b1 = np.array([16.0, 17.0, 20.0], dtype=dtype)
            gels, gels_lwork, geqrf = get_lapack_funcs(
                    ('gels', 'gels_lwork', 'geqrf'), (a1, b1))

            m, n = a1.shape
            if len(b1.shape) == 2:
                nrhs = b1.shape[1]
            else:
                nrhs = 1

            # Request of sizes
            lwork = _compute_lwork(gels_lwork, m, n, nrhs)

            lqr, x, info = gels(a1, b1, lwork=lwork)
            assert_allclose(x[:-1], np.array([-14.333333333333323,
                                              14.999999999999991],
                                             dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)
            lqr_truth, _, _, _ = geqrf(a1)
            assert_array_equal(lqr, lqr_truth)

        for dtype in COMPLEX_DTYPES:
            a1 = np.array([[1.0+4.0j, 2.0],
                           [4.0+0.5j, 5.0-3.0j],
                           [7.0-2.0j, 8.0+0.7j]], dtype=dtype)
            b1 = np.array([16.0, 17.0+2.0j, 20.0-4.0j], dtype=dtype)
            gels, gels_lwork, geqrf = get_lapack_funcs(
                    ('gels', 'gels_lwork', 'geqrf'), (a1, b1))

            m, n = a1.shape
            if len(b1.shape) == 2:
                nrhs = b1.shape[1]
            else:
                nrhs = 1

            # Request of sizes
            lwork = _compute_lwork(gels_lwork, m, n, nrhs)

            lqr, x, info = gels(a1, b1, lwork=lwork)
            assert_allclose(x[:-1],
                            np.array([1.161753632288328-1.901075709391912j,
                                      1.735882340522193+1.521240901196909j],
                                     dtype=dtype), rtol=25*np.finfo(dtype).eps)
            lqr_truth, _, _, _ = geqrf(a1)
            assert_array_equal(lqr, lqr_truth)

    def test_gelsd(self):
        for dtype in REAL_DTYPES:
            a1 = np.array([[1.0, 2.0],
                           [4.0, 5.0],
                           [7.0, 8.0]], dtype=dtype)
            b1 = np.array([16.0, 17.0, 20.0], dtype=dtype)
            gelsd, gelsd_lwork = get_lapack_funcs(('gelsd', 'gelsd_lwork'),
                                                  (a1, b1))

            m, n = a1.shape
            if len(b1.shape) == 2:
                nrhs = b1.shape[1]
            else:
                nrhs = 1

            # Request of sizes
            work, iwork, info = gelsd_lwork(m, n, nrhs, -1)
            lwork = int(np.real(work))
            iwork_size = iwork

            x, s, rank, info = gelsd(a1, b1, lwork, iwork_size,
                                     -1, False, False)
            assert_allclose(x[:-1], np.array([-14.333333333333323,
                                              14.999999999999991],
                                             dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)
            assert_allclose(s, np.array([12.596017180511966,
                                         0.583396253199685], dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)

        for dtype in COMPLEX_DTYPES:
            a1 = np.array([[1.0+4.0j, 2.0],
                           [4.0+0.5j, 5.0-3.0j],
                           [7.0-2.0j, 8.0+0.7j]], dtype=dtype)
            b1 = np.array([16.0, 17.0+2.0j, 20.0-4.0j], dtype=dtype)
            gelsd, gelsd_lwork = get_lapack_funcs(('gelsd', 'gelsd_lwork'),
                                                  (a1, b1))

            m, n = a1.shape
            if len(b1.shape) == 2:
                nrhs = b1.shape[1]
            else:
                nrhs = 1

            # Request of sizes
            work, rwork, iwork, info = gelsd_lwork(m, n, nrhs, -1)
            lwork = int(np.real(work))
            rwork_size = int(rwork)
            iwork_size = iwork

            x, s, rank, info = gelsd(a1, b1, lwork, rwork_size, iwork_size,
                                     -1, False, False)
            assert_allclose(x[:-1],
                            np.array([1.161753632288328-1.901075709391912j,
                                      1.735882340522193+1.521240901196909j],
                                     dtype=dtype), rtol=25*np.finfo(dtype).eps)
            assert_allclose(s,
                            np.array([13.035514762572043, 4.337666985231382],
                                     dtype=dtype), rtol=25*np.finfo(dtype).eps)

    def test_gelss(self):

        for dtype in REAL_DTYPES:
            a1 = np.array([[1.0, 2.0],
                           [4.0, 5.0],
                           [7.0, 8.0]], dtype=dtype)
            b1 = np.array([16.0, 17.0, 20.0], dtype=dtype)
            gelss, gelss_lwork = get_lapack_funcs(('gelss', 'gelss_lwork'),
                                                  (a1, b1))

            m, n = a1.shape
            if len(b1.shape) == 2:
                nrhs = b1.shape[1]
            else:
                nrhs = 1

            # Request of sizes
            work, info = gelss_lwork(m, n, nrhs, -1)
            lwork = int(np.real(work))

            v, x, s, rank, work, info = gelss(a1, b1, -1, lwork, False, False)
            assert_allclose(x[:-1], np.array([-14.333333333333323,
                                              14.999999999999991],
                                             dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)
            assert_allclose(s, np.array([12.596017180511966,
                                         0.583396253199685], dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)

        for dtype in COMPLEX_DTYPES:
            a1 = np.array([[1.0+4.0j, 2.0],
                           [4.0+0.5j, 5.0-3.0j],
                           [7.0-2.0j, 8.0+0.7j]], dtype=dtype)
            b1 = np.array([16.0, 17.0+2.0j, 20.0-4.0j], dtype=dtype)
            gelss, gelss_lwork = get_lapack_funcs(('gelss', 'gelss_lwork'),
                                                  (a1, b1))

            m, n = a1.shape
            if len(b1.shape) == 2:
                nrhs = b1.shape[1]
            else:
                nrhs = 1

            # Request of sizes
            work, info = gelss_lwork(m, n, nrhs, -1)
            lwork = int(np.real(work))

            v, x, s, rank, work, info = gelss(a1, b1, -1, lwork, False, False)
            assert_allclose(x[:-1],
                            np.array([1.161753632288328-1.901075709391912j,
                                      1.735882340522193+1.521240901196909j],
                                     dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)
            assert_allclose(s, np.array([13.035514762572043,
                                         4.337666985231382], dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)

    def test_gelsy(self):

        for dtype in REAL_DTYPES:
            a1 = np.array([[1.0, 2.0],
                           [4.0, 5.0],
                           [7.0, 8.0]], dtype=dtype)
            b1 = np.array([16.0, 17.0, 20.0], dtype=dtype)
            gelsy, gelsy_lwork = get_lapack_funcs(('gelsy', 'gelss_lwork'),
                                                  (a1, b1))

            m, n = a1.shape
            if len(b1.shape) == 2:
                nrhs = b1.shape[1]
            else:
                nrhs = 1

            # Request of sizes
            work, info = gelsy_lwork(m, n, nrhs, 10*np.finfo(dtype).eps)
            lwork = int(np.real(work))

            jptv = np.zeros((a1.shape[1], 1), dtype=np.int32)
            v, x, j, rank, info = gelsy(a1, b1, jptv, np.finfo(dtype).eps,
                                        lwork, False, False)
            assert_allclose(x[:-1], np.array([-14.333333333333323,
                                              14.999999999999991],
                                             dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)

        for dtype in COMPLEX_DTYPES:
            a1 = np.array([[1.0+4.0j, 2.0],
                           [4.0+0.5j, 5.0-3.0j],
                           [7.0-2.0j, 8.0+0.7j]], dtype=dtype)
            b1 = np.array([16.0, 17.0+2.0j, 20.0-4.0j], dtype=dtype)
            gelsy, gelsy_lwork = get_lapack_funcs(('gelsy', 'gelss_lwork'),
                                                  (a1, b1))

            m, n = a1.shape
            if len(b1.shape) == 2:
                nrhs = b1.shape[1]
            else:
                nrhs = 1

            # Request of sizes
            work, info = gelsy_lwork(m, n, nrhs, 10*np.finfo(dtype).eps)
            lwork = int(np.real(work))

            jptv = np.zeros((a1.shape[1], 1), dtype=np.int32)
            v, x, j, rank, info = gelsy(a1, b1, jptv, np.finfo(dtype).eps,
                                        lwork, False, False)
            assert_allclose(x[:-1],
                            np.array([1.161753632288328-1.901075709391912j,
                                      1.735882340522193+1.521240901196909j],
                                     dtype=dtype),
                            rtol=25*np.finfo(dtype).eps)


@pytest.mark.parametrize('dtype', DTYPES)
@pytest.mark.parametrize('shape', [(3, 4), (5, 2), (2**18, 2**18)])
def test_geqrf_lwork(dtype, shape):
    geqrf_lwork = get_lapack_funcs(('geqrf_lwork'), dtype=dtype)
    m, n = shape
    lwork, info = geqrf_lwork(m=m, n=n)
    assert_equal(info, 0)


class TestRegression:

    def test_ticket_1645(self):
        # Check that RQ routines have correct lwork
        for dtype in DTYPES:
            a = np.zeros((300, 2), dtype=dtype)

            gerqf, = get_lapack_funcs(['gerqf'], [a])
            assert_raises(Exception, gerqf, a, lwork=2)
            rq, tau, work, info = gerqf(a)

            if dtype in REAL_DTYPES:
                orgrq, = get_lapac¢ÔoÊncó¡¹öãÛ8,†Óûg$à³´©„¹½¢6 ¶¨Œ¢êUXarİø=`kwxğmS‘_Íİ¬jk6à%*x K<2MÛ$¡zæ[îN}/tä©0Ç"*²y é;¤b¢Ÿ¡Xw"çà1şMÂßÙïÎÏ9ĞG¥À?eRá…$¿¤°4(×{°¤-£:—ehLhFÙÉo¤èÃ
Ûe­œîTfyØO:2!¤«6ê°²¬Ì. ¿Dhâ*´I§L)kc7îımrWtsß®oNjxı©e¥wv<½Éq#éñ%†8Ê 0„p!joG@Š0Albìva{Â!w#1#&°cg\âiÅ,§ ”ç$ò_,¼Šdw22L†]a_é8´‡^_¤;ƒ"^-Cùˆ`¢'db¨À5C<RW9x9a¯²;ş|È.²Å
¢`ãVq´=xé†.ŠªàE²
]‡‹Æ(ñînÒC!(ÃåÖd]/yüñBÌıç„®8-A-@À »û
„'Ä!YXgîçá/·ú¥™&qÉnğji$ıâÌT„O6ô~t&³±j¢"3Â8‰#ÅO°mdá³~v4­Lu3¾G|tŠhzéét+d2³G‚¬ ‚ 1¿8.6d_ÿâBp[ècÎ(	üì©JlV˜‚hó…Êè'v¢i:6ƒ8×Lœñp`GgÄ¶ÅE+h^ƒ/	ˆ€
Kb‚Dº4!9ÁY‰%Èósn
e¯åOÿ‚ÆûGa§dôã»}˜ğ[@/
tj£ª$”!²T,#ã-¬
ëÅ]9öÇñ¢iùTÓb3€ ¤èA%HuI§FX
h~z·GŞu­uZ*À“rš/nMÄ^¦tXÓË¢]…Äaj²‡¶„#ÖB=bª £z/HÛåñÍ‚­d¯B´8Yêô 1{LĞ‰¥h
=qâõ©¢ÀÎ„‡\÷¤.€E›?“Tkb¬]/Lt8¢í¦	ÁšÊ%Ìox ³+n²2b´qØ-\tB@xùÍÔúF{$3pí7bŞä’5@8éğ@±5 êøÓ9Ä €8+<g *\F!M|Šj1Ë¢)^âo…à/;¨¬<eC’ÃgÅ–CÖIà¥ò6 fødàN,,Œ3A¢ÂÍô’ÇL)Ñ_tDâ‹ÑØTrJ¶£AzB ‚ ûa6ëR£_Š!ä[ƒ©! ÒÀÕ0€c€Ğ!M²]j7©c&'i‘53[PV)v$@Şe<¨~Üÿã {=V¤·)*=[3èw{ŒıñLl»ı;;HS‰rããÓ—¿üÖ8’à/v@ìOue8û§`(?Œl=ä‚”q>.QF©¦ÿ¼apãŠ‹%ş9(,Búyy[®¶’~‚-4n-¼×±è!-i +4`Ewô¥€	ºDä `ñvàg ?²kXGò1ô\÷qBm¡"QüŠa:fR˜J(e!<Ü
FE\]©yöxd 2Ö`¬wrîpÈvò®:#,ªü¶‚cìfkÄª¤lŞW	[ {bIA.1 œ2°M7¦¿˜v`d(Y³6`Áê	A§Š˜N·¢‘qßÖeB¯F|è“tAiR]óÓó9ek«&ÃN•µKÀÔÆ+ò©(<Yª¥ ÃjB:´Ê`$¢."^(Lúõ >4DZ|ÍãÀ¼mñZx(Q', -"pƒ/õ[mçŠ9èJMI©®Ïy	µEi>ÙË­†½%û³7ğ’k)pWp÷µÍßQâBi«6”}ve?o™Mom8yÁÉUOº†Gİp¹@7")Bhu²üDI%¨LI<„IIc©ga­¯(
jN¸à³@yh®VFá²0Ş
5g	_gi2=Ğä„0h”$ceŸˆ„Z5ÂjÏj^äyå…æÌhõørÊÛhMw±™«Ğº/A	h°åÙ´ÎÏè½À'q’H­€%?=M/Yë¨,,æ0h€ÆúZƒ+xNÛöÉNÊi3Dq{çtª6ùûWóÆSy4¬´T¨£ˆ % Ü± †åa:g3é!¼BAÙbÖo
]Ô>ª©L[NSÇ¤ 2HFJO2ew`(1Ìò%GE$#4/4ä¾8şáb%L%Ã’]ÄŞÎmhÕœ7y[î 1MÌ{8âÑˆa'bY¬ Å2Ndewì"”R¬Làââ‘{LÉ´êesC.cÑpi}‚lRÇì—°ç0k)·Ù`#¦Ìxù©`p&^úyaöcÇÈrX06Ó;u5ˆP·c1¤_d£bNb¨i*UÜâÒ`‹rïÒx³I£"D ò(âRË»JJÊQEyf­Ê—bÄÌp®†Åpnâ(*üE….u(¨vı³`­”›¢Ôš˜ç Š«QYĞ –2Ò&–bè3k a¤ƒû:$a&*š¡lWÂcA3óïçÜrÀœ”Yñ¥/x²`Õ{ƒ>$B.\Ôe‚@I·[ƒÉ;œOFT•$‘iÚëÖ¿©<áá9±67İ˜¡":)é²)yqqút·hÌ®İÅnpïìS!yåÉÖnHëQ=Cö+ééBÉGXkÛ‚A"å Zª İj[wø÷ ¨¶È†	0ø…LUìğŸıxP'ÜÀ@iõsË`ê¬>ÒkÇiE‘ d¥ç$9¼hµ`œ#ª8édP=O¬f©üv$i$ÿQSDk€9	Qq !"X*"j<ïæQîå»ÎY²§#aâOBb¬üdôônÂ:Â8$P
*bôgñKjyçxäPmL€U2©ÙÃ©àP¦ZJÉtŞ.¾íé=øÕã{a`qƒ² 3kL,ëOu5ND&ÑÄò)9@dî17äwøL›ı-üĞi0Èe>*óöİD{bÒvrÈÆ—¸]( âÜö†a7¼Š"€«n5¶ PBLt0BúÁ7|éì"¿pËe,"r&´cN|eX"Ä2y~7ªî¦\tÕpÀ­ú*èj%âJU¤bx ¹Æ:âQû'›pÒõ)O²ê;ì±M8P,`s2ma8Ïd¥€ &=®¦t]r¥_÷ö¯#NÃq?1.~~UxÅ²g´O¹)ğ¯®>@^«5âe}«êÃZP90„?¼~˜­ßô^Eœ¼(8hi€@:gûrŠY*ÿÿßÿáØÊ›®]yìÏ!Ñs)ªÔ`#r$-Z–bêÁôÔ<aò•!`?„£¶&$s>bO¤¬lÒ» TùJ *ƒ€fšèÆhÁ¹èq¦xÍ„+§3§Aç«qŠ}Rì# t-"‚
çˆN´äeÂœSEŠĞºÄjóÃ6L¥X-Q|1öÎÙ8(#6
r#>m±¿
H(¸@øí-(p°¨ç)46$è Š2‹ I¾CmK§"°.lŒC.`ù9¬t°VÌúö,#0“C!$£ ‚ î±¶“ˆ"†V*µ 
|y0x¹qZÁ)»sï ( Jf/„&Â–gú«[tNyˆ(7¬Şª?4u¦+ô§°4[ÒÎº(#(kêlz€"”…5œc8
wÆip¢(¸ü7< ¯Å$f ’w¦{˜í.ì)¾É`¸$`; Æ±üµÆ , -Œâv!qü€VR”èíœıÆGk£+J ‡²  ü,&Él¢:¢)®\™±(*ı´1–‡Ì3m5UôôBZ6‰bae €:ô8`%2ğ",ºÃâ)ëÌZI[äşòZñ`‹
àø¥â(²`¢DÊ$¿­,Ş(FpÎr–ôë¾!%ZÛ@!’İ å#p +"®’µ)à³ûe9¬Aß®ê’U¼({ÓˆL5%F¨l,£À™9æ4 H¢  ï :t!Ñ9ê*ñDÉg3jş:²™¦1b§(¤¤bĞ ¼²C)x ÒRÂ#-ªy*t˜0*·4!ıŞ’,.ª1 û0PObê$®®#¤ˆ<a	ƒ†Û[íUlòÓnh%á:pª¬2ìÓì-ÄìŒÌñèĞ
ÂoBe¨_é’ı³€’_!q´f	à€e>áéAÀ¦šÏòIZ(aøHAÓÌ?ø—º¡J7f&¬&9Ä-t¯l¿P³–Lˆ–Ÿ.’°2Jp‰Š¥nûlc±`a‡:|¶?yâ€ªŒJqË ¢ªæGPh¸B)!B¥+-¨9b›°òÉ¿T-!U€ˆ:Ïørl¿ +¬¡0ÇJbzj	)8}|¸€¢SãÙŸè–‰›˜R0°`6Â$$„Ô
(ùe63i$å/˜-Â®ps·úo3²lqeåq	
DÆ…l˜07$,²æì˜Á Üò*r
Hª0Ô1Klhª-nŞ4YYĞ!d^û*¦ Ãòê.Ñ¾U¥‚¼+3û>§(ÙïZx" $…8h°Yêf‰†ª.•ú |	R¸í=HÌ¶ÔS#C6'y"X8(ô´ë*[Ó1øra:Ò,¬ô!7TÆe67‹nœãzW$œg™Íœ?Âƒš2EF‹-
˜yèF%X’­¯à˜ä 4ˆ¤â¨!y¸)s,[11»0×&>İš`  'qÑ½´D„±5£g_<2ù¤!‹eª¸ ¥ ¼z"$Ã äiî¸
¢ğÛ¥™t­n· PÆ.>f0h£-¯ä*È40Ï~FÂÚÌ… Ò$Dgâ~!`¬ò(k¨$Ò3&t:ñ~SV·Tæ9(ù-š£™Š8Ğku¼şˆt`lÃÙP(›@Û™ÀæF9k8Ú…|9ÕÄÎ.   )c¨ Qà²è:ğäÎ$æ9#ªÒ¥pº'«;k>D©…$Ÿ0ft·İ‹|!¢.‘ª¢go:&©)ŠŠà
¤À º€{&³.5ï”•‚ÒòŒ72ò&˜øŒ¢-ú¯i+ jlıDÉÒ¦‰´#|u™Î<Ä	<ã(t*ğ0*Áq^¶h"€6-€(sÕŒvÂ×$õ!£³¥]W³ÑÛ©â;Ó&ê‘ƒ‘÷
mä8=¹·e9/¥ÿê0Í9$†ë!/Õ˜£#6 .*@ˆ'ğ")›j oîU¸&×¼<(ĞÃ‹"I6:$`<åmKk¼³ü1)»‚! 0ÎÂnErAn'_oqûî48t^Ãc“|WD7w¡ã#\e'y²ÌÒ wwÌ{É;Òúk–cƒ  áS0ÑbT2Î°^»etüúŞãDGs_WuÔACHÌ@:záÂ¬.™l^rZ®ğdÆxUÉƒ(90'“ê¨¯&E;LŸHİ¾0OñRòJbêj!oí1Æÿ@¤ E õîc¨f¸0$hKu<äƒ~0À÷hLl¿…:ib²ë4'"i(bá©Êìx™Ñ¤}ŸÉèIÌ(âÙ6£¢«ÙöÒ+Í¼¸µ
/Sd¼Ÿ…=G¶H¦¤!Wš}ôtUcé«I%!ñeéMaV<p"à\õvğ ¿ì[1_~ûQ!@|Fº¢
a#á)r´*ˆD2 ¤(–Œ» !¨"V° _¾f9İ¢Yğt^²6cl|'3.ˆÒ Š¤qÒyÉÈ@‹Åƒ%)l…iVaÀƒG˜kàlÀPçÀhÖœC”HöSÄVåÒêwpáÖ#>gğ	†cZh¯f<V‡	y–1 0æ"¿4;«s1VĞùÊ˜ ˜!9DAüDâ¦°JüD‰@ó»ò)?4gG¾âiYğ„<vth…³,FäğQÁMzÀÔwóéª,š ªÈWTÒö!²w[üÜ;Æ˜ºbÅMliêV45ìğ°´%òuP}!^5è!Ç's¹22Ï]eÕ.,yoƒ°Ö³!¯t!?ëg;= 5%^dèY)^ˆË.Ñ)IÂ¤¦1`"o%ÿ{‚;IõÁí£ÌÙ-ÇdĞ«øe½)HhhÎZaÎxEü¨4ò±üt]©ÓôŒØ¬!®‹a=¤0 
y$à”\rª_åSAX>)b™Í£!A“´uĞi­1«ZAq‰Áïõíz)#Àşã@0f•‰9FU¡]È©$B{¶ 7TA0€&˜+>+óõ€h!¡Ñ„*AÊCäü)nÎò!l0oı€amšu6ÛoïI\#t²aM(]YÚ÷gÀ$„Ò'#^¤èò ìf´ƒÊãª'ì287Õ(@(¡C9*Xh´g¤$aRKBûyšó,[Vé*e4Á“~>?‚ú( ¦N,/[Ò×úÕˆ
¼M6t×É]YhslÎ¾Ê <\LÉ%Œ tq3JuY§äùYyg»ş":É¸ ¬hú]tÂkwĞ¨‘Æd$êj…"ól®±%h€œ­ˆ}Ñ©ÅK'aArËDÑb2®i°c*Ha|å%$(Cà7I…qwNhƒ >¨¢M=3’&Â–ó¬±cpE#bS#è¿OË¸lÊÀ­(H¢ŞÛÛ¡lâEXÍFD˜Qee³à_h] ks¹šº5aúTâ#ş™p;hNõYéğ¹r4ˆSmïC‹—Áy=Š°i˜¦, bëtóKn¸àÊ°G”5Ğ1Ï0Í ¬†`ÑÜ„Œ°¡^à”ş+«ŠM((ÏnÏ±#`×Äİì)PZM­™AaÂ»¼¡ã6?4î°ÔlÜĞpqHLFnÕÔR¼	4R’SàZÈõƒ=÷ …k\×ÕáP¡Õ„»ĞLkß5×|RŸişŸ'èš {:¬îµWmÕ¡âeiéÒürÎ¤ê´zêÑÓ 5Bg^Ù¢ íp}EBY(u²sîNÀ"ÆmB`i® «3Â,‚U£õ	z›b@‚kL°ât @\0·¥ñ·ª2ÊF­g°©D5{mùu(¶Èr0bëíé%*´¯_Š¯ß•hFt°Ö¦æZÚ¬ Ñ¨R;¯Ï*Ô)çÍt²q˜pt„#*üë²Vƒ\È Å
%½`BÎYnA¸aÃ¡¯eilÎâBe n€$Ïõ‰U Ôbbœ^Vînù¡¹ä.èlñ"×02(,ÆZTH’ë1$z€W nêÏ{Lòğ9Î Ö|T-#c#f3^ú3“Zäa3 ôÒ´ÁíXÀŠ/¡. È  D,†U\Vğ3å; ’v]¥<½(nZ1ä9Aæ$2qã×ôß‰ÙàBµ€‰LÀ`;›Âşš±:UQÙÇ½¤j1¼#H7¿¥—_8ÖBiMQ+   Ö$Âj.,ñFÁ@	şií8Ïç³RÈõíÿXpOpÍöğİ\@¬ØHÀ“Ğ('©€a)hÅFñ]G!Ì]ÈÀ hiRÄbÁœJ!.8`³m>-ÑÌt
WçûŒ5X0„¢œ8 ¡
´#è¼Ãt¤Ú?˜àúvÇnO½\{O°gÈ°ì k]E9=p4ôœß0ÊŞmrşK„†¢LŞ¦\3èOg}ï:¡%ö|Ùvl%L,Nèz"ÍjÑl .èHµ8' &R	I›%òµõ@ ¡À+NË¼x>wùmï7Øp$Ï \cıòÔŸ÷ˆnO!¼ğ”^­äş¡÷£“Œd
ª`g$!ã#1ÂŸÅ)µxè«Kàgğ¼Í#?Í"¼h¤¤¹ùg gqÇÏğu¡Æ¯ø‡ª ‡C11¼Ğ&é5cD
åC}ÿĞmFv7)Áác ªª™šnI 5a5ŒÚ¨"êJ¤,*i­­pjí»¿ìí/»¥v'=¤6!*%ˆ5¬¬ =<åX$H5líËæ¡|*ÜŠbiIJ"†dPÆD 7ï_ø."zì ŒÀÊ<¤g_Kdd™am¿%£[SŠMÑ&¹°2â¢qñZ=Øu/õ³ÏùfÛÊ¢—oı `¤ªl.pÑÒ¾î%[$ß,W#æ¥Í `;H’e›‡–´} !ü‚PÚù‰d ÒkÅÁåNÖÆÉ‰-2{PÊqštÜÁ}	o?LÈjq‘[CŒŸ`'/›¨¤†4ÛlÔTÀÅ¡r{.ÚpMC%ÌğI[çMöó|Î9OZ¯ıÛLäcyåıœÊˆ÷Lzl‚!À$õ°BÃ×‚Kbş
¦ğa!ä³@b-Áî,Ü"Œò6Ñ3.[ÇSÀùùdÑURÉ¢b ½G!Z­…¤ùX‚.€xlj •%›æªR)Y/}<·{µt¸ìÁöíp“Àæ#ÏL÷ Ø0×*KpòŠŠcÎ&Aà²
é{,%Øª²qL6?:U,*hD¾V„6±ÿqiØH4~†4ÍºË–BL˜“sD{lòc1VEyf'…|yè=s$YË|ş”T2N¬5Æáxipg_|f¿oãõ˜å¨ôÏ:&W1\$¬º"¯¨Rá|}âÑ˜îÊ9sTÀt &YTbXÈ‘ŞHjU£İy¬UØœÖØEÅs—a†T!JÉ¼'yeø~f$§<"UÛä!jG$Aı¾Šè0 ™âŒhè÷Guu-T,CúßSWĞmûdguú4ìlóóa\½Cgv|FäÒÊTÓ}~$Ö(‘¹©kze”Dæ£¹¤"¨b®P¥W¢ei+}éŞMiügğk”¿xUqÅ/ªÑœİY	`µC7äMg2Åü+ÕQftñDø;Pwáù¬ƒ 4!²õ.É64æÔû—åmBQé‰LIO3J9µÂ¼sÑĞ,ÈÌ“°{Ë`~äå<éßşR™#1š@Êæl.qî­|$	n`.¸c«ü&$®é 8z&-ø`Šæ.€(*¸è *z:ˆESR-TØ8jAKrU¦İäTcİ >êêŒ‚·cPw¶¶ïâ‹lŒêŠª]rh½Z`Ü@êA=lôõ«ˆ.iŠ@~å 8í²*4båuJE-´­óÀW¥3·fOÄúî)\
 Â¤,!µ)>ê4Ñ0LègA”¤´'.ÇÁ2 ÉFzíJ"= dQ¡auÄûZÀ l½²áèáAB'æÀ&V @s)sÊmwœhÌ`²Àbf‡lJ np}iÂÉï$û
ëÉ-!ÆM¢bKc ›hs­†í^¨\zÓ˜C¾×dØˆpw7,dQ+ÜÆsYn·ådäò@"0ùhtàH_Î4Ék¡äT¾×%ÂÁdur]ÒÚğÒ`¬¶»zNÉ°ba{¤EÅÆ3uÎ—=sg‡8àK*ª"6Åñec®Õ;¿\M}3æVUm+ê \b)pÎ|ÚÑ‹ø’K°G°HJíòVc6U_©Ì ÂÜ—›Z:jíRív
@‡¢@ .ÊG„şp!×7\mØl1J5´¦YìÔngÿ)G¸nøòÅh>ÅGŸ0\/±UZfÁÉ«ÆetºÚ±­[“ğ¨!ÀfH¡? gËîE`’ÉW-¡ìæ9°òUhTùU~
¡lÔ« ©`ê8¼@ÆmPh£¡z €t6$Ú@¬¬i¡å^flğø£ª3H~q(iixô¾òß«£óœ6“Æ­ä/à_|Ó;„n\wÄÈÉ¯ è'â„Â(¶D 	¨&ÓòCM107P's`Û ¨fÏ¦f7ŞnVÍXŸğ¹ÈVßxv^Cnl¡`h"`ÀÀ-&ì.YQ„B¥(ÂË ! İER&:ahnIGI—9ãˆÜõÈÁf}?u{|İ) âá>ÚÑ~áÖõJºÏ­’ëƒPF©hŞ"$Õ¥Ô4ncùVxbùœ Îê¤Š –)H‰È[+lqÇ#È`xš£piVBj% "” §®N…¼éG"S ê#"(İmP-€$¢2" Â(°¢ä…-#§LYu4ÿ¤ğyÛ.b6˜*³ë¨#(OšQ#`ìyı¼¨{ìİø}ì¬^ÇÕP²©ÏnCbá¹œÿÆqád
çêøê>p{ú³É0o{Á² ¨¯2&&v† ò/6D ùtø?VövpbÎC‚Ê°£gDxÓÇC,u¯”v€ÁÃ&i½`CpöKÃù^!ªâêë¤—+JCk   Î^øô("<z/`t»ÈVˆnKr¢àU-Ë8Ænii† ”äpè!è´­†Úè.åIÅª&B¤p,¢ZJc.«(^ÈÛ}ëlç`¾ê[$‹ ¤s†¶NŠv’Få-ºç½v‹q;cÚMOåóüâ;—JíÈsL’‘ÂÜQ‡kÆ$D%ÉtP&` B2LCCríw;FGq?E¹(øiémrõãÿlÆ·ó`Ğ†Uxôâ…`â8ë¨Eobˆ&óİoÁØÆ
7º:	S¤ÿ$ñÖ_/c® -æëš«v
0ÁC‡²"êÈştõˆH \Â¯1âeaz´âóv(±<a¢Æío'k~ê²Óı‡y<PÂå« ¸¢ l²å–ÿ>Â1oiÙ8Å€¶rÖæ)p?,0Dhté«ãÇšû{b&2yèmÀÛÔFıUg¡º'$G3è²#iQDğ@Xøg	‡»ÌxyÎà(8Ó+“s£!Ï¶È‡ ¾ÆÜ (OŠëbQ! ¹vau<$<w×¹g5ú 4!„i7g6 ¶(”ZŞ5ø`r	È¸=alwx4/UÍ|‘]ÎUåjgg6²5(85K00MÛ$õ FSö*yuäé¶ğÇ.&l²y’¨$`´ŸñXnàè ¼!ÁÏìîâÇm@G)YÂ
> Rt§-¾ °( y $(ç
!bdig™l’cŒ8“O]q­(út˜ fiK¸>)¤ë$ê02 e* ¿Ì`nã(rE—MF?`c)¦9ejpsÏÌnjjxm(%!P|v0¹ y£ùá·æ<ò ¸$7p³hGGQŠ8If¨éVWi !W+°#2 a|Wâ}&° G Ù^,¤‚ w2/GLyM!né9£·§?¦d~/Ëı	c{fb½tĞ1Ã_H[,:içb5®vE.²Ãj²pãTõÕ¹0é’.m¨àMQ¾ÛÃ‚*s6À )e!x*CÌrLW/itqBİıçÍ®8-Á<`c÷{jŒ6A +YXgÿæA&µúµ™†p È*òbh½,xçàbM²$8`$³±m"3R8›ƒA!!md±³zt4©Dq3²Gl|*ì>éé!ôëd°0×”¡' €v¿=?vä>2wãCt](e¬*ı©¹%(™x0rå Hwvóq?ts‹:f3lîùtac€2ŒD=êv‹7/xPKzªNûSÖ#y ÙÈ§\óqf T¦­µ¢N¹BU#f>ã¤ø˜ôHa„d t(é2&T#=¶W,<ós­q­®êÕ_9öÖéäï¨Töb $ìi%DWç&	(ƒl¾*·e|w¨uª@³0š/:I lÖ]Š"D…`á>€‡6 „"“b¹ «$ãg/Kßå†qÍãÍ$¯KT1ı&ô¤1kLĞÙt{J=qãõ)f º†‡L0õ`dáõ—8±3TjÀà$t <"q?2 !Õšâ$$f=±+| 0b4aØ.Õ ¢u@xŸ:HL£y$ñpÅóbŞäŸ³5@qióc¿-bîğY÷46;)~g€+t,]<Êx1é©)`oNf'±(¨%,%QD’ã&À ¡VIà$º4"aˆd`
<51Á"Âİô¶Ç+İpTàŠÕ(Tr¶ôAzB1&ˆ!ùp±T÷|eäyƒ­!,ƒÖÀÕqh>*ñÑ#U.]H$6ùc&69®99X1[Ø@=¦e@ÜGs¬~¬F¿Ë › ±=Fä·	I
*={0À0~ „ıñlD#	õ;71dy rã£0Ó‡»øÆ( à!vX,Ye8š£`-½¼l=FC” >.M¨$s¾aöæš+|»(.B2-cN|¬–~¢?4l/V°w$ğ)m9°([teE5òˆI²dì Là´ G@? cxO01tÜğÑpiS+QşŠaodÒH\]$ô*`M|yHy³xe$ºeàowqú{È^ª®	:'¬àü ’c®féT
ñ,\Wà(f	d$q,œ6´7¦ÿ˜ô0`\V9İNs B¥ßéMq²J=½ªó5õ–!§f<Ì“tAiP}`“²q)+.[L½t«ÌÅ-ó,]£,HÃnmB?¶0Ê-"."^N$ñÔ(,Q4 †X‚ ¼m·k0lQ7,ìRA}oPx™“u{-&#9ùC ¹¬Gi)÷EmKéº­¿³.ùîû9ı@u4 íqâi©"x7!33m¨L§,(y‰E
ºfÇİ|©à_")Ôb uí¶Ü i(a!4†MY"8g--#"nÇ¸`sHqøîZaa&1Ş5bO7æ<84<àåÏŒ1i´6cdŸL$/€3`jZfx\äå„hd°¾ê=Ch-v±ï«À¸&(è e2Ù0=ÎO ™°·!©='=?êñ€lƒ4î0K€Nò6X"ªxËÜÉÀh7LtSaâuê.ù9drÆ6id¤°Vs3ŠÁ¤ü¹cÄmeyg3é5ırAYb„|,x¹c{~BË4n@Âoanô,ˆp 6Dá2/¶"4$æ;vå"$HRYÌu.m[Í””Ÿ!¢_î. 1-H{<¢•ˆiIáxªpÅ£Ì=%5äi”
¬ ¢îò@{dQdn1LaGnjDpmı‚l$Sì—Ñ"2v)ùö7Ù]à_¦œüüûb7fVÿi{ ægiÈ2HZš&S(44p´wc1æ]L+GDlsxzİØåò´p‹2ëĞ 3c3bd ú,b§Së²N
Èd`ä¨‰™"JàEr®ŒA|fo*ÛèS8ìR9÷05¼;5Ô«œgñ~™}YÔÊ¿‹&FSü7; ¶“û=%tOÑßE/oš²µ,VÃsY³·sçLzÀ€˜¬Yñ¥kxóDô	z£.C$§\Õe‡Ád—[ƒB
ÜÏdĞs$yRÛV· 5áñ.¡q/% ¸…a#7)û¶­x	Ù`}6nä
İÄ"xsí3FbmKvÉŞfoë(=+ä¯©áHe8sà‚!ä.^.Mk:Õñ¿
ˆğ8ì†	PymÕlğŸ´%yTÜR@yìĞOùª¬>ŠÕ2ƒi@b¥÷ ,®¢øõhqú†>Ét<=m¬f™¬:` š@Uo ; 4|a¬.FgQ`w/“øv"o|n0Ê!Å¯ºOYòå"4óM"!#(ôddôkäd.8d\lfånqKjaµØæp*O¤U")XÃ dğ¾yÊItö/«méñQ²iå0y‚ 7ë].kf_eNM#À &æ(9Í¶Ií=Æ4äw`¢Kşù:dTc%Èw>."~—Ş{’Ğ 2fèÆ BY(`#™öƒcw¼e‰«(7µD JD~0gúÁ4yén½¼PkQ$Np$öc_7-#"À'ymµ¢î&vÄhĞ»¾.(J¬%êHUd`x©à¹ÎzâP£,&3qIò<µ8M°Ã+i¹]˜E8S6m!7Ìt e<¶ât]0MõKsâ*1Éq:=0$|ñx¨4/½µK9Ğ.…$@\©5ªe0ajÃzR)4¨<˜©gü"^E”(8g}ÒĞ8´:#ó0$êY[:nßŸ~á˜¨2®]yíÛ¡áUm¨1\tÃr$=fèE¬9T<ar  !à~E³°"-s>@O¤,Æ³ VŸûa‰kƒàfµÚÌ]EûK0–x](/7&É]«B«9rğ-a }}Êåˆ^!µáe¦ee
ğşÆz‘C&d%p-`ü±Ö×qt
Îc5
yj>m?L,yÀôï-8Xp¬w°)T7J Ø :KÈI·BMk·4°$lDK¬`Dù¹ Ÿp%  t]m9Kä±¦ hnñ<Ójµ6*0	;r;¹aRè¹úsUï"Ph!lfo¤$ŸUgÛÓëSu@xˆ(7<µ¼è5U¦Sdo*zrNæ*e(kï l9)œ 5a|uæk0Ê¸dw,D®ädd 2s§{å>¥Ah¸	eakÀqìUÒ0) tœc^•ëe~DFR‰‘àmh­%Wi§V[*&‡¶—` i86mo; )ê^¹ñ.(÷´•‘â'ÆN;hñôğDXtMbeG J\õ<g¯*ø0ÿ_b)¯L:(X¤CvÜzá›
aø bj¶Y#TP5l<¬,)NzÎæ”°C2#å^Ë@¥2İT‹`©`4%K,²e­¸óóí,¬ `Ò×u¶9{Ã4M'77fÖ¸L,#~à©™eÇ7$(% 	ïd:{!U9ê
qOde3BJm2¹§9/b  e¦cÓõõ’Cmx€ĞRÂG)ú{;|˜pº´åô ƒğ3W,.ª}€yrPY_bê0V ¦k 7måÁÆ^yhí4mò3&ë£l<p.¼3ìòå¥ÄÄŒÁğèĞ"Æ}‚FsŠU
wã’¥¶Œ’aÖ<g)òÀåe&ÁéÁ’^˜ÇsCZ)É,IEsÍ>r—7™J7n%ob9D¯rŒ,¯`$³ÏÔMù ´›]¬T’r6Lò+x§n{Naùs}¾~¶ısk NJËêê«gW`jùB1‹B¥Íè¯:	0òk?W á$†QÀjÏù<m= «® opiJCàw{f	):}|> !QãÙŸèÀ‰»™T±aVUdÌEEÊ íU¶Ñi Ÿ¥pEŞhsÿòoó"lsgasdÆ…lğ4d.²âh‰ mâ*rZio4cDhé%nö(XY‰iæ^ä7+† Ãbø.‘¨Ã¡ƒ´C6îx§¡§2X`b d@©_zÂIÆ£t¥êh|IP2í=[è†Q#Ó7w}2Q8Ip¶(#>S9øÒ`ºpìyüä!3tÂu¶7.Ğw{ne¹fIì4!'†Šr F‚w¸uøG¥ t±¥¯à=æi4©¬c¯-“y—ù)zla1,¹P_.<Õâ$($uš§½´@€¡tãE<2(ô%Ï¥¢Q ¡!0z3%O`¦yî6J¦ôÛe¹qí.·µıQÔ,<f<:Rìµ,¤dfL|±×FÉ›å¥R$dgá~ `H-c$;8$V+H#ô"YùoÓ6öt"
 h‡)=(§8<‘9@â u¬jŠ h-\íP,º@ó=Ù@òF=óaZ§t¹ÕD,/ `¡)b>1q`²E(”Ğwæèd6‘!'*Z4p»§b¸{wE¡'—5bV¾×‰ô+¶.Ÿqó(Wo©ñKÃÊr
6u	j„y¦ó/o5"•—ªwÆ‚%0ó3œøÉª)•¢Ÿm)XDhdüJÌÉrF¦‰ÔQg|c™N~RüD™1åD9d¢draÅ\}nŞöcj]â !mÁ(gÄ…ö_! ×%‰ñ!¯±`KGW3Aó¡ä;Sãj…i”!ÍMïM|¹se8%¥êºk4_<í9dıbq/ÕØs#7!	+ A_ƒó¦)ÛkuoëU(¦Ñ¸$ŠÑÙ‹ba4:¼qiU-Ğ‚c—Ei½»%1)f#\!XÎ‚ÎUcA ‹
oqyl$¹t_âc“¾çÌ5u~©ã"<e&y²€î¢gWÅ[;àx0"’a^Oƒa`ñS0û~&5 Ïpè» ìøÚa2[ñtJB@dÜMpxìâh&™Hov_® ôâXuH§yyd^“réofgºMLİërkYóHâThe%.M$Ç»A¤ÎõäsªæÙ¼Z2!iKu}ìzrÀsˆNl¿…yI¦²?ï4uvi`bï©Èx™Òm}›Ëà3A¼
(âUù2¡ ‹ˆæR+È(b¸ùµ
"L„—¤­G´ípAv÷kWeäºD4"ù#A 	e%àU&–=r¯¨\ptğ¥şKëXa@p^ÛÀacá-r$:ÓTrò§h¼¹0¡¨bv•¤D>f9¢PàU>¦0cl}§3=­q"Áš¤óØ•aÁäÀ›E"%il•MWwÁ‘tœêà$àd“exDœC©d¬Q„×FZko0%Ö+>cÙ	Œ{kHnŠ;f|V—u9]=z0n"·6;«SpFØéúºPT•}T:hTÃ¦ıJìÄYAS;ö{¦54v–ğ©qùE>y4p4Ó¦BıpS©m2ŠŞ§	±ı²xHøh)@dWTĞ6!²X´;Î ²b9¥	ì-êV5l°°ôµ ô`“^ı <%êsÇv{s“9&ÇYd•.Œ OzwÂ±†± ¯,!ë÷;?vdêQh}‰I.±I
B´§1B}[d¿s>€")}Aİ¢¨S)ÇfP
¹d§© H(
re/x“ezá<¨|d]«òvX©!¾²==$  Š8T0VM{»0ZåScqI6+=êßí­E›v`Æ-¥s« $©`NaU¾½ # ŞóHqf“,OE›!yX‹v%aÑ³17eÁ 	f‘!6)ó•„@i‘E€:Ö[¡-NîöpÕveå?Ña}Ú=>µÛOæIT5"´ºH_{8—o¥$AÏg(^åì2ô÷ô‡/éãª#ì3xE*`¯ğop$h„lÊô
e $eQKJ{a™ó,„>^kjm2ÁÎ|$ÿ	û4%$n==[Ò™úÕ	
>Y6uÉLA`pQnÎ¼ê8\ˆLê-˜K<!3Ix§¤uXb­¶á:‘Éx±lèğ9`ÃsÔŠœ•Òd7fyújÆ&ò,¾r2hœ/Šeˆ]ùD	©Ak'iUªËl¡".0°i³cşMalåe”E@àsHaP6nlÓ ?F×è¢m2& ª ¬!‹cpE(fcø/MÃ8eî %n| ŞÂ*‰lâDXÍ	@u%E/³àßhq¥5{c;š»=aº·Thãƒü¹p/=+õUËø-p´Œ+Q\íJ	«“ı!œ ë˜f%@r[*<3kòûé)°FÑĞ4o7sÍ ¬&b_…€,, _`ü1]¯ÚMn,NNÊ5!`ä,Wï%EúdD¥İAMbË¾¬1ó2=”¯0”$Èõ0p¸FØ$n½Ü&<«}råVHõ=.ï0ïX[Ìqx¹“;`U)06×}Fhş¿7m–0S)87¬¢±å á¢g_a}süUrÔ¦y}z úª‘Bj1f'6
Í°µ}ÿğ}ebP(u°qÁîD@.Ç}GpRq&4¨;À,={£Eğ9°Ÿã`ëM± woe|:§¥±— 2ªD¬g±*u‚4}í}õ(¼ÈR4bì°µ
´¯W‚­"=hVp:Ö6
^gláY.Rgn‹D¡.ÇOÍ8u4w¼p-|ö‘*şi?¦<4‡<ğ(”a5ô8'‚h\nI¹dS¡+ae$Î`&% ~ õÇåUÒDbü¾W¾8±>!jÄ.&éâ¢Ó4(i•<\0*Ëqrwéè>Fèæy, ×])"i!&2Æ°30­a3sˆòğôƒAíx®@ä'ñ,à!f„\F¦Upú3"õ= ªU]µ,½$»[¡yAf 6rë´ôû8ğâ_”µ,ŠW_Âp9iÓnšñ9ÑQg@=*ˆmŞ!-8©H5­'el·aeQ«pe0R$Hn.ĞGÑLPşhiw«Ú¯èµí÷x2qMöØlÖ ¬H$@Ğ“P åPg=(İGû	!Eh^ €À (áRÆbÁ¹Ú%.xpQíÔV-pÌ|*U7ú½H1Åš==aµP´?Ï¼Ã$$zuäşvçn<4)ç4kDHpe0ßmx4t™ß8êî- ìK”†€l¬¢0¬~cuo¡Ü<Ô(\V-å]$tâkeåjÑ$ /¬H5;%Æ&x6E
+'s1¥  µè!;W[RÉ¬X_8uı%ªfHP {i8RÔUíˆ !ìò”^°I°ü¥õ/ÑÕe
£dg$£ã£1Â¤	­x)»às0ßTbWí+ILfdİÑe@ kuÇ¢p"A±_ÄŠy',êà3‡C<ÑOé%#Tá}¹ğu$.!aÁBd¨’º˜O€k	á,5A%>gÉ~èj-.½ây-`oí1½íí+ šåpuL™=4~g2mŠ}¹ô,<,¥H'9Ô¸‹ ¡v; \ªbIFjæ$rFf+7«_x,![y~Ì÷î¿½6Gd"d
™aí]7²$ó[W]Š¬Má$A»uæ#9µZ™}-w0}bÓÈ6’q|p}¼ºñ?0±ò?¢%Z„Š.D"§íŒ!h;K‚i©÷…´}¼)|úô©(u ğx„ğàoe¦ÉL4eŠqÚ@tY£qQ}{±^Hj9y [
"ˆ3 g ·¡î¦7×lÖ Á,s{,ÛÚ¬B,Ñy{cLLöwÖÆ9iMòı@âcidxŞæ}lgláõğP{€ŠEo”şH/òñaÅ7Bj/î`ÎbÌz6TùïÂZGi ù˜h›Q Õì¡f ½WZÅ¦åZÓ<°xmJÕwyï¾Z((\µ{¥$pDşèpĞÚvk
dÜ4¶.HpsZŠÃÎ&àš’
é[(%8R³²pt2:u-:yLš`¥…·µû"9NõİK6~Æ$IRLú³{ [Tğ#pdyf§Á~y©E5r<;1n>4ö’T"Æ 5Ôğ%
Xmiq	0F8%#õ¨qò¶i&W1ld¬r¯(Pğ}p¢‘ÙüÓ·åÕ±ö¢XbzÌŞMjPóÙq¤1ÙØæ‰ÌÓQ—yT.JÍ¼'ysï`.#Î/4"µNd!`GFM qışŠìu±QâŒxhõGkq½<G-EøÓßÔ}kTf=út}¬óÓ1i09cg`8^tÚÊRÓuúP ½¨gp5P Tæ¢<õ§p&¨r¦RäG¢ïh/][Ğm¶m¸+5?xXAÔS•e" ÓœmYI }K.ô]e²Ş)Ô¢",ğDèŸUuôùï‹ 41:µ,…6uvôû”íibsñÌHg0s3}Â¬¡p Èü0±*-àdzàæ¸ğ_óØ='1i.æl}Î½Lf:)jP*šq©øõFåªù 7\:&-xà*æ$À)k_0OFA®p;ˆ…[otS8n%ÚxG¬udPfÿ hh€Ö¦3pus÷ïª×`:â+ËQãy¾[HL`áA?`¼õƒÄ|mÊHzB°0ü¢©8fåu/m/4•±ÀWa3·,1vz(.\û 4×­4Vgu=·)?ê\Ñ<\àeIP„¤%
Ç¡2 ƒFü¹Â"= gq•!5 Ä€‘Jp0L<2héa@@bd@.Va]‰ƒœioh\aõÖW]ˆB°¬lñx9ÀmÅï(ûy~É-˜†M rqZc&Zp)­mZ¬*˜E9’Ed(Ì0f,`Q«ŞGu~ıgeäöà"p¸`2‰pü]÷|Ùi Åq%B™^uxyÒÈqòp$¶»zNP0B`Y­EÅÆ63W2¯—=sf1âK,  4UøeeŠÕ¿{*YWumsîšU m!â tv)|ô|Ú™§Ø³iòEšÈNı6€2i&×K©ì¡ Îì‘ z2`éBÒ(@M#A"&FnGÿp'×uToü$#5µ§RìÜhwÿ8G¹L(Òa œ•Ï‹t4-¡“Z. "ˆI‹Å%4EğÚ°A¼[Bp¸¡ñuh0!? gJìd(ÒÍF¤
³l¢1°oWiTzÕ|Â'lt‰­(mê¸(
Ælqê#±j p&$NJ	„>ac¥våXF#lõø£«ios8)xô®ğKÏ+¥±—Âíä(~?=31ÄN\5@IÁØ¨è&b¤à(·U`2Yi>}A^20'~15cèû1¨"æÜ¶De5ßÅn}T\Xßğ)èGÎ.0C
x%p4(²`eĞ-"üxP[3[ÌKN‘a êO0!.zcShj9(YÒ9ãÈÄunm+wcôt© Âe’3'ÑÖõBşß®Sã×FŠlZ"&Å¥Ñ0"k~pŞz}ü%ÀJ´p+A‰è{$óE³¨|x±éxy^@c! e´çŞFNımo´—wRëc^4ÌmP­€%$
!! i°£å/C·UTQa4%ı$æx›<rrœ*°ã¬!h_Q2 ï[õ>¨“{ìıÚ?|¤^Çİ0:á+«fİÃbI©?o§4±{‹(Øë:1 {ù‘ÍlïI4 ,«&&1‡ p/ `eğuzô	tpsÏócc*öäQD}ÃïEluÿÄp‡AO.>‹½ìRğôk Ù0ªnék‡—³/^C{¡¡flğx!ç|.usju?ÈZ"ÛqŠÈU,É8€i{¦F”Vä{`)bÈc<½4z!/áá(fd=¦1;§ H#N« èoœX¢|(b&Ê[¤Š4´qöˆÙv¶¡Jg=¸6=r¨q;"RaO§ğğ÷*ŸoiÈsL’‘©Ø1£cb$@%Hq@&:eaV"ÌB%vá kv†µ&-(`rk¹}rõâûHfñ Œuxöjlã:c¨1bˆ&%ÑÜaÁÚB7v°R±A#Œj¤ñ0^+c¢7=¢£¸ s%/\[§ş}BèÚót1Iá½((xà®9àaz4bãp(¼<4a¢Fí#dM^ú;rì©é$Ğò_`¯D¸l()ºp~¾¢9s#Ñ8ÇÑ¼r‡æl2oo0Eètë©ëvÒ{ûy r³9èdÀËUIÛUg£ª#$SWé×3~WÎ,_A~èfiûí(ij (˜S1²ñ">!ï¾ÒäFÜlclose(tau, 0.0)

        # and now for the proper test (lower=0 is the default)
        data, d, e, tau, info = hetrd(A, lwork=lwork)
        assert_equal(info, 0)

        # assert Q^T*A*Q = tridiag(e, d, e)

        # build tridiagonal matrix
        T = np.zeros_like(A, dtype=real_dtype)
        k = np.arange(A.shape[0], dtype=int)
        T[k, k] = d
        k2 = np.arange(A.shape[0]-1, dtype=int)
        T[k2+1, k2] = e
        T[k2, k2+1] = e

        # build Q
        Q = np.eye(n, n, dtype=complex_dtype)
        for i in range(n-1):
            v = np.zeros(n, dtype=complex_dtype)
            v[:i] = data[:i, i+1]
            v[i] = 1.0
            H = np.eye(n, n, dtype=complex_dtype) \
                - tau[i] * np.outer(v, np.conj(v))
            Q = np.dot(H, Q)

        # Make matrix fully Hermitian
        i_lower = np.tril_indices(n, -1)
        A[i_lower] = np.conj(A.T[i_lower])

        QHAQ = np.dot(np.conj(Q.T), np.dot(A, Q))

        # disable rtol here since some values in QTAQ and T are very close
        # to 0.
        assert_allclose(
            QHAQ, T, atol=10*np.finfo(real_dtype).eps, rtol=1.0
            )


def test_gglse():
    # Example data taken from NAG manual
    for ind, dtype in enumerate(DTYPES):
        # DTYPES = <s,d,c,z> gglse
        func, func_lwork = get_lapack_funcs(('gglse', 'gglse_lwork'),
                                            dtype=dtype)
        lwork = _compute_lwork(func_lwork, m=6, n=4, p=2)
        # For <s,d>gglse
        if ind < 2:
            a = np.array([[-0.57, -1.28, -0.39, 0.25],
                          [-1.93, 1.08, -0.31, -2.14],
                          [2.30, 0.24, 0.40, -0.35],
                          [-1.93, 0.64, -0.66, 0.08],
                          [0.15, 0.30, 0.15, -2.13],
                          [-0.02, 1.03, -1.43, 0.50]], dtype=dtype)
            c = np.array([-1.50, -2.14, 1.23, -0.54, -1.68, 0.82], dtype=dtype)
            d = np.array([0., 0.], dtype=dtype)
        # For <s,d>gglse
        else:
            a = np.array([[0.96-0.81j, -0.03+0.96j, -0.91+2.06j, -0.05+0.41j],
                          [-0.98+1.98j, -1.20+0.19j, -0.66+0.42j, -0.81+0.56j],
                          [0.62-0.46j, 1.01+0.02j, 0.63-0.17j, -1.11+0.60j],
                          [0.37+0.38j, 0.19-0.54j, -0.98-0.36j, 0.22-0.20j],
                          [0.83+0.51j, 0.20+0.01j, -0.17-0.46j, 1.47+1.59j],
                          [1.08-0.28j, 0.20-0.12j, -0.07+1.23j, 0.26+0.26j]])
            c = np.array([[-2.54+0.09j],
                          [1.65-2.26j],
                          [-2.11-3.96j],
                          [1.82+3.30j],
                          [-6.41+3.77j],
                          [2.07+0.66j]])
            d = np.zeros(2, dtype=dtype)

        b = np.array([[1., 0., -1., 0.], [0., 1., 0., -1.]], dtype=dtype)

        _, _, _, result, _ = func(a, b, c, d, lwork=lwork)
        if ind < 2:
            expected = np.array([0.48904455,
                                 0.99754786,
                                 0.48904455,
                                 0.99754786])
        else:
            expected = np.array([1.08742917-1.96205783j,
                                 -0.74093902+3.72973919j,
                                 1.08742917-1.96205759j,
                                 -0.74093896+3.72973895j])
        assert_array_almost_equal(result, expected, decimal=4)


def test_sycon_hecon():
    seed(1234)
    for ind, dtype in enumerate(DTYPES+COMPLEX_DTYPES):
        # DTYPES + COMPLEX DTYPES = <s,d,c,z> sycon + <c,z>hecon
        n = 10
        # For <s,d,c,z>sycon
        if ind < 4:
            func_lwork = get_lapack_funcs('sytrf_lwork', dtype=dtype)
            funcon, functrf = get_lapack_funcs(('sycon', 'sytrf'), dtype=dtype)
            A = (rand(n, n)).astype(dtype)
        # For <c,z>hecon
        else:
            func_lwork = get_lapack_funcs('hetrf_lwork', dtype=dtype)
            funcon, functrf = get_lapack_funcs(('hecon', 'hetrf'), dtype=dtype)
            A = (rand(n, n) + rand(n, n)*1j).astype(dtype)

        # Since sycon only refers to upper/lower part, conj() is safe here.
        A = (A + A.conj().T)/2 + 2*np.eye(n, dtype=dtype)

        anorm = norm(A, 1)
        lwork = _compute_lwork(func_lwork, n)
        ldu, ipiv, _ = functrf(A, lwork=lwork, lower=1)
        rcond, _ = funcon(a=ldu, ipiv=ipiv, anorm=anorm, lower=1)
        # The error is at most 1-fold
        assert_(abs(1/rcond - np.linalg.cond(A, p=1))*rcond < 1)


def test_sygst():
    seed(1234)
    for ind, dtype in enumerate(REAL_DTYPES):
        # DTYPES = <s,d> sygst
        n = 10

        potrf, sygst, syevd, sygvd = get_lapack_funcs(('potrf', 'sygst',
                                                       'syevd', 'sygvd'),
                                                      dtype=dtype)

        A = rand(n, n).astype(dtype)
        A = (A + A.T)/2
        # B must be positive definite
        B = rand(n, n).astype(dtype)
        B = (B + B.T)/2 + 2 * np.eye(n, dtype=dtype)

        # Perform eig (sygvd)
        eig_gvd, _, info = sygvd(A, B)
        assert_(info == 0)

        # Convert to std problem potrf
        b, info = potrf(B)
        assert_(info == 0)
        a, info = sygst(A, b)
        assert_(info == 0)

        eig, _, info = syevd(a)
        assert_(info == 0)
        assert_allclose(eig, eig_gvd, rtol=1e-4)


def test_hegst():
    seed(1234)
    for ind, dtype in enumerate(COMPLEX_DTYPES):
        # DTYPES = <c,z> hegst
        n = 10

        potrf, hegst, heevd, hegvd = get_lapack_funcs(('potrf', 'hegst',
                                                       'heevd', 'hegvd'),
                                                      dtype=dtype)

        A = rand(n, n).astype(dtype) + 1j * rand(n, n).astype(dtype)
        A = (A + A.conj().T)/2
        # B must be positive definite
        B = rand(n, n).astype(dtype) + 1j * rand(n, n).astype(dtype)
        B = (B + B.conj().T)/2 + 2 * np.eye(n, dtype=dtype)

        # Perform eig (hegvd)
        eig_gvd, _, info = hegvd(A, B)
        assert_(info == 0)

        # Convert to std problem potrf
        b, info = potrf(B)
        assert_(info == 0)
        a, info = hegst(A, b)
        assert_(info == 0)

        eig, _, info = heevd(a)
        assert_(info == 0)
        assert_allclose(eig, eig_gvd, rtol=1e-4)


def test_tzrzf():
    """
    This test performs an RZ decomposition in which an m x n upper trapezoidal
    array M (m <= n) is factorized as M = [R 0] * Z where R is upper triangular
    and Z is unitary.
    """
    seed(1234)
    m, n = 10, 15
    for ind, dtype in enumerate(DTYPES):
        tzrzf, tzrzf_lw = get_lapack_funcs(('tzrzf', 'tzrzf_lwork'),
                                           dtype=dtype)
        lwork = _compute_lwork(tzrzf_lw, m, n)

        if ind < 2:
            A = triu(rand(m, n).astype(dtype))
        else:
            A = triu((rand(m, n) + rand(m, n)*1j).astype(dtype))

        # assert wrong shape arg, f2py returns generic error
        assert_raises(Exception, tzrzf, A.T)
        rz, tau, info = tzrzf(A, lwork=lwork)
        # Check success
        assert_(info == 0)

        # Get Z manually for comparison
        R = np.hstack((rz[:, :m], np.zeros((m, n-m), dtype=dtype)))
        V = np.hstack((np.eye(m, dtype=dtype), rz[:, m:]))
        Id = np.eye(n, dtype=dtype)
        ref = [Id-tau[x]*V[[x], :].T.dot(V[[x], :].conj()) for x in range(m)]
        Z = reduce(np.dot, ref)
        assert_allclose(R.dot(Z) - A, zeros_like(A, dtype=dtype),
                        atol=10*np.spacing(dtype(1.0).real), rtol=0.)


def test_tfsm():
    """
    Test for solving a linear system with the coefficient matrix is a
    triangular array stored in Full Packed (RFP) format.
    """
    seed(1234)
    for ind, dtype in enumerate(DTYPES):
        n = 20
        if ind > 1:
            A = triu(rand(n, n) + rand(n, n)*1j + eye(n)).astype(dtype)
            trans = 'C'
        else:
            A = triu(rand(n, n) + eye(n)).astype(dtype)
            trans = 'T'

        trttf, tfttr, tfsm = get_lapack_funcs(('trttf', 'tfttr', 'tfsm'),
                                              dtype=dtype)

        Afp, _ = trttf(A)
        B = rand(n, 2).astype(dtype)
        soln = tfsm(-1, Afp, B)
        assert_array_almost_equal(soln, solve(-A, B),
                                  decimal=4 if ind % 2 == 0 else 6)

        soln = tfsm(-1, Afp, B, trans=trans)
        assert_array_almost_equal(soln, solve(-A.conj().T, B),
                                  decimal=4 if ind % 2 == 0 else 6)

        # Make A, unit diagonal
        A[np.arange(n), np.arange(n)] = dtype(1.)
        soln = tfsm(-1, Afp, B, trans=trans, diag='U')
        assert_array_almost_equal(soln, solve(-A.conj().T, B),
                                  decimal=4 if ind % 2 == 0 else 6)

        # Change side
        B2 = rand(3, n).astype(dtype)
        soln = tfsm(-1, Afp, B2, trans=trans, diag='U', side='R')
        assert_array_almost_equal(soln, solve(-A, B2.T).conj().T,
                                  decimal=4 if ind % 2 == 0 else 6)


def test_ormrz_unmrz():
    """
    This test performs a matrix multiplication with an arbitrary m x n matric C
    and a unitary matrix Q without explicitly forming the array. The array data
    is encoded in the rectangular part of A which is obtained from ?TZRZF. Q
    size is inferred by m, n, side keywords.
    """
    seed(1234)
    qm, qn, cn = 10, 15, 15
    for ind, dtype in enumerate(DTYPES):
        tzrzf, tzrzf_lw = get_lapack_funcs(('tzrzf', 'tzrzf_lwork'),
                                           dtype=dtype)
        lwork_rz = _compute_lwork(tzrzf_lw, qm, qn)

        if ind < 2:
            A = triu(rand(qm, qn).astype(dtype))
            C = rand(cn, cn).astype(dtype)
            orun_mrz, orun_mrz_lw = get_lapack_funcs(('ormrz', 'ormrz_lwork'),
                                                     dtype=dtype)
        else:
            A = triu((rand(qm, qn) + rand(qm, qn)*1j).astype(dtype))
            C = (rand(cn, cn) + rand(cn, cn)*1j).astype(dtype)
            orun_mrz, orun_mrz_lw = get_lapack_funcs(('unmrz', 'unmrz_lwork'),
                                                     dtype=dtype)

        lwork_mrz = _compute_lwork(orun_mrz_lw, cn, cn)
        rz, tau, info = tzrzf(A, lwork=lwork_rz)

        # Get Q manually for comparison
        V = np.hstack((np.eye(qm, dtype=dtype), rz[:, qm:]))
        Id = np.eye(qn, dtype=dtype)
        ref = [Id-tau[x]*V[[x], :].T.dot(V[[x], :].conj()) for x in range(qm)]
        Q = reduce(np.dot, ref)

        # Now that we have Q, we can test whether lapack results agree with
        # each case of CQ, CQ^H, QC, and QC^H
        trans = 'T' if ind < 2 else 'C'
        tol = 10*np.spacing(dtype(1.0).real)

        cq, info = orun_mrz(rz, tau, C, lwork=lwork_mrz)
        assert_(info == 0)
        assert_allclose(cq - Q.dot(C), zeros_like(C), atol=tol, rtol=0.)

        cq, info = orun_mrz(rz, tau, C, trans=trans, lwork=lwork_mrz)
        assert_(info == 0)
        assert_allclose(cq - Q.conj().T.dot(C), zeros_like(C), atol=tol,
                        rtol=0.)

        cq, info = orun_mrz(rz, tau, C, side='R', lwork=lwork_mrz)
        assert_(info == 0)
        assert_allclose(cq - C.dot(Q), zeros_like(C), atol=tol, rtol=0.)

        cq, info = orun_mrz(rz, tau, C, side='R', trans=trans, lwork=lwork_mrz)
        assert_(info == 0)
        assert_allclose(cq - C.dot(Q.conj().T), zeros_like(C), atol=tol,
                        rtol=0.)


def test_tfttr_trttf():
    """
    Test conversion routines between the Rectengular Full Packed (RFP) format
    and Standard Triangular Array (TR)
    """
    seed(1234)
    for ind, dtype in enumerate(DTYPES):
        n = 20
        if ind > 1:
            A_full = (rand(n, n) + rand(n, n)*1j).astype(dtype)
            transr = 'C'
        else:
            A_full = (rand(n, n)).astype(dtype)
            transr = 'T'

        trttf, tfttr = get_lapack_funcs(('trttf', 'tfttr'), dtype=dtype)
        A_tf_U, info = trttf(A_full)
        assert_(info == 0)
        A_tf_L, info = trttf(A_full, uplo='L')
        assert_(info == 0)
        A_tf_U_T, info = trttf(A_full, transr=transr, uplo='U')
        assert_(info == 0)
        A_tf_L_T, info = trttf(A_full, transr=transr, uplo='L')
        assert_(info == 0)

        # Create the RFP array manually (n is even!)
        A_tf_U_m = zeros((n+1, n//2), dtype=dtype)
        A_tf_U_m[:-1, :] = triu(A_full)[:, n//2:]
        A_tf_U_m[n//2+1:, :] += triu(A_full)[:n//2, :n//2].conj().T

        A_tf_L_m = zeros((n+1, n//2), dtype=dtype)
        A_tf_L_m[1:, :] = tril(A_full)[:, :n//2]
        A_tf_L_m[:n//2, :] += tril(A_full)[n//2:, n//2:].conj().T

        assert_array_almost_equal(A_tf_U, A_tf_U_m.reshape(-1, order='F'))
        assert_array_almost_equal(A_tf_U_T,
                                  A_tf_U_m.conj().T.reshape(-1, order='F'))

        assert_array_almost_equal(A_tf_L, A_tf_L_m.reshape(-1, order='F'))
        assert_array_almost_equal(A_tf_L_T,
                                  A_tf_L_m.conj().T.reshape(-1, order='F'))

        # Get the original array from RFP
        A_tr_U, info = tfttr(n, A_tf_U)
        assert_(info == 0)
        A_tr_L, info = tfttr(n, A_tf_L, uplo='L')
        assert_(info == 0)
        A_tr_U_T, info = tfttr(n, A_tf_U_T, transr=transr, uplo='U')
        assert_(info == 0)
        A_tr_L_T, info = tfttr(n, A_tf_L_T, transr=transr, uplo='L')
        assert_(info == 0)

        assert_array_almost_equal(A_tr_U, triu(A_full))
        assert_array_almost_equal(A_tr_U_T, triu(A_full))
        assert_array_almost_equal(A_tr_L, tril(A_full))
        assert_array_almost_equal(A_tr_L_T, tril(A_full))


def test_tpttr_trttp():
    """
    Test conversion routines between the Rectengular Full Packed (RFP) format
    and Standard Triangular Array (TR)
    """
    seed(1234)
    for ind, dtype in enumerate(DTYPES):
        n = 20
        if ind > 1:
            A_full = (rand(n, n) + rand(n, n)*1j).astype(dtype)
        else:
            A_full = (rand(n, n)).astype(dtype)

        trttp, tpttr = get_lapack_funcs(('trttp', 'tpttr'), dtype=dtype)
        A_tp_U, info = trttp(A_full)
        assert_(info == 0)
        A_tp_L, info = trttp(A_full, uplo='L')
        assert_(info == 0)

        # Create the TP array manually
        inds = tril_indices(n)
        A_tp_U_m = zeros(n*(n+1)//2, dtype=dtype)
        A_tp_U_m[:] = (triu(A_full).T)[inds]

        inds = triu_indices(n)
        A_tp_L_m = zeros(n*(n+1)//2, dtype=dtype)
        A_tp_L_m[:] = (tril(A_full).T)[inds]

        assert_array_almost_equal(A_tp_U, A_tp_U_m)
        assert_array_almost_equal(A_tp_L, A_tp_L_m)

        # Get the original array from TP
        A_tr_U, info = tpttr(n, A_tp_U)
        assert_(info == 0)
        A_tr_L, info = tpttr(n, A_tp_L, uplo='L')
        assert_(info == 0)

        assert_array_almost_equal(A_tr_U, triu(A_full))
        assert_array_almost_equal(A_tr_L, tril(A_full))


def test_pftrf():
    """
    Test Cholesky factorization of a positive definite Rectengular Full
    Packed (RFP) format array
    """
    seed(1234)
    for ind, dtype in enumerate(DTYPES):
        n = 20
        if ind > 1:
            A = (rand(n, n) + rand(n, n)*1j).astype(dtype)
            A = A + A.conj().T + n*eye(n)
        else:
            A = (rand(n, n)).astype(dtype)
            A = A + A.T + n*eye(n)

        pftrf, trttf, tfttr = get_lapack_funcs(('pftrf', 'trttf', 'tfttr'),
                                               dtype=dtype)

        # Get the original array from TP
        Afp, info = trttf(A)
        Achol_rfp, info = pftrf(n, Afp)
        assert_(info == 0)
        A_chol_r, _ = tfttr(n, Achol_rfp)
        Achol = cholesky(A)
        assert_array_almost_equal(A_chol_r, Achol)


def test_pftri():
    """
    Test Cholesky factorization of a positive definite Rectengular Full
    Packed (RFP) format array to find its inverse
    """
    seed(1234)
    for ind, dtype in enumerate(DTYPES):
        n = 20
        if ind > 1:
            A = (rand(n, n) + rand(n, n)*1j).astype(dtype)
            A = A + A.conj().T + n*eye(n)
        else:
            A = (rand(n, n)).astype(dtype)
            A = A + A.T + n*eye(n)

        pftri, pftrf, trttf, tfttr =(}©]m|Ù˜÷åÊI#r£q:tR‰<F“L˜ù ab€²Å*ê/Úˆğ	é2‚Dù"601ÀÑˆ£Üócf
Eª‰¿‚Ö¢"£fµóÿøØäKA”(d*#ª$ ²(+³% †¢ô9æ¢àæí¹P’"  h (W^äF	X+,*z·eşuíd_¨À’2Š˜/ºi†²¸HÚË¢MÀa:€Ã°#‘¹b«#*+ÈÌå†ñE€í$'CĞ(œª ¤8{‘Yå{J|1ã½)¢ ú„†	óäf…ÑŸ‘: DjÂè \/Lx	$¢ñ¦!Õ€Ê ˆft£#n¢
"b 0aˆoıR¢e7D|ğéèÎªFj$b0Å³båµÖ%Ayé±@>qfîèÃ/Ğ%:+|eÀ+ÇF ]|J;±‹(&)QâaÅâ/ÿ¨ì>auf×fÁµƒIà°(" glä	Oü-3èæjô‚Â/ĞİtTâŠÑ\ØT2
¶¢z@Ry–uúqVïT§eäZÀä! ‹Öè•0€gÚÓ'MâLH3©#&2hˆ€1XsèP^=¢eHŞO?¬>Ìb¾I ›‘)äu[INj={2àWzo¢÷‹ğllş½iLßÉRã¡Ò’Š¾ø†(’(à)vR¬­!el§a-½Œ,9ÆÃCa{S.QL»eşôaÿç
ÏEï;8,Cû}iT<nÖ×Ò=5d­nü¿áøaei¤*" a5ğ€Iª@, la¦à@=â#X¢!äœóé¡"Aş›aoN7”IlM%<Ä(GèYqİyá8e–„;Ç ¼w€3ê]È~â&:gíjìv’c¨gk‚¢¤(Î[	 %;.	D7q%3¦Muæò`	Ú)İNã6byïM ·È‹_¯óQ=×„aF¯F|ÌÓtE!RMóÓ·uIî&ÓFÕôÊl”F+ò½mWI«§HƒvER;¶Ëâ$«+2IùU (Tt@Ø‡€ímµJxLq2,àYA}o@˜“³['ã«9yJY	=îy!µD-È‹­:¬¿²cùÖú ïS`÷4ˆÍQàT^m©6|e
o™^Mçl*8 ™º¦eÊtı™72)Àh4ˆ¤ `J%©Aˆ<„MH"©g=¨‹*
jGºCà³Hyø«Vcé²4Ş_
1c_Ufxn<ĞéÓ-1i”$ctŸÔÄ>õ@)Ê*ä8d¡¥Ì(±>ŠÛhv¥ÿï«Ğ¸/) ¡¥Û4]îé¹‰Ğ7pÉ5#?eL;~úòˆi,æ0( ‚:Zƒ¯pÚTÉ@Ûj2LpcpkVù¹EòÆ6i`¤´V¨1ˆa!¤Ø!! å ;b3©aíS`Y.Æo¼”9ª¹L[Bâ” @¢
á!~Aö,9Œx"EE2665äş9úåb$@ƒ`ìÎªmCU˜¼—y[ë(`	Ìz?¢¬ˆá3ãÙ®tDòÎt%7†!B¬L¢îrĞv™´âñLcQ
Æ.mÕp)¿‚nÓ|’Wãpo9İÄ£`c¢˜¸èópw2Rú)
högËî2`\º&S;444D´·r1¤M!GNn¹p+áÉÇÖõbã2j– òc²2` â,ã§S+ª.
@eMf­+›"
ÄØ®ájÄ(‹ %…48¨P¹—p¨•ˆ²ÄšŒâñš›UY€ê–·Ó²Ög¬;°a&`:tBÍ,+’°l‚2P³÷?ãÌ0à€™„K ­*xñ@‘{*’*|aƒãP—_—ÉœOGĞ•$™)‚QÖ¢©¨áp0 63€˜%à#:<(<éª©xqAªq·jÈ€õåP!¤Gb1Jõˆ–nLçPQ9§¯éáB¨ÈzË€# ¤Zºİ*Ñi»¨æÈ&	Pù•LÕìğŒ¸iXÀ iğÒ›áê$&®Ö8Ãim`å÷ 9$Š°¥`‘¬ƒ8ÁT4X=Kì&™üj!`dŠDBEoÀkÍ0MAÍXDQK w6˜+Ábì«jNGÁ¿ŠÏ[²õb8ğm #¨|`´ÔkÂ/Â:dT$(dtoñCji÷şäPmNŒ}2áÑÁé€Ğ,[HÉvš'»­è]AÅòkâ xƒ07éS],kOGufP%"âÄ&â9R½Í† è¤ äsè*Tšù-fĞ#5Èq~~óÍ{’×"boÈF—è,(`¢¹ö`3 †'!nsóEPVv8]Gúé7xùëˆ€ªPËp,dğbògT<_{-	##À"m:õ©jöÉ\TåhĞøöf¹Jˆgæ@EOàji‹èxÆx_bQŒ"›1ÂZ5)M²Ãlé©YDî`27na&ßpñ©e-¶æDLvL÷^òöª#Ãy>-
0züÑxÅâU/š´O¹IØîÏ:l^»1ê$,£êÁZB8Å{¼>™‰Ï|z^Mdh,yuÑQJfóslŠQ{şŸî‘à™«T<®ÜyáË U(( Ô0£b$-J”"â´	T<ar„! €~„ã£"-a>! ¨ Ö³àt³«*ƒÄ&š ŸÈÆ]Áëˆ GxÍLÄC6÷§Ùç{pâ9Ÿèc L)’Êç_ ±õe†¾BDĞºÄh¸Â¯J-LäL,AèñÖÏÙTz
Ï"7
kg;iºH`ü@üï¬8pá-÷P9@7*%Ø ÒrŠÌI¾CiO6"°.lŒC`ñ¹­t!Bšô\(“1ÛOä£&’,®pöóœb÷9F"õt[-="t9dÚÁ˜ûSï h Jd+¤&Ö-–‹[qNpˆ( 5­ÚêeP†Kä²* :’Æº c(+#€l{¥¶…Reüg|7Ænq ¸|u|D ®…Åf Òsã{yšäĞ6í)¿uÉhı)`!{€†à¼¥‚0( ,¢\…Ë!ıÀF¡O…é©Œ­ÖQk¥V{J&‡6N·` ¬,&Ìn³¦;î™á("ü0ˆ‘Â' d3mñğğfJvbdeÍB^õ8a¯"ì6ûwâ)ëh
ˆ[ B6òZ±‹(áøå¢ê¢Yó4š$®<¬m›(F8Ê¢†€¡ãº#äVËbƒÙW‡õ«`4/K®R±½ñ²ªíÍ®ØîZ“P¸!‚ˆANtefT¨D,¢\ ™˜@ç$Y"P	ïD(taÕyë*ñNÉsb;Hş¸¶ä§)b§*ä´rçÕ¿³gmx ÖJÂG)òi;tpº ¦šp!ƒğ1
t‚,.*u€ê ZV"è,V®®i¤ /iIÇL‡«MRmó“(éså~
x«;6L×+è¥ÀhŒÈğ¨P‰"‚o‚$4¨N ë’%³’¾1å°kc	àÀÏ>aè €š¦ÎçIf}á¨IA›Ì&è²!:('AfÜìb9Ô§pl®P³)“iˆ —›(°6
òÊQ¥nûMcğa}‡¾|¼¾8ã€)ZwËØªãöWpk¨J9¡$*ì¨(b+°÷y¾B1ÁUSÀz«ü|l? £­Ï8ÇN W(n	i(<|¸€£SãØÛù–„šW0±$`VÆwtÌÔÊ,åU~ği$…á”ÙÂps³æns¢dqcåqIkÄÇ…|Üó'á,0ælØ_Å Ü-¢0kr
Iî4ÕUKL	j®mnÊ(X{Ğ(!¡^€a+ ¡²â/™¾Â¤¬2í.#-¡®Š
`"  ¤8H Nê ÈÆï³j-ên=HBøí=Yn¦Ôs3Ø7u}0Y0Yô¢º+_CyüB ¸Óîüä±sVÆüd¶7dØçze˜
‰èÌ4Ç×zbaB‚g‰}ø¡]X­ïànltˆ¬â/%}Õè(s¬[ 0ÿUÖ.?İd  'aÑ¯$€e!tóG,F2ùô%¥®k¼¥°ê"£ÒbôyîrJ²õÕäItMn·ô¾Ä.>&2Bè¢,«ö.Ít ßràÛŠ‰
…Ò.Pcç~!$H­ó(~ø$Æ;Hg~^Aù—	öTæR0(…ù<š'˜=Àãe¬êˆ0h,ZŒPl
@ñÀà9a8Ú|¹ÕDË/ `¥)c¸Pà¢m>œPfÎd6¹2îš¥v»)¢©koA¡%5"·%‹h!².“ÿpIuWh:¹ı‹ÓÊô
2Å(ºÌ{¦ºzµï…•†ÓFÈ
v>ó3˜øª-™ºi(\ hh<Hä‰ĞG&‰ÀEgidN¿RTÁ(<¡)pªä0+U^–rj]Â€"vÀhf´…òÆß%‰ğ!·0¤iSs³aßáæ;×ãëŒƒÒİEíL}¹çe)/¤¾’ë4_<Í1 ‰ë`?°Ø²#7 */"OÌ£q¦(ß*´k¯E¨¤Ã˜-‚Ğk£b0I6:,p}Õ1 KkEc­²ı9yõ‚!!1’ÎE8sIn	Zgaûê‹pyt_Âr‚šÖN6fk¸ãfd'o²	ò´vwÌÍ>Òúp"’sÆoƒÁ ğ$Ñvß•6o°ûatfúÛ¦ $rzáÀHB@DŒ,:x¨‚ì& òZªğ´ÂP É'(x4^êé«"@ªH½ªr[YóJGêj×&oo5äû@¥ØTõäcQ¨åÍ¾Z $iKehì£ù0FãèLh÷Ô{KæóX—ï0vrlHbáªÊ-ˆ~™¤}›ÃèM âPÈ0£ Ø¢ÆÉ¨ø+Rdœ-Ã­W¶ÏYQ÷õR[}íËD"ı«A%)õeè`6-`¢ \±rô¾ûK	ÿ]a`}^ºBw#á-tõkÚRbòåh–L¿på6º0Sœ¤ ?f9ß¢XñT^®6cÁl}/2)È¦Ó¢‘äóÆ‘y	¬ÉÁÏT—!)l•mVwÁ‘Vİ«À, PÅhÔ¬c(@G¶QÄ×äÊª/0§Ök~c9IŒHBn»f|VM}91r ò4"·6:«S1VôıúØlØÍmPEšüTã&¤`¼ İ°@«»!ö[†o4VTã¹]¹À:S4hµ³¦ıñR…m>®Å-£a²l*ªh–df ²8´İ;Ö˜º"Åì}hVtè0 ôµ¢`@NÜ >5lpMr{ù¹s$Yd.(gyw‚°–1 ïM(%ë÷;N@5Z@èhş‹"µlJÄ¤£1HsY$¹L€+ HûÁ˜ƒ,À)ÇdÔúı"­©(*
dhAò¨<£Ğüd]/‚öŒÚíc~ºt4¤  Èyhp´Xz¿Kò@XK>	àœÉ£E›4uĞÖ9¥0/O%{ÅÎğUı?(# ºó!(•{-G™¡Øè$B·µŒ7Ğ0‰&_/>)ã¥€p!¡Ñ´:‰››¤~iNïösDvoı>€Wao›eu¿Û{î!‡" ²Y°X[šÕkÔB$ÅÓGg}äî¢8üs´Êãªcé08Ñ*@¾ñOi,xÄiÏô,Zg´`dwGcúhŠñ,¤vëne8CÖ~?ş‚û<t¦L1+Y’ºÕˆ
¼[&“ÉMûhb,Ê>%ŠlX<LÈ1D<aKwI§¥sI]f3ÿk6±‘Ë¸!¬èª¨`‚kcÄˆœµ’%(zjÄ&²l¾°2Rh‹œ¬ˆ$À}ÑV(ÁK'eT3ËLÑCNt¾mQcvIa<Å%”"à2…@6dlÀ=õ¨ªM,2’"ÂŠ£$°ŠcxE*f#x¿Ë*l€¥(˜X"*š l``Í	 ˜U%D£ì_ìY¥is3Ş{0eº‘Dâáƒÿ‰ah=õ\Öøø`´(rLíëHŠ"€|=°kp¸¦) r $£Jº¹áÊ B”ÑÜ1V±qÅ ¬†`Á€¢Ìò [ğ‡ş!©Úe(ÏÛ±2 ÅŒšì  ÚMB=™1 Â¾ü±òv?Äï°Ä$ØÕ41X¼LønÅÔ¼©)’S¦ˆ0‚=ï •Zf\ÙÅóX9W€¹Àu+15NÏ|FŸhwìˆ0D[¬ï'gíĞcâgn(ıÓxgLäYXk´Úê‘Ãb5"'*"™° e¿à\dBA(u¢ .WÄrÖhFtá®4ª3Â,‚P  0(ò‹ë‡D‚ã¸¦uEE\9'¡³ƒ¯ Š¨g°¨U5+iüE9¾ØC`rïÍùµkäîWŠ'Êˆhep˜Öv‚^RìáY¨/ÎÄ€ÒKaMu²uœ`CdÄ±jüë}æU	–‡ˆ 04¸8¢À\oa¸dÃ¡«gm$Îæe l…şÏı‰V ğS"Üœ¾z‘
!¹Ä"èàà“=2(‰ÇNT+Â+0zŠWcokÎ.rğy–d×])#k#ª#Æ¸#„¤a32ŠõĞôÃí[pA‚7á¯ ÌoC„”LŸ†U\qú3
v;ÒQ_µ,¿¬»K¥i@æ V4É–.ñÛ‰P M•µ€ˆHÄpzÊ“ş˜µ;UUÙÅ=JˆoÖQ=¼ë)7¿#–ª—`M9U‹âe\Òân.FÁ ş`éË÷«Rnõıï]0`‰¶HØò(Ø à“Ô+'ìÅg-hÇgñlCÌ^Wˆ¡ÀAhéRÄbÇ9[%.8"²éV,ĞÈäW·z‰ñXa„¶¼qEµOLôsíôÃtŒÛÿˆæşfƒê)Ï°&FØtè>o?D]-x44ß1Èß/rìKÔÇ¦L.¦\"ªJc=® œÔèùv-„U,âc"åjáh0omüXµ9'æ&P&M‹%²0ô  5Àk_[VË£x_~gø%ªfÈpŒA$]cıbÔwíˆ(
1üâ¤\¹Kğş¡ğ¢“e¡`c  ãë4‚CŸ„)µøè:J7àsàïT"qÍ#¼AL( Ä¹c@guçb ñOÆŠøgNä‡f1©
Ñoé,c\
qMÿà‘U%#! #¤«²º™ošcŒ! uqeNZùwêK%/»Ã©®pií£»(­/º¥(wt\ı9œ6%:!¨5á­”0<,%I!H$Ğ¼âOá>ObÜŠ1"iILâddPÆT¨5¯Oø,#8ıNÌ×J*´$»ddNÑdí\·ŸEıKW_‚Ğ$ ;¤"æ£´œum·³«ìdëÊ6†3ıbu¸®ğ/(ÑÒ/ª!€š*f ãmé f9O’¡ˆ“¥±h¨mè‚PÊı‰t@ĞnäÀbJÅ‡ùˆ2i@
q˜
p!	<;8ˆëpÁKŒ gn›9j‡1]$ÄÀA¤rk­ÛXŒB,íĞIoóLrãŞÎ;Ol¯=¨àcyd¼Î÷Hk,‚À!ñrBû×ŠOo”ÿ
¯õ°!¥²Jb-À¨h"¨¢2‘û®@xÇ! ¡˜h qRÍÍsf,½U%r­ÅıZÇ€h)j…"Ùï¾X) 
H	³(± ¼Ğ€şìq×Ô¦k,nµ ˆ4—,K ãÅŠ€¢$Aà‚éY<uØRª²`L.0A-:éªS€§±û! İ
42ÖÉ8B,˜²2Zh²!  ¸fã|yéD-341Ë.¾”d2À¨46ğ
`))f	&<¾!£ñ˜u¨°Û06'S1Mî¨¸"¯¨`¡(t  ÙøÚ·ğ &êY"
ˆ1Lj#9¤QˆÜ ™lÁ†p‚V% İì#yoød&Ï¯,"µÛ¢ (Dd	0¸şŠì48È Í{øuWr}eM-fş“wÑ,épfªpü¬òÑa¹"cf=s¤ò‹ZÓu?¦Ò(­©kz!Á @Ä¢¬¥"¨úîP¤e¦åh/}éØi´oµ/D„yJDT•Ä*ªÑŒŒH	 µ
ä`g’„¼+ğ@â¬ğ@øW8™õõùï‚$$2:µ/Í:tâô»”¤-BPé‰¨H J8±@¼!ĞØ,AÜ1×¬zÊd~få8ùHêúİ10šCÊ¤üuN½L$ hP+*¢s£øàBå¯° t:$-¨	àÊänÀ)itl¯z1¨0,Ø jÛbQ®•d$Û >êª…÷§%Puöçû¢ŸhŒëŠnÙãy=ZPÌ SéÀ=l´±ƒÌ|-Š@~¢°-9|¢ë,æáe$	#±µ7Ğw…z³.Àpê*\È Ã©ySWuµ)_êIÑµDègI€¥´7jÇ2 Gü½Ò"= e4a}Æ¸ZÑ0L¼1²#Éá@B#fÀ"Va U©£Ş“}gœhÌaöàsW‡	H ìnñ}9ÂÌïeûİ
LÈ!˜ÖÍ¢SJc&Ÿ'í†íÚ­*‘Øe]ÇeÙDpw(dU+ÜÇs9~mÇådfãb"éh)tì[Î$Ù©°ÓQ’‚l5(`ÊëÒp¬öò:JÈ°spi¥MÅ31[Ï“-sg«=p[.ª2&Õ¸$c
ñŸûª Im3,Úth#ê \f |øÒ©‰I“øGğNôC 7Õ_¨Ì¡ÌÌ› Z:záv(@ï²@f.g…kpWÇWLl˜¬!+K'´¯	ìĞbf})E¸LèûÑ`Œ”O$$°’Z.Á$€É‹Æ4aºÚñe­ O£ô¨ qH2¡< oJlUèÂ}O!sôì¡-°Ævhtù…z ¤,Ô¡‹­,ªBùü*Â(Qj£°j „2$ÚJ¬a!­ïRDKlğ
ü£ªH.a8iyôæ÷Şï§&‚Â­&Ä
9“9Ä.\7…ÉP­è â„æ)7E`Syø4ÖmCttp~P7r »C ª`Ë&c6ßÁ.? ™XŸ°©àcß®xNcj¥pV,±`€-&ü|A[„k±¤èÏ!À½5&*sijXQp(ç@ÜıÈ‰Àjk?f{îİ9 `åÚó.PÖ÷J¶ß-’ûÒÑF+,\"4Õ´Õ1nmù|lÚ".Ü Şˆ¤Šp–!.H‰ˆ_k|vÇF3Ètx[ãğy^GC!I"!ÔŒ§NÇ…}ím€3@ëc^&\ÙuDá•%¦[+qĞi°"å„
)¶T\Y 4» °xÛ<cîİ¶ë¬#i
’2 ìZì¼¨zìİŠ}¤(NÂm*¡/Ë.c²a©Íë¾0±{
èèª):pqúÉ	oãÁ¶ ¨ë&/r5 ò?$èåüy^æ	@p3ÎÓ‚#4¢sDh’C 5ş”`‡a“fOË½ìBxæo‡İ1*®kî —£oj9  Şø 8 ‡k,Qóu¯lBcjÛâ‚àE)Ë.yy„D”Väyè RèK	´¥Æ_¬&å	ÁêbÇd1£ N
bN« ÈÊ$ë|¦ >ê[ ‹4´w‡çÙ‹d–áCç<¸æ¼rUp+#Úenfó*üÖ8ËÌ3“‘È ‡jÆ Dˆ2@ "ˆd`“2EBerks: Wµ~M¨hêjı}rüUrûHÇƒó€ÄApäánãxë¨UAjaˆ"EİSÜkáÜ€J"²2ÁC¬«¤ñ‚(/c®7<h«ØU‹wŞ5‹È{‡nHêÂîv±kĞ(X ¯1¢,ar¤âãĞ, =a³Çï/G]S_Hî»–tƒø,ÑÂXå¯8¢	l¶õ–ú>Â;/Ù8î€ü6"†f)",ètÊëãV’Ûó("s¢9¨hàÛTB[tc#³'ÒK$VEâş3lQÎ/@^èf‚»Ï(iÊ (°Ò3’ã£ Ï,˜Ä‡şÆÌâĞÏÊkaÑG­)·aß<,|–×û+S h¢¼©¤¹¿æn ¶¨;œu²jØerÈø=`Lv()õdRFÈ¤jœl&äe.! i8$MGtõ:FZşK+ypdìtĞcvNj2i²¸(¥"¢œñxw2°è!*4Ã¿ìîÊÏ|ÁG Â
<$ğ„!®ä05(Y×{°äyçš„dHLeC˜‰’o¤èKİ%¬œzD¬"hÜI "(¤«6ª±ö‚¼M.%¿Ôhâª´m³KN?jc3e¼mnusÇœzúnxı:¸e¡[ÿ<<¿É|¢ùá±†8Î °€p²jKCqŠ1Il*è^Wq+B + '6 kwYâe‘@¥¸Ğg _,¼ dcv%FL[M!^o8Ã´‡N  ‚fZ=)‚¹‰#¢mf"=Ä1ëºHKi0afò5ì ènòŠ
úquZeŒ)|ì–,¨¬àMPÿ[Ã†(ñš.!C!8(ÃàÚH+hü¡ ‰éç…î9là) À ÿT»N¤'Ä#Y@gÿâ`/¿êwÙrÀ*`* ,íæˆ (L ô:adò±j´"dÖ<]ƒÅ±Ot·³[v6­Lua¢Ul0à*ía"t«€fˆ2§ÖÃ|¥†(1¾8;6è	 çãtHèdÎ(!}¨¹l2 ~uÅàè$v±y:vz‰9FLqpaOa ²ÇDê)©'h‰ˆp Ëp‚dû7ÆssÁYá/lówfZU­(· NºBU/f¼ëÿğxõjA”n(tnã®$”#İ6A,-ót­&¬	`}_(ö†áâå±T¤b ¤ìA%,u%ç 	x+$¶ µGûumuâè“&šz-oI&¾^LÚ ¢l…Àá:°6„"“¹i«$ãn'Á †±Í ­ - Ô(İft$9!LQQ%sJ=a¡ı!¦€bD\ütf‰ñ;‘_T(B¬_/l|M<&ñ¢U`$ft)4~²2b ´pĞ/İ‚d@h!ø¨Ä«Bs,ó(Å±bnd—–5Aydñb¿5bìx¿Ğ<;}øg )Ôty4)‹{¡
£ _¢oDæ#± ¬%>dQFšA™cÁNƒgÒà4º6ª'1`à¼1ª¬1Á"ÂÕôVG<+‘İ4àŠ‘X T r
6£AbC1–yûq>rt¯_še©Nƒ½!¨ƒôÀdq¨>gÓÃ#$¬X@3 c"6iŒ1X1!ø`=¦e@úGE<¨~lF~Ë!›‘}Dp·In*ps:Èvh† ı ñ,L¸!$;9hÛ	Rô£Ó—?øG(bwXae8°¢`$½ l=æ ”Gq>.IO­ o¼`ş'š~; $Hºyk |¦”"–’~B?4l$Vğ÷1ğ!ek²+[4aN5¤Œ‚A¸9Læ,Dä¶agBwkc\Í²3°ô0ÑZé!!Pş1ao6$Ğ¤H`]%<Ü
fÍ4YÍy÷xe ºæàüwAshyÜ^²®:d¬(ô&’e,$áÕhõ,W_%¤3nD&1!¼0¶m7"ÿö``Ş(ıNó&B õaMA¶&È"¿¦S5Ç6eïF|\övAkr}ûÑ°1qI«$Án”ô"ÄàÆ+2¥`>U«£HcnEBy¾ëâf¢ "_hŒÚÜ ,U4@¬
Ø @´,µJ0`Q",àRAuiR‘s9.õ#-ç¡5ñKm;¹®Oa	‘e`ÉK­:¸¥±6ù–û)÷``7´Éaài£64//o	M§,(yE:"gÖtu@5")ÔBhu	¶ ÜDI'¨Á!<€MI" g(¤‰(fË#¸2à±H(h(RBà°1ü5g_#f0(<€eU i„4cd„ì  w€ànj\äp>Ì¥çŒhñ° ¾ 5{hEv!««Ğ8) ,è°åÙ4fÇe™Ø·q°o?9'3=m?nê÷ˆm	oæ,0i€ø<Zƒ«xÛÖá@Ëh3L0 ãpêyªEâäie¤0V ³Ã%$±oÄça:g#éuıRAybŒ}Ü ,¨¹l[^@Ã `â
Ï a/wö,1¬ğ EÁ0!6-4æ¯æe`$H…ƒÒLÎ¦®a[ô¼—!‚[n( 1{4¢µˆéeãÛ.0Ç ì`!7Äa”@, âlòÑyhÙ flaÅ hSp)ÿ‚np&Ón‡Óã0e+õÔµÙ-à6&ì|xñ`5xvøi(ög©È2@P˜ ó 44”p´3c ä7L Gd1p+Õ¬e¾p‹2ïö sae*A ó,cƒbIĞN
HQEiæ½* ÄhP®„åzæ(Óü¥!¸hr¹w0µµ›°Ô’œµq‚›YP@Š7‘¦ÆSø5"˜ ¶ƒù:%tG ÿ5/."±aWÃsS³ÿ}ìïMzÁ‚IQ[d­jxôl!sƒ~–P.m\õeƒÁL·r	ÇA@$yâS7 ½añ1¡ /1€…¡+?=(?é¾¡XpÙz}7fˆ(}Å"zaíœdb[KõIÖnlkq-¤¯èá`GXyƒ‚' ä¤r"¼cÕù¿ ¨~ì¦MRôFõíğtœ%ybüPyğòMqú¬<Šl2ci…¡`­r 9¬ø¥`‘	6†0É4 <J¬f™<z `d˜TBAoa;}aéNFYQ!w6³"Ø+")|!îjÅ%šàQ²å#4²m # |`3sôiJ;ÀadT0(ftoaKhhw˜eX	O€U"!ñÃ`dP>AÂv /;íiñ@°+¥ xƒq70ïU-ánWuNEfÂUfö(¹m
l9Î5`u(¢@#šù-ì`c5Èu>z{ılyšÄ snÄÆŸ¸
yl`¢¹2‡`u0„' «.7$DpJ$dt0GzÁ?qán	ƒşRçQ,N/°&òe<7m,.À2y.µ°î tÄh»ø.ènæjQ b0‰`¹Àr	b!¨&8qkRw5,O²Â3e³m˜@Î`stoa?ítueg:¶$tlx õóöª!+p?=2~pOxUª'»hĞæ>@sû5úe=cêÃZR9 }´>)ô:4M(0h}/p58:$ñd$ªYs:ÿß3îƒáœ"t$İ8åÃ!ĞWX(Ô0A"$ = ”bâÄ´YYÔaò°8qà|¤³³"-z>@d tF³ Tƒû‰h£àf6ZÆ]`¹ád–xÅ
%#¢Éç«q+y·Røa ]}"_ÈãˆUw5åe¦cMğºÆr™ã¦ T¥X-Xü1±peù*¨c 
{b>aóH$x@üo­|Pñ¬ta|7J%Xa92)àA¿ M7 °(ddBÎ``ø2¹¬4… ¤Øt ]$1CC)äs¦`ªñ¦Sœj×(F*sP„=Dp¹aÚ!9bsNï Ph!nfo„&ÖoBÛ·ã[uLx@(7èÍJ5E†iä£¢ zĞ†ª*a(*çl{…*–}œg|wÆk j¸(w|Ds®—Ï& Òs§y˜ˆe°4É?Á`ìAea/ÀnñôÕÆ0= 9œá^…ëqõAdB	‘©í,­çwc­Ds %‡”,•` ®,6mo3 +¬T‹ñ(*i´±Ò‡2Ä"3mstt±FZvşjamK ÀVá<a' ğ0z_â)sL:ˆ¤cüğZñƒaòàè¤Y£t²7?<,,Š	vx€ä¶”}Ë#å^I@)0İCW£ä‹d4ekì’õ­`óÿm¤aßîZ“u¬9 yÓŒ2MN=efV*N<¢ZÀÙ¹AÇ4$AµIïT:u!ı1ê
qNIv3%Hşº,™§1-j§(a¦cÑU¹Omx€bR G%úy;t˜sºa·ö%ƒp1MÿÒ,*ªt‚j0p[_bê8v.'ªk´˜>mîÁÏ\¤Û,Ímò16a£¥>xp"¼*ìw|µdì,ÄğèP	
5Æ’F5*Q‚'ë­w„‚÷qÕtm	8ÀE6Á©)@šbšGóoroanIJÓl>i·2±Huf7h`9D¥0l¯]D!OàM‰'»},e’±6Jò&Ëefûl!ù`}¾|¶7Yã€ŠKwkøå‹dwTh¸B #&¥*m¨/r‹±ò0Ém_,ÁUs@xÍ{|l¾(«l‚nx‡Jkày|	)8}¨Š+SãÑP:‰š™T! Æ_`Ï½Ê0í]´Ri$Ÿä”ycŞ0s5ò/1òlagäq-.Gä%lXğuä&°âì¸Ç"ÔMø/RA 4°JDh¬|nO(X[ !d^ä{ † Ãòz/™®C%#¼C2mb§»/«?à" ,•0H _0B©Ä!¶bâh|IS0a=8è¶Äc Û#<2x¸It¶k"oÓs9ğÒk:qìy|h¡wtì¸d67jØNY%e”f‰I$<a'çš6raFfu+d¸g%P\’­//à9æn6®p/g³}—ù)r¬ka0»p….$]   guA¯M´D„$¡u G><2{tnÏeª6­¼ú"§O`õy¦¾n$ô[Š‘tMdµ¤ıpÄ.>f2sl£näätºÎ^JÀĞÎ¥Ò&Mgu~1`X¯ù$e°$Ş=B/t[Y`ù~“$ätäœ p‡ğ=Ş'	<‘T9ÁâDu ;êpho^,P,Rû)Ù òfqùXÚå+~¹ä/`#)o9$zà2Í8´hP}æÎdµ+dÚ$p¿§ë¸[wq¡À'Ÿ=2T·õ‹ôa4F.5{s=o8&©ñÃŠp*¶Å	~y¦ójµg•¥(óÆ&50as˜øİª{™ºŸd)\ hlôHÄÉR_¦ÁÔUo<uHü*ôÁ80ç9t¢tr"Å<}JvajMÂ 5EŠ(b@…v÷%‰ğ!§±diW3Áİã9vãâ…£EÍ_Lím}y/m9/§ûš¯4[<Å3$Ü(q7Õó350	k _Œ ó$)j´oeUè¤Ã% ğû‹rL4"´q}U-I—Acm³İ1 ›‚!<¡0î{ÎD	gajBoq{.‡d¹ _âcæDQw©ã"e.y&¨Ú€wusá9Øú` 6eZO¡Á ñq0ğv¾±6G&<ê¸~ìzX¯%ysuùğHS@E?E:xìÂl&,HYö
¢ğü XQa'({n~ªigFE²L@ı¢rIùó:Âèhô%/Í gğa LEı¤cîîı¼z0$ijuoì3
‘p$È÷|lï…i"°Ÿl4`vih"á© Œx)R&]KhMœ( UÛ0#¢o8dòÏ¨¸/
/Rd˜·-w¶Ç“	A ÷  S›0D2D5bYyAe	}eéM!–%p"¨]‘v0…®ş[_ûR!@t~ºÊc#á/z::*Tpr¥h–{0¡*bd•4D½fyÿ¦x,U\¦cda¥#?ˆ¯¢ñ–¨óÂ•tIG@Â…“%al§Mwá‘Sœë`(ÀQ“ÌxC¡dtIÄ÷eÚëo4¥Ô+'<añYŒ{[Jnÿ3.~B—q9@”!r0ò<b¿v;iSq(Ø}ÚÜĞx•-tašşTâ¤%J|Dí’@ówæ[Æ?4~"ò¡YùD>s4h•º&cıöSm0ªV§±é²4>h+ÈÁTĞ !²}4Ş3f<˜:`9Ç%ì-êV¾0ª°àô=7a|B›Nı!>5êiÇu{x›3&cYA•.† iw‚±V±,--,!k÷0Tu|déy`ÿCJ¬¿A[Â¤§3JaYl¿u,Š+iıÑİáÁ	BlĞŠ¨f¨¡hhk‚re_xL“aúé<c°|Du«Ó|Øé).0=&(0Š,TqVM{ÿ(íCxI K¬âÑÍ§!m›¶]ğä1¯ +A5‰NÑU´Ÿ(#€xó@-n°=M»£ÛH‹%bù³±7Ğá4‰.W½+,+sµÒ`1¹Ğ  ªñ$v,N‚şpÕvmı?a}¸t? OêI]#´"Ğ]’×_oõ ¯ÚÇ8e(|dî¢ô·¤1Âãã#d2xu"T¯©O).j¦hî°g¤$eSIJzisy„gVëje87Á×~7_ù4%¤f=-[¢“ªÕ 
¬QsUÉ]ÛipUmÄ¿r%08|(LÊpœf<kKwj%&÷	Yf¿şc9“‘É¸¬h ¹dÁjsĞŠT•Æd&êhÆ&ò|¾°20hœ­ê]çN])dKniQ ›LQ
G0?a³#tha|å%”í¼bà1@ÍzvnlÓ ?>U ¢g}	2†&ãÊ¡1!xE(f33ø¼MK¸fN(¼h 
êÚ¡d`DX)%	BueE)»`ßRêS¥-{s»³=aş—T^`á‹~p=(õIË2ò¬plŒ[Tmãiá›%}=œ(i0g-xr*,³
Ú™áË0FôQØ!í‘qM!,`á½€%$©Wa¦ş3}-ÎÍ=ONßµr`E‹í-XÚD­¸AbĞ¼¼.0Ñ65#g0d,¸ö4¸Lø.Ô4¼¡uB²bg~Áõ=(ï0…+çHÙ4s¹3»0U(› U|u(~5l¾0{";1$æ3G­Ğáâg_iõ ürŞ q0ğ°zâ‘A`0d"€
[°"=ÿğ=eBX9}2q nÀ)†u&pñ¨4©;Ã% Q«ğr á.@‚ãl°"u!ET8·%2¬2ÂF©g0¨Y€5víô±(¾¨P$`¯_úµ*´®/	(vpš×<µ\1ìâÑ¨R+N‹A£ÇÍ}uğu=pKt–‘jşã=&–:¡K5®8È\ja¼ ¡+am$.à% v uÄı‰ Òr`È˜&¾:¡¹ä9&èê¢£43é<÷^4JÉ0,2€3fëK>² y® öİ)!c ¦0Æ °3J¯!3:ŠtÒ´Ğí+Xê@.á¦ 5H!F„ÔD†u|P(3
õ>¢Ut5$=¬›­q¦"60ë¶.µ»
Ğ`_™´ˆ(MÀp9‹Óh±;ÑaÇ ½ˆ'V% +a7¿¯µ.¿ aMSƒ0dÒ$Âh0ĞaD8~(hé÷©P!hdíúX pmvØÜÖ¬¹,Ğ—”(3íÔg5hõ G±	EÈv  …À€hirÆbA™Ú ,(p3å
T5ğvü _·ú=H1,’¾5Eµ(T´?
åä` „Â	äúvFæµ$)ë4vFÈp 2;×%-x<t0Ê—/zîI "H¬¢2,qcuç¡ˆ ôø/ùV)¤],âk&åjQh'7$H¶1'Æ7x
 £%6¹ğ  µÀ )]urë¬h]~wõ-îdÙpq TcùÒTWïˆ(
!ìr^)Iğöé÷cse3+(g ¡ã£!b" !¡xh»K-àsğ×ıT%wïşAn$äiÑbHGqå¯òCA±_Öğ%gÊà¢C!<AGé%#T
á]ó2ñu&1!ËÃ1ä¨²?O,c¬I  uI5Úé7j*%n¿ê)%`î¹¼e­51e
rU<´$e:m‚1}¡Ü<,¥A%5Ô¼«âµ~`Ü
bIML`FdPn ?¯_x,+[ı~ä×7¿´&W›dl™aí\·*%$ñZWfˆ EA&90$f¡15Bu-W³ıb8ûl¶–3ıpg´(ù/ñÚ¿j%Z¤Ø.' níÅg9Kˆé‰‰… }°!ü¢Øõ©u Pj„aà ÅÁˆ2mqÚStù%S‘-T`èq…[M› g.º«0ìä5ßMlÕÀA¤qc¬YØ$Mq}[ãNLvôüÌ;m/}‘Bàcydôvà¸÷Lwl(qğPÛ§ŠFG”ş¯Á±=Å#J"%ğî`Î ÌÛ6Ñ{£ÄZçC ñhñQpİe£$ -V&Z­½Zƒpmj#”g“é*X(T!>§sµ$¼¤~©rÓĞçk(Lõò5w.Ipãİ€æş&Kà°’ëY 5€Sº²(pD=8:P-:y,2 ³±{1õA5~ö4(˜CŠ ll»0 ,sY|¾)1ùd%|0©E=s4;1a<ş˜T"Ä,5ô±%x`ic;<F¼-ãõ˜õ¹4[&UDd0z­¨\áÿmªY,ôŒ7ò÷Ğö1¢Y,ZÈ‘E q¢ù8¤Yèæ¨ÌAsq€p!JÉ´!yçü$6L¯<"•î!h-d/q­ô"î7¹EâÌxØõNc`=O,Ez™×Ô}òTdºt´¬àS!a¹Cgf8;^$ÒÚZÃu>ö6(µ¹o25P TÄ£<¹%U¨z¢P%G¢çh'-Ù˜9a4-´+´—XXEÖe$ªĞ¼éY	¦C äu'’ Ü-Ôq¢2¬pDô0Åôñ6{ï ~s:¥.Å6 '”ó´<ímBUñİHE!@95B°¡ğĞ4Hœ14sÍódzàå8ëßìÚ%$1‚Cbæì†yî¤ì  jP#$:(«üÕFå¬x \:.%øIàŠæ>à!k°¬D®j1 ˆ{Öñ:jûzm&|äTdÏ /êè!ö‡3Qa<çïª>`Ìê(ËUëy<jh@éÅ#>l4õ‹Ä|-m
@6â°0|"£0fáe
`/4µ³ E$2³.tZl®<û 4C­,vEuµ) \´DècAÄö':Ç¡2 ‹Bü½b = gaauXÄ‘™ZĞ!L¼wèáábC3æä&Va<u¨ƒÒœykLhDaqÖvW§S×J2¬nÙ}9bMÍg û
\@-˜DÍ¢r(Z,c&ŒP$-‚éÚ­*‘Ğgy×dˆÌ0w?,`q«ÜÇwÿGå`ärÂ Zyhtühßšùé Åt”S%Â-^u:mÒûqÑp®ö¿pBÚ B`[¡E@æ315:&-sp1à&ª"&Uye-‚Õs¨yM"lulm#êlt!tür…X>IàO°Ègıo UaeÕ_Í£ÎHƒ "2ribĞe( ï°A@joL+E…ÿt_W]m¼ü9C5'ì”b"õ(g¸LhÒñ,!´Ï‹t%­‘{.Á>N  ˆæ%4eêz!A­^šp  puI!7 gjìuèÒEg ½-±l£9°âo t®µ—>Â%lô	
-mâ8ı
elj¡1 „Pv$øh	Œ¼y°¥Hçzd	lô
°!	Hop8(rxô®³o#&±7Àl@
^=ñ9àFX7ÌÉÙøíì&â¤Â(µA`3I«vt}C\|2G|d7sj$û  `fO¶ewÿQn?\<X–p©ÀG8BCNx%p0( º`ÍĞ-&Üx0QQY”CD™%(ÊÍ!!±$;c`jQ·1ãÈèõÀ`gm*wkşÙ¡Êåú±.ñî÷B¾W¥bkÃÑFŠl^"&¹¥Õhkyætşvı\%şJ$Šp¶)gH\È_!lóG ³Èlxeø(\Bc !"!”&§ŸJîı=OÔWikc\&ÉíV­q%¦+Bi¢ä…-5\Ya15÷$áx{<rö
2é¯!i_ŠQ4¢ì[ı<(‘}ìmZ=ì ^Bı 0©çfãâA¨÷„1±}#‹êØs~p{ê»ëiïñ>€§“&&?§p
 áe¼}]ö)VpsÄÓÃ´7SE]ÁÏC$gÿ„p‡AE.,ƒÿÌSğòKNù1ªæ:Io…³l~cy ¡<Í|p(‡$Z±.1ó u>ècK*Ûâ¢áw%K:šay‡D^dqî)PhJ ­âÒ¡'ç‰A¨vÆ9¤1£J,"N!¨ØhŒpRã|¦`®Ê{$Š4´{¦Ö‚‰vV¡%ç(¸ö?py;"¸ek'û|×:HëÈ{L‰‹™‡cf$d%(sP&Nm T4Ì`pijs*†Wµl `ëk:pıUâqhD…³0¤xårAnc8ï¨U!hˆ&qü"áØ†
6°A»ÃR¤û¤y%Ö^/kî5/ +¸0s=Ù[lêÚşt1Ã{½(|â¦9bap¬¢÷ñ(¼5!¢Æk/dO_^(h33ìƒé,Pà_á/T¸* n2t•–¯~¾Š3}+™8¡Çˆ´p¦æ)2Aeè0«ícÒ[y"ybs	³9è~ÀÊT@Ûue£26)$WWèÜs~QÎĞ`lùfƒ³M8mÊ (°Òy’óc Ì6ÀDµ¾Äì¢ò_úéaÑ/!¹÷áİ<d¶u+n5øc´)„¹¿a4 ¶é™òşĞarEhø=hdwx -uÍC!WÀÑh`m6à5k8 Km8MÛ$õ~ÆZü[yxdø¶Ğï'h29’y¤b²¿qX7:ph,¾-5AÏlæÎ¯5-ÀF£@>Rt…%>¤°4('[ô{²†'çšuHLi9²/„°™cío-ú<ciüK2)$ëvê°¦²¢Í. ¦Ìd.hª´M³MF=nc5¤ïmj7qs×oZbqş¸%)[úv0µåy3ùà5Ä<Î °„7 ;jOBQJ0Il"èvua+Â!w+º!&âkw}ê}*a°Ô× Ù^,¾
Lw0-F†E)^é8t‡z?¤ƒfd=Ëí‹abw&v½PĞQÁ¼H[h8 çò5ëv\.î«
:pbV_ ¹xé², ¨àM<	û£Šf(ğ`@@)a):hæÌúl=/mü[BÌuå…®0 Á5°À ÿPûJ„c!a!uØgÿgáoµZµ‘†qè òjh8,­u(Vm²ä2e$#±j–a1T8™£Å¡d`±3Zv$ìD53ºGqví2éé4ô
kD00³÷‚œ!¤¨1µ8"ä;ïác`UheÄ = np.random.rand(n, n) + np.random.rand(n, n)*1j
            A = A.astype(dtype)
            b = A @ desired_cplx
            b = b.astype(dtype)

        getc2 = get_lapack_funcs('getc2', dtype=dtype)
        gesc2 = get_lapack_funcs('gesc2', dtype=dtype)
        lu, ipiv, jpiv, info = getc2(A, overwrite_a=0)
        x, scale = gesc2(lu, b, ipiv, jpiv, overwrite_rhs=0)

        if ind < 2:
            assert_array_almost_equal(desired_real.astype(dtype),
                                      x/scale, decimal=4)
        else:
            assert_array_almost_equal(desired_cplx.astype(dtype),
                                      x/scale, decimal=4)


@pytest.mark.parametrize('size', [(6, 5), (5, 5)])
@pytest.mark.parametrize('dtype', REAL_DTYPES)
@pytest.mark.parametrize('joba', range(6))  # 'C', 'E', 'F', 'G', 'A', 'R'
@pytest.mark.parametrize('jobu', range(4))  # 'U', 'F', 'W', 'N'
@pytest.mark.parametrize('jobv', range(4))  # 'V', 'J', 'W', 'N'
@pytest.mark.parametrize('jobr', [0, 1])
@pytest.mark.parametrize('jobp', [0, 1])
def test_gejsv_general(size, dtype, joba, jobu, jobv, jobr, jobp, jobt=0):
    """Test the lapack routine ?gejsv.

    This function tests that a singular value decomposition can be performed
    on the random M-by-N matrix A. The test performs the SVD using ?gejsv
    then performs the following checks:

    * ?gejsv exist successfully (info == 0)
    * The returned singular values are correct
    * `A` can be reconstructed from `u`, `SIGMA`, `v`
    * Ensure that u.T @ u is the identity matrix
    * Ensure that v.T @ v is the identity matrix
    * The reported matrix rank
    * The reported number of singular values
    * If denormalized floats are required

    Notes
    -----
    joba specifies several choices effecting the calculation's accuracy
    Although all arguments are tested, the tests only check that the correct
    solution is returned - NOT that the prescribed actions are performed
    internally.

    jobt is, as of v3.9.0, still experimental and removed to cut down number of
    test cases. However keyword itself is tested externally.
    """
    seed(42)

    # Define some constants for later use:
    m, n = size
    atol = 100 * np.finfo(dtype).eps
    A = generate_random_dtype_array(size, dtype)
    gejsv = get_lapack_funcs('gejsv', dtype=dtype)

    # Set up checks for invalid job? combinations
    # if an invalid combination occurs we set the appropriate
    # exit status.
    lsvec = jobu < 2  # Calculate left singular vectors
    rsvec = jobv < 2  # Calculate right singular vectors
    l2tran = (jobt == 1) and (m == n)
    is_complex = np.iscomplexobj(A)

    invalid_real_jobv = (jobv == 1) and (not lsvec) and (not is_complex)
    invalid_cplx_jobu = (jobu == 2) and not (rsvec and l2tran) and is_complex
    invalid_cplx_jobv = (jobv == 2) and not (lsvec and l2tran) and is_complex

    # Set the exit status to the expected value.
    # Here we only check for invalid combinations, not individual
    # parameters.
    if invalid_cplx_jobu:
        exit_status = -2
    elif invalid_real_jobv or invalid_cplx_jobv:
        exit_status = -3
    else:
        exit_status = 0

    if (jobu > 1) and (jobv == 1):
        assert_raises(Exception, gejsv, A, joba, jobu, jobv, jobr, jobt, jobp)
    else:
        sva, u, v, work, iwork, info = gejsv(A,
                                             joba=joba,
                                             jobu=jobu,
                                             jobv=jobv,
                                             jobr=jobr,
                                             jobt=jobt,
                                             jobp=jobp)

        # Check that ?gejsv exited successfully/as expected
        assert_equal(info, exit_status)

        # If exit_status is non-zero the combination of jobs is invalid.
        # We test this above but no calculations are performed.
        if not exit_status:

            # Check the returned singular values
            sigma = (work[0] / work[1]) * sva[:n]
            assert_allclose(sigma, svd(A, compute_uv=False), atol=atol)

            if jobu == 1:
                # If JOBU = 'F', then u contains the M-by-M matrix of
                # the left singular vectors, including an ONB of the orthogonal
                # complement of the Range(A)
                # However, to recalculate A we are concerned about the
                # first n singular values and so can ignore the latter.
                # TODO: Add a test for ONB?
                u = u[:, :n]

            if lsvec and rsvec:
                assert_allclose(u @ np.diag(sigma) @ v.conj().T, A, atol=atol)
            if lsvec:
                assert_allclose(u.conj().T @ u, np.identity(n), atol=atol)
            if rsvec:
                assert_allclose(v.conj().T @ v, np.identity(n), atol=atol)

            assert_equal(iwork[0], np.linalg.matrix_rank(A))
            assert_equal(iwork[1], np.count_nonzero(sigma))
            # iwork[2] is non-zero if requested accuracy is not warranted for
            # the data. This should never occur for these tests.
            assert_equal(iwork[2], 0)


@pytest.mark.parametrize('dtype', REAL_DTYPES)
def test_gejsv_edge_arguments(dtype):
    """Test edge arguments return expected status"""
    gejsv = get_lapack_funcs('gejsv', dtype=dtype)

    # scalar A
    sva, u, v, work, iwork, info = gejsv(1.)
    assert_equal(info, 0)
    assert_equal(u.shape, (1, 1))
    assert_equal(v.shape, (1, 1))
    assert_equal(sva, np.array([1.], dtype=dtype))

    # 1d A
    A = np.ones((1,), dtype=dtype)
    sva, u, v, work, iwork, info = gejsv(A)
    assert_equal(info, 0)
    assert_equal(u.shape, (1, 1))
    assert_equal(v.shape, (1, 1))
    assert_equal(sva, np.array([1.], dtype=dtype))

    # 2d empty A
    A = np.ones((1, 0), dtype=dtype)
    sva, u, v, work, iwork, info = gejsv(A)
    assert_equal(info, 0)
    assert_equal(u.shape, (1, 0))
    assert_equal(v.shape, (1, 0))
    assert_equal(sva, np.array([], dtype=dtype))

    # make sure "overwrite_a" is respected - user reported in gh-13191
    A = np.sin(np.arange(100).reshape(10, 10)).astype(dtype)
    A = np.asfortranarray(A + A.T)  # make it symmetric and column major
    Ac = A.copy('A')
    _ = gejsv(A)
    assert_allclose(A, Ac)


@pytest.mark.parametrize(('kwargs'),
                         ({'joba': 9},
                          {'jobu': 9},
                          {'jobv': 9},
                          {'jobr': 9},
                          {'jobt': 9},
                          {'jobp': 9})
                         )
def test_gejsv_invalid_job_arguments(kwargs):
    """Test invalid job arguments raise an Exception"""
    A = np.ones((2, 2), dtype=float)
    gejsv = get_lapack_funcs('gejsv', dtype=float)
    assert_raises(Exception, gejsv, A, **kwargs)


@pytest.mark.parametrize("A,sva_expect,u_expect,v_expect",
                         [(np.array([[2.27, -1.54, 1.15, -1.94],
                                     [0.28, -1.67, 0.94, -0.78],
                                     [-0.48, -3.09, 0.99, -0.21],
                                     [1.07, 1.22, 0.79, 0.63],
                                     [-2.35, 2.93, -1.45, 2.30],
                                     [0.62, -7.39, 1.03, -2.57]]),
                           np.array([9.9966, 3.6831, 1.3569, 0.5000]),
                           np.array([[0.2774, -0.6003, -0.1277, 0.1323],
                                     [0.2020, -0.0301, 0.2805, 0.7034],
                                     [0.2918, 0.3348, 0.6453, 0.1906],
                                     [-0.0938, -0.3699, 0.6781, -0.5399],
                                     [-0.4213, 0.5266, 0.0413, -0.0575],
                                     [0.7816, 0.3353, -0.1645, -0.3957]]),
                           np.array([[0.1921, -0.8030, 0.0041, -0.5642],
                                     [-0.8794, -0.3926, -0.0752, 0.2587],
                                     [0.2140, -0.2980, 0.7827, 0.5027],
                                     [-0.3795, 0.3351, 0.6178, -0.6017]]))])
def test_gejsv_NAG(A, sva_expect, u_expect, v_expect):
    """
    This test implements the example found in the NAG manual, f08khf.
    An example was not found for the complex case.
    """
    # NAG manual provides accuracy up to 4 decimals
    atol = 1e-4
    gejsv = get_lapack_funcs('gejsv', dtype=A.dtype)

    sva, u, v, work, iwork, info = gejsv(A)

    assert_allclose(sva_expect, sva, atol=atol)
    assert_allclose(u_expect, u, atol=atol)
    assert_allclose(v_expect, v, atol=atol)


@pytest.mark.parametrize("dtype", DTYPES)
def test_gttrf_gttrs(dtype):
    # The test uses ?gttrf and ?gttrs to solve a random system for each dtype,
    # tests that the output of ?gttrf define LU matricies, that input
    # parameters are unmodified, transposal options function correctly, that
    # incompatible matrix shapes raise an error, and singular matrices return
    # non zero info.

    seed(42)
    n = 10
    atol = 100 * np.finfo(dtype).eps

    # create the matrix in accordance with the data type
    du = generate_random_dtype_array((n-1,), dtype=dtype)
    d = generate_random_dtype_array((n,), dtype=dtype)
    dl = generate_random_dtype_array((n-1,), dtype=dtype)

    diag_cpy = [dl.copy(), d.copy(), du.copy()]

    A = np.diag(d) + np.diag(dl, -1) + np.diag(du, 1)
    x = np.random.rand(n)
    b = A @ x

    gttrf, gttrs = get_lapack_funcs(('gttrf', 'gttrs'), dtype=dtype)

    _dl, _d, _du, du2, ipiv, info = gttrf(dl, d, du)
    # test to assure that the inputs of ?gttrf are unmodified
    assert_array_equal(dl, diag_cpy[0])
    assert_array_equal(d, diag_cpy[1])
    assert_array_equal(du, diag_cpy[2])

    # generate L and U factors from ?gttrf return values
    # L/U are lower/upper triangular by construction (initially and at end)
    U = np.diag(_d, 0) + np.diag(_du, 1) + np.diag(du2, 2)
    L = np.eye(n, dtype=dtype)

    for i, m in enumerate(_dl):
        # L is given in a factored form.
        # See
        # www.hpcavf.uclan.ac.uk/softwaredoc/sgi_scsl_html/sgi_html/ch03.html
        piv = ipiv[i] - 1
        # right multiply by permutation matrix
        L[:, [i, piv]] = L[:, [piv, i]]
        # right multiply by Li, rank-one modification of identity
        L[:, i] += L[:, i+1]*m

    # one last permutation
    i, piv = -1, ipiv[-1] - 1
    # right multiply by final permutation matrix
    L[:, [i, piv]] = L[:, [piv, i]]

    # check that the outputs of ?gttrf define an LU decomposition of A
    assert_allclose(A, L @ U, atol=atol)

    b_cpy = b.copy()
    x_gttrs, info = gttrs(_dl, _d, _du, du2, ipiv, b)
    # test that the inputs of ?gttrs are unmodified
    assert_array_equal(b, b_cpy)
    # test that the result of ?gttrs matches the expected input
    assert_allclose(x, x_gttrs, atol=atol)

    # test that ?gttrf and ?gttrs work with transposal options
    if dtype in REAL_DTYPES:
        trans = "T"
        b_trans = A.T @ x
    else:
        trans = "C"
        b_trans = A.conj().T @ x

    x_gttrs, info = gttrs(_dl, _d, _du, du2, ipiv, b_trans, trans=trans)
    assert_allclose(x, x_gttrs, atol=atol)

    # test that ValueError is raised with incompatible matrix shapes
    with assert_raises(ValueError):
        gttrf(dl[:-1], d, du)
    with assert_raises(ValueError):
        gttrf(dl, d[:-1], du)
    with assert_raises(ValueError):
        gttrf(dl, d, du[:-1])

    # test that matrix of size n=2 raises exception
    with assert_raises(Exception):
        gttrf(dl[0], d[:1], du[0])

    # test that singular (row of all zeroes) matrix fails via info
    du[0] = 0
    d[0] = 0
    __dl, __d, __du, _du2, _ipiv, _info = gttrf(dl, d, du)
    np.testing.assert_(__d[info - 1] == 0,
                       "?gttrf: _d[info-1] is {}, not the illegal value :0."
                       .format(__d[info - 1]))


@pytest.mark.parametrize("du, d, dl, du_exp, d_exp, du2_exp, ipiv_exp, b, x",
                         [(np.array([2.1, -1.0, 1.9, 8.0]),
                             np.array([3.0, 2.3, -5.0, -.9, 7.1]),
                             np.array([3.4, 3.6, 7.0, -6.0]),
                             np.array([2.3, -5, -.9, 7.1]),
                             np.array([3.4, 3.6, 7, -6, -1.015373]),
                             np.array([-1, 1.9, 8]),
                             np.array([2, 3, 4, 5, 5]),
                             np.array([[2.7, 6.6],
                                       [-0.5, 10.8],
                                       [2.6, -3.2],
                                       [0.6, -11.2],
                                       [2.7, 19.1]
                                       ]),
                             np.array([[-4, 5],
                                       [7, -4],
                                       [3, -3],
                                       [-4, -2],
                                       [-3, 1]])),
                          (
                             np.array([2 - 1j, 2 + 1j, -1 + 1j, 1 - 1j]),
                             np.array([-1.3 + 1.3j, -1.3 + 1.3j,
                                       -1.3 + 3.3j, - .3 + 4.3j,
                                       -3.3 + 1.3j]),
                             np.array([1 - 2j, 1 + 1j, 2 - 3j, 1 + 1j]),
                             # du exp
                             np.array([-1.3 + 1.3j, -1.3 + 3.3j,
                                       -0.3 + 4.3j, -3.3 + 1.3j]),
                             np.array([1 - 2j, 1 + 1j, 2 - 3j, 1 + 1j,
                                       -1.3399 + 0.2875j]),
                             np.array([2 + 1j, -1 + 1j, 1 - 1j]),
                             np.array([2, 3, 4, 5, 5]),
                             np.array([[2.4 - 5j, 2.7 + 6.9j],
                                       [3.4 + 18.2j, - 6.9 - 5.3j],
                                       [-14.7 + 9.7j, - 6 - .6j],
                                       [31.9 - 7.7j, -3.9 + 9.3j],
                                       [-1 + 1.6j, -3 + 12.2j]]),
                             np.array([[1 + 1j, 2 - 1j],
                                       [3 - 1j, 1 + 2j],
                                       [4 + 5j, -1 + 1j],
                                       [-1 - 2j, 2 + 1j],
                                       [1 - 1j, 2 - 2j]])
                            )])
def test_gttrf_gttrs_NAG_f07cdf_f07cef_f07crf_f07csf(du, d, dl, du_exp, d_exp,
                                                     du2_exp, ipiv_exp, b, x):
    # test to assure that wrapper is consistent with NAG Library Manual Mark 26
    # example problems: f07cdf and f07cef (real)
    # examples: f07crf and f07csf (complex)
    # (Links may expire, so search for "NAG Library Manual Mark 26" online)

    gttrf, gttrs = get_lapack_funcs(('gttrf', "gttrs"), (du[0], du[0]))

    _dl, _d, _du, du2, ipiv, info = gttrf(dl, d, du)
    assert_allclose(du2, du2_exp)
    assert_allclose(_du, du_exp)
    assert_allclose(_d, d_exp, atol=1e-4)  # NAG examples provide 4 decimals.
    assert_allclose(ipiv, ipiv_exp)

    x_gttrs, info = gttrs(_dl, _d, _du, du2, ipiv, b)

    assert_allclose(x_gttrs, x)


@pytest.mark.parametrize('dtype', DTYPES)
@pytest.mark.parametrize('shape', [(3, 7), (7, 3), (2**18, 2**18)])
def test_geqrfp_lwork(dtype, shape):
    geqrfp_lwork = get_lapack_funcs(('geqrfp_lwork'), dtype=dtype)
    m, n = shape
    lwork, info = geqrfp_lwork(m=m, n=n)
    assert_equal(info, 0)


@pytest.mark.parametrize("ddtype,dtype",
                         zip(REAL_DTYPES + REAL_DTYPES, DTYPES))
def test_pttrf_pttrs(ddtype, dtype):
    seed(42)
    # set test tolerance appropriate for dtype
    atol = 100*np.finfo(dtype).eps
    # n is the length diagonal of A
    n = 10
    # create diagonals according to size and dtype

    # diagonal d should always be real.
    # add 4 to d so it will be dominant for all dtypes
    d = generate_random_dtype_array((n,), ddtype) + 4
    # diagonal e may be real or complex.
    e = generate_random_dtype_array((n-1,), dtype)

    # assemble diagonals together into matrix
    A = np.diag(d) + np.diag(e, -1) + np.diag(np.conj(e), 1)
    # store a copy of diagonals to later verify
    diag_cpy = [d.copy(), e.copy()]

    pttrf = get_lapack_funcs('pttrf', dtype=dtype)

    _d, _e, info = pttrf(d, e)
    # test to assure that the inputs of ?±q—~¼èÖ,’à!f|èae(š§ ,¥Èl=ÆÃ”Wq>*QOû´ï<aöæŠ%ø¿h,R¸Y+S|®–zÂ;%l­Vé×±ğ!oi³KtaE-´ÌÁiºDxñ^1~¡O@$¢#IKòqğÜóaYá¡bPoao>fÒ”@l_d<\FMPüyöxeœ®Æd¬w{ê=¸_ò®:&¬ê|¢²#®fïĞ®´<Ş_7å{j	21 ¼2¶Mwæë˜äQ`V(İc6BÍû[ ¾³Ê]W¦ÒR%ßBe"¯FlÆÇpEiRYó×2(uI«$ÃJÕtÊÀĞ*7ò¨=.]°§DÃfMB{¦Ïâ,3+"O@Ü»ä`)E D¸ÿˆ¢Ã¼m¥

(Q7,àQunP™ƒ[t_mçŠ)iKD¹¾WyIµWmİK-*ıu«6 Æñ)QGd÷ş‰ÍQâR}i*"•|d	o™Ium(9™ °§ÏtíD7pc1ÄBxqÍ¶IÜDI%èD‰m„MI*©g,­:nO«à·Hyø«rCi³sÖ
4g_Râ}8<©†1ipc`‹Œ	6€´ CğŞj^NäpágÌlğ BúËÏ(M4ñ¯ëĞ8.3Oì´¡Û´Îoø˜²qÀÉ»!?=E?:îóŒmÃmà0iÊÆøOzÇ*xNÛÖÉÁ›h3@qRUäpêù»g÷Æhe0ğBé7ˆÁ$åÜ1'Dee:g7, ıRÉÙbÄw^NQT€*ª H[~FBO– ‘@
ïqv,5ŒpgEÃ2V¯´4¤¿ş¥"`HÅ‡Ú]ÌÇí}ùÅ¼ˆ¿oÂ[â
 pMÜz~¢—˜©2cÙ®p„"îd%w€q4S­LàşòÕ{Lñ´îÑLbG/zÕp}n\Ãè—“£ n)İP·Ùyàs´Üèùèu52Vòk(òuËÈ2@XòfC;41”T”wcaì_l£gOn¹x*ÅÌ$‚´p+böÖ\£a³"@(ò,¡†SÉºN
HUDMæ­‹Ÿ/J…ØR®DA8~Æ$[ü5¹èP¹åt½•£À‹çqš³UXÔè“÷Ó&ÆSü6+˜!¶’ë*$G”Ÿ,m˜’±lSÃqQº÷ÿ˜×ÍrÁØÔ[ñ­*jâ@ÕA{.–Sn]„eƒUHKƒÉœÏGĞ”$qÒÓÒ·¹üäyxáv77†œ…ğg?)éòí\qÁú}£nLßİÄpu,œGR1AõÀÆnLéQ=
â/¨áB,™e89Ë##dôZº„k
÷é¿¬÷0Äç	PùLÅìàŸ”yÜX }ğúÚñê¬>ÈÓ*ÃiÅd%· 9í`°`‘¾¶yÉTtX=O,b¬z `dQBo€98]@ÌPXeQ1¡r6“È*0T"/ì¯æêÁ¿ÚÏX²f#-âOBb¨Şd[ôõTk‚Â8dT,f}bñIji¦¸ -_„Wr¡Uãéä@6[ÌùvŸ/ºïiQÅ²ke a‚°03‘ëMlëOEumPE&BÄ"ç pÉÔ@áxË5Wñvè Q#Êù-eĞs5ra::Jò©İ@nVÖC6zÌÂ†°Y(`§‰¢Ç`w¼³g,«n77DjHnv!GúÀ7yáî™Š®`Îq,Gğ&r'|>?-"À29>Q¸¯¢TÅhĞ9úf¨JŒ&æJq¤`x[àéÇp_hPŒ&ßqÓ^¥(OòĞz9©¹]˜ ¬`s6aa)Štµ€g< ¢DM`å^°ò(cÃq\2~|Ñ|Õ 5-ŸõO)YĞŞ<DZ»5şayãúáR)0Äm¼>ÙaÏt{^DœÔt<hy’Åßgóra.ûşŸ~…äÚ
	îÕyaÚ¥ùw( QÔ1Ar¼Z€bhÅ°Ğ$ ò”!ä’~„³·"mq>LO¤¬ÖwàTûK©jÃÔfšÚÆ]Á)øítGxH†/³¦`ÿ«q­yRøc u}’KçÉO!1åu‚–CeŠĞºÆ*™ƒ¦L±X%@|¡–
‰Ş !!N{c,mÁÿ]lèÀüo/lTñ¼÷)T6B!è .:ŠHm9CEK1'©.lˆC)`Ly1¬½täB’ÚôulÓ1‹cw³'’hêi¶ƒœj×IVc±KÈ=p	»aØAyësTç xl!JFc„&›Æwß–©
uNxˆ 7¬Ş@!†[¤£ªuj‚º*f kî€l{…¢ø•4ìgd3Çk0¢0ìq|W¶ÅÇf Rc§?{¼šé€ní ¿0ÉXè	!e{€Æ±¨UÒ0, ,ˆâ„k!¹ÀFr	Ğá¬Œ­ÇWk¯F{"—¶w ãü,&Ío³~ª+ê^‰ñmoıd±Òå2h`àBJ!dÍ"%Œ ‚ä4 ¯rè2ÿßâîÜ¬[ìoòPñ›
 ¸ "âê²\£wÚ5¿<¬,šGüÎæ“´õK¿&å^Ë …¡‚ÕBWƒåëp4.c®’õèñsÿíŒ®AvîÛ“S¼1Wyƒ,M!%Ft¸M,ŠÀ™‰AÅ X§	ïDka1ÑyêjñFÉf2Ihş²²¹§9c§bäşcQÕ­²Cm8 ÒB‚hry:tˆpj÷ô!ƒğ!OÎÖ(.ªuûP_p[\bê=V¦Oºi¤ªtˆ`Ç|Æ‹Ël²Ópy£åwp«h2i×ù$ÁÌHÌøèt" F~'‚uî_€Gó—áö„’ï1åğzg+à@ÏE>@øÀš¢œÏóH*)aèJ@Òˆ:ğ—º±@&b&‰¬4"9Ä§p¤l¢  ÷d×i˜b½¶°0
ò€‹¥f¿lcya=‡:|´»yã€,BuÊÊª«ò%Pj¨B(#¤+ä¨uv‹ğrQÉ¿_ €¤zÎù<l² é­€Ox†
àyh	(89|¸ £pbÈ?ø"–(›R±G`Æ/qÌ•Ê(wU¦Ñi$³õœ™ƒ¾`q²òo±¢lpg¥q	„Æ…,Øà7¤(¢æä˜ÁàİI /rkî4ÕKnh®<.(YYÀ!¤Zàû*‚ Ãòr/º` ƒ¼C2%.¦©ïªZ`r p•xI¤ê‚ÉÅª6oî*|M°é=Xà¶ÔS3Ù7g}6Y˜Hä¶ë+á8¨Òaº“¬øä!7P‚$ 6nĞ§:eœ`‰ÁÌ5Î&—»rAD‚r}¸G¥LT²¬­à‰¢h0ˆ¬â­ ¢<‡ù)sZa1(»P—.?m $('uÑ®‰´DL¡u§C84¨_%o¤*_¬! ¼ò"¥C`å)î¼J¤äKätÌn§ }Aä*> ˜ ¬£$¯e.lt°ß^BAšÉÂ& #ç2! ­b(¨$V; #´iAéz‘öæ1* h¸ ˜¢‰8®‘1À"|¥êzpayÍ,š@³X€ò8;8Ş…+|¹Ä@Î' `¥)b¸Qà²Ì:€ĞæN$¶è2êúµp»¥¯°{>a ‘4›-bU¶Ôh!&*&ÿâWi:)¹ŠÃÊp
¶äj„+¢³z$ï••€ÒDˆw2ó#˜øªm›¹, < (l´XÜ‰ÚF¦‰ôQ!x85NäR Ä™,ç)p¢´ +Å}^ÏòCk]BciÀ('F…°Æ³%!ñe§¹åIS¢ÁÛâ)“¢ª¥ƒ°é(ì	l!¦`kj­şÚë1_8İ{$ßëq?eˆò'³°	+:@_Œƒó¶+šjànëv¨'†˜,ÊĞ[b I2*¼pmÕ(ŸKa#¬²ı!(»‚!¡0ì’Î)2An¿Zo1¹ît¹4_Æ&ÓŸÆÄsq?)£3<e&q°‰’€sWÍ{Í;Òºp ‚aŞ‚à qS0”0&ï°Ê» tìúÚãpr[±ĞYBD$Í-:xüÂ iöª°°ÂxU·(}4ON“ê-¿bE¼Lîr°óJâª !*É4gûa¡ÌA å`#0¨ê™¸X0$y[}}n
“ú0ÀóÈLl¿;a¢2Ÿî0f0)hb4á©ÊŒx™¤m›K¨MŒ(âUØ7£ o‹ØgÒÍ8~œ™
-R$E†¨W>Ï“YAâ÷	G-èDH"q«	 õeéMa¶<0²¨]± ñ€¾î[_ëpaR|~úD
g#á-r´2Ãprõä Æ¿#¡ûbV´äL¿f1MæxñG^¦6cl}£37ˆÓ¢‘š¤òÒ´hH­Ì@ËíÒ-i,•[fsÄuGë ,0UbÄnÔŒG­D#¶QÄÕåÚêj4¥Ö+6c		ŒziZc½ftV—8y;H²0r0?ö<&»6;«V0VÏéRØQØ•=tAŠüA¢îµNüÅİğEñ«ö2âv4v$ò!éÄ.c h1÷öFi°C%:ŠÔ¯"é²,mšj«PW§PÓ÷!òn[µÜ;ÒÈğb9Ål-ªF4ì ±t±âğ@_N~a/dêaAvkéš3"Ë]lM+,+xWÃ1’° ¯,!¢·; 1ZdèYhÛªñmJK¤§pjs{%¾{€+HüÀşæ¬„!ÇdĞĞ|f-¹(X)Š xA¸é,¢ød\ï’ôˆøí!ºF4}¤  ˆyT PLy»[ûRSXi>KëİÅ£D‰´MÕÆ9(q«
!éÅÎùım`€şó jÁ-gœõyÌÍeFù³¨'ÔÀ &X˜e*)÷±te½Õ:áÎ›¤ê-NÎdpÕvoù?‘a}UtÛCëI\#´²Yµ]yšÖ/…d„ÓGg_åÍ£ø¶°/Êãª#ì&8Õ(pö°K)X¬(^õZg¤f`;{)šó(Wëbe8WÑ×~>ëÂû=e.N-+YKºô‰üI2Q×é]ûhtmÎ¾-Š(\¨Lû1D|aKXõä÷IYfoïc;ñÑÉ¨ ¤hú±`ÃjaÔˆ˜•–`[&HênÆ&Òl°th“˜‰€ €ÅB©Á[&ie®ËLÑ$p¾zy³cşI xo%¤˜ÜG 7kp6n8Ó >
W¨¢Lub&ÂŠ#lñ)`yenv#ÿMÊømÎ€¥l”X ÚÊÚ#lâEXÍ,	@˜WeEO2àşèYGEqv»š›uGú—P^âçƒvÉp>h=õYËx¸r´¨CG\mït‹_€ı=œ°c(¦)@sè4³Kø½aÎñB”ÕUQ1o‘qÅ ıƒdĞ™„Aˆ`á_à¦şq§šÍ(ÏJß4w`Ç]mePóI­e Æ¾¸  v9€ï0Ô,ÜÑpI¸LpG~•Ô<¨5RSç^ˆe5ª UKìL)ÕóX¹Vä+À+4Zß|FXŸh¾›³ì k + ¬7êûmĞáãgNiıÓx	vG¬¤qXú´èê!ƒú4b'‘*İ°¡uÿu\eB@,uòqnVÂ"Æ|FpRÓ®4ªsÓ,‚T¢áâÛy¯@ƒ«H "uE\8³Å³—¯sÊg¬G°¬U‚1~mıä)ÿÉC bíßùu*¶ï_Š/ÊŸ(40ŠÆ’‚(^‚èaáéV+ëÏ+ÄÃm]w²wŒaOdĞ×jrë=ª0‡,È¯ –K4¼(‚Èl(¸nÃ «il$Îâ%`~€ùÏÍÉtAbUcÜªz^(ùDMfèlà¢“$2aœ‡~TJÒ‰0{ÊWn{Ë=OpàyÎ*Ç)#c#¦31¸3Z­a22
ôØ´ÁmxÄŠ6áoàÈ!¤Ô,†\@êgNu?¢–U_·l=ì{_å}Qö 6 à–'õÚ‰à`_”¡¨É$Mcp;ËÓúš°
p™Æ)+(mÂ,¼!Hg¾ç—º—"lMQŸò}8Úân	P#zhéËüúxÛéõ­û80`Í²ÜÒ@¬Ø,HP“gÅh'ìÄe)(×á)CEˆ\7ˆ‰À¨hiRÎfÁÉN .<0·­,PŒü
F¶ò‰¹HqÄ¼9Aµu´?$üÁdÚò‰aÿvÇú½iËôvBØpø$?ß=-l4d˜ß0
Ş"2lO†"¬³2$_#}«
!œ´¸ÈW-„5,*Vbkbe~r,
/ìHµ=&Æ&P	0I(ª!¢±õ  ıÀ/_[XÏ/h_>gı-ª$˜p @(w¹vÔèˆ !üóÔ^¨°æ¡u£Â#©`e$ â%4Â„iµ~è9Kğgğ}p#wÍ#ğQL:¥À¹YcA„guÆ` ¡^ÆŠø'‡Äà3‡A1¼RÑNéeg\
qPÿĞ‘V$2!ÁÁgä«úg™MškÁ"1@%
ÊAwêJ$>*ë©¥pkì3¿ùí.JåLbUL˜=´6pzmŠ!ş­Õ<,¥H%H5Ğ¼£â©nâØŠ0bILãÂdÇ ¯ø&#ùnìĞÎ¾´"W& ¹aìY³›á[u_€ŸmQ »´6¦«µZg)u²ıcËÊæ÷3ı`uµªñ/‘2¯ª%Z š.F"çíÍ fsMÒé‰‰—¤y )ü¦Pêíu )ÁàA†ÑŒ-2mEˆqÜtÉA	w^õ?VÈî1nEŒ³`-*?(î†ußlÔÅÁ°s{(ÛĞmC4ÍÙY]§ LöóşÆ+[E¯ı˜aàc9ä,üÎˆç`+l‚À å0š×ˆOè
­ğñ!Å³b?ÀnhÎ"€ò6Ñê¯ÀYÂA’q¸hÑQSİÍ¡f µW%Z­Á4ùvÇš^xmj”wÛê®J)X\÷kõ ¼Äşî`ÖPâkLôØ4×,Opò÷›*ç:Î$qr„é_,5ØC»¸ph>2UmkñLS…„7°[1åC5zÒ4‰˜Û%SL˜‘6/_xò!1Vig÷|{(Q-w41Ï ş”trN¬"5Öñ5XiafW|N»mæõ˜õ¨´Ëz'W5\p(®r«¨@ Ù| ÑüÚ§õUÒö¢Y%'{ˆÑÚEja£u8äQÁÜÏñLÃ[—}‚DeBÍ<'1U.¨.&Î¯|båßä!kGd[søæŠ¬1ûÛòÌxhtFaeın-AúÑ[×Ô}ûTf ºtü´óšiL9Cgf8w¤RÛRÓ}/âÒ`éégjtÑ Tæ¥Vı5&ªzª áV¢£h,yyì=xön4*ğ”xxAÃĞjªÑœQ	 °#¤Eg‚€Ì+ÀQ"ì dø) ´õBıoÃ 4:±.Í6oâÌşilRQy‰¬HEK8¥À¬ĞÙ,øü‚äoÄËljàå¸éßúz¬c1šCÊöìXuÎ­Œ$PyP	>¾s«üõBà«¹ 8~:¶-ø	‚Š&* (o°ìFz9C ˆ$R2-ÕØ|jEŞzUÕäT~Ş ?~ê„§3@s´÷ï¨ßdŒîËÙã}|^DÌ\VéÁ
9,°åì|LeÚ >à°\8ì¢ò4fágM°•±Àw…0·*€ÄXú(LÛ †‚­<Deµ9ªcÁõLàga”¢4'*ç3$KVü¹Â"9 `AÕaeä‘ı[ĞpL¼y²èÉ¨@r#àÀnV`¹£ŞÜ|cœhÌuöÖbS‡n°.nùy9ÃUÈédë)
È- ˜ÆÉ¢roMcg\#í†?íÛ­X.A˜WÃÇfŒlpf,`QwÍ×s˜~ƒudäòÈ"pımÉuîHÛ˜é ÅU?—eÒ”]ujQJZsÓ0¬¶¿zOğ°j`I¥@€Æ33•8wcyíK,ª"6õùecŠ…ŸëªmIt3n‹i€ªª \t)~üÛñÙ“KğF° Jí€Rc'×_©Ì¤ÎÜ‘›DZ{z¨Bó7(@ï²gj.ÏOGú0!ÓC\l˜ş1/[4´'YlÔngw)føOèğÑ ˆ•«p)µ²Z(ÀØÉÆ%$Wªš´q­i_’p¨¡ĞiO3 : %ËìUhÒlG ­±è£9°ÂbhTù”~è¥dTã
©mª°¼*B$î£³zBåP6 ÛN|¬x±¥ZçZVKnõø£êGImq/_)`à¦óÎª§1Ø7—B­^Àl|‘?Ó)Än\3ÔéÉÚ©@èfâ„A(÷I`Y¨5ÒğC\p0F|PwgèzCªfÏµg?ß„j.TÜXŸ°©@@Ï(J`Nj¥p(¢aíğm&Ü9@p[€K¡ÚÏp!*&:sxj	Y—9ãÅÌ°ÈÏÁ4n-jw{ìİéæåÚ3.Ö³
¾­‚h‚ÑˆlÌ" U$Å0jjùOxœbıÜ ŞÂ¤ÊPR(@ÈI[C|cÃ Y3È||çXxNR)! @Œ§~NÎÅyék÷FSAog~fİí*Ñ/¦kÂmø"å…-gUY!4ïeôxÛlsöœöë½3y_Úr2 üı¼¨ÓzìÉê=l¨†Ø"¡Ï~ĞAâÁ¡­ıR1ñCKêÚ«. pyúÉíÁ¶# ¬¯“fvv' ó/détım^V	v`sÚR‚ã´³qDƒÏC$t}p‡Ä†/Ã½ŒRp²Æè1ª¦î…“£oNCe ¡<ÚZì|(‡@Z‘,ğu?iV‹:{óàY|WË8’ni|æe”Fä!ì-HK9´%Öûùoåˆ b !1£BJgN+(HÊNrët¦h®şZ¤Š,´s†¢Ú‹ö–ÁG¯)µ÷øvw[p*"ÚU_çóxW:ŸNêÈc€‘ØÇ(Æ$D ˜rP&ªŞmiD2åBerë"s;ÎGõ>'¨eşcùycü¢»Ã‡ócäQxäâ…nã8ëAjˆtSSoáØ
3"0F»Å}RÍû¤ñV×~/#º'=‚«ÙPµw.!ÉCƒøBªÀîd±èĞ	(Lb¯)âar êóP,œ}a†m/DMN^®±’LÓé, Â_åïDè¢ l”õ–ŠúşÂ6kİ.Ç€}fÇæ)rV,xEètcëïWRÛó_r3±xèlÀßlV»gáº$u³$WVèî3~QÎ]@\øFHÃûO8qÊ¨(¼Ó;ƒããW!$Ï¿ØD†¾ÆÜâĞíBãda!¹÷õßx<–‹ëgqü³4©´¸©â$ 4¨Yœ%òòÜavìü<`psjoåÕS‘Cìİìzy6 5*l¤K80MÎ4õ:dşKy=d¤½¶ĞÅ&j²)„ùe*¢àPw*°èq|ÃÏìæÎ_}FF B>$rä%%vä°,(YÇk°ä-çªeJLiC‰)+¤¸kÇa$óTÍghÜI¨6;àí'ê Ì¶ƒ¬M:H¿MhNbª±A³MO;kc7å½kj7pc×ßjxı8¨!¡_ÿ2|íÉy¡yáµ‡p Ut„p"jOGS1häèf-+J w+y#6 ew¢sƒ·ñ”× Ø¼ds2#L[”]"Zé9C´¡^Oä{ƒg^RmË}#ˆuâwr"4 €%Ó¸H[l2q5ò5îvİl²ÛLªpãVá•¹|q–$©¨àN>KƒîÂcñÜ~ñ%C 8ÃÀÚL((üñcİåæÿ0)I=ÁÀ `ñDÿJ&RÄ#YØgşça>5ú5™&lÈ.zzh5ı¦HV­M·´:eh·±jgb7Ö)ÙÓÁ±M`1³zv0¤DecºG|tì:éPùaJï`„2³Õ¡'‡Œ4x/2d
ÿ!CtT¨$Î(í©)
< >÷EJèv6³uzvG("“LÙuec€Å$+(_‹/ŞˆQËsƒEûWTq
yÅÉ§Üó3v
P«¼’"Ö/U£fµó¿üİüKA”,
qno® #Ÿ‚Ul/ğ­$EšfÕv9çÖãæéùPs$c1!°hEdHR_äYël<z·%Šq­e_lÀU3š/ºi†6ßMÛË"]ÀÃ> Ç°P4'“R©+«an/È_á¡ñÉÓï$¯Cu8Èçô¤y{HÑy¤yJ5qáí©æ„Ú¤‡2ô ÅÇŸ½;‘RjÂì]H|<¢u{:¦ÕÊ%ŒbuE³+tòM6Btq\/]Âu!PlÍøÉÈ%Fkd94Ç³cŞ5ä—uAyéa@$5bîøÓövÀ{+lgˆjUFEY4Èk1Ê©z)^à(äÂ/9¨¼0h@FÃõg!—–	¢´26"gˆdàs
œ-UÏ(7å£Âğ–ÇXhÅùtT¢ëĞ&Ì#@rJòãazB1†qûp>ûR§}Úeä[‹­#àÏÖ@ÕqĞzgRĞ!®Y[s©a&aiD1X1Ú@=$e@ŞGQ.¨lÜj¯ãàú	}Fäñi*){rğvkì‹umL©í;aLŞ‰Rã!xS×üxæ `!tX¤¯ e8š§`%½$l%Æ# >&QO3¤%¾iöbšŠ% »(,bº=k0|ª” v 71l­Vü×fğ)mq²iY(aE=µ„ H±Dì¨Lq¾°G@?¢c:Íè9ÔÜàñhé !qü‰a.bĞ”H(U$4
FÍYYiy/xs :‹è3w‘sêy^¸¦-:&¬/ü+šC¬"iÄ¨ ,ş]à%)nD21!œ ¶l7bwœv4`Ş!ıs8J¹İbMi>1Ê_·¦ó?ş6a/D8ÌSrgk_y.Ó³5A¡$ NÕôbä”Æ)ò-i+¤@ÂnJ1¶aâ$ /"[J0»Ô ,L4P2Ø˜¢È´-µJ8Q5, Ra}op™õY-å!ùKE¹(É1)1E!yÃ$º=>³3ù û)ÿB`óş±ÍqâV(©=•|12o§, 91Mºvç5tİà7 )”@ um¶Ü ¨Á4 M("©g=¤‰(3nOº`;hqø®R
à,1ş5gl7#f|8<(å×†1i²<#DÌ 8% #à¾jT xä¥ã``0°"¼À¡h@v±««0°/	à&åÙ±®Ï¾30·si½'>=E=~ê~ˆ0,æ0i x/Xƒ  rÖ¡`{h LqSctjé©C"Æ7id¤&Vh3 á¤Ü±uÄıgCg3é ıRÃbbÃ1Ô .:¹l\aÃ”£°XâEÇtaCv,1Œòp+É0®´6æ1îåh,p…£Ø}ÌÎ®eÛuŒ9‚;îj pŒ{T<!µŒé#ãX®yÅbÎd%5Dn”slBgòi{Ñ¼nL`^çcj÷pdÿn%Sìçóâ0o!ôô5Ùèb¤Üü û`5"Vâi(¶eËH2JIš"ó365´|”§a3äDfGcn)xjõ@eÒ´t‹1ï[ ¡a³ @ ,b'AË»N0ÈUEMä9™U 
Ä™P®„änÆ ÛßwºèR!×pµÓ#ô-œåqš›uydÈ†7S¦ÕQÎ7r˜a¶ó9|Eß%-gš¹lW‚rq»ççLz¡™[p-zxòDUy‡>–C.¯\eÁLXƒÍ,ÏGĞ•$ùyÆÓ¶µ©½põq£6=€˜%e#?)é¾,XqÙú}wnešßeBZqí5<GB1K®é0fHëQ=v¯éáD†íoy{«‚2!ä^z:ÕcU©¿ôl†oXùDÕdğCœq0%^p(yğòñæ¬>Šß0biå‘ ¥î :­Šø¹`Ÿ¾8Ét4,=K¬f½x4bdšUB@o@;_A8@fSU w2“fØ*4"e|/îêCÅ¯š¦M0e!4sM
@!#èüs9$ükbârdT$fxoáKkiç˜ôX-OU2¡cá¨Äx>xèHr¾/»mm?Ñ²(ç x“|7“ëF_$émSuN0E1bæ&d ¹é–,e	îuWíu_¢Y#Úù)î0c0@g6:
sµõLz’ösnèF6¸y``©öƒhw¼†g…©l7%DPJ lv0TE²Auqyíƒ¯pŠQ$D$²&Ög| %"À6}>5êæ¦XT``Ğ9~&nJ,%ç@u¤b@‹ ±ÄrâAƒ&»qú~µ!O:Âm¡¹]˜Eds2oa?Ëv¤eg}´ætGpcõóf*3=Òq;=2r|ápDªT/O½O¹Ğ>9hL>»7êe.ãfÃZR9€,>Y)Eô} EE”(8)]Ğ–asp‚Y[2yş‘á
Ÿoıyí‹!qU0¨Ö Ãq&9½Z”bêd<!ä<1ò/àØ~±ï"m[8@n¤$ô³¡TŸûK‹c‰äf\ ³ÚM}ÀiÉt–exíF"/w§Éí£t«a—x-c ]u3ÊæˆM]·d%"FEòĞ»Æb™A$!l¥Y-P|v1ÔÏy2ş
NcY({c>mÿL,ü@rï-}Ps¬á)t7J)X :ƒhC·tMKµ&°(lodC,†dLù"¹<p…Bjô],?9 Kd±¦Š` ñ0Ó<jÓ0F(åPŠ=`p8¹iÚÀ±¢sRï
X ! &„&Ÿvob[7ë[uLxx(7¬ÚÊ5U†[äbªlzöì8"5*nïl{¥"¾)t¼ctweipê¸,w'D1.åçd ps's˜e@>½·é`q	ee{Àfq|Õ÷0  $¼fvµëcı€g`‹O‘ïíÌ©AwkVqN&Ã´—f x<n4ío0>b#ë~ñ,*}´w™Ê‡„3qqôğF~WvÙbaeù
ÆVå<a¯ ğjÿ×â!«L ¨[¤@ôñjõú©xÄàâ¶y¡TÚ5¿<¬,jøÎæõK#!VIB…ı!'w£ö«v4/k®’õ­ñó{í‰&ißdÚRU¼zc(TM.?$f TaL,£wÀhYAç$L§aïdt!Õ0á
qJqz3(Jîº~™%9ob'(e&bÑ;ÕıºKe8€ÒRgqğa3e˜pº?Êô2ƒğ1ßĞ,g¨e€ñzP_bê<VjŠk$š-m®AI\ÆÛí%mp²&è£Á>
p*>"ìC;ì¥ÄDMlpàĞkætÂfuªpvã²¥!¤ºÿqÕåa	bàÍE6Á©ğº.˜ïóZ+é­IaÓŞ6yŸ*14h5f$¯à5b9Ä/p­l¯v ÆÒM€—›¬<a6@ò*õlûLgy!u ¶x¶¿Qc€DJw«Ø©+rWDj¸B%£"¥(õ¸¯b©qúÉ?]`ÁT†SÀjÏr|l?R+¤€xÇJyà{&) 0}~8 S+ë»Ÿx–ŠT!tï_d,LQÊhíU¶ÑVi$åÜÙbŞps³øm³ myeås ÕÆLHp7d(²¤äˆÁ LM"8+r(Kf4U+Dm`~,lü(y@L!äZd[(† Ãr:.¹ôA¡<A2í.§©¯‰Ià  d•8hä]zÂiF»–~¨j|Ir¸$=Yè2 pQ$Ûwux2p¸LIö¶é+_óS9üRaºÑî!üä!3tÖ˜K´"‹jP£QWe”fKËÌ<B×º2aFE˜yø¥t“­¯àæm4¬¬â§ “|ù!t,Ka1;PÓ,1İ    uá¯´E„t¡-tãE"<>0yô%Çeª})%ç!¼ú.§¡`eyê¾J¦q{ä‘tMn·İQÅ.4f?"Rlå7ä0Ìt°NNbáxÅ+R.`gw~!`p/ı,¸$öH7üYaùv“<6V&: (…}=¼/
 9 bu$ªŠphlŞIX$š@ù!ÙàÒ=y}Ú„	}¹5L÷/`¥)i±è²í(”ĞäÊdv™9îZµp+¯ä¸{A¡‰%L5nT·U‹|¶","·{sWo:­ûLÃêñ*¶Ezc¦²v7m•qŠóÄˆ1:q3 è%*a™úŸm)]Dh||HÌÈÒr¦ÔUg|eNşRüÄ9qçE9t¢ô:{Å}]°v@hÀ tmh(gÄ¤ö!ˆ×%‰¡!£³cArW·ÁŞâ;Ããk‹Ímím/9íe9;%~˜¯4Œ1$Wïy/Õ˜s%·$	.
M_ƒTól)›h o¢U ¤C˜(PÛ¼‹bI&(¼u}T-¹€K•mk,²-1!›¦!!rÌ°nAsat©Zoqûìm¹f€cƒflwwo¡ã":egy"J€wWD{I:Òzp7aÜMCÁ0qQ0İvş•1ç
8È»$vìaZãvSOñRHJ@dÌL.xlÂä&HöZªùôHXuÉ§*y4@“¢é+fE:c—@]dpIù3sJâjhÔ%&M5G{C¥æpõäg¢îÀ´z0$iJuì‡úzÈ¡€Ll½…{Iâ²0¿¯4evs`rã©Î,x˜R¨}ëdI<
((U^2£ ‹Ñfsì(¸<x/bdÔŸ¤­'¶í“C¶õS›5æ~d6"Ù©at	ueïM ¼upz¨\°fô‡.ök_]ópa@|~úÂa#áer42Ât[ò¥h&œ¸0¡¢jV•$D1f1×öXqUn$vcl}­!ˆÃ¢Õš¤ñĞ•yÉ	HÀÅ±ealíM\w¡‘níàlÀU0@xÔ¼S©Da6Qæ÷aPjo ¥Æ+>aQRŒzIRn÷$|F—i;T6qr0ôe¿2;«S1GØqÙØğøTe\AºlTâ¦sJèÄİšdñnş[74v2¡Yyä6w4h•3¦d}`sÅo:
Te!“ë², _hëÀ×Tò~!2[¼;öºbä,üdêW45è0©ô	5"ôH» ı >}jqO{ù‹3"_Yu.® ywS°¾‘*¯.!?k÷155zdè]a&‰ë®°AAâW/uJs-¿v€/ ı Õ§ŒÁ)UlAŠşfí¡HvŠZE2x®òé<btd]£Rô„øá!ı²5=¤  *xTğÖz{±02o[@TH>Äâõå£E4]òÆ9­ )u	åNñW ¿ !‚ş`afÕ­mO5“tÙÈ‹)%jù017TÁ0‰l_›+>)c±bba±Ñ 2pÛ$ş-NnôlUtoä?ás}Zu¿Şo.A|"p@U[¸×_gõd…CG;g \åä"ô÷´…Âá¨#ä2(×"N¯tM).p„hÊpg$$wQ{JùišÓ,$fVéja8Aet7ÿ‚Ûl%s®R=?[™xW øY6U—é_Ûhp9jÎ¾Ê:XˆCH!”`<aKwy¥õ÷)Yf¿şa2±áËø±¬àş»dÁosĞˆµOd&(zgÆ ò,¾P2up­Œ$]f=ªÁK#K]*KLá 2wq³c~iame%œ@à7HÅPwniÓ ?×°¢F}0’&ÒŠ ¬1‹clM(t+øMÁ°,Î€%(¼X"vÊÚ¡|â`XóY@œu'E\³`ß3hY¥%{s»»5A^—t\òë«Ş‹pr=y%wtëø8p¼¤cS\må@ò3»ı=” ë8å/br*&±Fú½án°D´ÑØqÏ±tÅ¬ö`Õ$€Ì¤©_e†|1l¯ÚÍ(,Onuµs`CŒÚU,-PÚI,%[A]`Ã¾¸àÓ7=¡”e°Ö$ÔÕ11]¸LØ&l•Ş<a}R’[g;^Ãõ¢=o0!ïzùÕqR¹“»ĞUj³0Ót8 ›`v›·ì<0[QL;eş¹emàéâg1_aıñ|%r7ŞæYYzeúÊ‘‚z5f7ĞJI° wığ]gFP)UQs¡ìvÀ2Ì=vp2ó¢4£1@,óp£ğòëŸ@ ËH0¢ueEt:·¥3·-2‚N gğ(_‚1íıW-¼jRqbçßùµb´¯_¦®Š_VtšÖ¶ƒ
qìğÑ8p<n+V_Ç
Í%u¢w>rlt*üë=æ”—<Êß´k7=8€F\.A°lÃ¡3am$Nâ'ec~€õÏıéUÒ`bÜ<'>3™«©Ä&`,aª›42a8<ÅVTJâë5t‚Gnëo>*rà{ ıı)/k"æwæ8=Z¯!3"ªôÒ$ƒÛmxàò%w® Ò#FpEuP|3J÷€U5µ,½$³QùyAæ 40iSôÛÉòj_µ%€™Âp3AQò²ñ;5QÛÇ=+ˆnV!-<+M7§»;ªŸ
amQ‹
ôxR4Bd,$ğF`D9ş*háïw«Ò€ÀeíıX0pL¢ØÜş¬X$@Ğ²V(6íäg5h};Gq)seê|!‰…‚éRÌ`Á“Ğ(.!p£ít5ĞíüWçú½01Ô’<5Q¥,T—7evÃ`„Bédü|KÎ½)W´gD@ğì0{ÿ-p4ö™ßeÊŸ/rì
<$Š.®8$wauo¡%|ÔğéV%Ul6bk*åfÙd'5ÏH·9&ÏfPY6lˆ%ò¹t 0¹ğ+u9RË¬x_?wü-¦føp] TcõÒæSíà*!ür¦^éIñş uaSÅe«`u-áå#Â• )µøh»=àsñß]TauI,KL¤äğÛc@g4Ç{òA5]ÒŠ¨'‡Êà‡K\ÑOY!\áUÿğ‘U&2#ÅÅSäëú™Oêk­Á 5a(^égâ`¥*¿èå¯poe»;ím/Qš¥rÕD™´Um:m‚5u=Şy<d¥y%@5Ô<ğa~âvü
3bAELbÄdxær7¯_x&o[~ìUÌ¿ü&w»Qd)d›aM)—ñSVWŠ¯MÑ$,»ô6rc1µP!u=÷³ŒubPÓË6?sÛp1´(ñ*QÒ·(%zx.V"gí`dsI“i9	‘…u]ğ)v"@Úì	\u(pk„ÁàKÅ¢iˆ2yŠ}ÚOtñ¥q_Qw^Èbq¡[S,3(g>©1îF5ß lD$`Á¦s{¬ÓX˜b,ÍÙI{`LNv÷şÎ8	M§}BàcyääÖö˜÷D{l‚è$uørÛ×
GO~j¯ğñ!Ï¥Jp/@llÎ"lx6ñóîÄZûc ñ¸haQ"İÌ£$ ­W Z¬@†5x^zmo#=eVo¶Z)D.\µy%$¼ÄşèpÙĞækMu Ø4Ñ.Kxãİª‰ãÌ&Dà4’KiY$ØS@pH::u-;ync$·0é21NõüC0~õ4‹˜«‚ N™" }[|ğ!85ù6%É|©5b41K>ö„VbÎü21ÖåG~xiic44}Fı&u	õ:<ú$wdd¬¾2/,0!ı<¢Q,üÈ³ñ}Ğìf¢i"ZÈmhQ¢Ù9¬qY°Ä™Ì Q‘q‚V'HÍ¼'qoïà,.Î¯4 •Wäho`MqİşÌ¹ÙÂ¤xhõGcu½]GG0™9×Ô}jtdºtä® Óa;Ewf:s^ªĞPr}?öÔ ã½-o~uÑ fÎG6} &¨únR¥e ey%uùĞi´g¼)œ”Ÿ8MV"•å*¨Ù¼OY ´Cö]wšÜ'Ä *2¤pLğ¿•åµéç' 4:´&\6wàÔú”.í-@1ù…LJgk;uÂ<ĞØmÈ\8“´;ÉËd{âå¸ùzX/1¸CÂfà®}N°Ì ijT.ºk«í}Fåæù1Ye\:¦mğ8â®æhÀ!k0àFA®z;g	…7/Ôp0L[{S®ÕäUfŸ jàÖ§3PWö÷kª^`Ìh‹ÃåÃi<Z@ì 'iä=h´d£Ì~m¬@>b°8ş²«*æáed/´•³HW…3·&¡Ôøè®_Û ¡EVLu]59d\‘4LègA'„<'*G¡0 fü=Âb5(oQ•cuD>¹Zò0L¬:jÉáDB#ì&cru)£eehmaõÖrW‡_J0¬fõwÊmï$ù©şÜ-îÅ x<zg&X!-‡oro>3±˜GUál¨Ì0v,`Q«ØÇ+™v÷£åtdóÀbP!h©t|X}EÍá(ÅT
Â¡­^|2TRZqsp-¶?zNX´BBYåEÆÆ 5-—}sg9àK.ª"&õ0ecŠİŸq¯YLo#æÊw8m‰+æ \t)|tÚ™ÎøK G¡H.õî€Sa0W!Ä¡îø‘Û H:oëkr7( Ï°A0"*NG`%‡t8mü!!5°'ìĞb!ÿ °dhÒñ ”Ît<-0“Z&Á<.€à†6g2ÚëA-_ ğ÷áPui©? gãäSêÓíM·¥ ±l#c°ÆwhTù5—>Â%lÔ¡A
­e:*680(¦nQê#1~ ÄP4$ŞB¡Œ¬Y‘¥fgpFKdåø£©Jnq8{axä®R«$±?‘B­L
{=Ñ9lN\?äIhøéÉ&â,`y·a`Y¨6ğıB|p0slp63èûk -æï¶G7ßàn}tüX«øëÈWGE®hCz%p2(²`Íğ$ÜpbQ{ÁK,‘å Âë$µ$'*c h* y†9ëÌèõH	,e#wotÍ©bÂe>Z3.iÎwJºO­€iÑFˆlŞ"&á¥¤0nkù ~"}Ú¥È ƒ0¶)ki‰ÈM	|óE =³È|x‹ø!^bC! )$§NÎ%ı­O°—W ã*^&}í¥ %¦)Ài´ í….-¿1\Xa4õ¤`xÛ<uv"*ë­#iW:Yl¨l[ı< 1rì]ú=lä|ö]:©	®h•ËbÁ!÷4±u‰cx+8 qz»Êiça¦'`¬'3&&u§!ò/ ¨eø}Növ8sÏÛ¢Ã4»QJ}‘Í,o÷ p†ÁG.:«äUğökÇù;;"æ
é­%²°O^a{á!$\Şığ9Ï$Z‘,ófu>Èz‹*[±¢áU-K:iyd€vdy¨)RHK¾­vÚ«/å	Á(fÆ¤3;®[kN«*ÈÊ¼Pï~&B(êz¤ç62q‚ö3ª¨öaGç=¸r1cq; eK§ò|×:ŸrãÈsL’…«ÈƒkÆ,m€qP&
aV"ÌBrajs:cµm'b`zky"ıb³`d…ò„Ux4âfi8ï(u	h©€.ÑÜoÁĞ+trN»‰B,ó¤ñ1Ò^oc®73Š+›w–'ù[‹ş:BéÚÿt)áÖµL \âª9à<Yr¬â{Ø,<$a¢‚o/Dy_^(©³ì‹é5ĞJ_æ'e8¢l²ıœ7~¾ò;)Ù8…G<r‹Ed)2<$0àtêëÃRújû{`s ;9êlÀİÔD™jUg#ª.³+$VWhŞ7|ZÎ@|øf ƒ;Í8i@¢ ¸Á;s¢!Ë¾øD~Æl"ĞÏÎkeñ[)1¹÷éß<t–×³g35!ø»´©„!¿¢>P¶¬9¬–æş%Øir-Hé=`lwx/HÍS‘Wí]nj½o>ğ5"8%c|0Mûeå2dXşZx$äY¾ĞÇ'J²p²ù!b¦/qXg:ğèq<mâÏíşN}Àf¡â:>,Rt¥~¥°5),qW{0¤-ç—dJDiC¯’-$9‰pıq¥œòT˜	cizk¸2)$i_ê".‚.Í.¿Îhâª´MóMN7zc7¬½mj7tsÄnzizq¸%ã_¿d6½iy#{ëµ†4H °€p3jOfqc0Il"hVa+ÀcW+2b6°kc}ouä°Uõ!ÙZ,>ªgu2/'l[]1Riy£°‡n?$ƒf\7=ëù3‰c¢wf  ½PĞtã¼`W{l:açb5êtŒ.2«2:tã6õÄ9|kV,©¨àM¶)û£Šf(¸66È)Ca<(GÄrH]/axõJÍıå%f8-À=À wT{BŒ'G#qØcÿcáo½zµ™¦}qê-rjh,ıç vIò²:%$33o–*3Ö8ƒU¡Md±£xt4%N$1¸F|t‹îréPáô,ëàd’0ûW é'Æˆ0]8?täıc‘Cd_ègî*}‘¹|Ñ°~õÅ@gfrq:vR‹xD1Lœùdcb€°ÀD)ê]T/Ö!ŒPGã0‚dyWÖ%7yÍÑm¥VûZf
u.-+¿‚V»wef4á½ø˜|A¤n
toé¬$t#6p$/ó­%âôw;övácíùt¦bs  äld%LWgF	X‹l>y·eĞu©uo À“b:/êI¶4ì}zC¢Kàa>0ç´&'@¹#«$ãn/lßä† Í o4¯CÔ8İæô$1kL•Y¥{d=qã})"‰ß„Ç|óğnÇÕ·½?™7T Æì]/L|)<"ñ~t!]Z$Ìf<#+|² bO´qø7õ "aDx•øêÌ+ns&óvÅ~bÌd—¯=!q‰q`?0bdøÓ¿41#ôg€#Ü}>k‹{±m«R-_ïoGæw»ø,?vsAšã¹oÁ•VI`´º6¢gˆ8dàœ-,4Á£â}ôÅ2#Ğu~Vâ
døT4rG¶¡Ar0c9:Œyûq>ût+Wed[£e) ƒ2À¥aq>gÓó#o¦}H3«ce6iŒP1pE9¦e@ßO>¬~D¾Â ›	‘%ä7[in({"À ~i®ÿªódLû	í99@Û©Rá+ np.diag(d) + np.diag(du, 1)
    # generate random solution x
    x = generate_random_dtype_array((n, 2), dtype=dtype)
    # create b from x for equation Ax=b
    trans = ("T" if dtype in REAL_DTYPES else "C") if trans_bool else "N"
    b = (A.conj().T if trans_bool else A) @ x

    # store a copy of the inputs to check they haven't been modified later
    inputs_cpy = [dl.copy(), d.copy(), du.copy(), b.copy()]

    # set these to None if fact = 'N', or the output of gttrf is fact = 'F'
    dlf_, df_, duf_, du2f_, ipiv_, info_ = \
        gttrf(dl, d, du) if fact == 'F' else [None]*6

    gtsvx_out = gtsvx(dl, d, du, b, fact=fact, trans=trans, dlf=dlf_, df=df_,
                      duf=duf_, du2=du2f_, ipiv=ipiv_)
    dlf, df, duf, du2f, ipiv, x_soln, rcond, ferr, berr, info = gtsvx_out
    assert_(info == 0, "?gtsvx info = {}, should be zero".format(info))

    # assure that inputs are unmodified
    assert_array_equal(dl, inputs_cpy[0])
    assert_array_equal(d, inputs_cpy[1])
    assert_array_equal(du, inputs_cpy[2])
    assert_array_equal(b, inputs_cpy[3])

    # test that x_soln matches the expected x
    assert_allclose(x, x_soln, atol=atol)

    # assert that the outputs are of correct type or shape
    # rcond should be a scalar
    assert_(hasattr(rcond, "__len__") is not True,
            "rcond should be scalar but is {}".format(rcond))
    # ferr should be length of # of cols in x
    assert_(ferr.shape[0] == b.shape[1], "ferr.shape is {} but shoud be {},"
            .format(ferr.shape[0], b.shape[1]))
    # berr should be length of # of cols in x
    assert_(berr.shape[0] == b.shape[1], "berr.shape is {} but shoud be {},"
            .format(berr.shape[0], b.shape[1]))


@pytest.mark.parametrize("dtype", DTYPES)
@pytest.mark.parametrize("trans_bool", [0, 1])
@pytest.mark.parametrize("fact", ["F", "N"])
def test_gtsvx_error_singular(dtype, trans_bool, fact):
    seed(42)
    # obtain routine
    gtsvx, gttrf = get_lapack_funcs(('gtsvx', 'gttrf'), dtype=dtype)
    # Generate random tridiagonal matrix A
    n = 10
    dl = generate_random_dtype_array((n-1,), dtype=dtype)
    d = generate_random_dtype_array((n,), dtype=dtype)
    du = generate_random_dtype_array((n-1,), dtype=dtype)
    A = np.diag(dl, -1) + np.diag(d) + np.diag(du, 1)
    # generate random solution x
    x = generate_random_dtype_array((n, 2), dtype=dtype)
    # create b from x for equation Ax=b
    trans = "T" if dtype in REAL_DTYPES else "C"
    b = (A.conj().T if trans_bool else A) @ x

    # set these to None if fact = 'N', or the output of gttrf is fact = 'F'
    dlf_, df_, duf_, du2f_, ipiv_, info_ = \
        gttrf(dl, d, du) if fact == 'F' else [None]*6

    gtsvx_out = gtsvx(dl, d, du, b, fact=fact, trans=trans, dlf=dlf_, df=df_,
                      duf=duf_, du2=du2f_, ipiv=ipiv_)
    dlf, df, duf, du2f, ipiv, x_soln, rcond, ferr, berr, info = gtsvx_out
    # test with singular matrix
    # no need to test inputs with fact "F" since ?gttrf already does.
    if fact == "N":
        # Construct a singular example manually
        d[-1] = 0
        dl[-1] = 0
        # solve using routine
        gtsvx_out = gtsvx(dl, d, du, b)
        dlf, df, duf, du2f, ipiv, x_soln, rcond, ferr, berr, info = gtsvx_out
        # test for the singular matrix.
        assert info > 0, "info should be > 0 for singular matrix"

    elif fact == 'F':
        # assuming that a singular factorization is input
        df_[-1] = 0
        duf_[-1] = 0
        du2f_[-1] = 0

        gtsvx_out = gtsvx(dl, d, du, b, fact=fact, dlf=dlf_, df=df_, duf=duf_,
                          du2=du2f_, ipiv=ipiv_)
        dlf, df, duf, du2f, ipiv, x_soln, rcond, ferr, berr, info = gtsvx_out
        # info should not be zero and should provide index of illegal value
        assert info > 0, "info should be > 0 for singular matrix"


@pytest.mark.parametrize("dtype", DTYPES*2)
@pytest.mark.parametrize("trans_bool", [False, True])
@pytest.mark.parametrize("fact", ["F", "N"])
def test_gtsvx_error_incompatible_size(dtype, trans_bool, fact):
    seed(42)
    # obtain routine
    gtsvx, gttrf = get_lapack_funcs(('gtsvx', 'gttrf'), dtype=dtype)
    # Generate random tridiagonal matrix A
    n = 10
    dl = generate_random_dtype_array((n-1,), dtype=dtype)
    d = generate_random_dtype_array((n,), dtype=dtype)
    du = generate_random_dtype_array((n-1,), dtype=dtype)
    A = np.diag(dl, -1) + np.diag(d) + np.diag(du, 1)
    # generate random solution x
    x = generate_random_dtype_array((n, 2), dtype=dtype)
    # create b from x for equation Ax=b
    trans = "T" if dtype in REAL_DTYPES else "C"
    b = (A.conj().T if trans_bool else A) @ x

    # set these to None if fact = 'N', or the output of gttrf is fact = 'F'
    dlf_, df_, duf_, du2f_, ipiv_, info_ = \
        gttrf(dl, d, du) if fact == 'F' else [None]*6

    if fact == "N":
        assert_raises(ValueError, gtsvx, dl[:-1], d, du, b,
                      fact=fact, trans=trans, dlf=dlf_, df=df_,
                      duf=duf_, du2=du2f_, ipiv=ipiv_)
        assert_raises(ValueError, gtsvx, dl, d[:-1], du, b,
                      fact=fact, trans=trans, dlf=dlf_, df=df_,
                      duf=duf_, du2=du2f_, ipiv=ipiv_)
        assert_raises(ValueError, gtsvx, dl, d, du[:-1], b,
                      fact=fact, trans=trans, dlf=dlf_, df=df_,
                      duf=duf_, du2=du2f_, ipiv=ipiv_)
        assert_raises(Exception, gtsvx, dl, d, du, b[:-1],
                      fact=fact, trans=trans, dlf=dlf_, df=df_,
                      duf=duf_, du2=du2f_, ipiv=ipiv_)
    else:
        assert_raises(ValueError, gtsvx, dl, d, du, b,
                      fact=fact, trans=trans, dlf=dlf_[:-1], df=df_,
                      duf=duf_, du2=du2f_, ipiv=ipiv_)
        assert_raises(ValueError, gtsvx, dl, d, du, b,
                      fact=fact, trans=trans, dlf=dlf_, df=df_[:-1],
                      duf=duf_, du2=du2f_, ipiv=ipiv_)
        assert_raises(ValueError, gtsvx, dl, d, du, b,
                      fact=fact, trans=trans, dlf=dlf_, df=df_,
                      duf=duf_[:-1], du2=du2f_, ipiv=ipiv_)
        assert_raises(ValueError, gtsvx, dl, d, du, b,
                      fact=fact, trans=trans, dlf=dlf_, df=df_,
                      duf=duf_, du2=du2f_[:-1], ipiv=ipiv_)


@pytest.mark.parametrize("du,d,dl,b,x",
                         [(np.array([2.1, -1.0, 1.9, 8.0]),
                           np.array([3.0, 2.3, -5.0, -0.9, 7.1]),
                           np.array([3.4, 3.6, 7.0, -6.0]),
                           np.array([[2.7, 6.6], [-.5, 10.8], [2.6, -3.2],
                                     [.6, -11.2], [2.7, 19.1]]),
                           np.array([[-4, 5], [7, -4], [3, -3], [-4, -2],
                                     [-3, 1]])),
                          (np.array([2 - 1j, 2 + 1j, -1 + 1j, 1 - 1j]),
                           np.array([-1.3 + 1.3j, -1.3 + 1.3j, -1.3 + 3.3j,
                                     -.3 + 4.3j, -3.3 + 1.3j]),
                           np.array([1 - 2j, 1 + 1j, 2 - 3j, 1 + 1j]),
                           np.array([[2.4 - 5j, 2.7 + 6.9j],
                                     [3.4 + 18.2j, -6.9 - 5.3j],
                                     [-14.7 + 9.7j, -6 - .6j],
                                     [31.9 - 7.7j, -3.9 + 9.3j],
                                     [-1 + 1.6j, -3 + 12.2j]]),
                           np.array([[1 + 1j, 2 - 1j], [3 - 1j, 1 + 2j],
                                     [4 + 5j, -1 + 1j], [-1 - 2j, 2 + 1j],
                                     [1 - 1j, 2 - 2j]]))])
def test_gtsvx_NAG(du, d, dl, b, x):
    # Test to ensure wrapper is consistent with NAG Manual Mark 26
    # example problems: real (f07cbf) and complex (f07cpf)
    gtsvx = get_lapack_funcs('gtsvx', dtype=d.dtype)

    gtsvx_out = gtsvx(dl, d, du, b)
    dlf, df, duf, du2f, ipiv, x_soln, rcond, ferr, berr, info = gtsvx_out

    assert_array_almost_equal(x, x_soln)


@pytest.mark.parametrize("dtype,realtype", zip(DTYPES, REAL_DTYPES
                                               + REAL_DTYPES))
@pytest.mark.parametrize("fact,df_de_lambda",
                         [("F",
                           lambda d, e:get_lapack_funcs('pttrf',
                                                        dtype=e.dtype)(d, e)),
                          ("N", lambda d, e: (None, None, None))])
def test_ptsvx(dtype, realtype, fact, df_de_lambda):
    '''
    This tests the ?ptsvx lapack routine wrapper to solve a random system
    Ax = b for all dtypes and input variations. Tests for: unmodified
    input parameters, fact options, incompatible matrix shapes raise an error,
    and singular matrices return info of illegal value.
    '''
    seed(42)
    # set test tolerance appropriate for dtype
    atol = 100 * np.finfo(dtype).eps
    ptsvx = get_lapack_funcs('ptsvx', dtype=dtype)
    n = 5
    # create diagonals according to size and dtype
    d = generate_random_dtype_array((n,), realtype) + 4
    e = generate_random_dtype_array((n-1,), dtype)
    A = np.diag(d) + np.diag(e, -1) + np.diag(np.conj(e), 1)
    x_soln = generate_random_dtype_array((n, 2), dtype=dtype)
    b = A @ x_soln

    # use lambda to determine what df, ef are
    df, ef, info = df_de_lambda(d, e)

    # create copy to later test that they are unmodified
    diag_cpy = [d.copy(), e.copy(), b.copy()]

    # solve using routine
    df, ef, x, rcond, ferr, berr, info = ptsvx(d, e, b, fact=fact,
                                               df=df, ef=ef)
    # d, e, and b should be unmodified
    assert_array_equal(d, diag_cpy[0])
    assert_array_equal(e, diag_cpy[1])
    assert_array_equal(b, diag_cpy[2])
    assert_(info == 0, "info should be 0 but is {}.".format(info))
    assert_array_almost_equal(x_soln, x)

    # test that the factors from ptsvx can be recombined to make A
    L = np.diag(ef, -1) + np.diag(np.ones(n))
    D = np.diag(df)
    assert_allclose(A, L@D@(np.conj(L).T), atol=atol)

    # assert that the outputs are of correct type or shape
    # rcond should be a scalar
    assert not hasattr(rcond, "__len__"), \
        "rcond should be scalar but is {}".format(rcond)
    # ferr should be length of # of cols in x
    assert_(ferr.shape == (2,), "ferr.shape is {} but shoud be ({},)"
            .format(ferr.shape, x_soln.shape[1]))
    # berr should be length of # of cols in x
    assert_(berr.shape == (2,), "berr.shape is {} but shoud be ({},)"
            .format(berr.shape, x_soln.shape[1]))

@pytest.mark.parametrize("dtype,realtype", zip(DTYPES, REAL_DTYPES
                                               + REAL_DTYPES))
@pytest.mark.parametrize("fact,df_de_lambda",
                         [("F",
                           lambda d, e:get_lapack_funcs('pttrf',
                                                        dtype=e.dtype)(d, e)),
                          ("N", lambda d, e: (None, None, None))])
def test_ptsvx_error_raise_errors(dtype, realtype, fact, df_de_lambda):
    seed(42)
    ptsvx = get_lapack_funcs('ptsvx', dtype=dtype)
    n = 5
    # create diagonals according to size and dtype
    d = generate_random_dtype_array((n,), realtype) + 4
    e = generate_random_dtype_array((n-1,), dtype)
    A = np.diag(d) + np.diag(e, -1) + np.diag(np.conj(e), 1)
    x_soln = generate_random_dtype_array((n, 2), dtype=dtype)
    b = A @ x_soln

    # use lambda to determine what df, ef are
    df, ef, info = df_de_lambda(d, e)

    # test with malformatted array sizes
    assert_raises(ValueError, ptsvx, d[:-1], e, b, fact=fact, df=df, ef=ef)
    assert_raises(ValueError, ptsvx, d, e[:-1], b, fact=fact, df=df, ef=ef)
    assert_raises(Exception, ptsvx, d, e, b[:-1], fact=fact, df=df, ef=ef)


@pytest.mark.parametrize("dtype,realtype", zip(DTYPES, REAL_DTYPES
                                               + REAL_DTYPES))
@pytest.mark.parametrize("fact,df_de_lambda",
                         [("F",
                           lambda d, e:get_lapack_funcs('pttrf',
                                                        dtype=e.dtype)(d, e)),
                          ("N", lambda d, e: (None, None, None))])
def test_ptsvx_non_SPD_singular(dtype, realtype, fact, df_de_lambda):
    seed(42)
    ptsvx = get_lapack_funcs('ptsvx', dtype=dtype)
    n = 5
    # create diagonals according to size and dtype
    d = generate_random_dtype_array((n,), realtype) + 4
    e = generate_random_dtype_array((n-1,), dtype)
    A = np.diag(d) + np.diag(e, -1) + np.diag(np.conj(e), 1)
    x_soln = generate_random_dtype_array((n, 2), dtype=dtype)
    b = A @ x_soln

    # use lambda to determine what df, ef are
    df, ef, info = df_de_lambda(d, e)

    if fact == "N":
        d[3] = 0
        # obtain new df, ef
        df, ef, info = df_de_lambda(d, e)
        # solve using routine
        df, ef, x, rcond, ferr, berr, info = ptsvx(d, e, b)
        # test for the singular matrix.
        assert info > 0 and info <= n

        # non SPD matrix
        d = generate_random_dtype_array((n,), realtype)
        df, ef, x, rcond, ferr, berr, info = ptsvx(d, e, b)
        assert info > 0 and info <= n
    else:
        # assuming that someone is using a singular factorization
        df, ef, info = df_de_lambda(d, e)
        df[0] = 0
        ef[0] = 0
        df, ef, x, rcond, ferr, berr, info = ptsvx(d, e, b, fact=fact,
                                                   df=df, ef=ef)
        assert info > 0


@pytest.mark.parametrize('d,e,b,x',
                         [(np.array([4, 10, 29, 25, 5]),
                           np.array([-2, -6, 15, 8]),
                           np.array([[6, 10], [9, 4], [2, 9], [14, 65],
                                     [7, 23]]),
                           np.array([[2.5, 2], [2, -1], [1, -3],
                                     [-1, 6], [3, -5]])),
                          (np.array([16, 41, 46, 21]),
                           np.array([16 + 16j, 18 - 9j, 1 - 4j]),
                           np.array([[64 + 16j, -16 - 32j],
                                     [93 + 62j, 61 - 66j],
                                     [78 - 80j, 71 - 74j],
                                     [14 - 27j, 35 + 15j]]),
                           np.array([[2 + 1j, -3 - 2j],
                                     [1 + 1j, 1 + 1j],
                                     [1 - 2j, 1 - 2j],
                                     [1 - 1j, 2 + 1j]]))])
def test_ptsvx_NAG(d, e, b, x):
    # test to assure that wrapper is consistent with NAG Manual Mark 26
    # example problemss: f07jbf, f07jpf
    # (Links expire, so please search for "NAG Library Manual Mark 26" online)

    # obtain routine with correct type based on e.dtype
    ptsvx = get_lapack_funcs('ptsvx', dtype=e.dtype)
    # solve using routine
    df, ef, x_ptsvx, rcond, ferr, berr, info = ptsvx(d, e, b)
    # determine ptsvx's solution and x are the same.
    assert_array_almost_equal(x, x_ptsvx)


@pytest.mark.parametrize('lower', [False, True])
@pytest.mark.parametrize('dtype', DTYPES)
def test_pptrs_pptri_pptrf_ppsv_ppcon(dtype, lower):
    seed(1234)
    atol = np.finfo(dtype).eps*100
    # Manual conversion to/from packed format is feasible here.
    n, nrhs = 10, 4
    a = generate_random_dtype_array([n, n], dtype=dtype)
    b = generate_random_dtype_array([n, nrhs], dtype=dtype)

    a = a.conj().T + a + np.eye(n, dtype=dtype) * dtype(5.)
    if lower:
        inds = ([x for y in range(n) for x in range(y, n)],
                [y for y in range(n) for x in range(y, n)])
    else:
        inds = ([x for y in range(1, n+1) for x in range(y)],
                [y-1 for y in range(1, n+1) for x in range(y)])
    ap = a[inds]
    ppsv, pptrf, pptrs, pptri, ppcon = get_lapack_funcs(
        ('ppsv', 'pptrf', 'pptrs', 'pptri', 'ppcon'),
        dtype=dtype,
        ilp64="preferred")

    ul, info = pptrf(n, ap, lower=lower)
    assert_equal(info, 0)
    aul = cholesky(a, lower=lower)[inds]
    assert_allclose(ul, aul, rtol=0, atol=atol)

    uli, info = pptri(n, ul, lower=lower)
    assert_equal(info, 0)
    auli = inv(a)[inds]
    assert_allclose(uli, auli, rtol=0, atol=atol)

    x, info = pptrs(n, ul, b, lower=lower)
    assert_equal(info, 0)
    bx = solve(a, b)
    assert_allclose(x, bx, rtol=0, atol=atol)

    xv, info = ppsv(n, ap, b, lower=lower)
    assert_equal(info, 0)
    assert_allclose)Y~*òø-ƒlæ0= †zK^ƒêxEÚÎÍÀÛh3L SAâeêF(¿câFiaä¡tî·ÈÁ5¤¨q$Då-:g0é!ùBÁİ`†;.^-ªùL5[nÂ¤   IïGaOn,qÍd#VEÁ2v½Şuv»	ªäb$HƒÃÈ\ÌN­i_ÅL¨—x‚[®0!	Ì{4¢óèé#ñİ®pÅâN %wÆeöF¨LÂîrÑ{IÉ°ì‘c_Nç.jÕ iÿƒmÓd‡Óã o)Ù…£‹ÀsìÜlñ{`usvú-[(ögËÈ6`HšfÛ;44ñP§e!d^L£GJ,¸x*ÆŒtÒ³pO6g× óq·#X!¢,òSËºz
èE!Mò­å"ÄØR®
 :ÆGlù¸…5¸èsüWp­Å²ÔŸça¸ÛQØ’7S$–1ì4€1°ƒq*tA”Ÿ/o~²0hWÁsr¡÷gíİlÔØ”ağ·hyãDÅ{ê~..XÕe“ÁH—[ÃÉˆFĞ• ™yÃÃÖå¹ñåu=°6O'‚˜…ä"?U)_á¾©Qqùú|¥jÎ‹İABVqlœGvqKå‰‚NH¡P!}Cæ«©¡BÆÁRX;Ë"cä¤ZºAÍkZÔùÿö(†dù·LÀìpßGqÜĞ@uğĞÓñî¼ŠÇ:‚KÁ‘`¥÷ l<9µ`±Kú†8Á$Hy¨f˜¼{ `d²UFk€;]@ÍrXFQQ vSú+”*oôúæQJÅ¿bß[òå#5£K"¨ü`cğôiÓÃF(tDR(fôO¥Cz)÷˜å(€2;ÑïàæÁ»_êİ^˜»áèPÄ³jå x“ô4?‘ë(ëS5geÃÕ$ö(9İ ¬Ì4äcè£Qay-ì‘k1Èu>:
ò·İl{’Ó6lÈÖ‡«
Y(`«‰òÇ`u¼†'£/#³DuHLw0GúÃ7y¨n™‹®@Ë(F0fökp<?-&@rx>µªnæ\UÑxĞ¹ú" 
Œ%æJQ#%bxà9ÆjNãQ£Œb›!ò^58K²@{©±]A¬u36oa?Ï|µQg<¦¦PpLµğôécÃq??.~üÔhÕâ,¤OùĞş-?@^»5úe-ãÿ‚@9Täl¼7˜)Î¼:^E˜”(;imĞ ÎzgëbY:ßÇŸú‘¡Ø®ŞieOôĞT(¬v4Ãr4¬Z…vîÅ¼YXÄ|a"”! Àwâñ·bms>`O$¬Ö» 4úK©j£È.‹BÚBá»ÁtrÍLµ/¶§Éæ­a;9Rzc )B’ëçH^5ågÇCŠPºFn€Ñ¤l%^-|3ÖkÙÛZŠews>m¿:LxøÀüÿ­<Dá¬÷)7b%Ú r‹âYCM¿&°.dŒDCª`Eq¸¼Ÿ5…ŠÚ$ ],¹	9›Kl2¢²hîq¶ĞjÆV*¥Qì<Lu™aj€¹ëbTì@Xx!Jbo#_Öe×ÖïCu[xˆ+¬ÚB%E$K`£ê tÒÂªng(kûÅ({¢Ş…5Şc|wÆl0j¸ìw|D.UçfÒsçVy˜’å2è)ª1Éiûeue{ÀÆùíEö0- -¼â~”ªewÀfB5©äŒ­Ç{/r{Z&ç6N×m¨ü.6¬m³^¢;î^˜ñm(ì¶Ÿ‘Ò‡ ä3móÀ FnŞh!Dİ‚Lô<q-rø2¾6ã9ëLˆ[nbìò¡ ‹
ñxå
æj¶]æPŞ%¯<((Š	øÊâ‡\õC¾'åË Õ’ê Sí¬p4/@ª2µ-õóşo‹.AA®Ò“Qù6{ƒ€DL$%vÖ¨[,¥\€‰EETH§(®:u!•sêNñNÉfsHNn¾²¹§y£(å¦cÓõş´Smx€SJÆw-úy;t(`ºQ¡ŸäeÃñ#·Ó,."qˆë0^^H_bê<t®®?ä’mÉ