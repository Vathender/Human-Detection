# -*- coding: utf-8 -*-
''' Nose test generators

Need function load / save / roundtrip tests

'''
import os
from collections import OrderedDict
from os.path import join as pjoin, dirname
from glob import glob
from io import BytesIO
from tempfile import mkdtemp

import warnings
import shutil
import gzip

from numpy.testing import (assert_array_equal, assert_array_almost_equal,
                           assert_equal, assert_)
from pytest import raises as assert_raises

import numpy as np
from numpy import array
import scipy.sparse as SP

import scipy.io.matlab.byteordercodes as boc
from scipy.io.matlab.miobase import matdims, MatWriteError, MatReadError
from scipy.io.matlab.mio import (mat_reader_factory, loadmat, savemat, whosmat)
from scipy.io.matlab.mio5 import (MatlabObject, MatFile5Writer, MatFile5Reader,
                                  MatlabFunction, varmats_from_mat,
                                  to_writeable, EmptyStructMarker)
from scipy.io.matlab import mio5_params as mio5p

test_data_path = pjoin(dirname(__file__), 'data')


def mlarr(*args, **kwargs):
    """Convenience function to return matlab-compatible 2-D array."""
    arr = np.array(*args, **kwargs)
    arr.shape = matdims(arr)
    return arr


# Define cases to test
theta = np.pi/4*np.arange(9,dtype=float).reshape(1,9)
case_table4 = [
    {'name': 'double',
     'classes': {'testdouble': 'double'},
     'expected': {'testdouble': theta}
     }]
case_table4.append(
    {'name': 'string',
     'classes': {'teststring': 'char'},
     'expected': {'teststring':
                  array(['"Do nine men interpret?" "Nine men," I nod.'])}
     })
case_table4.append(
    {'name': 'complex',
     'classes': {'testcomplex': 'double'},
     'expected': {'testcomplex': np.cos(theta) + 1j*np.sin(theta)}
     })
A = np.zeros((3,5))
A[0] = list(range(1,6))
A[:,0] = list(range(1,4))
case_table4.append(
    {'name': 'matrix',
     'classes': {'testmatrix': 'double'},
     'expected': {'testmatrix': A},
     })
case_table4.append(
    {'name': 'sparse',
     'classes': {'testsparse': 'sparse'},
     'expected': {'testsparse': SP.coo_matrix(A)},
     })
B = A.astype(complex)
B[0,0] += 1j
case_table4.append(
    {'name': 'sparsecomplex',
     'classes': {'testsparsecomplex': 'sparse'},
     'expected': {'testsparsecomplex': SP.coo_matrix(B)},
     })
case_table4.append(
    {'name': 'multi',
     'classes': {'theta': 'double', 'a': 'double'},
     'expected': {'theta': theta, 'a': A},
     })
case_table4.append(
    {'name': 'minus',
     'classes': {'testminus': 'double'},
     'expected': {'testminus': mlarr(-1)},
     })
case_table4.append(
    {'name': 'onechar',
     'classes': {'testonechar': 'char'},
     'expected': {'testonechar': array(['r'])},
     })
# Cell arrays stored as object arrays
CA = mlarr((  # tuple for object array creation
        [],
        mlarr([1]),
        mlarr([[1,2]]),
        mlarr([[1,2,3]])), dtype=object).reshape(1,-1)
CA[0,0] = array(
    ['This cell contains this string and 3 arrays of increasing length'])
case_table5 = [
    {'name': 'cell',
     'classes': {'testcell': 'cell'},
     'expected': {'testcell': CA}}]
CAE = mlarr((  # tuple for object array creation
    mlarr(1),
    mlarr(2),
    mlarr([]),
    mlarr([]),
    mlarr(3)), dtype=object).reshape(1,-1)
objarr = np.empty((1,1),dtype=object)
objarr[0,0] = mlarr(1)
case_table5.append(
    {'name': 'scalarcell',
     'classes': {'testscalarcell': 'cell'},
     'expected': {'testscalarcell': objarr}
     })
case_table5.append(
    {'name': 'emptycell',
     'classes': {'testemptycell': 'cell'},
     'expected': {'testemptycell': CAE}})
case_table5.append(
    {'name': 'stringarray',
     'classes': {'teststringarray': 'char'},
     'expected': {'teststringarray': array(
    ['one  ', 'two  ', 'three'])},
     })
case_table5.append(
    {'name': '3dmatrix',
     'classes': {'test3dmatrix': 'double'},
     'expected': {
    'test3dmatrix': np.transpose(np.reshape(list(range(1,25)), (4,3,2)))}
     })
st_sub_arr = array([np.sqrt(2),np.exp(1),np.pi]).reshape(1,3)
dtype = [(n, object) for n in ['stringfield', 'doublefield', 'complexfield']]
st1 = np.zeros((1,1), dtype)
st1['stringfield'][0,0] = array(['Rats live on no evil star.'])
st1['doublefield'][0,0] = st_sub_arr
st1['complexfield'][0,0] = st_sub_arr * (1 + 1j)
case_table5.append(
    {'name': 'struct',
     'classes': {'teststruct': 'struct'},
     'expected': {'teststruct': st1}
     })
CN = np.zeros((1,2), dtype=object)
CN[0,0] = mlarr(1)
CN[0,1] = np.zeros((1,3), dtype=object)
CN[0,1][0,0] = mlarr(2, dtype=np.uint8)
CN[0,1][0,1] = mlarr([[3]], dtype=np.uint8)
CN[0,1][0,2] = np.zeros((1,2), dtype=object)
CN[0,1][0,2][0,0] = mlarr(4, dtype=np.uint8)
CN[0,1][0,2][0,1] = mlarr(5, dtype=np.uint8)
case_table5.append(
    {'name': 'cellnest',
     'classes': {'testcellnest': 'cell'},
     'expected': {'testcellnest': CN},
     })
st2 = np.empty((1,1), dtype=[(n, object) for n in ['one', 'two']])
st2[0,0]['one'] = mlarr(1)
st2[0,0]['two'] = np.empty((1,1), dtype=[('three', object)])
st2[0,0]['two'][0,0]['three'] = array(['number 3'])
case_table5.append(
    {'name': 'structnest',
     'classes': {'teststructnest': 'struct'},
     'expected': {'teststructnest': st2}
     })
a = np.empty((1,2), dtype=[(n, object) for n in ['one', 'two']])
a[0,0]['one'] = mlarr(1)
a[0,0]['two'] = mlarr(2)
a[0,1]['one'] = array(['number 1'])
a[0,1]['two'] = array(['number 2'])
case_table5.append(
    {'name': 'structarr',
     'classes': {'teststructarr': 'struct'},
     'expected': {'teststructarr': a}
     })
ODT = np.dtype([(n, object) for n in
                 ['expr', 'inputExpr', 'args',
                  'isEmpty', 'numArgs', 'version']])
MO = MatlabObject(np.zeros((1,1), dtype=ODT), 'inline')
m0 = MO[0,0]
m0['expr'] = array(['x'])
m0['inputExpr'] = array([' x = INLINE_INPUTS_{1};'])
m0['args'] = array(['x'])
m0['isEmpty'] = mlarr(0)
m0['numArgs'] = mlarr(1)
m0['version'] = mlarr(1)
case_table5.append(
    {'name': 'object',
     'classes': {'testobject': 'object'},
     'expected': {'testobject': MO}
     })
fp_u_str = open(pjoin(test_data_path, 'japanese_utf8.txt'), 'rb')
u_str = fp_u_str.read().decode('utf-8')
fp_u_str.close()
case_table5.append(
    {'name': 'unicode',
     'classes': {'testunicode': 'char'},
    'expected': {'testunicode': array([u_str])}
     })
case_table5.append(
    {'name': 'sparse',
     'classes': {'testsparse': 'sparse'},
     'expected': {'testsparse': SP.coo_matrix(A)},
     })
case_table5.append(
    {'name': 'sparsecomplex',
     'classes': {'testsparsecomplex': 'sparse'},
     'expected': {'testsparsecomplex': SP.coo_matrix(B)},
     })
case_table5.append(
    {'name': 'bool',
     'classes': {'testbools': 'logical'},
     'expected': {'testbools':
                  array([[True], [False]])},
     })

case_table5_rt = case_table5[:]
# Inline functions can't be concatenated in matlab, so RT only
case_table5_rt.append(
    {'name': 'objectarray',
     'classes': {'testobjectarray': 'object'},
     'expected': {'testobjectarray': np.repeat(MO, 2).reshape(1,2)}})


def types_compatible(var1, var2):
    """Check if types are same or compatible.

    0-D numpy scalars are compatible with bare python scalars.
    """
    type1 = type(var1)
    type2 = type(var2)
    if type1 is type2:
        return True
    if type1 is np.ndarray and var1.shape == ():
        return type(var1.item()) is type2
    if type2 is np.ndarray and var2.shape == ():
        return type(var2.item()) is type1
    return False


def _check_level(label, expected, actual):
    """ Check one level of a potentially nested array """
    if SP.issparse(expected):  # allow different types of sparse matrices
        assert_(SP.issparse(actual))
        assert_array_almost_equal(actual.todense(),
                                  expected.todense(),
                                  err_msg=label,
                                  decimal=5)
        return
    # Check types are as expected
    assert_(types_compatible(expected, actual),
            "Expected type %s, got %s at %s" %
            (type(expected), type(actual), label))
    # A field in a record array may not be an ndarray
    # A scalar from a record array will be type np.void
    if not isinstance(expected,
                      (np.void, np.ndarray, MatlabObject)):
        assert_equal(expected, actual)
        return
    # This is an ndarray-like thing
    assert_(expected.shape == actual.shape,
            msg='Expected shape %s, got %s at %s' % (expected.shape,
                                                     actual.shape,
                                                     label))
    ex_dtype = expected.dtype
    if ex_dtype.hasobject:  # array of objects
        if isinstance(expected, MatlabObject):
            assert_equal(expected.classname, actual.classname)
        for i, ev in enumerate(expected):
            level_label = "%s, [%d], " % (label, i)
            _check_level(level_label, ev, actual[i])
        return
    if ex_dtype.fields:  # probably recarray
        for fn in ex_dtype.fields:
            level_label = "%s, field %s, " % (label, fn)
            _check_level(level_label,
                         expected[fn], actual[fn])
        return
    if ex_dtype.type in (str,  # string or bool
                         np.unicode_,
                         np.bool_):
        assert_equal(actual, expected, err_msg=label)
        return
    # Something numeric
    assert_array_almost_equal(actual, expected, err_msg=label, decimal=5)


def _load_check_case(name, files, case):
    for file_name in files:
        matdict = loadmat(file_name, struct_as_record=True)
        label = "test %s; file %s" % (name, file_name)
        for k, expected in case.items():
            k_label = "%s, variable %s" % (label, k)
            assert_(k in matdict, "Missing key at %s" % k_label)
            _check_level(k_label, expected, matdict[k])


def _whos_check_case(name, files, case, classes):
    for file_name in files:
        label = "test %s; file %s" % (name, file_name)

        whos = whosmat(file_name)

        expected_whos = [
            (k, expected.shape, classes[k]) for k, expected in case.items()]

        whos.sort()
        expected_whos.sort()
        assert_equal(whos, expected_whos,
                     "%s: %r != %r" % (label, whos, expected_whos)
                     )


# Round trip tests
def _rt_check_case(name, expected, format):
    mat_stream = BytesIO()
    savemat(mat_stream, expected, format=format)
    mat_stream.seek(0)
    _load_check_case(name, [mat_stream], expected)


# generator for load tests
def test_load():
    for case in case_table4 + case_table5:
        name = case['name']
        expected = case['expected']
        filt = pjoin(test_data_path, 'test%s_*.mat' % name)
        files = glob(filt)
        assert_(len(files) > 0,
                "No files for test %s using filter %s" % (name, filt))
        _load_check_case(name, files, expected)


# generator for whos tests
def test_whos():
    for case in case_table4 + case_table5:
        name = case['name']
        expected = case['expected']
        classes = case['classes']
        filt = pjoin(test_data_path, 'test%s_*.mat' % name)
        files = glob(filt)
        assert_(len(files) > 0,
                "No files for test %s using filter %s" % (name, filt))
        _whos_check_case(name, files, expected, classes)


# generator for round trip tests
def test_round_trip():
    for case in case_table4 + case_table5_rt:
        case_table4_names = [case['name'] for case in case_table4]
        name = case['name'] + '_round_trip'
        expected = case['expected']
        for format in (['4', '5'] if case['name'] in case_table4_names else ['5']):
            _rt_check_case(name, expected, format)


def test_gzip_simple():
    xdense = np.zeros((20,20))
    xdense[2,3] = 2.3
    xdense[4,5] = 4.5
    x = SP.csc_matrix(xdense)

    name = 'gzip_test'
    expected = {'x':x}
    format = '4'

    tmpdir = mkdtemp()
    try:
        fname = pjoin(tmpdir,name)
        mat_stream = gzip.open(fname, mode='wb')
        savemat(mat_stream, expected, format=format)
        mat_stream.close()

        mat_stream = gzip.open(fname, mode='rb')
        actual = loadmat(mat_stream, struct_as_record=True)
        mat_stream.close()
    finally:
        shutil.rmtree(tmpdir)

    assert_array_almost_equal(actual['x'].todense(),
                              expected['x'].todense(),
                              err_msg=repr(actual))


def test_multiple_open():
    # Ticket #1039, on Windows: check that files are not left open
    tmpdir = mkdtemp()
    try:
        x = dict(x=np.zeros((2, 2)))

        fname = pjoin(tmpdir, "a.mat")

        # Check that file is not left open
        savemat(fname, x)
        os.unlink(fname)
        savemat(fname, x)
        loadmat(fname)
        os.unlink(fname)

        # Check that stream is left open
        f = open(fname, 'wb')
        savemat(f, x)
        f.seek(0)
        f.close()

        f = open(fname, 'rb')
        loadmat(f)
        f.seek(0)
        f.close()
    finally:
        shutil.rmtree(tmpdir)


def test_mat73():
    # Check any hdf5 files raise an error
    filenames = glob(
        pjoin(test_data_path, 'testhdf5*.mat'))
    assert_(len(filenames) > 0)
    for filename in filenames:
        fp = open(filename, 'rb')
        assert_raises(NotImplementedError,
                      loadmat,
                      fp,
                      struct_as_record=True)
        fp.close()


def test_warnings():
    # This test is an echo of the previous behavior, which was to raise a
    # warning if the user triggered a search for mat files on the Python system
    # path. We can remove the test in the next version after upcoming (0.13).
    fname = pjoin(test_data_path, 'testdouble_7.1_GLNX86.mat')
    with warnings.catch_warnings():
        warnings.simplefilter('error')
        # This should not generate a warning
        loadmat(fname, struct_as_record=True)
        # This neither
        loadmat(fname, struct_as_record=False)


def test_regression_653():
    # Saving a dictionary with only invalid keys used to raise an error. Now we
    # save this as an empty struct in matlab space.
    sio = BytesIO()
    savemat(sio, {'d':{1:2}}, format='5')
    back = loadmat(sio)['d']
    # Check we got an empty struct equivalent
    assert_equal(back.shape, (1,1))
    assert_equal(back.dtype, np.dtype(object))
    assert_(back[0,0] is None)


def test_structname_len():
    # Test limit for length of field names in structs
    lim = 31
    fldname = 'a' * lim
    st1 = np.zeros((1,1), dtype=[(fldname, object)])
    savemat(BytesIO(), {'longstruct': st1}, format='5')
    fldname = 'a' * (lim+1)
    st1 = np.zeros((1,1), dtype=[(fldname, object)])
    assert_raises(ValueError, savemat, BytesIO(),
                  {'longstruct': st1}, format='5')


def test_4_and_long_field_names_incompatible():
    # Long field names option not supported in 4
    my_struct = np.zeros((1,1),dtype=[('my_fieldname',object)])
    assert_raises(ValueError, savemat, BytesIO(),
                  {'my_struct':my_struct}, format='4', long_field_names=True)


def test_long_field_names():
    # Test limit for length of field names in structs
    lim = 63
    fldname = 'a' * lim
    st1 = np.zeros((1,1), dtype=[(fldname, object)])
    savemat(BytesIO(), {'longstruct': st1}, format='5',long_field_names=True)
    fldname = 'a' * (lim+1)
    st1 = np.zeros((1,1), dtype=[(fldname, object)])
    assert_raises(ValueError, savemat, BytesIO(),
                  {'longstruct': st1}, format='5',long_field_names=True)


def test_long_field_names_in_struct():
    # Regression test - long_field_names was erased if you passed a struct
    # within a struct
    lim = 63
    fldname = 'a' * lim
    cell = np.ndarray((1,2),dtype=object)
    st1 = np.zeros((1,1), dtype=[(fldname, object)])
    cell[0,0] = st1
    cell[0,1] = st1
    savemat(BytesIO(), {'longstruct': cell}, format='5',long_field_names=True)
    #
    # Check to make sure it fails with long field names off
    #
    assert_raises(ValueError, savemat, BytesIO(),
                  {'longstruct': cell}, format='5', long_field_names=False)


def test_cell_with_one_thing_in_it():
    # Regression tesôH(m©æì9ÚqâUf=£1ÚSÙÌQbÁÍ¸‚STzT.Ë>Ì(ø¾YN…O,(ê¨©äÑ=ğuÜ{¿z (È~¡|… wÕy2 ’íaâåcdNkÎcÁ©şxá<(CpE%'š:7hê0­od”O
$’ƒ*²ß S!ëüÌz
¯©{ä éĞ,ÉIŒ0ÊD°V10íróçbİ–%à»pOH’g¬'ûƒO l2a½ñËtU_!gÈYN##•¡^lK Ù÷Óv×Òòí-º9°!·ÇP@?Kt?"Ë!z¾*AY¾¥?dáYæé.a­,T™Iu§</HˆÀ„ØaöÛRø¢(ñ ÖcÊçgu„"k‹óï»qe®ü#Bé•Z7êud}¾ÍYÚÓ)­0C~ÚjôµÆÎ—ğn¹ïİ-ë¢H$¯¹ +hîrÄ|àEf>\äã`jhıpˆ;h=}DæT‰áßEÚà+vğ!ê±&ûBEhòRç„&úÉqğMµ&i_sòõ"®«× ™ÑÏuåmˆ) Àå‘e( ÃØ=}¬Ûd”dÓ¡6¥gg’9Ü5	© bE‹/r(¹ßË”C™ötrd(Şn{|Âï`C÷V»…€g–â(ïVqT£¡e¬&îóÍ7e Q„ğzk‡çÏ¨HÛÕî%:U+Ô31æ4 Ëzz³„ï(1e¯Ğ§¨ª¨É‘Í{˜¯PßËôãÎTúLßP|R<bÑ!PA‡¤ÉP%d0ŠaO)RV_M<Jäå á6€íDèJn_Öb¹¥xFß)@ Ô=dîå©Zl1èæìN:Ñò×Éï ßÇá]7™#õŒ˜³ÚH±I×d^•;da.Ç|SlnòÁj^Ös¶3$qk3Ñt¹I] a€ŠàwÑ~HïT±„Šq:hnñ~-(óÀæ 	Xô6k™ñ¼Àïñ&²‹£â´ªlWöUiuåÀêG5İ^pÆœåDÓ‰Ax0")Í¹/m”ÄR£n<¦}xDNgã¸‚îµ[Yêü1AMs&s§RMQíçˆª4–ÕCtè¢®ASÿ«$o«÷hÙ§mEÀ@ï›äçAïWaiÇÊ0
¥€˜‹4‚ŞÎO`ÏŸc«Rt[êan‰"yª¼!ÑZ
ækâ¼qñqt×ÕYïÊ;&$ëö¾|®Â¤YJùÎ¡T” ZX|~şºuV\ØQÉó<Meó7#S,yt$”ƒG’imÎ)qºJ$‰°6NsÓ4n`CDõå5*q{:s…÷g¡[	ym*–ø`˜E|@êdº#ÚWh ïzğ2áŠ ¹Cú¨qøwQ{K ¸-¨L6Vö²TW» vj§j‘Ì•Óx-y¥ZtùC£FÉ®	k¨"spXRkl÷;N~¶ƒø{œz`âØD¢L`C»ÚcN¤è*ª"ÔVj<kzVm¼h™¨‹#Ÿ-ännĞzŞFÒñâ–:M…°b	hOeB ©cWmqHÊ ŒÆ¼ûr»T.goD³O¼òDü³Ïlg¹q ¯ˆwúD@ §¢Åı!Z­ŠNzAj+ØÅ]U¤ô›€JF¨R-*R£~%én¸Nqy`uLö×fP‘çqYÒã€h©Yüušà&B)ÖÔ€}ñÉF(".ébo¢› ïåA5£¦¬¬Äú4<>tAÕOÁv×4YzqúJÁ(á:ìö_ù±üä”‚eÁ\3öW¢£Bara`vŠc¡	¢OUÌT¾Boe¨æ
9ş;º)ÂE¾ $£h0ïEX¬ m²`ÌTÿIÿ¨iœÏ„wãz¯¸qEíqhÂçû3Pù–ïC!_#‡Cê ä<ù!/l‹Ú¾ÍATÕh5:ŠˆLN2m#8ÕÍxZ‘#‹©@‚uç6<cÈ<DSÜ^bN ]í=vy»œõÍ¥hk¥[ÈÔ ¦( ¹²u|:TŸ#¤üº[++¬%ß4ãÈFpà5=º÷CSÒèw`4+Xh¬$b®3ı|„ÌY;ŒŞ§{¥ÏNÙ7(†ğa±ğ·*Eè ¾äi! ôéÚk;ƒ9Ãİ$‡Yfá6Uü8·$·!ë$€#ï:¢cMb[¥Öá*à(fBË!™¬÷z^;´ÚJp¤/£¦îñi.E$b®SCF!ÍRŒqùT#±œ*†íHjÕâ'.òd”ìq´RÌ:!5k¢Ş$µhpÅcêù‹o¯  h¾#_×! Tú¯¨5¼ñÄÌL"¤@¤b‚fÚ®"l©cm†ïYÆAÆ!zi	q
¼§Ğ L‘—ÉÏ¹œÍ‹a'€dd@r2~:äŸoù5ä`ñR*Pª€4¦ÌĞ‰$†¡HÇé\R`AjyfÂ#Xë¡tÒöÁ¸ÌnçµkHåHO%MBB &);(¦!	Ù>h jp“`óvKhä=ãÅÍlªä´¢™'bï	ä?ş‹¸sÁ!À"’ [ÅXÜìÒ/‚À¸Ny:ü[Pó"¡"w¬eGCmıp|ñµ·m{÷LÛÒ)åı5©¦ÕDÚŠU§"iÛ¡:U7lBë±]á5¡(&pñsÍ<ˆrÂl0â®ïÂLÓ`9‰öÈuÑZÑı(t¹GAlª ²*Z‹(appceı°&ÖQñN#‡c
WŞğpœ¤%*M1ìB(‹'Ã¦"¢9ßÈk‚ ¨d¬2ªàÁR|Ôi^úVe¿Qy÷+ìT–\P„.ûóævö"@plDd*˜…~UÿæLIbò8m2É>¶T–sg m!±–êhà|I¯àIÑğ’b© ¼îPJn«8wk˜úÍ‚ `6Ê)úaLL\Áƒ©Yfwáˆa¢à¨çW·pãè³‹A(¥¥S¯öïÿ")%„ô$if0À¥#ˆ3ämIÄ®ÀzTHo#è©è¦Ç”u¤Ólù–(¤Õ)¤›—aß”¡*rauQ^š¨ÏÙ8ª;BNbÜ'îÛæD÷u’gC-#ì%ëÌ÷›,izBœ6_Õnl;Àcio‡²Q*ä(åò4R@ÄW‹vBsäP-4ôÀûÓğMñóäõ„,*¸oi»ÑDW<_Õ°¼yFM/jgı™@Zåí£_ƒwNYe(>£€§?C,
 ­à«7˜±©ƒ¿ %$mÛUz‰.ıÒ,ÒF]y×­#mÌ³$KÖG˜W˜gXs8ª ~eë³¼2¨s|r&¤î†Ÿ0P?Ì§`H8Ü€Â!"ƒ¢)àû$á6‹°‚eÁo¤VÓVËàzÌ«R1¼¬qD(ğÀ¤&d1Jítw;¥åİ5bJcÅAÛÌ¬Êl€»x+rr&Şõ‰¥"EñFÈgíö]rÂbèG“ï(:õ2ÒR0zÏy+ÍÀkj¿¶à`oeg6ŞeOìKäˆµa<(,ò˜lĞôg@,{=l.¾Ü–Q5íæçN¯kÕv,'$&şi«„¾€$º‰&¤pß$U
 ïè¦`ÉÇÍ4EÕ(xXèÎ]v,
Œ >yxâ#â`vµE°İY3¸lâ·çÅp!JKÁh2LZ(Ò/M‘aFêQ¡z¦=±‘‡agÓg0ÀĞcKØ,¸,şE¼"˜L¨¢ÿÍÙn§öıvØcæ¬€¤ª²yDzó(09ü¬!ÇÅ©OÊq Ü Õ¿&ÆflçNâÈ>ªº(œl~%cõE€QQeÆ e!vôc?1Aš;	¡1	ˆaæOvG_Äã¥ÈæM²QHsÃ§]ÆÇî-]ïÓë|Ñ#H™&}"}ë*šd‡é%sğóã?×  EI­ğ†:áZ1IõôR¤5çY( gğ×<j;´š- »dv«Ëd€x¬¸ë¢i®úÏ>‰;ábclàg»	5ˆ …uÎQl3)³­(œn´DP=¨£$LeC@p?	oü,ÓòÂm7Ğ³Ù&HO$ÉA(XÅi¬²v¬_ğN®«1½çÔ¥p@Õ³®çà0gæ|“d$Y.€$ÉfÛek"‘i4{k ®lY"+»¦ü	èxônª±CşS6~€kçKüê1ğWÊTÎóF3Ù%ÈÀÄy…¦Ùáå»Í,üGØfmï8	]2¢HîûU~Ol ²ZªBJ7dI½ü^wz·d÷h•r•bFU^˜ÊÀğÉoÅË/ÀPí‚;=®LJIìÔ>Ò)okR<õ5ÄsÃfåi6º,(`Pt£µ³dÆa|E8Dq=1°ÁuÓ„ÎøáSñÆkÒ‚Êş‚0_ıİ‘àx(‡~ˆ5jNLré4ŞXè8˜D™íËüö“l QåYÿAbÅYìl‰ó "h”ÄÙï`±|I}ûLPb9j}ü2Oã©§şš|»‚ú`¼¯vçez@OrĞjâŠ.djĞf||ØTåu-Óèã29İcE"dñ#sVv®In·)"j`8­
A“qÁn&Î5¬˜F %KqxËcDp0Ê®ıdáY2O&¹¨§jXq‚L70˜Èìøg—}0uÕKr²i˜GˆéİÑAZÄà=Œ1Š{’…ĞâÀïFëËê&%EûÉH6*ù’uËÂ":"901Ìi¬9ô,›ÅœY´B“ÄfVèÏóè 8H =¿pL_KòÖ;dáefÀ~#nÛ[ïnÛd¥v°%pE»¯f«`Š,¸š3MÅM„yáBö°bÎè,`¢"™Z3é®DhøMøá~o÷”‡	SCÖx+Ÿ4Y´Šv{Âp5góòmb…p¬_ëÿåì;ñé,äqpÕØÁÊp†;avÿƒ´R.S+'QîåÃT©ÁTÓáZ¸¹DA“x)ıÕã…oöì B ë_®øû,îá^s1=gV?göÕÀcŠô¶	
+sçf 6bá¶Q[Ax[ÔVNŸaSs@¯ˆ èº.#5æ#ÿ™É¬vS¤ïˆ$j¸©‹æÅKÃö´•ÍövNH¼qe…ğjTÎÁ™p/‰LOrûF ÙÒH¥s(ú.nÄÄälØwÿ]£ï‹İ&{¡ÉÏøke#
  ¤"«ë@¯mì¢ÃHYñ‹JO¢*òšÚ7r(U©;nao´ãf®,ïÂW³6(1sù'$-RBoÃQtî\	*º(*³	çjÚà]Ó%îkßd{¬ËR-fûwƒÏauLI}}29†ÎeÈôŞ}
<ãSGgÊ} °`P+I^m¿©e 	‰Ói ®.V¤%()! `€’ÇÛÌ†WùôÄßSr(HD"%¶ñy}€dÅDÅöIİ-ü.`¢£jL&:Vi&ê8ø2£übîêJW!VxG[óqq{-±ÏÍ$ æ_TO€Lm0w„ë‰Í'k¨f—xÏjÖ€ñ¾war}Ü he(ıÂ›)å%ÇY5j(~BÔ#[6ˆÊ ÈRælşÆ‘¯	 W]çT'Caµ“)mkGdi$»,$ê!nH•)G!¦Êá@Ğ6±•ûR4K8mSÏV#Dµµ¢5†åÎîÕ:à>J>Ìaióh)4£@äÔ‹ş^8ğaD, Bv±R¨²$m¢è¸10$ûsCÈ®b;Jeì6òÇå~— ³d\P`ƒJnwÉ„«w)<lOUUlaàÈ"Pj
ˆ»!@íQ‰#VbÑÅö, eš'šjˆ1H2\ßÏã²çüC =BŒtø[1û¹^m¿9ô‘·À’by¤G#Ea¹2ë{ÂÑ
=€³!÷2®s/"v$ÉøïPµ¤vûCAdï
MıH pdÎYmpÒ?ÌAÑ'& ,1GíËl poì&Qdl§&·Mç0²C¸Úü&oµ~õWí{ìYTX“ù—Ô“Š„e 3‹8âÜúÚ00fğ­vR!o»äœƒ½*Y*ù7Ô™Äçd¡LUŒG}- "g:v¸†)d¹‹Ğâ2,„M,Ze¸”ŞOtA‹e²Û‚Êpn:'€`¨aÌo¢Ôêmˆ%àãMae'`½K0¬ÑğİZ¡ì%òúkèÀ|:J°¸úôµXÂfuŒÛ}ú„i`7Qû]#ÒóU†*ìÏ)¼_s/«¢X,€C,é<¨`‰kBD l"ÍétåiBÔostc3X&îmûsJJê†`ô“è2Xòxùn¸Tuo%D³kìç¥Ôxÿö2eK]`crt¡a	(ò íÈŠ=Ô8œnF3x»èîÓDÍá+ç¸]${aÕÚn‡£Ôd\º+31‚)ò ¹~R×*‡xekt`7ÃŒ?¨à(•Mµ}0üÍKÿ^OM«U×% §®AõVoŞ)åN~dÕ_áoí¦ÍĞv÷'(u€5ú,rßä„­ÙÉïùö°N9r€"'—Zm<=W”9Åù²¤ZiÕ,:1a¯0÷|`]‡ûjM%|µwJÿ­wÖSQ²Qõò×(ÿÁÁ\h#Şú$Ø£ÕİöDf7CÇ~gÛqûàx~0Š ß`DÉTà_rİ§É»VM>?Æy©qUJ~à¯§üùa&*Ûø&„è8¶¤yÂ8ØaµòŒ>²xTGÅHÇ5İÍ`k¢jì|ÚC`Å¶¡/«ÁDC·Î¸VGäãxz½÷	¶)µ¹¤©aQ€5‹Å,l©ÂÉ/X@e_H‘AÆ¤è	ÑåÍEíÏd'-µ‚1Š‚ãeo¿T-d`XåwWæIØt¬Ü®2$dThIeãnóêÁeı‰0Ó¶"‰£Q8Ä§šÄ‰Ü™ß"B®'üÖÏè‹#!( {YŒeïK6¢®Îfm7J‚)Š
’Š„`	>ğ\@»NUr>´9 Qµœ	;!ÌÚ¥ğd"ƒI¬Ør§ÁâgfÁ€k‹f0­İ^ŸÈõhË{ …íãt9h¥B§¸,i(_a9‘a+0è3`…£gr_9Éä$ –ÄP÷YönÉÔîIúõõFı>rsqô"Oÿkvà|Èòç`D]Ó±fÙdïûÕ@pteÃCĞ"ˆ,ñpIÛ`Û£fCá"  `v+Óåø~Hy[Ğ"ç÷Pæ]îrø°)~R
Èês¼h\{Êå|­óËğuH'0W|eÎæ¹Ï<"ò¬fC‡÷tXÎseDk|S;ïx·rı ÊráeæçáwFŸ]mêBÜx•¾dò¬ã÷‰…à#~5mxÃ½ò3gä÷oŒfB('’†@uk[¤y"˜%õ}^é2wÑó%
¿záhÉˆ< 	 l¾!H8dçád(eO9ø ëÀÌ™bSM±—`”ŸÅI^¯vÏÆ‘t’qÂÀwtRwÆSü+|L‹ŒMAÍlR)şN}U 8­<4QmgøBõ]FÈHxc(Y|Ì¡è¨IÅÔ j8"„áı©j ™"@‹I»´‹ £ñ0)`6æa ô%€÷è2J	è»ÎRô·&-ÄìiÕm£õ#¼£î#lZæP•¬á'İc¹á_J'iY2RK—°‡Î6¡[Egx£3 Æ— y`k °ñü@İ‹ôü PP³}Ã{=×;F×;ÏH&yÅÔ”†à[¼A¥‘ŒrşW9ë+F‰GQP(bBX˜ ínŒe~³Z]eß49%KœZå¿ ¤ÀÂv%-z`ı3q=+Jâ W(á2AQ/a:¯2ŠÄ ’°DúéfrqcndMs³zñœâŸ»³î(`nb eÒãò/ ò|ì$ª¨ dØ Ûj£_î:Ós¼W¨ìxqe-ò‰(ªg¹ŒöƒI!8çjå{jK*âFA°È2röÓyiÖæaUdHhªÖøª(ÆÍÑF]¥5~,‡Ua	id*Ê2Q.<r÷hJíóÙawj—Op"bAàë¼"Ü%FçÔ\óì™-t1¡Ymğ­¨ß­Ò{šÌEïñ†ªDz5_*Z¸—Æ…0ºÁ²1ñÙp*YèHYóê¹mõhOo2/@uG*(' ƒµ“ô±ë¾İĞ_×‹-ØáäĞäS
·Ó"Õs‰5YÓ+ Š%Ğ7ÀvßûİšÎbƒÿŠ“m{Fl'™.@Ñ¢fª…‘êLiŞ}²J¢#yEK¶=cb!)O
}…4â³ø…¢é/H`ÿgÓA”+ğ.U?ø8ÀxÑëhÏ0nSŠ;–2ùà6›š!x*)«},ˆäåhgÚš>wO  ô%»,‚F&&
à¿fÀm=3) 0 Öz-g?®åÌn¡GÕiN´§Î2TsÂª{†r¢ÿ±±Í”àv5Q°+“– ÕhÆ=äï?/Ûuº@…[º„¡—öoB—Ú‚#{Jä®	MÓ4ˆĞ®ñ§sQ>É-(ñ[¡ğ¯v­d|"eQ`¤hl#‚«ñE+V92êŞæÿ÷zê–íëhA(q-ÜggkŞDşñGEÕ¡+:¡¤£$fÛ"uOÈLĞcÛö¬}ÖÄmó‰’‰t#\¦€ø;/j}i,y3—$kahVÁkP-Ú0‡qnb¾¹cUV0®AáScmY–iğ1o-5‘÷LeöËo„6—xmezÜ	"+q	±Êf6z¦:ËËa7ŸV ø*íòE`ê¤ùÑSí½¸"°fàZù¢ì.~oB±¢kqaFÚF¦°À«a3—ØM‡öê4ø"P|ÿÄyv?vleÕûthpøÙóH&3rh*äx.W3šT”tö'©ONhpö½Ó÷ç">A¢6—¬.ÂqlŞå
`îa¹ƒØè^lº';÷´{Ö|,464ò2ªbÔAz+n€¥•|…~²q:	Ou›îçl÷¨Æ Ésïßèfúeª0;*oB{rìUŠ$™!ÔQeY‰—{Xõêæ|å
hOBq·Ï-(a.&â¯
ù>/=Ù2²ZÈh*IxöíğÆ¡\èvtÕå0åMcf)5k(ğDWG*¡w*·BfùlQ¶j!I$ö`·¸HIlî,'(y¥/1[«oâ Ò?^!¤()êºE`G³3H%ø4ĞCÅí(RA „ƒ"¡!ıÓ¬m3¢uà¢úz¬¦(®²$ˆ	Ëeùu|ğçOâm_UX¡îØM-\O¸¬Vïò†o£|ÅbTÕqİi’C4ôuŠ0ù¡×!”}ÔY’=r@«r.™Z¤qt5ì%ç8Dgñà-ğtQô{ŞÖÔa
3²¥_aq¨!7{@]pªø}­v›a·ße¥#5áçéÒ#¡¾q®Yv`ğj É±s šAƒ8Ì‰*
o	á“`Rfå;í_FğL+£kk«Dıë9|ØÓme@¥pˆ,çàÄtñN‚¬D¿M- €ãõ6ˆ{e#`k¯E€êƒ 
`0Õ‘óá'÷RmŞ<yb/ÿ÷~çzIbelàXãfÊ+¥9š²Zp ÓpÊï~iwaf(pÇÅgdd~dé'PR¦hìF‹Z^åe')°ùø$yêtˆH…5úé‡p û¯g´ ô&Ûğ*ÁW¿KšcYÿø›ù×H Ïi›Qş­ƒ %_xoØí(fhïêš¢ÈÑÕ€)!£"dá£ÁjÓ)eRª- BE@{W‰Ö^uÕYá¨€í}ws)V}/fr%iÁ1ØdæËGdAbvÊ:ŸàepÈ4ˆÎ[øÿ´q-" £:¯ yãÆ2ºZ¨v;?Ã_—Z	=GĞ•0‘ñ	_8|œsã&€ ”$nDd·Æ~‰ğó=æqŠ
¦|!Æ+èa`ÙqS€ÿŞåËÙƒn~ğÔ;`•ºf:ŠK'RC;”!wRS¶­’?gEDH7"ä([ú#Ke”0¤€X•BÈğqN‡
p<lOSYa¢ô{pPù'v²2‹Z~µŞWä²ÛÎu¼#tğ°tpT70‚!:ë1åÄé1
iTw?RÎî~äáF› îû‘V~E#a^é˜õ`Á¼%‚$(ã¸¸EÕ¦ß”Òíƒ<fZ]QLˆ„â2{…êÿ,ÕÊAü·ÛXñU÷2]Ê§LzB¨ö`¡é*E§şW4]UxŞbË2npótâré¶&Ná :i#©Xt /©t{© ¥2êû}7hŠwK|MMíÒÈal ÁkµóÁt[\ ‰gÙß§D!b
¢®1hM®ògK	MbàuÖeõ)á#(›õå´ÇÍ}‰)÷Q°í×:S_6>\}ƒdğ›äaÆ=SZ›u%uK:!3Ó+’*Ó¶ÚÈ!K´cXscH˜u˜]Ğßùp ‘  #{“y]SŒ_B÷»NU1)w/©÷ljÂ-‹IÁsû·ömJ]Õİ=?cğ™bjAk¨¬©o)b,dzëáz¢vú‡ìM/ğvd/Krã7Gisfg”>İlN­edu^*gõ²&_t*ğ½şÄìõ¾aèæ«lõO$ëã¢(y"{2úùO(p,gßw)wrs|OÉx6‘‡ªâ,øCEN8Æ<fx‹Éæ2 Ã|¥õs‘~I· h €ñriiêM¤tçCvêÙf% ìT¦8K'\h¦	,b­0µŠZBÚ4¬±R#õ)ïğ7dlhZméì=hqbU2=á±sS(ÙÌS{Ñ 8‚CTv\
,Z2Ìi¾{ì*hº* ­äá=eµ8{¿›Srm ar¡|Å &‘92.9åøsC |nbzSà©ş,ñ.dckM0&Š üàd¥/tÖL/g—ƒn›ç R-í,MvK¡¥~±Á9ğm-©­0ÃLS°V1q©grójô£e ”"Po×'¨%s¢Å¨ä2q)qÊ´ `géYl³7œ {m¨Z·×y!—Cr', 3tco£ÇpQE*$O2Qq¸: pYó"q?uû@äma`¬$|™YIa‡<9ËøLXkGÙA»Ó,¸#²
|ñu˜|;ªç6tf O3¸î»ae åcøp—87zutu¾ÿRú		­üø*d±ÎO’&´3¯}9ú"œ)¼/é0¡w! pÄütEbtfô³`i,¼ğ;`ı T£ØÁã[ÑA×q+t$èwwqûg¯E@vÄWc:€gúÉpòMµ¯h†0s`±"./»ÎºN1ËuğŒi%9ìå•‹ `+ ÃÑ9un¿b4bÚ³²4cc’9àU(&í `'q-<0h¹ƒ°Cáx2d {nxÁç ƒ`[Vû¥bÈkãF§ e¬†.qa1q€q[k£ß"H_U­*u+öh¦6 ¼¢82ó%O(]m¯@·n«.™€Ùéçp÷ …6'TÎLÖP\Ô¼{‘'¡U…‚¦Ëhj8[!o—1VV.m<ÄÂ¤ 0íì	è¨4BôS`"¥|Ä°)bàvıUdoä¹Z`1ø¶»cÑòÅéç İfåt	óÜh»m`°IÖ f<%±,$u¦F4wS[Dzrc|p·%y3Ä/‘¸IEVq›à~JçT1€ªq;xgñ ra(×àv	q5z‰ø´`?5"°®`	–ëlWõw2}Õÿ9ÁÀc¨˜^|&¶r/…‰aø m²/¹-!Œ`"l>§t``Fn ó<‚a8XªŞ1ƒåsös£QMQå÷£tµÔtè¢Aï) m»ÿ¾Ig§|E @û,šı§'AÇaQaáBÎuåØ«´‚ÜÚf`O3*<tºb""{·¼!Úxgkâüe?`%0ª—
İ\&ïÊ;%më§¾¬$Q#û®‘D’Dz8<^	ü»'3#ØQÉ{dLi­4#8ô%4ÒWctüc)q:ØH$y•ò6N1±4i #„õé/Štú%>{…gg¥[}i4°(ÒD|Pj`n;Ú15(2h ¿9ô"ñ‹‚µQ(¨q¸o3`O Ä¸¥¡N Vâ×ø 'ê£êÏ—Gx{¦Zht1A#ÆIgáeÏ"rMR/nö,_%›ğ{msâñÑ$OAWÿ	qj
ïj:c4^¡j>@ÚblìB˜ªË•cí :^#z"úMVğ÷R–vÍ„5r‰*”*
åb;©KEhuHÊ0†äï;F.){F³@ø²l@¶j> ½ qïˆüplQ¦¢`r¥œŠj	*/¬dW¯ôY¤h°R-*0¦2%áLºîbyauä¶s^ “a'sQZoÁiÉ,|1sˆ&")Ô ×YAG(".h`Ã—keA5Ç,%–(<Æ1ú4,<f‘•Ôvõ¾H{Qzj!$a=œ;ü6Iq©üä”tÍ\ -öAç£RhaqPÿs0f£	¢NW,tŠC*í¨æy½3*)£G.¨[¤&8°èå¢ä‚y¶6ì^õHßª834[Dwaø­=hÕ½Aj gr$Tµ“}E(S«ÂËk d½ı0(LŠºMÄQ}`5. ÀDIN0u!9ÕÎxZ3!‹©BUge|c#tFW´\ª/ ]m}Qw{»œ×U¥i %rÀS ¦
 »Êun8Õ!$Ü*I*µ%s0cÀÆ¡ğ5>õ9J‰RÂèald:|p,1¯2­d„Ly3„³j¡ÏLu5I6ğA·f÷b/`è¯.å9)eõíZi¿ƒ>İ¤Qfñ&Qğ8ı¡â¥|2¢áLC% ioñ¬fâs¡)®3>W?dÚNp%E/¡)*sk.UtjnûaV)‘Ëh8ùc·œ2}Œ4€¯Øhí2a.;D ìföoÜ*!&%!xnó	lpeúk:ùï.Àhİc_r1¤|z§ª1òğÎÅø^e,Dåbj&Ú,(l©sí&g,–;]æaxi)y˜¥vi¥ŸÈÊ8¡1Ëe%dD,ò|vkä/á5ö" s2RÿÀzï‰ğ f7¤)H EARñM`=vd1<«&0còa9Ìoã440Å`OgoÅhSp=?h„pù<l b8Â)şvûH,<ãÕÅbër´"™$rí)êG~şÃÙ[á!ÅkJåaŞ€üÓ®^<ÀºExzıÓaXyR¡"w eg8A8p`µ¿d:úLËĞ¹lå=¤U@3SŠU7&Ìkÿa*uqAê ëe1œ(4t9Ó"L<é3ãl0@Ë®n bÜ_`³€¶Wuzñ½(U\aiªsº!R‹ˆct`^Í!”ğ&ÖSôc§p

WŞ |)¦¡- …r`b¨«âÇgâ=ßhNà”¦Fa6şıç-h4i(uúttiñ\{/dt÷™\\Q.º{<æpÖ6az“$0d¤.	û%`Ar`,96í?4t¶söS‹a)=÷êtìâşJ(á}Uy’.)1¼mTHã¸"k˜Ú/I‚Q!3Ê/ÿÅTLÕĞ-q"eá@,Ë/cæÀüåwytâê³‰[©¥¥W¹àW{
,%¤ô õ"	Èµû’1%iDœDp@P*"í!è¦N9mÓmñÖhöÕo »—áŸ”"‰c@=÷dözªÇİV¼Yo
Bf*ˆ/nÛ'Däı’WC%G#¬ªˆ÷h, ms@”F}Ül,Àb#?72qiä,‚åô=VÂSUöuólğ)6asĞóGá’ó¶äı¬*<{d)…DW8[Õ®ä^cM/›j%ü™LZíé"UR·yex<âQç.O?ãB ­à#?(ñ©‹?!e4ßU¡6ıÃ,ÂfyùÒ¯s-Í3$K”e`ÑˆgX!w8\~cë?üàstd ¦î†1P?LÇ`H	 0ÇÜÅ
3kË"‚9à{"Ã#‹"°ƒgav$<Ó®uJò_H+#·¯¼ƒua&ĞRÌd$!hıpw7¡eßtê
KÁ@ğÜ(úi€£zkzr&Ø÷‰ç#eñNàbÎ–`rÒbÉV1`¨+FôBÙiú/I/do0ê³´ä`ke`	6Î'~_äœ·a|!mÀ|lRøw@lhul<›T–p­âgrK^	kq^¤%˜@Æ¼J(Å>„$º	6äûÿ$QVªø¯ZiçY$Õ”(yğƒœrl*ñ}yxÃaªa6²DÍQ#²tò%¦ÅpAKhYdMZ>r?h0 `RnF©~¯$± …!çe³V5ikƒ*Xô|-¸hŞF¼.\wø#%ÍÙîe”(VR#æ,„ôè³)DfÓ |x]<1Ïß©MÉQ Ì Õ="Ätxı^æÈ¿¢{)<ü|&guGÄ1Ugf`%9tàg'3	ÛH351É#~fK\Fç$ì§mè\Js7]ÂÓo=uş·kt½´£Q2|"n|“UétQpàñx×) Õ	øpó¼ñZ¡zõàPdãÑ-Ï&gŸ,úsÔ²5B;tí>tÅ7tmkâyùúw<{;ïCcMhG9)õà|-k-%|WQ(3"³)¨dTe<¸h 7^eKJ!¿u<,RóÖ¹S7IsÑ2IKXQ(IÅkd¬Òi~=WğL.a0R°Ã^¥xLİ³¯~ª!gæ|3p&]<f&IfË&)"‘i4;©†3lX"n»*¬á•áÔ
ôd« F`¾s?z0iáIúês|oÂTÎñ¨,aàäiå¤ÁÁç£Àe?üGZd}m¸Ør6AïqEx£Mlá °Q(Bn' âl¼®l'8ûdõi«¶rUâU
ˆÂÊq)fÅO«Ä<) ?9®YfRarU:·Ú)_crY<ı·Ğ#ó6åë"~Y,U*,a	¸[²ñlf~_xt0Dq%M1°¡Õs„îxáSqî=Ò Âî‚p[ıÙ±átj
5jÆH¡v&Hà<ŠÌüÌÂúüëü%5	ÇY§  eÙîló%"n”ÄÉo`ò|J}ySTPi qj|ì3gi‡öµ˜|q¿&òi¼ïr÷ms@îrP!ÊŠ>dx&(øÜTõu¸ÆaÈç=sE"uuá³V&tì52i`b½
S“qAev6Â6µiÌVAOapIÚErpï&$Lá]!²mvpì·ZHq†Nƒ·  tæå´u0xQ*{èFˆéK€[Jåì5B:¶¥ÒâÀå"ı_ª'-AøeX2ªZÙ’uhÂ2*!x+0°)ì°ô-¼åœ\±CªD$2èËa'hc¼p4™0sR
b~*~ ¢4ufFv!oÛZíNûdõf±%$±G;¬g«Â©$µ:sMß„HáTí±3h(^i<`¢0™y¶Ú-Hx(-x¡=+&Õ	rE²tQk_x°IÖ~ÀR%aóq#ˆmcólXê¼uî!(<©(àp eØIÊp†;ab¡´J.# P"¡‚Ô¥ t›aRø4uÏCY!ÿõãtÏ¦± B(ê{.‘ø¶$î‰Ã]y 14mTµwâÑÀcˆHŸ(1$3ÏfÄrâå%AgkÑÔ.½ s @í 74`,.3%ç*¿©š ÉªsrGP-ìÜ$iğ©‰Ç…Këæ¡•Íf6Î Xğsa`	(5„Îå90/MLO²ú$àˆÔ“¤C < ë®nÄÌ0u~Œwo]£ïÃõfûa™)ù!|Q'è!p&«êB§7OW Di×KPC‚*ğšZ7ri]±;ngï”ÀvY${àU£¶:3UÓ}e$uRa¯Bé@~Œ&²­F °'NÛ@9ù%"kÄ{¬/mâëw/#m`uM9I5´8:„Ogˆórm+¼ãS_½à]á°!P
) ~h˜?©mö}‰Ói¤7 W$%)¯!x‚´GL„Tİ¸xÏS2(XD@‡¶û8}€5áDáv©ü!´/`†!êX&zVefj8p¾¦|bîº &aQA!± y*- Ï©% ÛĞkLj8w€ë°Ë/k· f•xTJˆ^ 3ñşçpZw;4pmÀ5´ıB‰	çbgX4:,<F®Ô3r6€¤èPæZlîÆQ§	 _i¥5vaõ›(ı#G$h!?l¯fI)c±>.‹åHĞ2‘»R$øl‚&"„05 'åÎnœ[ğ?k<ÄqbÑw!)4ƒ@õ„‹¼N(ğ`$h.R~;µZ¼m¢j{A9!»tCì‚ïê;{a¯=xÆå!v™¦‹hLtàÓB{=”»s¿tlePÕdaà)…i2@jKc£oDíp!aöGö,!e»šhˆ1H2iíïà;çéKBEé~¸Ú!ù¼^o¿0ÙW‘§À‚r9#raù3<}rÚÑ	mBUs!w.ª#ï"q%‰Ğÿ”¥ärùcdd*Í)@!p3d&g0Ò}ÜEÅgdÓ-eGéÈUm¡ğl¤tÓdl&&·ÿ^c°÷C²H½&t,µ|u7uzx	TØÓÛÜ}ŠÄels„8ªØşÃ00r0(ß#e»å¼ƒé¾AKĞ9T™Áue~Ts}\@&'~0OmdÙ&,ŠÛb:, K,x`°”TOUke¡?aQâø+o2¥äe¡cÉf2„ì$J/`¢‰q5a6 ´wQñüp·ì'sjkè@#88`Ó´9şaXd5Ï5®¤` 'à}B£áóM†d.è6 ì”_$g-Kƒz¤ÍC.ë-<0m©-J$ j"íéhõ8yBØrwvcx>¿Ş¸qeªLöÄbô7[°YPyqf¾pm@±jä§……y÷ç"EX #r|`éºgö$íìˆ5×1ünV> \	 ä"	Aííoe=W øáQ[$”³+\;+~5Ã-ï¢ ºP×&‰hTxh&`wãÌ
>-àüTO¤% ÷êO}\O9¿SW%E¥· ü=vK<2eïeÕ<_!f-¦)Ğs$(u€4ú(rã¦ ­6™­îyöT”Jq#—Ze><†9%Ù².1Õ.%~1qa¯1ò¥ }®‡1OE|¼3*ÿ$ÿSP"A¥ºÿ(şƒÙ]x _şvtX«õİEvDn7@ãno¨s3àx'r6¬Ê`ÃQà_tı§i›F{gÇ{)q^J¨‹§£ü»$&óx   <r´XÂ8èà•±ò?F0yPÇyNSÜÎ;`sªXZa² Ä0¡*ªA$A·J(6däãP(x0ü6%´)v©yuÒ7/c,LüEÙ­p,'‘W•r!Ç¼ì	ÑğÉ†Uİït&­õCA½£¢&GÿÄ=--`heõßcKÈ	u,Ü?!4p`Iáã.ò hMÿÂ õ5>‰OQ0Ä7ÊÉ\ß"B¦/ÖïÿRa‹#a/8hjÌegK	2b¬†fe%H¥)	Öªz/)64ğÜT‹nyur`saY¶ŒK3!H0Ú%tfSxCY­Pp‡UæddIÁ°¹ƒï ½]ŞßÚµy/{ ïã}1GxµB¶8=y ß +Qé2xè³@‚ b]yÉì%uVÄturöÍÔ{iëuiNÙ>sS{äßjô`xì'ò¥æ}!õfÙdë¹åPqueÚS+X0£Ì,Õ`IË`”GëeWfñ²"p rr«ÃîÉ~g¹˜!îr6Sæif?Z¸°6[
Ø#u98][ÈÌdµçİñt2
ewe-x%f_¹ì=^óæfOã´TØ_qad{|5ïø—6©†p¡efÅ¢F}òByx´Iú(¡Ïr‰±"àeşH7x85t·e­´n*-älF)”7‚ f.Yt"ú£}TirWñÛ5¿.%ÊÈi<"kÀl4~+(H:ô#apdI(p ÓàÌ™"×ó“`€](T»6ÏÆ‘tó‚@rRwÒSìyM‡W}IIhZıF}İU0{Ğ%?0p,wøC ÕF¨Pxñ(­½-x€Aø*I&… 1à)#ÄÙ]!#W6ê™~`¨Kë5/B‰õ$)3bvniâü!Õ·h2pş¨›®Rı?&$äèke"õ#œ£¼G¬L¦1‘äaÍhc¹ã{P!éi2%pÇuº8Z6¡_Gcy£wÆŒ `{d"°0x@_Ûäò¦P³² óZñ0D›zªY&z…M$ó;>¥Œ0¼';wé
Ş™CQPjcAHY¹ ÷løÃı³Z}mäd'1KRi}ş´IL¨Âwr,{j}!p9c·Fw´_ `QP53'a7ŠäW ²4-Fú°vri+o%F-c³)ã à-“3*hzfdÈgs/ˆúÜí4g‰´tü Òš¦ÎN:ãw¬u¯¨øqmr‹êg90ÍÈé8ånundv‹b3VAõâtr÷ƒmhŞ¥æ!TtPd7 ÷^øê(ViQÃ¥&5|-u!(yç„{R2Y.|rıhêè"àEdj§I{"rcáª¼Fx!G¯Ø^Óø%^±9mğí’B+šİoî9n¢£Er5_Jº…NÔ
ú+M2!ğÍ8zhúHÛ¸`Qiıio.3m&%G ~&2£µÔ³Å¯Åğ[!Xáì„ğ3+s€R-İsØYwm"BD´7%ÿó_†J¥h“kZBl-½4pÑŸ^v#…¥ê } Y C;Sj%'Na3!I0}$.â³¸: #@ııgÒ`„³Qø*_?ÊtÀ<Ã{i6F0zÓ:–88 uĞ!<ê ú},èôİh÷E°†<wOaàÕ%úHhV&&7¬Kğ<Cg =31l8¤Ö~d5>-Š`±wf×iåãÌt7W¢÷q’¯¼µà”à~d+Ÿ¶qal8äî>,[QáaÖ[º€¡´°æA—P‚'eBDî	ÓfŠpºt§sa<‰.$	qs¥psídi&Et@ hl#ü=q]"ö(6òü¯o·2êSgh$C8y-ı/gkndîRA (0íä£4tÂ	`ß¸¯è‚" w¨}”ÁmñÍ–‰4Ã]¶àû³/8}	$,x3—!Ó!°IEêy3qn‚¾©c?PîS%Õf]Yƒ6y°¹+ˆ$÷Ägò…¥„$7Y~§z—&+Q360Jf‹~p¥a2ÛËi7ÖÜ"eğ2(¸tùÁp¡½ˆ"°Và^é ¥¬~cn!¬=t#Ú„9a+³)wó]”…üJ7 b twli$7vif	ÔitbqpxÙë@3ºr"tp,q9ĞV˜|§%lONyNQÖ¹qçd";y«£¤&ÂaöŞí"<ğìgé{d£ŠŒêÚ!>>7·{Vtl6”~"ªR´ey#?…¥|±òâq(9G1¿ˆg|õ Æi3½Ÿéw¾(6yªE" j²ä¨¡ÂíO[	?y^ íöqu)|^rp·Ïlhabfæ,.h>ÿ-Ø2’J "a*ÌxôàĞÆ¡úrtÕå@2çewo©3k98ğhUF UB"gBfph(6f MåvFæ70i8.v,g)ue/qYaOæv?n¡­z9êšEæg“PqP%ø4AbÍí)RY(N ÅÃ7+%ı>Q¾c¹n¦uà¶ºx¬¥`³£5‰9ƒÍèôx°åoÎiw]P( ¦ÚI<LM¸¶9şs‰O/±|AÔbö1l`’A5ğm;1y¡ò,ùÔÉ-pA=8l¹sùm9t>ä,ã´!,%ó°à5qvsÜ”`•rµ]#qÈQ!7ûAMtšy|¬v›j²›e'¥cµñç`Ò/¡´qn`ğo É¡W#'aZ0Ò]*Vm)å³$Rfï;énø;2G)£ji›$½êy}h¸ãìeHµt (.càÁ‰lqnM L?K$4 óõ°ˆy5!$‹/lê~³ J#brô‘óà&Ö~yc-ûŸ=çzËâ%qraPcFÈ+¥=¨²Z0 Ã
 [ko¯vCv¸`ÇÅGdDol¡!Arö:dT[TÅu¥)8qú}jt‚{¦¡2úñp0¸¯f t&ï2,!U+B
aá,ü³Ÿù–à ïgÛSÿ%¢á!xy­5(uhïK­â@ùÑk!â',‘cÁckÕ	a+eHR\@#V÷vt”I¿ å6uºP/.{%y?A(ddËV ``wÈŠ?¤beXtHtNJiS?4ñ)"ña¯py*–òª^îv3¡7ÅVÇJH-Wğ ‘Š¡O0<˜S]c6á0ÔffPSdfF|‰èã=fQ º²^!@Î/sğa`Ø5S 
wŠ^Á×]ªl~èÖ?d5:÷6ÊJ'WEÔ… <C'[¾©2oçFH¿#Y(:î"+í„°¤sfwÈİqNGp<%ØW	a"äi@Pu'tt.4 B|µ^]¤ÒËÎmô#qàñphW7^0pæ!zêyõÄmñ™u=SÎí3>„ñÖš¨­sQs>Eaa^3é7a¥¸-×½(«x¸EÕ#¥EÒˆ=FX‹YD@ â6Uê9î	QJËa·OIñOv:T' ·X8B9çC ¡i>U|ÄER6Uh
îãË²/ôñtdr©0WNàz`'?Mô &)"1( å²ªú|wpnwr|iméBœ)d òk·±ËX[]¦è©fÙë¥D m`0'|*ógkLiõsÆLuô+¥#,šåÎ¬Úm	÷Q°ôß>Iñß®øyt€p;h)‚;4!}C>1'Ÿ?*Ó¶Ú¢!i14GØsãMm}$]ô÷eh ûğè'_ù]3´dC7ifE)s¯+õFV„MˆC`ó¹~õc9Õm2")õ%"j'¬êc/›z)`r¯zÙ}5ªOòö‡ÀOôfgXdä iOIsfÏ”?]j­­í:fy°!W&hõ”ßàly”3Èã'LõT"ê¤¨q§o{?ú@Û	O(q0o×w(örqL†x4‘¢[$8İcl	tqf}ªÛ.ævp9Ã~ır.i¶ h
óviaèX¤Y.çSrèØG%·i^_x)U%oX8çf©°5²dr8j¬‘Rqc0oq7ound by DC where Cython code was insisting on
    # ndarray return type, but getting sparse matrix
    st = {'sparsefield': SP.coo_matrix(np.eye(4))}
    stream = BytesIO()
    savemat(stream, {'a':st})
    d = loadmat(stream, struct_as_record=True)
    assert_array_equal(d['a'][0,0]['sparsefield'].todense(), np.eye(4))


def test_mat_struct_squeeze():
    stream = BytesIO()
    in_d = {'st':{'one':1, 'two':2}}
    savemat(stream, in_d)
    # no error without squeeze
    loadmat(stream, struct_as_record=False)
    # previous error was with squeeze, with mat_struct
    loadmat(stream, struct_as_record=False, squeeze_me=True)


def test_scalar_squeeze():
    stream = BytesIO()
    in_d = {'scalar': [[0.1]], 'string': 'my name', 'st':{'one':1, 'two':2}}
    savemat(stream, in_d)
    out_d = loadmat(stream, squeeze_me=True)
    assert_(isinstance(out_d['scalar'], float))
    assert_(isinstance(out_d['string'], str))
    assert_(isinstance(out_d['st'], np.ndarray))


def test_str_round():
    # from report by Angus McMorland on mailing list 3 May 2010
    stream = BytesIO()
    in_arr = np.array(['Hello', 'Foob'])
    out_arr = np.array(['Hello', 'Foob '])
    savemat(stream, dict(a=in_arr))
    res = loadmat(stream)
    # resulted in ['HloolFoa', 'elWrdobr']
    assert_array_equal(res['a'], out_arr)
    stream.truncate(0)
    stream.seek(0)
    # Make Fortran ordered version of string
    in_str = in_arr.tobytes(order='F')
    in_from_str = np.ndarray(shape=a.shape,
                             dtype=in_arr.dtype,
                             order='F',
                             buffer=in_str)
    savemat(stream, dict(a=in_from_str))
    assert_array_equal(res['a'], out_arr)
    # unicode save did lead to buffer too small error
    stream.truncate(0)
    stream.seek(0)
    in_arr_u = in_arr.astype('U')
    out_arr_u = out_arr.astype('U')
    savemat(stream, {'a': in_arr_u})
    res = loadmat(stream)
    assert_array_equal(res['a'], out_arr_u)


def test_fieldnames():
    # Check that field names are as expected
    stream = BytesIO()
    savemat(stream, {'a': {'a':1, 'b':2}})
    res = loadmat(stream)
    field_names = res['a'].dtype.names
    assert_equal(set(field_names), set(('a', 'b')))


def test_loadmat_varnames():
    # Test that we can get just one variable from a mat file using loadmat
    mat5_sys_names = ['__globals__',
                      '__header__',
                      '__version__']
    for eg_file, sys_v_names in (
        (pjoin(test_data_path, 'testmulti_4.2c_SOL2.mat'), []), (pjoin(
            test_data_path, 'testmulti_7.4_GLNX86.mat'), mat5_sys_names)):
        vars = loadmat(eg_file)
        assert_equal(set(vars.keys()), set(['a', 'theta'] + sys_v_names))
        vars = loadmat(eg_file, variable_names='a')
        assert_equal(set(vars.keys()), set(['a'] + sys_v_names))
        vars = loadmat(eg_file, variable_names=['a'])
        assert_equal(set(vars.keys()), set(['a'] + sys_v_names))
        vars = loadmat(eg_file, variable_names=['theta'])
        assert_equal(set(vars.keys()), set(['theta'] + sys_v_names))
        vars = loadmat(eg_file, variable_names=('theta',))
        assert_equal(set(vars.keys()), set(['theta'] + sys_v_names))
        vars = loadmat(eg_file, variable_names=[])
        assert_equal(set(vars.keys()), set(sys_v_names))
        vnames = ['theta']
        vars = loadmat(eg_file, variable_names=vnames)
        assert_equal(vnames, ['theta'])


def test_round_types():
    # Check that saving, loading preserves dtype in most cases
    arr = np.arange(10)
    stream = BytesIO()
    for dts in ('f8','f4','i8','i4','i2','i1',
                'u8','u4','u2','u1','c16','c8'):
        stream.truncate(0)
        stream.seek(0)  # needed for BytesIO in Python 3
        savemat(stream, {'arr': arr.astype(dts)})
        vars = loadmat(stream)
        assert_equal(np.dtype(dts), vars['arr'].dtype)


def test_varmats_from_mat():
    # Make a mat file with several variables, write it, read it back
    names_vars = (('arr', mlarr(np.arange(10))),
                  ('mystr', mlarr('a string')),
                  ('mynum', mlarr(10)))

    # Dict like thing to give variables in defined order
    class C:
        def items(self):
            return names_vars
    stream = BytesIO()
    savemat(stream, C())
    varmats = varmats_from_mat(stream)
    assert_equal(len(varmats), 3)
    for i in range(3):
        name, var_stream = varmats[i]
        exp_name, exp_res = names_vars[i]
        assert_equal(name, exp_name)
        res = loadmat(var_stream)
        assert_array_equal(res[name], exp_res)


def test_one_by_zero():
    # Test 1x0 chars get read correctly
    func_eg = pjoin(test_data_path, 'one_by_zero_char.mat')
    fp = open(func_eg, 'rb')
    rdr = MatFile5Reader(fp)
    d = rdr.get_variables()
    fp.close()
    assert_equal(d['var'].shape, (0,))


def test_load_mat4_le():
    # We were getting byte order wrong when reading little-endian floa64 dense
    # matrices on big-endian platforms
    mat4_fname = pjoin(test_data_path, 'test_mat4_le_floats.mat')
    vars = loadmat(mat4_fname)
    assert_array_equal(vars['a'], [[0.1, 1.2]])


def test_unicode_mat4():
    # Mat4 should save unicode as latin1
    bio = BytesIO()
    var = {'second_cat': 'SchrÃ¶dinger'}
    savemat(bio, var, format='4')
    var_back = loadmat(bio)
    assert_equal(var_back['second_cat'], var['second_cat'])


def test_logical_sparse():
    # Test we can read logical sparse stored in mat file as bytes.
    # See https://github.com/scipy/scipy/issues/3539.
    # In some files saved by MATLAB, the sparse data elements (Real Part
    # Subelement in MATLAB speak) are stored with apparent type double
    # (miDOUBLE) but are in fact single bytes.
    filename = pjoin(test_data_path,'logical_sparse.mat')
    # Before fix, this would crash with:
    # ValueError: indices and data should have the same size
    d = loadmat(filename, struct_as_record=True)
    log_sp = d['sp_log_5_4']
    assert_(isinstance(log_sp, SP.csc_matrix))
    assert_equal(log_sp.dtype.type, np.bool_)
    assert_array_equal(log_sp.toarray(),
                       [[True, True, True, False],
                        [False, False, True, False],
                        [False, False, True, False],
                        [False, False, False, False],
                        [False, False, False, False]])


def test_empty_sparse():
    # Can we read empty sparse matrices?
    sio = BytesIO()
    import scipy.sparse
    empty_sparse = scipy.sparse.csr_matrix([[0,0],[0,0]])
    savemat(sio, dict(x=empty_sparse))
    sio.seek(0)
    res = loadmat(sio)
    assert_array_equal(res['x'].shape, empty_sparse.shape)
    assert_array_equal(res['x'].todense(), 0)
    # Do empty sparse matrices get written with max nnz 1?
    # See https://github.com/scipy/scipy/issues/4208
    sio.seek(0)
    reader = MatFile5Reader(sio)
    reader.initialize_read()
    reader.read_file_header()
    hdr, _ = reader.read_var_header()
    assert_equal(hdr.nzmax, 1)


def test_empty_mat_error():
    # Test we get a specific warning for an empty mat file
    sio = BytesIO()
    assert_raises(MatReadError, loadmat, sio)


def test_miuint32_compromise():
    # Reader should accept miUINT32 for miINT32, but check signs
    # mat file with miUINT32 for miINT32, but OK values
    filename = pjoin(test_data_path, 'miuint32_for_miint32.mat')
    res = loadmat(filename)
    assert_equal(res['an_array'], np.arange(10)[None, :])
    # mat file with miUINT32 for miINT32, with negative value
    filename = pjoin(test_data_path, 'bad_miuint32.mat')
    with assert_raises(ValueError):
        loadmat(filename)


def test_miutf8_for_miint8_compromise():
    # Check reader accepts ascii as miUTF8 for array names
    filename = pjoin(test_data_path, 'miutf8_array_name.mat')
    res = loadmat(filename)
    assert_equal(res['array_name'], [[1]])
    # mat file with non-ascii utf8 name raises error
    filename = pjoin(test_data_path, 'bad_miutf8_array_name.mat')
    with assert_raises(ValueError):
        loadmat(filename)


def test_bad_utf8():
    # Check that reader reads bad UTF with 'replace' option
    filename = pjoin(test_data_path,'broken_utf8.mat')
    res = loadmat(filename)
    assert_equal(res['bad_string'],
                 b'\x80 am broken'.decode('utf8', 'replace'))


def test_save_unicode_field(tmpdir):
    filename = os.path.join(str(tmpdir), 'test.mat')
    test_dict = {u'a':{u'b':1,u'c':'test_str'}}
    savemat(filename, test_dict)


def test_filenotfound():
    # Check the correct error is thrown
    assert_raises(IOError, loadmat, "NotExistentFile00.mat")
    assert_raises(IOError, loadmat, "NotExistentFile00")


def test_simplify_cells():
    # Test output when simplify_cells=True
    filename = pjoin(test_data_path, 'testsimplecell.mat')
    res1 = loadmat(filename, simplify_cells=True)
    res2 = loadmat(filename, simplify_cells=False)
    assert_(isinstance(res1["s"], dict))
    assert_(isinstance(res2["s"], np.ndarray))
    assert_array_equal(res1["s"]["mycell"], np.array(["a", "b", "c"]))
