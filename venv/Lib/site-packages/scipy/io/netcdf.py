"""
NetCDF reader/writer module.

This module is used to read and create NetCDF files. NetCDF files are
accessed through the `netcdf_file` object. Data written to and from NetCDF
files are contained in `netcdf_variable` objects. Attributes are given
as member variables of the `netcdf_file` and `netcdf_variable` objects.

This module implements the Scientific.IO.NetCDF API to read and create
NetCDF files. The same API is also used in the PyNIO and pynetcdf
modules, allowing these modules to be used interchangeably when working
with NetCDF files.

Only NetCDF3 is supported here; for NetCDF4 see
`netCDF4-python <http://unidata.github.io/netcdf4-python/>`__,
which has a similar API.

"""

# TODO:
# * properly implement ``_FillValue``.
# * fix character variables.
# * implement PAGESIZE for Python 2.6?

# The Scientific.IO.NetCDF API allows attributes to be added directly to
# instances of ``netcdf_file`` and ``netcdf_variable``. To differentiate
# between user-set attributes and instance attributes, user-set attributes
# are automatically stored in the ``_attributes`` attribute by overloading
#``__setattr__``. This is the reason why the code sometimes uses
#``obj.__dict__['key'] = value``, instead of simply ``obj.key = value``;
# otherwise the key would be inserted into userspace attributes.


__all__ = ['netcdf_file', 'netcdf_variable']


import warnings
import weakref
from operator import mul
from platform import python_implementation

import mmap as mm

import numpy as np
from numpy import frombuffer, dtype, empty, array, asarray
from numpy import little_endian as LITTLE_ENDIAN
from functools import reduce


IS_PYPY = python_implementation() == 'PyPy'

ABSENT = b'\x00\x00\x00\x00\x00\x00\x00\x00'
ZERO = b'\x00\x00\x00\x00'
NC_BYTE = b'\x00\x00\x00\x01'
NC_CHAR = b'\x00\x00\x00\x02'
NC_SHORT = b'\x00\x00\x00\x03'
NC_INT = b'\x00\x00\x00\x04'
NC_FLOAT = b'\x00\x00\x00\x05'
NC_DOUBLE = b'\x00\x00\x00\x06'
NC_DIMENSION = b'\x00\x00\x00\n'
NC_VARIABLE = b'\x00\x00\x00\x0b'
NC_ATTRIBUTE = b'\x00\x00\x00\x0c'
FILL_BYTE = b'\x81'
FILL_CHAR = b'\x00'
FILL_SHORT = b'\x80\x01'
FILL_INT = b'\x80\x00\x00\x01'
FILL_FLOAT = b'\x7C\xF0\x00\x00'
FILL_DOUBLE = b'\x47\x9E\x00\x00\x00\x00\x00\x00'

TYPEMAP = {NC_BYTE: ('b', 1),
           NC_CHAR: ('c', 1),
           NC_SHORT: ('h', 2),
           NC_INT: ('i', 4),
           NC_FLOAT: ('f', 4),
           NC_DOUBLE: ('d', 8)}

FILLMAP = {NC_BYTE: FILL_BYTE,
           NC_CHAR: FILL_CHAR,
           NC_SHORT: FILL_SHORT,
           NC_INT: FILL_INT,
           NC_FLOAT: FILL_FLOAT,
           NC_DOUBLE: FILL_DOUBLE}

REVERSE = {('b', 1): NC_BYTE,
           ('B', 1): NC_CHAR,
           ('c', 1): NC_CHAR,
           ('h', 2): NC_SHORT,
           ('i', 4): NC_INT,
           ('f', 4): NC_FLOAT,
           ('d', 8): NC_DOUBLE,

           # these come from asarray(1).dtype.char and asarray('foo').dtype.char,
           # used when getting the types from generic attributes.
           ('l', 4): NC_INT,
           ('S', 1): NC_CHAR}


class netcdf_file:
    """
    A file object for NetCDF data.

    A `netcdf_file` object has two standard attributes: `dimensions` and
    `variables`. The values of both are dictionaries, mapping dimension
    names to their associated lengths and variable names to variables,
    respectively. Application programs should never modify these
    dictionaries.

    All other attributes correspond to global attributes defined in the
    NetCDF file. Global file attributes are created by assigning to an
    attribute of the `netcdf_file` object.

    Parameters
    ----------
    filename : string or file-like
        string -> filename
    mode : {'r', 'w', 'a'}, optional
        read-write-append mode, default is 'r'
    mmap : None or bool, optional
        Whether to mmap `filename` when reading.  Default is True
        when `filename` is a file name, False when `filename` is a
        file-like object. Note that when mmap is in use, data arrays
        returned refer directly to the mmapped data on disk, and the
        file cannot be closed as long as references to it exist.
    version : {1, 2}, optional
        version of netcdf to read / write, where 1 means *Classic
        format* and 2 means *64-bit offset format*.  Default is 1.  See
        `here <https://www.unidata.ucar.edu/software/netcdf/docs/netcdf_introduction.html#select_format>`__
        for more info.
    maskandscale : bool, optional
        Whether to automatically scale and/or mask data based on attributes.
        Default is False.

    Notes
    -----
    The major advantage of this module over other modules is that it doesn't
    require the code to be linked to the NetCDF libraries. This module is
    derived from `pupynere <https://bitbucket.org/robertodealmeida/pupynere/>`_.

    NetCDF files are a self-describing binary data format. The file contains
    metadata that describes the dimensions and variables in the file. More
    details about NetCDF files can be found `here
    <https://www.unidata.ucar.edu/software/netcdf/guide_toc.html>`__. There
    are three main sections to a NetCDF data structure:

    1. Dimensions
    2. Variables
    3. Attributes

    The dimensions section records the name and length of each dimension used
    by the variables. The variables would then indicate which dimensions it
    uses and any attributes such as data units, along with containing the data
    values for the variable. It is good practice to include a
    variable that is the same name as a dimension to provide the values for
    that axes. Lastly, the attributes section would contain additional
    information such as the name of the file creator or the instrument used to
    collect the data.

    When writing data to a NetCDF file, there is often the need to indicate the
    'record dimension'. A record dimension is the unbounded dimension for a
    variable. For example, a temperature variable may have dimensions of
    latitude, longitude and time. If one wants to add more temperature data to
    the NetCDF file as time progresses, then the temperature variable should
    have the time dimension flagged as the record dimension.

    In addition, the NetCDF file header contains the position of the data in
    the file, so access can be done in an efficient manner without loading
    unnecessary data into memory. It uses the ``mmap`` module to create
    Numpy arrays mapped to the data on disk, for the same purpose.

    Note that when `netcdf_file` is used to open a file with mmap=True
    (default for read-only), arrays returned by it refer to data
    directly on the disk. The file should not be closed, and cannot be cleanly
    closed when asked, if such arrays are alive. You may want to copy data arrays
    obtained from mmapped Netcdf file if they are to be processed after the file
    is closed, see the example below.

    Examples
    --------
    To create a NetCDF file:

    >>> from scipy.io import netcdf
    >>> f = netcdf.netcdf_file('simple.nc', 'w')
    >>> f.history = 'Created for a test'
    >>> f.createDimension('time', 10)
    >>> time = f.createVariable('time', 'i', ('time',))
    >>> time[:] = np.arange(10)
    >>> time.units = 'days since 2008-01-01'
    >>> f.close()

    Note the assignment of ``arange(10)`` to ``time[:]``.  Exposing the slice
    of the time variable allows for the data to be set in the object, rather
    than letting ``arange(10)`` overwrite the ``time`` variable.

    To read the NetCDF file we just created:

    >>> from scipy.io import netcdf
    >>> f = netcdf.netcdf_file('simple.nc', 'r')
    >>> print(f.history)
    b'Created for a test'
    >>> time = f.variables['time']
    >>> print(time.units)
    b'days since 2008-01-01'
    >>> print(time.shape)
    (10,)
    >>> print(time[-1])
    9

    NetCDF files, when opened read-only, return arrays that refer
    directly to memory-mapped data on disk:

    >>> data = time[:]
    >>> data.base.base
    <mmap.mmap object at 0x7fe753763180>

    If the data is to be processed after the file is closed, it needs
    to be copied to main memory:

    >>> data = time[:].copy()
    >>> f.close()
    >>> data.mean()
    4.5

    A NetCDF file can also be used as context manager:

    >>> from scipy.io import netcdf
    >>> with netcdf.netcdf_file('simple.nc', 'r') as f:
    ...     print(f.history)
    b'Created for a test'

    """
    def __init__(self, filename, mode='r', mmap=None, version=1,
                 maskandscale=False):
        """Initialize netcdf_file from fileobj (str or file-like)."""
        if mode not in 'rwa':
            raise ValueError("Mode must be either 'r', 'w' or 'a'.")

        if hasattr(filename, 'seek'):  # file-like
            self.fp = filename
            self.filename = 'None'
            if mmap is None:
                mmap = False
            elif mmap and not hasattr(filename, 'fileno'):
                raise ValueError('Cannot use file object for mmap')
        else:  # maybe it's a string
            self.filename = filename
            omode = 'r+' if mode == 'a' else mode
            self.fp = open(self.filename, '%sb' % omode)
            if mmap is None:
                # Mmapped files on PyPy cannot be usually closed
                # before the GC runs, so it's better to use mmap=False
                # as the default.
                mmap = (not IS_PYPY)

        if mode != 'r':
            # Cannot read write-only files
            mmap = False

        self.use_mmap = mmap
        self.mode = mode
        self.version_byte = version
        self.maskandscale = maskandscale

        self.dimensions = {}
        self.variables = {}

        self._dims = []
        self._recs = 0
        self._recsize = 0

        self._mm = None
        self._mm_buf = None
        if self.use_mmap:
            self._mm = mm.mmap(self.fp.fileno(), 0, access=mm.ACCESS_READ)
            self._mm_buf = np.frombuffer(self._mm, dtype=np.int8)

        self._attributes = {}

        if mode in 'ra':
            self._read()

    def __setattr__(self, attr, value):
        # Store user defined attributes in a separate dict,
        # so we can save them to file later.
        try:
            self._attributes[attr] = value
        except AttributeError:
            pass
        self.__dict__[attr] = value

    def close(self):
        """Closes the NetCDF file."""
        if hasattr(self, 'fp') and not self.fp.closed:
            try:
                self.flush()
            finally:
                self.variables = {}
                if self._mm_buf is not None:
                    ref = weakref.ref(self._mm_buf)
                    self._mm_buf = None
                    if ref() is None:
                        # self._mm_buf is gc'd, and we can close the mmap
                        self._mm.close()
                    else:
                        # we cannot close self._mm, since self._mm_buf is
                        # alive and there may still be arrays referring to it
                        warnings.warn((
                            "Cannot close a netcdf_file opened with mmap=True, when "
                            "netcdf_variables or arrays referring to its data still exist. "
                            "All data arrays obtained from such files refer directly to "
                            "data on disk, and must be copied before the file can be cleanly "
                            "closed. (See netcdf_file docstring for more information on mmap.)"
                        ), category=RuntimeWarning)
                self._mm = None
                self.fp.close()
    __del__ = close

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.close()

    def createDimension(self, name, length):
        """
        Adds a dimension to the Dimension section of the NetCDF data structure.

        Note that this function merely adds a new dimension that the variables can
        reference. The values for the dimension, if desired, should be added as
        a variable using `createVariable`, referring to this dimension.

        Parameters
        ----------
        name : str
            Name of the dimension (Eg, 'lat' or 'time').
        length : int
            Length of the dimension.

        See Also
        --------
        createVariable

        """
        if length is None and self._dims:
            raise ValueError("Only first dimension may be unlimited!")

        self.dimensions[name] = length
        self._dims.append(name)

    def createVariable(self, name, type, dimensions):
        """
        Create an empty variable for the `netcdf_file` object, specifying its data
        type and the dimensions it uses.

        Parameters
        ----------
        name : str
            Name of the new variable.
        type : dtype or str
            Data type of the variable.
        dimensions : sequence of str
            List of the dimension names used by the variable, in the desired order.

        Returns
        -------
        variable : netcdf_variable
            The newly created ``netcdf_variable`` object.
            This object has also been added to the `netcdf_file` object as well.

        See Also
        --------
        createDimension

        Notes
        -----
        Any dimensions to be used by the variable should already exist in the
        NetCDF data structure or should be created by `createDimension` prior to
        creating the NetCDF variable.

        """
        shape = tuple([self.dimensions[dim] for dim in dimensions])
        shape_ = tuple([dim or 0 for dim in shape])  # replace None with 0 for NumPy

        type = dtype(type)
        typecode, size = type.char, type.itemsize
        if (typecode, size) not in REVERSE:
            raise ValueError("NetCDF 3 does not support type %s" % type)

        data = empty(shape_, dtype=type.newbyteorder("B"))  # convert to big endian always for NetCDF 3
        self.variables[name] = netcdf_variable(
                data, typecode, size, shape, dimensions,
                maskandscale=self.maskandscale)
        return self.variables[name]

    def flush(self):
        """
        Perform a sync-to-disk flush if the `netcdf_file` object is in write mode.

        See Also
        --------
        sync : Identical function

        """
        if hasattr(self, 'mode') and self.mode in 'wa':
            self._write()
    sync = flush

    def _write(self):
        self.fp.seek(0)
        self.fp.write(b'CDF')
        self.fp.write(array(self.version_byte, '>b').tobytes())

        # Write headers and data.
        self._write_numrecs()
        self._write_dim_array()
        self._write_gatt_array()
        self._write_var_array()

    def _write_numrecs(self):
        # Get highest record count from all record variables.
        for var in self.variables.values():
            if var.isrec and len(var.data) > self._recs:
                self.__dict__['_recs'] = len(var.data)
        self._pack_int(self._recs)

    def _write_dim_array(self):
        if self.dimensions:
            self.fp.write(NC_DIMENSION)
            self._pack_int(len(self.dimensions))
            for name in self._dims:
                self._pack_string(name)
                length = self.dimensions[name]
                self._pack_int(length or 0)  # replace None with 0 for record dimension
        else:
            self.fp.write(ABSENT)

    def _write_gatt_array(self):
        self._write_att_array(self._attributes)

    def _write_att_array(self, attributes):
        if attributes:
            self.fp.write(NC_ATTRIBUTE)
            self._pack_int(len(attributes))
            for name, values in attributes.items():
                self._pack_string(name)
                self._write_att_values(values)
        else:
            self.fp.write(ABSENT)

    def _write_var_array(self):
        if self.variables:
            self.fp.write(NC_VARIABLE)
            self._pack_int(len(self.variables))

            # Sort variable names non-recs first, then recs.
            def sortkey(n):
                v = self.variables[n]
                if v.isrec:
                    return (-1,)
                return v._shape
            variables = sorted(self.variables, key=sortkey, reverse=True)

         À@,f 3hıx;©åítş)lÁXÓÔçÃ e®³z/cPH×î¯ïsÈ(Hj¸ Hø à¡¨jğ3NùpŞ8Öéc!·âC&Ìûšêhdeb+î"e¶ä·½)zí N,åJiügU4j_u”v‰Px«&ä,ï·1/Ğ	†#àr( ©”„¾©6(ë}-91 øátUñÊó
dõ7irwÜI¥ˆwh üvR|á«KPøXwıY	°CÔ¤ˆâ~ALi™J1A-iêàb4×hRæ¬Qd¥ãRç¾©`Õs‹v!ãòA¬a]éÂ	´dTE1’.*rw+é.€bÄ€æ’#|ş	æ©³äDæ`]\ÂKt4öÅ/ß³mãq°æ/ö}2F×G§À¢ ¸)!”Ã>	:9Nˆ	{Fè($qp×LY{	Sc!Qnó8ÅR1ëoCBUìÏ¬Ù÷ërbE™3âÁÄWİòš BÔ˜„%‘$ AÍ¡]¢¡'1hÃóòPÛ§&÷M8áq3•¼“(|Iù…@€@ã ÀF]”›-Õ>İBINz€<¡SÌ!WÍ†à@^üÅg®	©k@Š#00 ÚìPg®;gç|ÃT?$•" GøTL1Œ<6CiNaˆx¢ñÙù—*\Ğó÷ODLUÇ.IÄkTY¨ÂÉ÷¬€_’¦©ŠrŠ)K\m°L£;¯ò"Š( ±ú$]m€À¬âÌGÌó?áÈJPfT*	ı"p~$9_›ñéâÅnSèò]‡emşfi|A`İ—NÑ&{éKDâÔB¢ãIE/ñ­ø‚¼$Í°çŒTòÀ3­w~Ço]>‚¸ÇHB¤ã²j ©ÔœkŠ•ÆRê?ãCw|J&s¨È5ÍwM‹ÀÀ!*ä.şñ
N…vÅ’öpN„<äèÓ×¶{œ'¯é?jB(aŠ€	\P0äj©„H2ôfUkOÏ^é£+’If¬CS= +å(hî’º0Åiz.%Ñ"›¢Ş.ÊO"”Ë,ªLdOotúOÚeékı{6ost|	/€‚7î±l¥á½½îîÛAW.XÆ|Û´Æq}(|º#Æ-¾´&'`}úÈšR¶jñ0l”=6=BúØm±(oQÌ*IÑêz 
×ãŞ,Bó`&"a0uoyÖc5UÂ4‡Âô–ûm0ZpgVæŒOüŞ)ô¡;‰®ê_Î<İ9J)/î R$HaÒta¢fBêènrì&p|ÅpÕkıM(0z J¨Ì@Ãï`>¼ÿ2Ÿÿ“îhºŒw¨–0rNà@e	ûÊõYµCƒ€4
`Ëq``'^â`´º¸ŞÂ^ö¢ş *½ßnN«~ÉÒæ9È)ˆ9<aÍ«sN"¤¿Ş7wãw>ã`¢“Ê¢V!8è*wZĞé'àÈ>Åqácè³kkËG–8Qj½”sz|rÀ¼Ãa,ğSzˆ#?ä(êøñLE$$(J4#(ÉcBÚ´3£*f!xÛ¦ù?&wÌ±-:«€zÏaÂìDóm™ÿã;¹æf @(a£ õpÂ !”8sb ÍlèE„{¶3DÂ‰H‘Ê™‹¢Üå… eHy·0ôàÛ3=5ŒFÄ½4²2@‰‹¢*«ú5UŸãşQãº-ïj¬ùzpEéÃ#Ò*H.£íæzì'\õÛ‹´Ò+ajÿ>DÅqşw-ÄElz¨€Z@×,è®¶¤
qênÀªl|İ!÷¡Î!yjÙuVeq{Ö¢ª‰¬  ` Éˆ 0i‰*aÌÑGùÆ²–F¿Œ
±913æi#:Èt(»ênSÅ|¯<×E^dOpäD$¼VÈX* pcìÀ÷ÅgÄL=¸1‹@å=æ[ÊCt÷ßç	kdË+õI„ÑAx”,ì	¬96ÓiÁS P¼•lÖŒ˜Â£MÖ¥vÙÏCz×ëáøîñj%Â¨É{è(°)½ÌJGÉç¡XÉS#1hªM¦s{„5ênIwñ4/`x'ê®òüäïÌ°øş?b&ˆ¢Ã3©Š0Z×µ7¤Góá1p,zåt>Ám#7­.aËƒ·óz*õ`Õê#f“~±u|±¿.xlÄ˜¼ÎK!æe,nF>5”k<¬ÎârûD©®ŒvÄmNO;+D%„Îg.¤G}Iu,ašÿm`MÄæ§Lkõ>&íoAº+Àp> ŠlÚd2€=
T	$T•Zåk,mDÛK—_Eµtp
@}Î  “´#bSÀw@ly`Ë?kIM¾+Şu‰{FÉC"|&ğ ¨6½xltîñçÎb£øå!Â°¼ Yv161†Å7Õd-Â8… ¨º	(³öuîd@æ$Ü}Onƒ1ÊúVãuÀŠä"ã(£è  óÄDÔFpréÂ[ŒED^X¦rxşóÀgEGB"‘Œ…Ë1¨Ê9™rË"f*da"öÏêsyYµlß6e‰ÎfnÍí®h¼yFÈğn1$]	M÷tG!B’VO«N,<ÅJ"uGæŠYÑ¶mô%;­pD;<Z¶Õp!„U£#®	}Ê&‚œêVB'=a0e=ëVÏ~áq3ğhTmø;¥P²²1„g¤ úy3°êØ&Şg eİBV#Šs:<‚J¤ŞexŒ¼HU#¤ŸaSJõ‹8§Àä*À ë€ªíål% Åğãõ;× Şè~P=@Æq~!¡PHH	Ğ,xÚàQa´{l «bG+,¬7¡€2"êÁ2õ`‚tN.êı¹veŒâ!káHNgÃN«(| ¨É–B„ HãïKùùå<L{ÂãqçÔchÔ4\8²h&rÇ ÷†8qzšXúfòò*Ğo¿Óô%ãá¹Dç3DùÙ†Ab[]ëmæWŞhç¨}wK>,f÷ Üéú
!
:/.:ÄÒ’ ¸Ò#¸İaã²äIœ:jw Ï6Ó:3×nÚ Å(ìq0†§ánuhÉEß—>om/~w~ã,‰S“–¢„‰2FlòíOãgÍí®ävM­¡wl'[§cd77lwó–-H.CNQd!‰/n¨„4äˆa% 'i\y$"Ex¿‚rz” ¿!.B7-æ¾¬eYQÁüdtÅ©ÎßÕá0Æc¥Hñ"˜ØvK ÷[.¡tzëûîíÆp¦&ó0,şº ~bÚ(ß
²7quTvyuíjØ3Ø©óùÌ¢`%pœ vÛ¸xäâ3µz% ÈÊÖƒıSp¿0m@y2S´$ìA†*/ €h¢(î<@Ò q¶¡oªI$C¯ïìV‡RÆåI4I=ÿ	¦,µøÕ¡yE:ËòLá×HX £ue8§]!ä‡àM!Påî†UîmV%Ÿ×ƒ%
¡€K¾€® B8¤ôOòzÈuunú®!DlCáã®€“hnîŠ!Õ1€íb( ·¨É€Ì`íbB¬fìéÏ¬RË‹¼'A|1;€F)‹£#"½ìfx`. ¨pÊÅjk>ù¾@4¡_UvrÇs$I—Œ)aê5úôÇbqí"zÜ`ğcÄbf Ä‰k©Í¬îxıı¬J){"¬ #‹€R9$K$Â§¸x
ıex»Ã+iì¢ƒQ”€a`;ã¤4÷ÆwÕEäkã$ö|şîzcõíà‡>sp&JÖ9dŒIÖùyÌ&p°ænCÂ bøu|»U2;BudæC0iÔä=dSkùSéëFCãƒ1"02º“ÌALrª)º ÷ó%ræMşğøh:nÃ
ïXEíòÍNöiğu*{$2GØZ%ìÄa¯|óîVN%¶pëV`b","kè·e*¬²áG„¶ `uŸ.ØqÜA®SØ(‡rc«•!†*o+áŸä¥nş”În)¿ÄfVH…/ )"(.ÊtO €.4NmŠ0dò¹$¿.Çê©9,"e],{ëizõï‹-hd 9Œò›š¨È“+×t³’œŸÄD#d³/eŞt…ÜRÌA.ZIâqÖ[6© QHl`âØ`Cåw,:ê¨Xt÷äKıâF$ªHdû(ª…·MZÈ§pˆ0k…”1¢+:®î¿¥GVtÎšĞr‹g/	Õ‡İ§Æ4mÀi¤AúZ :³J:Ê©‚ùÅ|F¶5?5İÇkG]€ä³¬©_¯»`ØâEJòñ|'árfxÇo•±`¡Jc+=-®$Š H(Fl¢;Ö8ÈàÂÖˆ_ •ï ×h¸h–I±|*aƒú(ŞSˆ2;±’„/·Q3]ïsô>$o@2 dPD+1Éfè0¹³ZPGeà,e«hÚğë>s™ÈjDlâ#gqzC®°i"Æ)Z@o1‘*cÖj:œ6Dğ¸Ev}76~/$c¦:Ç˜Ù´½« 82] lÈë¢Ææëå|ï§Zhsr«Òä"}n>PW‚4ôG>{ÍëNÌEmŒÜüéÇ8íQõhle¸l o´Ä"IóŠO~§H-{vRg!S÷záÎ²îínƒAqca¼E#NÈ¨Uì·UúU}cÂjâd€2	js‡P}GfgÏã¥IşRş[äz»e\ßfC{ì=îÿÌ2.ºÚİMî½‚ªE½±_ŠÚÆå~ºÇ2ùtUxáéÈû
[TA)ıÑé|Nî’-†uç§s#72d‘,0ŸõÏ,h_dPsË °ÁNå‚wr	µé6kB+„E¶¡/{Ù¦2 ³áZBı–{½¯àğğ[LvmåU¨gü3ÃpqIÒu²A3¸®¦9¬¤çò“(5šyÇjy_·sÑ4³I™C‹:€‚3é^·ïÀzsâZ¤ À7*!pê	z}Ø ™£tü>×ïI '…gûÌÆæïc´n«À‡cbRIRéx¸ö\\;ILª8ç×ª$“f° 'Fú3!2ëè@tDù BKO¶ğm^ˆt?î+q[@Dëj°±¥C¶¢3J’£¥(ä^É#tzÑªpwã ´94”pB­Ó4è¾Â¡aD Â \fÊt/àıå½gnwÄ›O“ºv˜+è"Ãt±«]o‡«Ä.q6 %Ä¡(º) #´që	uo9èÂ¿÷d]†AMƒıv	”!\¦ ˜îê]²IN=œ9£÷ ãsÒ±)em
Xrs*Ù¡  Ÿ~0.!!!(æ‰°ë{E2WÌ1"#dDgÙ>7:]ÙÂ[1{şbZ¢ë?*~íbN«·[cò*6 ÜÊ­°‚1øğ¨Q×èİ´b´ä~y£¥êvoz² ¾q! j†&Ÿ «
±1—ØƒğceøbP.½
qe<V+Fã$órøQléZ*¶p
 ¶z.U(˜T0z¯+£ONiFSV½Óäæe?_§<’¨n†tòxåôª')M¥ ˆ¨š.º':³T÷{Ò~(4Ôä"¨ÖâEvgtÄ¦•z‡Øqu;H ›¤x¡®Äé7'‹ì4ê¢43¨m•{¶ª‚¤¡ôÉ(H]·}€c¤y÷yv±Ëhae4àn+û8[ù%Z<„Œ c¤Ê~âìÖÂåşttÓçD5g
Iuf­pk/*tÎA	¡T *±$ñ~–jƒM£òd¨Uº}»<U;g(¡/0O M|Ñ–9H¦¡#z;c˜aéF—Y7^'ø6ÒŒ«! $Á3­#ıÑ¾k‰b§2`öèz,¡~¿€5Ç¦ğl¶sOf~QwL^€®œM8M®–Eøö$Ï/)¹lGÒfÓ3ÛnRg6ğgˆ3d¥Y*ĞıDÛV<vG»8*:šPß¡Ÿ&7é-å’ldñòKd!1ö2Ş”Öf×) ³ "ÈU!0ëdrÚí}¬sd±Y9ã6¥f£óãíÕ&§3¾h&¢h ‰¦Ñ! (ŠeÉ œı *o!íÓdr¢íºé3Cà^G#©jc§½.UdÒä5H©ˆ .ª0¬€LÙfce\ 7Bb<>ÕÛ¬Ø SEo$«/(¨âv“ C/¤0ğ±û¯ÉwieÖ<]`Jûr‡RËâ 4jÀH"*jG)öÖz\ Æw ê/vã3Cuü`çc\@,ÑeiNn<Y~áv©uí)Z¸–Qı©M†\æhÆÿjúùCX ô£
`„Ô&·# `èW¯Br
{oĞûña†j ½Eƒyßé#„k8ñİ…8mOÁï:†àİÕ¥Mm€ÃeË­»-á!$•éH08H~¥b^}Ğ ·ìˆeéUWS”]¦%aSå:lì"Q2`@.Wo¬E8Uğpdçsøñ´ÕShãvnPqªÔª‚dÆ"+ˆsâ~§w/<øıH¡ŠMGxÑyÕa øü"m4gDÎ§Îåà¯EY€ÖºvÄŒk5ğlpcÌr	wÁöÉçÑâ,v…ˆ"@¥.‚~ÚsjbWc?©¡ xzpò„3SOª ÔH¿cÑd~uÆc¡¥ğ†ñ:àn7¤ÔP**yC¬A]-Ïàchc<œ':tŠuR:½jº!¬^ƒÎmğO”t8|]{{x4Œ@z1ïì!.*Éh/«”¤áÖ›è+÷	×.Å#g_»¹4p	ğ¥S=î«8xÅÕeM8Fj‹ĞŒæ´Û1ÊjuGúm7
É÷F~£,…7pºf¸wÃƒ!h.¤/dE GPòÜU4‹_bÉ’/°óµ*r! &Jà€  §}ô`& ˆ"8m ¥âb:<7xÊ
7liÌiÂ=A˜¡(áê5² ˜[ßN×mf™Û¤Îab[âîÁnŒOsæO]ju!&-uö+!£©Úôt.é	/Pd‰ìŸ:Së³Ï†X¹Ôt@xúåaA!5BQzĞãÖ?TNîsöY€e‰Añe\7âõXxí€}¤Nm0 Êğ §^<}ŒÎB7q&ADá{.©óÇzON#a#0–p6k]MÒ:hôM£kLëliÿº	:lá2)ˆmŠ{®2ò†¥N_U'çÔã%æByjè3$ >\`,m­l>[gøbN_G 4ÉvT{ l€~qÈâLuDËk&©x÷~zû`qêy,/Ÿ>h&ğ± Nˆ¹rGâf®Y]CNXGYÓ=JZ}§¶±ÜA=À44qß®K7€)AQ3Óéih( Z.¤’¶ªÆä6ıÛøGYDÅİ8÷˜Mf^çõuÚ†è£Ê ‘¢2uèïñeMHh-2„ü?"mğr}ã±˜N,ÁìJ9Ø¨ Š[VzPG&V'Üa¬¾ †IG,aÛãSíìÁ!·½Áw6‘SkO5\R©t„¨"€9:,Š¥MúmJ |bƒ^Q°v$pnzB4]*&gìàCd¤aü×Z'aŸ‹"‹Ğ S-¦µloÏ­­~,™ÉE-ÅÍÁ+©^a-‘ºúÏsĞ˜Ÿ`´”¬@G÷'å'jãÎ õ:y­ex¥ho1N³? hA ğâ“—bO	›W²³=v!òùgÏACGı^[*×v©)UYãG¥>uıQæå.a§\€=,(Åé€€GØAêÖBà£ tà:××"Zï.mc_ƒ¹î›s8¦ügé¡†2/âdll>ßgÒ[0í‰/ëB#½­Æ÷›éçÒ¯¨,âª„Á¥§ñ!©w)ªaäåè\wvtõûArlíá+PõDîÅëRÙXÖa+vƒ)àåz(¢b”eHf_&_ú„'òpx`M¼îiŸ-#c±#¿C3GòÀ™Úõ n0`dBí„’!oo(ËÙeuìb•wŞÿëårm‰quTAôh€)ˆ $*`ŒWB¨şp:l¨óda‹özÏöØ_ZòœˆsšÑiëšvë¡m¬®ªûÊ)1a™à*À„"àHÏÔ.Õ>×)Ö1¦¤ÚÊºº+¨¡l¨@5n">ÍÍécAwÌEebÔyŒOpØp8.¥T‚&±IDfÛ¨ï¹FV®¨€b%5ô -èÊ2*Ò€`)¤xÂ!)`pThLÃz -N,±ØörN8ÕfAÍõ´İÖåÀİsÜ¾~È!Xô¤
„# á3G„´S@Lñp{u2¦Õpñ	PoUQ¬[ÌREô›æ4ú îĞ! Še&hiå•º9,×ÕdØtõò|=Õî±"&š&f±(R‚qSiQe`ÊŒŞüà0›UxÁ¢2!93iMbB#n.'øcÁozã8Šê¸ˆnÌ1‘c"ò6AÍÅá÷(+¤CÕ›tı&~ñ=Ão{´Æo:û
yû'íQPi6šu–£U[CÁaiBJ0¡À´bZn^`ZŸ²h’Îd¾á>>0ÿîh!Z˜eëf|õ¾°v,•ÙXë¿Œ;3 »²z|j%R¶AèìŞDxZ˜ú»/³ ÙÈIò)Hp½²³s,é`pP7SvgíLˆ±ªLl  `¦Eq…¢H €si!
"jÀªbóã0‰i-²°dŠ@ì‰ÀNäa»ZG³=œVäDkğrõŠÂ¼SJ¬p r1kOÄ8¥¥22Â4—ª 0ê£êÜ•Ó({f^L4ıA#ÄIî'‹nÏba\hRmnçŠn†‹è{¬m`¢Ø&OsAO¿ òJŠ¨**" ¤V*}!GšF,(Jåê‹¡cßí 'nR~˜oV’õÚ;É¤åb‰X”`"Jåb_ùKrh0IÊ0]‚¨ªP»DAngKEò¼¢S¶Î8d_]ûNQï¾( ¦Uà…¨Z¤ÊzQkŒL]ä´ïÄGDømnR§~gé¸08 5Ì¶·xÔA§5ØÍáÁ)é{­1š[Œ,viÔ¨ëñÁ("náâoÃ¿h¡ 1,¦¬(€ûtd8uõ_Ôv·¾i?QêN|á_Œ3ü¶Yù•¬$”²rã]´@ã£N(2qP­#šgó(b
D@¢C(¬ì¢@éî;¨ivW|ñ¤§iğï…Â,‚|ç$Ìaí
ß%ê=SıßÆ·càëı#ÔO¼aªÂ§ÿ'xAµÓîWgh:ëFÇ+€¤ù< #Ššú…1İ*52À”MNp5ciñÎx[‘ãÊeòAoå|!è|”*ª/¡­6{úÜÕ_åmKJåÀT ¢#û¢u<iÂ'ÇBOúIj¤%m0#È¦Åò5	8ôMN¨SÒígn$(hp¨`­1¬\„LI3Ş³i£ë^Õ
H$ó#¯ä÷(.è‹!¬æm«§õéİı ªæİ%ÇZhó%Qé87ı ë¦¤¥g0âÁHc%øéOq«dÂêá_¬¶8T?âÚ pàÌ)ª$ª !/W&chÛ!V-ˆCL-ëPg³¾¶}…oYhg³e¡tˆèr¶WŞ:!Æ#k„_oãzô’êê
ûŒï&Â  h _õ2¨^øî®ªòÄZØ|B¢F§C€(Ø¬+oîs˜ì í~ÅY]Dbzh^y]š¦×"‘ŸËË ‰d ’ B$³;uŒå*ûuu"yQBPûÂ~ïeÓIU‡¢IÁ×L'Rôcjzæ ôHè%W_²Á¸H|àuÁA$mÌcÀb.?&ÚaZ/Ø>o¦(q‚h´tËKç6cÓÏc£fµ¢™'`ígF>®¨ñÃ Ä&ƒkHÅJŠ‚üğ¬‚8B¨F{ ®ÙXøÑ0ã#w¤eAP>üs~†5¿,9blÙ’B7Ä7?"¡ÄBÓ¢T¡ÎhÕã)WsVëŒèLà ²*$G2³q Ì-3Ëoq@â¯ïAÂŞp_f©¤³ÌUÃO¿(V¶!Cnì2°kZyÊ`t`bäíÜ "FSôN'’b
/U^ Fœ¤-"ˆ à"Š«âÆÀ=îèNcÔ{æ¬6˜{õå<%”J+4ú}q¯á/‰e\Îw³ûnTEˆ«Ù>öbÖ.Ap¡l0VºÅ>;s5j` 2) Í?¤Tf–Pâ0¹ci¥ÈvÎãü)¨ÇV]ağ©`©šmfh8É¼ ;>º.m’³b{ä/ÛÕ\Às2uƒ8@*‰!gâ8ç4"^Ğ» ‹wáí¤aûÔìz(%Ôõıd#dâ…ê¦æ'HeŸbj!rh:1ËËÎ´ı²9"Ó0ÛäZ¢Õ) ›“á½Êépr:ÓTî:ùÈAŞY&k`N:şoÍË3TírWCV¤]*&ê÷Ú>5^i0$–T}D>, ®¢b)…c.ñ~ˆÃÀ^RÒV«ÅUÕ‚À! #Ñbúáá ã¬ à°%ŒeB*§vuTy7¼ºìaM~Ù2EmÙ`háéstó…|Omeq¾…Q£÷.‹|Á-ê"Ïá²«/Jƒ(‹•95ìTPïÒ9`dYé İ#=Ê‘&i$GôóxEx#dx-N^UëÍÚp’q|äa´HF©b-è¥`z02ƒÄÕ # é0Šaàì.Ã©h‘0ÅP7ôvıÁwiĞ}nˆ*¥··¡y@,@P &d Jíx ;(eytà(aÅhÛÔ¥º4e.³*%2XÔ~¢í"eø(èbÆ(TzeãL±¨h$ceùúß8 a %³âé»(Â`fekL9N"e×¦wåı½i|Í'$ğNØ¬ga$dE„ş¨xx!äà,‹¾ 1&\q'Wäól‰l´t®«6(òõe;`ù©pSéæó/43·]Z7Ş !˜uphŒè~Rt! ªK´7 İx0GĞ7Hã~ALiHqE-x:`0ch•h@f@¬p1å£f·¾1`R;;r0ã¾C e\ø´d ÔE12**²`é+€óDoÅ““}ş!®'¢üÆ²phtp 40väÏJ%eàp°ç&0•ïwFõGWÀ"ˆø)9´R~)FùlIUFh($92—l?ik)“[1:73Ì3;ûaNFq …¤é÷h¶.aqÁ ö[¢VİH$]€>P1uÍá¹_ŠmT1!FsşÛ¥&à8–p 3(Ó(|¿QàA&Eò Ä.H´»=Ñ>š H¡Nr‰8©`©1s¨†àÀ$°Ğä4®9aeo@Êo4,rîX'î;%§~ËH. !†d‘&¾_De „<vp)iGa™h’ Ûğì¶*8p"÷`NÍ(,EÅkD5¬[	ö¼}3nwšRË±r\,¸(uo;äò"Ínä1 6I`€,ã)KJ# ;á€J2¤”"	ä6R},an•±l¨¥fA¼r87ålÜpí~Orü‡ä ¸ÉB$ %dyAM¤ùqgeï¡­|‹¼fÅ ç˜¢À2½w~ÏOl=aÃ@"äc²|­ŞÔ[+*µ ÂWk?bBa|"q` Œ< Ä`a?Æ·±
JÅvQÔ°´SpNw¤¼dé³—¦S°§/ˆ7KR€.i¨Ä	\Y(dtm°H"ôd7+{Ç\Ì¡!“HD k £ (x:r° 1AÅe~%=UîÍâŞ,€O(”j,ªmdcoüê^	}à*İñ0o"tx/‚©’Duí¶±t•åŸ=Ûoê{ŠA.pâ| ´Ç1=(d²rÆ-¾5tfU‰zÈ `fnò8<lÔ=fBzDm! /PŒkIİkkÓ±Ü®ród gtkR´ulx×Ëã]0UÀ4¢Ê œ²ùm$Z &îO¬lxiÑ ;‰0ä%›Î•<g8gC-"¦ TFha‚tø¡0Fêhìs(¶q|Á°áá¨F=h-`À!ê7­ÄHSM46ü?Öà®`ºÌv¬
	0roäde`Âå8Y¥C‚Ä$ Ëgñaècœ® µŸ±ÅÒƒæ^æ2~ (½*îJ)mÈĞ $Æ¹Î=(9¾e+) G¦Ü3wãg.âC:vØ3n¢Vaxèi>JSk)ÙE|.…pá]oíµcC;ÛeÙ ½óPü0v ´Âc,ĞzˆO!+ôhè°õ`]$(4 J4'(*ãKÚé¹§R') ú y+$4ì¡(:‰ ú@a°üD÷méwó>©¤f(@`a³ ñø0b …0sb ´åtøE¤s¢'aD6‹F±
±¡DîØåç'gPy±°d Ò3±5(g½Trd2Xª+«è^$éîñ|ã2- â$ykpE¯F#áCL<sMgòø#Y¼u‹$Ğ*»n}>fÇş'/äÇlúhàUğµ<á®6¤sâ(,À8L İ%÷Ï!pbğåEgpkT73«¬ $`4!áHAù)¡*!íÙùVºVV?<
²5u;æí">Hü v$¿êNå¤|?4pƒAH$Oa¤aBg9QŞX«tslDöÉçÄ–J=,°@¥=çY
Gtƒ¢5r-ã#igÊ)÷K…Ñ:’(!î-4€iÁq¼UOÆMâ¡	Ö¥fYí?Ñïã ®õjq@¯ EëzÊg’c!)ÌjVÙt£xEB2 @`¢%¶39)„5êflö U³4gê`kj+Ğ½åêÈ¸ø¼,2bf˜bß‹ iˆy:óµ1y}GïC1p8nåt4 m57%.i0O‡oãn )µpÑÏJ:^H’|q(±¿¼pe€ J1æÇ,ngÆ5t0¬bòwR{D­¤$RD_D„_3g£bu,‘Ê7=®<}u ¬`š±e`Å D ·©õdïn@¾3Pwp9ànYd$#?9T…   •^†,dDÿj5_D¡ap@p<L4 “°c"ÂÀQ1}9pBkm¾;şt)sFÙA"l'1{!ü¶™[lDx±âÌ:"Ziãç´Y¹f17µÂÇftn¯Â8ƒÉùºE³4âõgdQltÄ~M~q!®š%V"p äfG"0!…à ¤¨TDãVaûr+{UQ~=¶'tº±ÀERa…Û™¨ 9	:ˆ±`" acşÃ*6]`µ,ÿ%m‰äblMıªè0]FÊwO9´l÷B-RºLo®¿Nl8å@b?u&â§Ùqäxua˜'r@;,[÷×`1×W£9îŠY }‚'àƒ$(Ö`%¹!0 7=ëWöbá‹+0‘$Tqšl?%Eûr3"ç3¥*vx³3ªˆ' ˜ŞÇ¨g]Bs‹Rân,‚„K¤Êe)”ìLU#ô#"` [C0©²¡À¥ hû€$ì¼ % €+ñ÷á)• 4¨<0=u^pş1ppIPxx»h90yl1 ‚w .&å 73â7AòE°Tk®éı±7}èãekáXNçÁæë*x(¤AB  `ó-Ïiµ°<H[ÂãagÁqÉ×•]ªÂ®ÿ×V"BazÀ“xè øòÄo½$QñæÅûLg2Wùø‚zz]émâç2H° iõA<i¶ \ÛfB	1R>/+:ÔZİ¼Òd¸ßeÓ²öCT:j±7 Lu€<ÖæzºÅIùV „w«
"- MD —~u]ve~O_.W—6â¤­3Ddô!n^<áEÄm¤å4=,!_m&?y§cbvs¬mó‚~ŒgnUdo-›/k±Å^eäˆK!€¤mHud/EPÿ?êwª”¢Ÿ /B5%à>¥wÙœQåü<uÙhnÎWáfP!¥iõ3H=Ù~O 7_5¥tøk÷ÏíÎT¬&—P0..›bÚÏ~2¬Ï
¿‰·aGpry=åúÚ?Ğ©ğx9Œ¢ap -wß¹9æã¼6%LX©‚õ_p·(0@q0S°%`C‘?+ ‚yèˆî|/S° e¶!/*Ã_G­Î¨V¦Ndá\Iµú ´(µ¹Ğ©aq²«òLûGhíP »h¿] å-J)Ñe ïUäí6.‡'!-Š©¡O·f~$FzefßâzØ	uu¬ì¯Y)P`I!ã.Ñ2â<ÿ@!Qµ‰ïwpve,Àˆlm"Jˆ6¼ôıRÃ	¼#vq83UMü£  -ìf|mhn ¨/0Š…(+>ğx@4ˆY_wRœÅw$XŸ,)3!h>5ø¼V qaƒ{ˆPdãägg!qe©É¬nôın¦J¨c"E&3ĞVq%b5P¥8yíe0³A+iè«QÃeAmd$WÒ%ÖEá{j,şÚ:l*kõõäİ6si&`Ö=dÎaæñiÌ5pğtcsNÑF=ùZü»Õr=@u0ÂQ2ip€ì!ìsküS”í‘TEGC‹1Bxt:óÌy/{9[² g÷}rfl®Pxsğ.~Ó
|øqŸi[ÊL^A%i±u

22UZ0$Døí¿lãlU[­vvhÜ`ELkmDïÉ·0ı ,pÁEDp !u¡}
XqÜi®'R(¨÷s+u! ´­"9\-áop'v.”®n ¿DfW(e&%µ"T~,It ˜oµNwk2vóí&v¿eâÍ¨-fQlBş£h:ôìùeyem9Z ÛhÌ³kUTñ›LœŸÀQ!d³oíntùŠÁS>xªpTSv©’5QIlPÏğa]õwpã­8t·ğBı`F ¨Xdó(ñ³UXÌãxíb.Å°*9à1 ®ìï¨#vÎrop‰‘#Õ‡F$/3ÂiÄCû^a:²J)Î¨ ‚©w4Ö´5{%ıÃkäQ€`!´87„;ìÜTFŠöñ}%eX*pÃ­˜ à ¡Kcc7”?¾äÊH8$<¤³$:ÈèöÖ‹¡· ÕI;qah×Qá\*s£|½¨^s/4)±‚„/³3]äô¿&O@r`VpPd»)Ïn…ëô 3XQ/õ`7 e£hÂÄküb¹ên
E`â3'9 Bî´YbRa{A'!•
âWn;´¶6DĞ°`vt32>c,Ei¦:çB´¹» hrM"hËãè%…sãá4¯7Yzñò«âd0ùlšW« dw.sÍ+L,mÌÔìå8¡QuXhm8n}k¼U#is}JŞ§È-;6Fg sóxà©J6âa/ ¢0r0<d`nÙ©Qè½òlcâNâä\şeiq‡@}(q'gçã(J~r‡¾zäR($</`Iğm6 İ€ó%¿õÅmî¸Â£Aö±_ŠZX76$ºº‹Ç0± ]8:aHúS 9}]a8O¾R-‚5¢¯İ§cu±f1'E©Ì-eFtPrË·éÒç‚Es	4Ù!k`ª†D3€õ_+]îÎrãmJ÷éy@¥–/½*ààù nvk!5(((~}’2[{/KÔ=¢Q1{m2ª=­,Ïh“ !yC``_µSÉ4£AmF>\À|kûi^öOpø"ÃZ¦"wa*!xj	zİ ˆ$% §7»ôBwïK /”…wûÎÂF¦v°j+ #`OSyh’&ø‡¼Yll1=çwì4%l°"d¨3 #"ßüLtz"VË&G¶!ñiVød–?®uÛ@Ö®X·%B'b}RÒ£%x¥^)!4Z1!0'ãA®9¤š”qÕB¯Ûiî¾ÂAa` €(|c(2eíñËR¹fªv
o·¸~¹‹@ C8¡¥lbç·Ä~q~d%Ñ³(º-D#”ä«@|{mzhĞ»fÌMÄMËıp«_€ØİïÊİ2AE=t9£Wfës	~±yem*)3uRù#C.Îÿ0.3!Ãd©+ä	QË{E2×Ü56á7DLg¾6xlùÇY1y²1*¢«? vu¢l«7SP÷ö'i üÊ-rR1xô®Ñuá¸"°à6ù¢¥¯~iLç$ºy!Ò¦¦€)Š¡1E—PZ'\êqpfRzwcy&=R+ 1 {¢søQüàJ!02r"öz.u0šWz·+«\JrSö-Såæ$?~§61Œ&\aÒÔå >ôîg½]U%¨ŒîÖ&ú'7³7öl(V4–ô"¨ÒT ~"4':÷½t‡ùğm9;M1
å8õ¤D Ï2¿ÿluúªq,mD{¶.ª¤›Ôé¬h]t^ jä{÷.zRPv³o!nan$ã¼)ù8*ù-Ú4´@¬ o¬J~po‚Â ştvÓæD4çiue,1#=(ò€U!I	©}j1ffqn—n€Mcôô°%š
I:(E. *u¥1o+_äVyn':ãz;kŠE g³6~&ònÒBEã/P $‰Q7¬#}Áºk¹`.iä¤ğ:, n¶ºÁ5ˆÓnlpt¶ãod1oQW^è¯yO2FU6òW(‹w«!¡|ÇÆd×"›(°G7ìgŠsıôõ)-ÔÃ5~G¿ ”<:›XÇ!6sê-å<@ewö
ä0p8$”†f°ïY!{JW%qyDKrÊít¬vŸF³	½k§o5sËè´'#:3¾xfò( á¥A#!KEé>1P	j
kíµ#R¢e*I`dò;E +bcd,µ¬1EtÖótuH¯x .ïú-±DÙg2eœa·C`.?ä·]“˜ pg$+§h¨ìvÒ¨ %dp ¹ñ­ï Eb<IbAÿcrãrÇâalÀ8CzêGeoÖuZ}€Ãn ê(vk3cwä`c©gdJfdgiZê0Loã{T©u,]ºåÑVøë]ŞtfhÃ}~øqKp ğ$OğBôg÷c°`èO§V²K½oĞ÷|ùÊä «F³yßé+„i<qĞ$momÏ/¶‚¨­ÕeEmËõG,g-ód%~oE <8hO~“\}°£}è%ºUVğZQm$aRå(e¬!Qq`A,qªŠŸlD8@à0¤wwqs”ÁAj¼áw¯P5*TªbvÄ~3‹aæn‡b!)ğµ ±j‰c;(8Z9Õë-%°¿ n0Gd¡Î`å '5ÆY"äºvÅÎ{7ñaLø+s$‡A÷ÁöÁåuçd~ ˜s@%şòãqbcU[>˜à hr'sbwŞW+ ÄH§galrv
a¡¬ ¤w4ñfw¤QQ"k+Xdc¼CUeŠdC``<½SrºF4 UW½kîAeÜGÎağN Ô<x|y~8$FE~u)ín¡o(5
ÑzG?7©wü¤Fáòš(¯aV|ä##^»‘ `c¼eW=0ª8hEÑçD4PMb<GZŠPÌˆ*b>ÚB¹*-RÀO}wÁñSö34¥""Xúğ÷Ç"#h6…%~g .¦PÕ|+]bË/&ñ$ j)‘.îà‰:!§Ùt`e)È=e %öj+<6xê
f’tAüiâP˜¡,åán5k@Ø[_W-)n‘Ñ äa-vØ¢®($*gsæ[Mfu1#&aük!£¹Úıt1/I·0üœ2QÛ"ï4¬U|äôDpòåaÜQYb%5J@zĞóŞ7\ïSöX åôç1òİ.YxÙ”}Ó^m0O¨Îğ`g^]JÂ#1#%iC&ÅwgÚ\¤nHAr:v4K9}­S8jğu£iH«$m`ï°™rlápoØu»Ú*—*²†n·U7oÕƒi!æRZhräTU$~|`T,m%l^HçùrfÇ W4itT@lu/aËän?$ë)$©9å>{0é q<-İ6è5ğ½,ˆ{tçâbà8ANXF3ç}Jx¯6ˆC5å40qç®I7 )aĞsò¨)hA(Pt¥ñ¶ª<gå4ìŞè] EÅİ8c‰mf~mõõzFø‹İ¤ù†7÷ø,¡wm@(2m*´ü9²}`Y8<a`c.ÙÌZyÈ‰ğ†Š[VzDC$Ğ#ìa¬¶ A…,aó Qé–lÑ$¥µÅr61fe1èR¡t…ª& u2,	à]ûmN |`ƒ~Á°ô$³lüB4O)&:g|â f¥u\7be”‹.zõ@Sm'5Dm‚­­|,À9ò·%AGCt=)^3	á²êosÔ¿uõz¿AGı&¡âƒæ õ<p½õÚ¥]e0hÑ}Lñ?” ^mBeØæ“Öv	ß@ğ¥5¶1ğêoÃÉdC­\*á0©2P{ï&%-7wñPæå6a¦\\›8}<(Õé€À•gØIàò°§tá8ƒö"Jı.8œp_øn¯ql¦¼cá5B?!dll¾m@RÑp-)ïR3¹½¢Q"ğ§“­H%r®Åó¥§áa!u)ªeÄõü_wvv’»j$ıi‰9huTGæÁ©êÂÓXSá£~ƒ)àf
ó@°IHöÎ_¢€%ğá|ğmµ®i<sãs"1-º÷ò€ÉKeü{€t,Àå¢De	y(Ã©ı5ul¾jôJ£+åsmi0ÙEA.ôè{º$0  cp>l¨FbScÃ¶xÈö¨_lñİˆw>ÑiãÖ\¯ m¤²ûÍi!QÙ`zÜ…Ÿ¡Ë*ëÕ-‘*W9Ò3&ôà]ë::To¬±m©@7o*vMíà-cP5à44ôjìLPØV<f5#T&½páfLÛ)O5¹uV®ı¨*âábt¸3 mdlÆ6JĞ•`)%xB#%bqVqTÂsF=Rl¥è6u:åroÍw ùVõI{±sT:¢şN5pÖä4E/¦õ2GÄ}SX@ú>p{bv¦U8	íºÕ©Ktv÷ÑàuQşÈ+oğ9,o>xiéê)÷Tf6˜`5ú|4Ôë0¦.˜'v>\{lSƒrP;iQg5HkÃQäşÿÂ&uK9UxV 0)9=m(Bb‚rn>¦laeÎz$òê :Ènì1‘ug"ñ7AíÁ}§	i4Õ¯T&2Ñ=sm;ğ…m;{ªiÛì@{4/tª«5EKË q)@F°O¥ÍØ!dNl[Ÿ·"Î†$>á>>(rç&(!ZÉgeb|÷- yo¤-Ü|èín3 ëò*|coòµAké
D!XJ-Z˜ú¿ÿ’HØqÉoªhñ,0³S,ùb´ —sgé… ¹±¤lF q÷¶F2… D¢Ïˆai1f8góëbií¼lIìÀFd"!ÚW“5¼"E¤T{å»©¢=Srª ¸%3cgÄ:­N8VòK5w:vè¡jµLÕ”Ó<s&bL4}a¡véj$‰o_bcpHBkh÷S_n­¶“x{œa` Ø…¦ 0 oºÛjz`à$ªcz´gƒ+=!DmšD,¼hyª+`…cßì¤V.ĞzšoVºtÒ7:m„õbéx—hOIbQ¹kg qê0æ¬jP3DIngQ3x0V´o!fN¿q0dˆªú@¤}`Q½3Jï=lzAjnü d ¥µ›ÌJf3mjR&|"á
¸§99!5Ì —PÑç1	ÚÉcÁ)á\¼1’Y©e
)DöÑp"njfoa?`o%a5/x§,¥ld{t,<tÕT0—ªH;Q¼jƒláØ;}¶Sù±üd„š&ÉM$¶Cacb`2qR¸1 :$ âW'Ìd¾O.<ìæJğş3 iâ_öàäã(ğï…<B¬ryş$ÈT¹ß= 93|ÛÄ"ë¼ï41]¼!+j§ûTQ´r¯WetkªÃ¯„${}0+	º²­1œ 5:À¸'mnrucy•cp[“ãİé tAog |"è#|.¡íu;0£Ü5İämA@`ÀÖ f[¡ù¢p<xQF% Fg:	+V= ÿ !À†0¡ò5g8ôbˆsğôcl$(X`¬(hl3¨T¶Ìy;¾Ú3i¢gMÙ5	´sa*õw('¨#¼ç{«gåëQk!¡ÆÜ#e‡zdg$@ù87 ¿!ãä„¤¯ "`lc¡Ğì1Oó+dÀê¡¤·<\,æDaeÌ/‹¶ªñi/W&b¬ûAW+ŒY$9ùP#»w}Œ¯QhÇ±e-£p°àp¶VÚ: 7k…ıoó¹hrô"ê #…l§   hÎ!wÔ2 ø¯  ªrÄL\N²EçBÚ!#oëQ­%æu}Njziaš¯×3=®ác œ-I$ d@±2~$+åœ>ûnõ ñ@PøE~¨ÍyëDÇªiåGLbxCjzâ€p8*¥âsÁ¸ÄlàµİåKB%mLkĞJ>?.!
'È8^i"h0 ö|ËCgwaWOk«šæ$£0'pï)äO>n‚ùYÃ$äg›kJEJÇô[¼’>bpnx0ÿÁzyÕ£#w¶fe0Q:ıs~†µ9,yúaLÑğ0;ä¿-«¥ÕnóˆT¥`Ôc+p7té¬*s6£$$G1sa lo0Ân3Hà§ïAÒÖĞ:`ú(¡ÌUSxQ·(¶!ni2°+XA‚`u`bä­¼06ÔSô-7OcnmUX&,$¤-"1`Fh‹ÂS/P=ÊèKB—¿d¤|;uá4v°K:4zWt/t?÷9Æ|°²~U±<É dV6p!,2F˜v#{$¶jiQğ,)vÍ?7u
Šqd1ùO)%·èvLÂtc©Ãf}Åğ(f4ú~h<ÉğcºÚ6o‚³ !è+ZåF\ÿ 1{2Uó5h(i'aæâ¨gu7~Ğx4µ	cé­¥q»ôlû)„`4eD#â‡ó® ¦!IRD®äd%bzzC‚í¶ü³1§×Vßôr¶aG, Ñ–á½”¡©rb3vPîš*íIN<)%ghN:¸+æé§Åm°gy>l¬	ª&æöy>2wQp¬—T0Äd.:¯  !m'¨Q/f<‚ÄPR«W¹ÀQÄ 9&#Ñâ}á  ó®FG´m®*œnM; vu8q÷¤¼ğaM=»zı9@he¡#%±'4)`8¾¡1£s&e7Ñ%Ê ÿ`n‰/ú‘¹«95uÍ0P çÒ<àdy}Ã•#?ÉÁ$t¼GørºtH!8ˆl\%ã­Î!’qvä%4Ì†©b-f)Bz32
†Ä`3" :Š àû$`¨À£wÅt6¥icéP=yî "a½¿¡q\%,@ `netcdf_variable` of length one.

        Raises
        ------
        ValueError
            If the netcdf variable is an array of length greater than one,
            this exception will be raised.

        """
        return self.data.item()

    def assignValue(self, value):
        """
        Assign a scalar value to a `netcdf_variable` of length one.

        Parameters
        ----------
        value : scalar
            Scalar value (of compatible type) to assign to a length-one netcdf
            variable. This value will be written to file.

        Raises
        ------
        ValueError
            If the input is not a scalar, or if the destination is not a length-one
            netcdf variable.

        """
        if not self.data.flags.writeable:
            # Work-around for a bug in NumPy.  Calling itemset() on a read-only
            # memory-mapped array causes a seg. fault.
            # See NumPy ticket #1622, and SciPy ticket #1202.
            # This check for `writeable` can be removed when the oldest version
            # of NumPy still supported by scipy contains the fix for #1622.
            raise RuntimeError("variable is not writeable")

        self.data.itemset(value)

    def typecode(self):
        """
        Return the typecode of the variable.

        Returns
        -------
        typecode : char
            The character typecode of the variable (e.g., 'i' for int).

        """
        return self._typecode

    def itemsize(self):
        """
        Return the itemsize of the variable.

        Returns
        -------
        itemsize : int
            The element size of the variable (e.g., 8 for float64).

        """
        return self._size

    def __getitem__(self, index):
        if not self.maskandscale:
            return self.data[index]

        data = self.data[index].copy()
        missing_value = self._get_missing_value()
        data = self._apply_missing_value(data, missing_value)
        scale_factor = self._attributes.get('scale_factor')
        add_offset = self._attributes.get('add_offset')
        if add_offset is not None or scale_factor is not None:
            data = data.astype(np.float64)
        if scale_factor is not None:
            data = data * scale_factor
        if add_offset is not None:
            data += add_offset

        return data

    def __setitem__(self, index, data):
        if self.maskandscale:
            missing_value = (
                    self._get_missing_value() or
                    getattr(data, 'fill_value', 999999))
            self._attributes.setdefault('missing_value', missing_value)
            self._attributes.setdefault('_FillValue', missing_value)
            data = ((data - self._attributes.get('add_offset', 0.0)) /
                    self._attributes.get('scale_factor', 1.0))
            data = np.ma.asarray(data).filled(missing_value)
            if self._typecode not in 'fd' and data.dtype.kind == 'f':
                data = np.round(data)

        # Expand data for record vars?
        if self.isrec:
            if isinstance(index, tuple):
                rec_index = index[0]
            else:
                rec_index = index
            if isinstance(rec_index, slice):
                recs = (rec_index.start or 0) + len(data)
            else:
                recs = rec_index + 1
            if recs > len(self.data):
                shape = (recs,) + self._shape[1:]
                # Resize in-place does not always work since
                # the array might not be single-segment
                try:
                    self.data.resize(shape)
                except ValueError:
                    self.__dict__['data'] = np.resize(self.data, shape).astype(self.data.dtype)
        self.data[index] = data

    def _default_encoded_fill_value(self):
        """
        The default encoded fill-value for this Variable's data type.
        """
        nc_type = REVERSE[self.typecode(), self.itemsize()]
        return FILLMAP[nc_type]

    def _get_encoded_fill_value(self):
        """
        Returns the encoded fill value for this variable as bytes.

        This is taken from either the _FillValue attribute, or the default fill
        value for this variable's data type.
        """
        if '_FillValue' in self._attributes:
            fill_value = np.array(self._attributes['_FillValue'],
                                  dtype=self.data.dtype).tobytes()
            if len(fill_value) == self.itemsize():
                return fill_value
            else:
                return self._default_encoded_fill_value()
        else:
            return self._default_encoded_fill_value()

    def _get_missing_value(self):
        """
        Returns the value denoting "no data" for this variable.

        If this variable does not have a missing/fill value, returns None.

        If both _FillValue and missing_value are given, give precedence to
        _FillValue. The netCDF standard gives special meaning to _FillValue;
        missing_value is  just used for compatibility with old datasets.
        """

        if '_FillValue' in self._attributes:
            missing_value = self._attributes['_FillValue']
        elif 'missing_value' in self._attributes:
            missing_value = self._attributes['missing_value']
        else:
            missing_value = None

        return missing_value

    @staticmethod
    def _apply_missing_value(data, missing_value):
        """
        Applies the given missing value to the data array.

        Returns a numpy.ma array, with any value equal to missing_value masked
        out (unless missing_value is None, in which case the original array is
        returned).
        """

        if missing_value is None:
            newdata = data
        else:
            try:
                missing_value_isnan = np.isnan(missing_value)
            except (TypeError, NotImplementedError):
                # some data types (e.g., characters) cannot be tested for NaN
                missing_value_isnan = False

            if missing_value_isnan:
                mymask = np.isnan(data)
            else:
                mymask = (data == missing_value)

            newdata = np.ma.masked_where(mymask, data)

        return newdata


NetCDFFile = netcdf_file
NetCDFVariable = netcdf_variable
