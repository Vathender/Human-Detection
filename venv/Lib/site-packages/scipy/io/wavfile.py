"""
Module to read / write wav files using NumPy arrays

Functions
---------
`read`: Return the sample rate (in samples/sec) and data from a WAV file.

`write`: Write a NumPy array as a WAV file.

"""
import io
import sys
import numpy
import struct
import warnings
from enum import IntEnum


__all__ = [
    'WavFileWarning',
    'read',
    'write'
]


class WavFileWarning(UserWarning):
    pass


class WAVE_FORMAT(IntEnum):
    """
    WAVE form wFormatTag IDs

    Complete list is in mmreg.h in Windows 10 SDK.  ALAC and OPUS are the
    newest additions, in v10.0.14393 2016-07
    """
    UNKNOWN = 0x0000
    PCM = 0x0001
    ADPCM = 0x0002
    IEEE_FLOAT = 0x0003
    VSELP = 0x0004
    IBM_CVSD = 0x0005
    ALAW = 0x0006
    MULAW = 0x0007
    DTS = 0x0008
    DRM = 0x0009
    WMAVOICE9 = 0x000A
    WMAVOICE10 = 0x000B
    OKI_ADPCM = 0x0010
    DVI_ADPCM = 0x0011
    IMA_ADPCM = 0x0011  # Duplicate
    MEDIASPACE_ADPCM = 0x0012
    SIERRA_ADPCM = 0x0013
    G723_ADPCM = 0x0014
    DIGISTD = 0x0015
    DIGIFIX = 0x0016
    DIALOGIC_OKI_ADPCM = 0x0017
    MEDIAVISION_ADPCM = 0x0018
    CU_CODEC = 0x0019
    HP_DYN_VOICE = 0x001A
    YAMAHA_ADPCM = 0x0020
    SONARC = 0x0021
    DSPGROUP_TRUESPEECH = 0x0022
    ECHOSC1 = 0x0023
    AUDIOFILE_AF36 = 0x0024
    APTX = 0x0025
    AUDIOFILE_AF10 = 0x0026
    PROSODY_1612 = 0x0027
    LRC = 0x0028
    DOLBY_AC2 = 0x0030
    GSM610 = 0x0031
    MSNAUDIO = 0x0032
    ANTEX_ADPCME = 0x0033
    CONTROL_RES_VQLPC = 0x0034
    DIGIREAL = 0x0035
    DIGIADPCM = 0x0036
    CONTROL_RES_CR10 = 0x0037
    NMS_VBXADPCM = 0x0038
    CS_IMAADPCM = 0x0039
    ECHOSC3 = 0x003A
    ROCKWELL_ADPCM = 0x003B
    ROCKWELL_DIGITALK = 0x003C
    XEBEC = 0x003D
    G721_ADPCM = 0x0040
    G728_CELP = 0x0041
    MSG723 = 0x0042
    INTEL_G723_1 = 0x0043
    INTEL_G729 = 0x0044
    SHARP_G726 = 0x0045
    MPEG = 0x0050
    RT24 = 0x0052
    PAC = 0x0053
    MPEGLAYER3 = 0x0055
    LUCENT_G723 = 0x0059
    CIRRUS = 0x0060
    ESPCM = 0x0061
    VOXWARE = 0x0062
    CANOPUS_ATRAC = 0x0063
    G726_ADPCM = 0x0064
    G722_ADPCM = 0x0065
    DSAT = 0x0066
    DSAT_DISPLAY = 0x0067
    VOXWARE_BYTE_ALIGNED = 0x0069
    VOXWARE_AC8 = 0x0070
    VOXWARE_AC10 = 0x0071
    VOXWARE_AC16 = 0x0072
    VOXWARE_AC20 = 0x0073
    VOXWARE_RT24 = 0x0074
    VOXWARE_RT29 = 0x0075
    VOXWARE_RT29HW = 0x0076
    VOXWARE_VR12 = 0x0077
    VOXWARE_VR18 = 0x0078
    VOXWARE_TQ40 = 0x0079
    VOXWARE_SC3 = 0x007A
    VOXWARE_SC3_1 = 0x007B
    SOFTSOUND = 0x0080
    VOXWARE_TQ60 = 0x0081
    MSRT24 = 0x0082
    G729A = 0x0083
    MVI_MVI2 = 0x0084
    DF_G726 = 0x0085
    DF_GSM610 = 0x0086
    ISIAUDIO = 0x0088
    ONLIVE = 0x0089
    MULTITUDE_FT_SX20 = 0x008A
    INFOCOM_ITS_G721_ADPCM = 0x008B
    CONVEDIA_G729 = 0x008C
    CONGRUENCY = 0x008D
    SBC24 = 0x0091
    DOLBY_AC3_SPDIF = 0x0092
    MEDIASONIC_G723 = 0x0093
    PROSODY_8KBPS = 0x0094
    ZYXEL_ADPCM = 0x0097
    PHILIPS_LPCBB = 0x0098
    PACKED = 0x0099
    MALDEN_PHONYTALK = 0x00A0
    RACAL_RECORDER_GSM = 0x00A1
    RACAL_RECORDER_G720_A = 0x00A2
    RACAL_RECORDER_G723_1 = 0x00A3
    RACAL_RECORDER_TETRA_ACELP = 0x00A4
    NEC_AAC = 0x00B0
    RAW_AAC1 = 0x00FF
    RHETOREX_ADPCM = 0x0100
    IRAT = 0x0101
    VIVO_G723 = 0x0111
    VIVO_SIREN = 0x0112
    PHILIPS_CELP = 0x0120
    PHILIPS_GRUNDIG = 0x0121
    DIGITAL_G723 = 0x0123
    SANYO_LD_ADPCM = 0x0125
    SIPROLAB_ACEPLNET = 0x0130
    SIPROLAB_ACELP4800 = 0x0131
    SIPROLAB_ACELP8V3 = 0x0132
    SIPROLAB_G729 = 0x0133
    SIPROLAB_G729A = 0x0134
    SIPROLAB_KELVIN = 0x0135
    VOICEAGE_AMR = 0x0136
    G726ADPCM = 0x0140
    DICTAPHONE_CELP68 = 0x0141
    DICTAPHONE_CELP54 = 0x0142
    QUALCOMM_PUREVOICE = 0x0150
    QUALCOMM_HALFRATE = 0x0151
    TUBGSM = 0x0155
    MSAUDIO1 = 0x0160
    WMAUDIO2 = 0x0161
    WMAUDIO3 = 0x0162
    WMAUDIO_LOSSLESS = 0x0163
    WMASPDIF = 0x0164
    UNISYS_NAP_ADPCM = 0x0170
    UNISYS_NAP_ULAW = 0x0171
    UNISYS_NAP_ALAW = 0x0172
    UNISYS_NAP_16K = 0x0173
    SYCOM_ACM_SYC008 = 0x0174
    SYCOM_ACM_SYC701_G726L = 0x0175
    SYCOM_ACM_SYC701_CELP54 = 0x0176
    SYCOM_ACM_SYC701_CELP68 = 0x0177
    KNOWLEDGE_ADVENTURE_ADPCM = 0x0178
    FRAUNHOFER_IIS_MPEG2_AAC = 0x0180
    DTS_DS = 0x0190
    CREATIVE_ADPCM = 0x0200
    CREATIVE_FASTSPEECH8 = 0x0202
    CREATIVE_FASTSPEECH10 = 0x0203
    UHER_ADPCM = 0x0210
    ULEAD_DV_AUDIO = 0x0215
    ULEAD_DV_AUDIO_1 = 0x0216
    QUARTERDECK = 0x0220
    ILINK_VC = 0x0230
    RAW_SPORT = 0x0240
    ESST_AC3 = 0x0241
    GENERIC_PASSTHRU = 0x0249
    IPI_HSX = 0x0250
    IPI_RPELP = 0x0251
    CS2 = 0x0260
    SONY_SCX = 0x0270
    SONY_SCY = 0x0271
    SONY_ATRAC3 = 0x0272
    SONY_SPC = 0x0273
    TELUM_AUDIO = 0x0280
    TELUM_IA_AUDIO = 0x0281
    NORCOM_VOICE_SYSTEMS_ADPCM = 0x0285
    FM_TOWNS_SND = 0x0300
    MICRONAS = 0x0350
    MICRONAS_CELP833 = 0x0351
    BTV_DIGITAL = 0x0400
    INTEL_MUSIC_CODER = 0x0401
    INDEO_AUDIO = 0x0402
    QDESIGN_MUSIC = 0x0450
    ON2_VP7_AUDIO = 0x0500
    ON2_VP6_AUDIO = 0x0501
    VME_VMPCM = 0x0680
    TPC = 0x0681
    LIGHTWAVE_LOSSLESS = 0x08AE
    OLIGSM = 0x1000
    OLIADPCM = 0x1001
    OLICELP = 0x1002
    OLISBC = 0x1003
    OLIOPR = 0x1004
    LH_CODEC = 0x1100
    LH_CODEC_CELP = 0x1101
    LH_CODEC_SBC8 = 0x1102
    LH_CODEC_SBC12 = 0x1103
    LH_CODEC_SBC16 = 0x1104
    NORRIS = 0x1400
    ISIAUDIO_2 = 0x1401
    SOUNDSPACE_MUSICOMPRESS = 0x1500
    MPEG_ADTS_AAC = 0x1600
    MPEG_RAW_AAC = 0x1601
    MPEG_LOAS = 0x1602
    NOKIA_MPEG_ADTS_AAC = 0x1608
    NOKIA_MPEG_RAW_AAC = 0x1609
    VODAFONE_MPEG_ADTS_AAC = 0x160A
    VODAFONE_MPEG_RAW_AAC = 0x160B
    MPEG_HEAAC = 0x1610
    VOXWARE_RT24_SPEECH = 0x181C
    SONICFOUNDRY_LOSSLESS = 0x1971
    INNINGS_TELECOM_ADPCM = 0x1979
    LUCENT_SX8300P = 0x1C07
    LUCENT_SX5363S = 0x1C0C
    CUSEEME = 0x1F03
    NTCSOFT_ALF2CM_ACM = 0x1FC4
    DVM = 0x2000
    DTS2 = 0x2001
    MAKEAVIS = 0x3313
    DIVIO_MPEG4_AAC = 0x4143
    NOKIA_ADAPTIVE_MULTIRATE = 0x4201
    DIVIO_G726 = 0x4243
    LEAD_SPEECH = 0x434C
    LEAD_VORBIS = 0x564C
    WAVPACK_AUDIO = 0x5756
    OGG_VORBIS_MODE_1 = 0x674F
    OGG_VORBIS_MODE_2 = 0x6750
    OGG_VORBIS_MODE_3 = 0x6751
    OGG_VORBIS_MODE_1_PLUS = 0x676F
    OGG_VORBIS_MODE_2_PLUS = 0x6770
    OGG_VORBIS_MODE_3_PLUS = 0x6771
    ALAC = 0x6C61
    _3COM_NBX = 0x7000  # Can't have leading digit
    OPUS = 0x704F
    FAAD_AAC = 0x706D
    AMR_NB = 0x7361
    AMR_WB = 0x7362
    AMR_WP = 0x7363
    GSM_AMR_CBR = 0x7A21
    GSM_AMR_VBR_SID = 0x7A22
    COMVERSE_INFOSYS_G723_1 = 0xA100
    COMVERSE_INFOSYS_AVQSBC = 0xA101
    COMVERSE_INFOSYS_SBC = 0xA102
    SYMBOL_G729_A = 0xA103
    VOICEAGE_AMR_WB = 0xA104
    INGENIENT_G726 = 0xA105
    MPEG4_AAC = 0xA106
    ENCORE_G726 = 0xA107
    ZOLL_ASAO = 0xA108
    SPEEX_VOICE = 0xA109
    VIANIX_MASC = 0xA10A
    WM9_SPECTRUM_ANALYZER = 0xA10B
    WMF_SPECTRUM_ANAYZER = 0xA10C
    GSM_610 = 0xA10D
    GSM_620 = 0xA10E
    GSM_660 = 0xA10F
    GSM_690 = 0xA110
    GSM_ADAPTIVE_MULTIRATE_WB = 0xA111
    POLYCOM_G722 = 0xA112
    POLYCOM_G728 = 0xA113
    POLYCOM_G729_A = 0xA114
    POLYCOM_SIREN = 0xA115
    GLOBAL_IP_ILBC = 0xA116
    RADIOTIME_TIME_SHIFT_RADIO = 0xA117
    NICE_ACA = 0xA118
    NICE_ADPCM = 0xA119
    VOCORD_G721 = 0xA11A
    VOCORD_G726 = 0xA11B
    VOCORD_G722_1 = 0xA11C
    VOCORD_G728 = 0xA11D
    VOCORD_G729 = 0xA11E
    VOCORD_G729_A = 0xA11F
    VOCORD_G723_1 = 0xA120
    VOCORD_LBC = 0xA121
    NICE_G728 = 0xA122
    FRACE_TELECOM_G729 = 0xA123
    CODIAN = 0xA124
    FLAC = 0xF1AC
    EXTENSIBLE = 0xFFFE
    DEVELOPMENT = 0xFFFF


KNOWN_WAVE_FORMATS = {WAVE_FORMAT.PCM, WAVE_FORMAT.IEEE_FLOAT}


def _raise_bad_format(format_tag):
    try:
        format_name = WAVE_FORMAT(format_tag).name
    except ValueError:
        format_name = f'{format_tag:#06x}'
    raise ValueError(f"Unknown wave file format: {format_name}. Supported "
                     "formats: " +
                     ', '.join(x.name for x in KNOWN_WAVE_FORMATS))


def _read_fmt_chunk(fid, is_big_endian):
    """
    Returns
    -------
    size : int
        size of format subchunk in bytes (minus 8 for "fmt " and itself)
    format_tag : int
        PCM, float, or compressed format
    channels : int
        number of channels
    fs : int
        sampling frequency in samples per second
    bytes_per_second : int
        overall byte rate for the file
    block_align : int
        bytes per sample, including all channels
    bit_depth : int
        bits per sample

    Notes
    -----
    Assumes file pointer is immediately after the 'fmt ' id
    """
    if is_big_endian:
        fmt = '>'
    else:
        fmt = '<'

    size = struct.unpack(fmt+'I', fid.read(4))[0]

    if size < 16:
        raise ValueError("Binary structure of wave file is not compliant")

    res = struct.unpack(fmt+'HHIIHH', fid.read(16))
    bytes_read = 16

    format_tag, channels, fs, bytes_per_second, block_align, bit_depth = res

    if format_tag == WAVE_FORMAT.EXTENSIBLE and size >= (16+2):
        ext_chunk_size = struct.unpack(fmt+'H', fid.read(2))[0]
        bytes_read += 2
        if ext_chunk_size >= 22:
            extensible_chunk_data = fid.read(22)
            bytes_read += 22
            raw_guid = extensible_chunk_data[2+4:2+4+16]
            # GUID template {XXXXXXXX-0000-0010-8000-00AA00389B71} (RFC-2361)
            # MS GUID byte order: first three groups are native byte order,
            # rest is Big Endian
            if is_big_endian:
                tail = b'\x00\x00\x00\x10\x80\x00\x00\xAA\x00\x38\x9B\x71'
            else:
                tail = b'\x00\x00\x10\x00\x80\x00\x00\xAA\x00\x38\x9B\x71'
            if raw_guid.endswith(tail):
                format_tag = struct.unpack(fmt+'I', raw_guid[:4])[0]
        else:
            raise ValueError("Binary structure of wave file is not compliant")

    if format_tag not in KNOWN_WAVE_FORMATS:
        _raise_bad_format(format_tag)

    # move file pointer to next chunk
    if size > bytes_read:
        fid.read(size - bytes_read)

    # fmt should always be 16, 18 or 40, but handle it just in case
    _handle_pad_byte(fid, size)

    if format_tag == WAVE_FORMAT.PCM:
        if bytes_per_second != fs * block_align:
            raise ValueError("WAV header is invalid: nAvgBytesPerSec must"
                             " equal product of nSamplesPerSec and"
                             " nBlockAlign, but file has nSamplesPerSec ="
                             f" {fs}, nBlockAlign = {block_align}, and"
                             f" nAvgBytesPerSec = {bytes_per_second}")

    return (size, format_tag, channels, fs, bytes_per_second, block_align,
            bit_depth)


def _read_data_chunk(fid, format_tag, channels, bit_depth, is_big_endian,
                     block_align, mmap=False):
    """
    Notes
    -----
    Assumes file pointer is immediately after the 'data' id

    It's possible to not use all available bits in a container, or to store
    samples in a container bigger than necessary, so bytes_per_sample uses
    the actual reported container size (nBlockAlign / nChannels).  Real-world
    examples:

    Adobe Audition's "24-bit packed int (type 1, 20-bit)"

        nChannels = 2, nBlockAlign = 6, wBitsPerSample = 20

    http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Samples/AFsp/M1F1-int12-AFsp.wav
    is:

        nChannels = 2, nBlockAlign = 4, wBitsPerSample = 12

    http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/multichaudP.pdf
    gives an example of:

        nChannels = 2, nBlockAlign = 8, wBitsPerSample = 20
    """
    if is_big_endian:
        fmt = '>'
    else:
        fmt = '<'

    # Size of the data subchunk in bytes
    size = struct.unpack(fmt+'I', fid.read(4))[0]

    # Number of bytes per sample (sample container size)
    bytes_per_sample = block_align // channels
    n_samples = size // bytes_per_sample

    if format_tag == WAVE_FORMAT.PCM:
        if 1 <= bit_depth <= 8:
            dtype = 'u1'  # WAV of 8-bit integer or less are unsigned
        elif bytes_per_sample in {3, 5, 6, 7}:
            # No compatible dtype.  Load as raw bytes for reshaping later.
            dtype = 'V1'
        elif bit_depth <= 64:
            # Remaining bit depths can map directly to signed numpy dtypes
            dtype = f'{fmt}i{bytes_per_sample}'
        else:
            raise ValueError("Unsupported bit depth: the WAV file "
                             f"has {bit_depth}-bit integer data.")
    elif format_tag == WAVE_FORMAT.IEEE_FLOAT:
        if bit_depth in {32, 64}:
            dtype = f'{fmt}f{bytes_per_sample}'
        else:
            raise ValueError("Unsupported bit depth: the WAV file "
                             f"has {bit_depth}-bit floating-point data.")
    else:
        _raise_bad_format(format_tag)

    start = fid.tell()
    if not mmap:
        try:
            count = size if dtype == 'V1' else n_samples
            data = numpy.fromfile(fid, dtype=dtype, count=count)
        except io.UnsupportedOperation:  # not a C-like file
            fid.seek(start, 0)  # just in case it seeked, though it shouldn't
            data = numpy.frombuffer(fid.read(size), dtype=dtype)

        if dtype == 'V1':
            # Rearrange raw bytes into smallest compatible numpy dtype
            dt = f'{fmt}i4' if bytes_per_sample == 3 else f'{fmt}i8'
            a = numpy.zeros((len(data) // bytes_per_sample, numpy.dtype(dt).itemsize),
                            dtype='V1')
            if is_big_endian:
                a[:, :bytes_per_sample] = data.reshape((-1, bytes_per_sample))
            else:
                a[:, -bytes_per_sample:] = data.reshape((-1, bytes_per_sample))
            data = a.view(dt).reshape(a.shape[:-1])
    else:
        if bytes_per_sample in {1, 2, 4, 8}:
            start = fid.tell()
            data = numpy.memmap(fid, dtype=dtype, mode='c', offset=start,
                                shape=(n_samples,))
            fid.seek(start + size)
        else:
            raise ValueError("mmap=True not compatible with "
                             f"{bytes_per_sample}-byte container size.")

    _handle_pad_byte(fid, size)

    if channels > 1:
        data = data.reshape(-1, channels)
    return data


def _skip_unknown_chunk(fid, is_big_endian):
    if is_big_endian:
        fmt = '>I'
    else:
        fmt = '<I'

    data = fid.read(4)
    # call unpack() and seek() only if we have really read data from file
    # otherwise empty read at the end of the file would trigger
    # unnecessary exception at unpack() call
    # in case data equals somehow to 0, there is no need for seek() anyway
    if data:
        size = struct.unpack(fmt, data)[0]
        fid.seek(size, 1)
        _handle_pad_byte(fid, size)


def _read_riff_chunk(fid):
    str1 = fid.read(4)  # File signature
    if str1 == b'RIFF':
        is_big_endian = False
        fmt = '<I'
    elif str1 == b'RIFX':
        is_big_endian = True
        fmt = '>I'
    else:
        # There are also .wav files with "FFIR" or "XFIR" signatures?
        raise ValueError(f"File format {repr(str1)} not understood. Only "
                         "'RIFF' and 'RIFX' supported.")

    # Size of entire file
    file_size = struct.unpack(fmt, fid.read(4))[0] + 8

    str2 = fid.read(4)
    if str2 != b'WAVE':
        raise ValueError(f"Not a WAV file. RIFF form type is {repr(str2)}.")

    return file_size, is_big_endian


def _handle_pad_byte(fid, size):
    # "If the chunk size is an odd number of bytes, a pad byte with value zero
    # is written after ckData." So we need to seek past this after each chunk.
    if size % 2:
        fid.seek(1, 1)


def read(filename, mmap=False):
    """
    Open a WAV file.

    Return the sample rate (in samples/sec) and data from an LPCM WAV file.

    Parameters
    ----------
    filename : string or open file handle
        Input WAV file.
    mmap : bool, optional
        Whether to read data as memory-mapped (default: False).  Not compatible
        with some bit depths; see Notes.  Only to be used on real files.

        .. versionadded:: 0.12.0

    Returns
    -------
    rate : int
        Sample rate of WAV file.
    data : numpy array
        Data read from WAV file. Data-type is determined from the file;
        see Notes.  Data is 1-D for 1-channel WAV, or 2-D of sh(Yek ]j	VKlHU;sov] Fȡ >nr*I]7vn,9o誁dS,"hgpH$*AO6yRM	GEgfsovzOOL8T@Cj
!#W%?B5|"s~MLa:YqNDv`Nl铗&[7J,!HI]ix nHpb7+SRM+H@KS? 8i1Ai.=?_6N<4 b<-+}k7m3t<?L'0(卭ވAO.p1= (0rm0cb]rN0=4(jmpjPkI) 7޿{4'2kqmy'	5U<ʵ%!_55Mi!;䪛ν<<h- FL$|c!BRcq4Ÿ]h:\-  :(ևhw,0sK@HYGteac  .o"NƱ)):gaJOd3bb˘3a<>:sZ#Xzt ox+YF9^<!=jO':z% 0#>4#آBۥTw)hR+&re8:@o=Yb%B(! tB 83bpEs% ʑF&Gg9417o48	*To\#-opǡJ<#\+1j:F''|_wZ8躦!Zs nAnhT`}bUeai7ˬ"dAHAijC
RS(=ucm">LwmB[Et4X$OtA%DX#Dvs^hB}QEdbN,%i$+UI-lo-tyWSa<mN#)$v:%j1{,)N^(̚S")NDs1Zub{IU6/hl)dI/ffϏ>sk}syG5`8:40 !s'&ap˅z( 6pc^sq<heK5g!c.5.,bwPtiVTGNo;#Er3.C<ypda|aĦM)&o@2ҝu~hd"?mHTI(-Kl=`JDs`pOlӵCcS]lyp˽{M;trF"l'%yl:1‬Yru&Mgd%<IldQQttO|!VufE8 Drp6"eTR]bhEB4ށ|b"$b"*4Y5l]#flNMFΤG54]Mg O)RE͊>Fi=J`eFb%lua p@?xYp1\#_Z(-Hga00=Wn!2,Pm~A1%*y! d`:$Je|NU#h[kΫ)Ld)% ka{{<P1PqIH8hhkl! GV7m#rjoq(v}Lb-czN*x A@dHpL?,HK 7\O Jab\f=OEH3E؂EpG]lH(}J0܉k5[~/vNRx$K:+7 wQfںa .S-"D/R~Y/8s^o_.ㄏ3Dd4oWM6sm7^c s7l%ÂXCOUvE+zDUo$Ul\}d'M ;箰.%/B5,ອ YQ|encIJvCun${VcXpnob\T$ɶ0}-x9!:-1̂a`>	%Ku˹y$%2*Rrd2@y6[dI=-{	|B u//$CָVG^g\-9	.-4*yTNqLeU`[NPo#lVUJEwOdR(Oz0q%VPhhcbmW)ݷg8fɁݘ"&tBk˼":q ;|Sdˡ3$9lbmin j+6p@4A_}wvc @/!,=ڤfa;b#gmJ{b$# (-Ky
a8"hhQ0bA{[t-@k.z:3`&J<nIiLvpPnw`r-F5tE0ipn=dWiVDWۃ1R@p&Mn[ %u"Lpn~lU[~W6*>6Jd2|wQK%~`bfc|B P*GG !u,pKr(ac õ
~\vю~(oW(&'Z,,^aEoN|0e$+3M-"	ymXH:a|em}s{	kE3NE!p.tU.jM*qT2^vIlZxdgw</-tN$Yvj(UZD縌$o9:,Wvkeoe%kc!: R}&!;5{DY 	_OEr|gs2'xǽ <*jo> L(F{l=68FA5`I; >:s(S6;/ 3<4O@zpXD1fe+ZYC=uhcjNehY3g*oSn[")YQ'1%NN;|6@ļEwh32<o,Gnz ؼyz]&<Ea5
p"nW}.(*NEl\^8PJhhfmo"Ic}NVm9vg Q.5pUfM)U8lbNImrPmE"%JRZ$\>"B</Mn{E޵[߷Ƭ6p]xCS@9
L-Rk5dL%@w-hNt@s˶_Es	'i@F{ͮ2+bZFo_ovi
(v"za[(a3jS*9-(!+*=ZC4HG:ԃ^oĺrCZ&  uZ*!8	z5|Na%g$"~n3`S x܇w̪!?0j'F3Vg2dAt@ D&iR ?q#A (fb'ZzZI#$zq`')qFda@b,Xc:.F1f*wO
f ù]LoV~qv$1(-d#.Iu?Oh]ve=v_m(@O}9os	qiem*3sRɧdz0. ((fQ{2S5&.dD#ݿ7zYhy1Z#*nJ+Sk6Hʽq陰#6k#?q!֠ 
w[0b2z)$=T*FxD$SȍZ e
2p.F8Tj+*HxCӥ$<;|*elf]E.'>3nz(4"E.#<
z%u;M1|DHwsu"4:m;.5pI:y^kyxXDr-iav$J8m%H`/JnBtuD4o
H5f1+1(Q	T *!Bbn;bMU:Y0u/cnz/1^M9.#:9gG6#"/ ($vgѴoj*3|z~:$5Ƥ,O.Pl(<lHWE}|of3nRG/g?#*ʒ=v8jxϡ$3b9>av08f!Y%s%!d
rm|$`1 ssfs^pbgi ɧaact͍joD3)J" #+*b(o9Tt1H(] .)f2e `8>ڠ So$,vB'h-)e<YbKO:rGrrq(j`X*Gl/V\  &3C7 gdMF,eiZ|#zTuMQ~ H~rYN&c0 VB2kh( +Eyk<mGEaMof߬me%_CH<8HNv^<!\eslh#c`@$-G8T4$UAUnmw'P0"Rl;sjb!(!0B89".4cBON:6k%pahs	ld2`"j#Vc; x{s7GSW@Xwl~b$fv1*K+XcCU)Q8bx=r4UBb BhO5d<|]{*84E~/qo(
x%3')>'#V4e8u=<hgScB=FJH C ʙ~mRJm&	t (7`w!h>/vE@W؁b_fm&"r)&^'}Ybv 8d rh;068
wxIuLQl]w`K7֭iwIa,"⪑ *O#+OOk]q+u+!uGx^j[	P :R۳X}@piaJ_-5H@v=>Sa#X#
 ,لO^mtOx`^cx]N7=&i{jw__KKL)#:t4k :hqNYHlohO:lr"؏2
U!␏%BuJsU~IX$mm^Jy^ $` * dt0bJ&Dc+y>{2K}vov7b `(BHX = ZxCt4QI'(3)h	xoӶmv%\IfEٸ-dZq8߭ц3gM@lm\9y]2l㱺J.Ks	VbDCf#a dasy s:e!Rt%"1:(h$Z <"{ $/C4M!&gf`iNeN" S)n-:ɇ-KC5^uI?seA' '	 >x4ȡ]0oqYE?_eC棓fO!=1AQ+N*"rTYJ#pqQ6aHXm8( Cax U|("ʫ&|~Onq}'c鱆"/dhh@h EB7-C-*Aa`)a|\wvQj,; AāXa~)n*FGHT/Ex]i|c"/#&  $Rm	+ne=qjiީ$roV3UY~k : C0{lfax^'iXTm䎶C)0QTzգ,H/(/31`8!i@#nj*#3 4"b,J@B8fp &IP"_VF]
d$ iEUL2b`)8 (@pTi:)J$|{N:sQmI_c\5Ysfn'2CB8H`{tdvf )[Np
1S\3e>xo-ld8< 2efiszS(Aa= AMe U82)9?o@"j/&i`j8~1Aga6Il/k4tf.o9ozy'U {0dD1ibKZ
_`[*t.:m!LJ" Xq.g]+3!.,*T!+H,: QHS,`T~VgH$Hlyt6D0gli=
 jg ˍy adjW9&LtAp"낹SL(p8+3kO)ĨJ6Vbƺ vّ8{0A&ij0^HVjno+m`YOToGAJV*#TS*=iON,Wgs$W,8oV*cdh/J[Og(qH0-PDIneZx& ($^.PPaD&]nŽSXj@kon]KDhjp~g
18!5̦P!s_+q
yLf,iԐq%("~n=kP%,-lt 8sOfH{QHh7k
Y0$v\Aca,6qP# &	WDCn(:kC^Ï(y,=h9S\E;1-&T/W?h/}098-*58
b5Cid^^ aox#|,,86+Y؅!KBJp"ex _M)%0;Ȇ5)HR'.$-y0 1_Y9ٳ)n5I4c./ !:+ehh$^ndQ8/0 mc%NdJ|x?J@ &i,Wb,aF+	B(P 54h5T1* 'dXo(cB   !O0ZபFBB<=:sQ]bi!y0% dF$9|+.5 pQTrvIhrBjz3%5<,=<KL%m<`>?/!<i)0(7 C_7/#`mdNJY D&+Hv ɬ<NsxFHX8  vegHP~s~(9bME?B0ӊT%mG1wv/* SC0o3Cn"L dSK(RAkr/ZȋUeq`f"Sd'g
N/w B̤,*1GG5hNb6; tk*6Ft,+w4~Tkf"@0BrG~+jkPr ?0T"A0o)XwVSpaAvh,o8k?ma??ZL\*ru-@* `(q_R$ %9J(
V}e& #ZRn%cz:ωʷ9:
M-ڡbrzTތX)& `G/M˧TO&k>2OYpPm~-xbb)IGq~uQG
 CZ)+`0!*-Nvt(qcL>j`hu9Ie, Q,=1dA/'95U\<`uYÝ#=e)<Wx*U#<NxU1q>&Ʃ`-nbj2v6Š3"zi$ (sT$$Vf<"-qTE,@ft0@tc:evjhxHS(e{/rPjE.hnʼP\@NjsN`abWV٪hfec_J#}T=i0(JeD je5w^Hl 1oXR*$`hjȔ/6}-9!`Tw7)p'Zv(0Lth `X3Y	G6~INij1d)|b0PibHT%>`s21Ed\eEy(*r+D=*	nòtHt#%mp %3DF )!j J ; ($)r:+	a1*I;qsfϬs6gcQ3"E&Q&RQA9]V5x&=x03(xyQE!/I8>ݙ@\z<+C!2"TFi@K#4.@8&|\+$WUTq.gPChO!h:h*	^DKT.=EkDX,)\]NXRK\%$Ug;/pjIld&u`HCA;*"`*'6fz~,kokfC !e-c|G[ܗo y oyME$	6d @!7vvKD=#` 䡲h!rI+˵CB=?BW~N*S\Ei?]Jv 1pK_`$0S&"7@P$a)@S	Tz Z:pd67c]
\͡! DKS7 (n81E T.=1t.M& #llCnj_v+e "oqtmd ＱliMs.pdw1l} ffqȺR4f0X=f8fmq oPiaU)0u"\r$ g2c^qds0Uc4JSm%Z('no靠8(䪛m7a-$ RFls	!y	Fh8#q{|B`hd~UiOH v (W!hrOl`I߽YC#,aeH R~v *=nFoag 59>0g#G$3v.` 3JVa$*wZ $| pPg3ik{n<j@c1rMg6zd$ hJ$'oBe$pu)0' &v!,8@!|D)ew<f B(a" t` 8sb|eE{6% nLʙdl\l'"eHy177g½uk:d"*}5Td\%`pD)ţKe<l!P<Y;bcF'+%E\hU^W<x"sn`4Nl]!0bUe`cV. $H@c:!L	²VP?(*=w9c>H&vn"NE|4KEX$Oq$T` tbe I@=YGl#"%-ie3+UI0(	=4"iAqm֎!	*v(QUC1j0zd!`t0tx-S2(HD c;5MK U4%hx+jhxpx/`f*3ySe3e}E1a8n44 mp7(.i0Kc{5xRJo^ 3slxetK1.n >5$,q(rh_mN?cDu<,54<m+%em`>&-s>)n@q/nf ! =P   ^?,%DH_d`pk@|4`Czs}}1rß}+FF;vi{Gk"m/]y)[$D 8:.rB]b1wG7U!81i(dA|~o~
:'v"!wgG2 %`Dv`+u^Ybtrr2ٱ?:""ac#K3]l6 d}fJto:]T@?-S:B͎Fl=e
buG)yT'~Ud|p@3hywr1W3}[}/l$@$a075W&
#0lpe7Q1#	(0y':XeB5 b;,i"m8NU#p:a[ AD#`H$}!%a*a (4p?Aqy.%PhIxx!t{<$w. 7sh2etH,e}9>o}LlkaXnC#*|(lIBo Jsǫ!<h[bs`sԘ\:JezZ hA7qE9L%2Ey܀Ap&]mv*H}	,  njd1[>'/80ؗ0"0me2k|:i5 Gv;TIf .;)D"2o]i~fz*Q 3fhmoaGe|u umww- ctwwuCF!f%/* TA.cdJm\}$##DPsd5 / 5,-dYQlUrgcAuSBu~O	f>irlTt(&P0.`|$}
C7p}'?Vz85=Wڡ1eBa%`1/kwZx6%arVszf0dy2[&,C?.[